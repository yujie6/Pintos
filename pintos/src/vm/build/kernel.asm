
kernel.o：     文件格式 elf32-i386


Disassembly of section .text:

c00200b8 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c00200b8:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c00200bd:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c00200bf:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c00200c0:	b4 88                	mov    $0x88,%ah
	int $0x15
c00200c2:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c00200c4:	66 05 00 04          	add    $0x400,%ax
c00200c8:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c00200ca:	66 3d 00 00          	cmp    $0x0,%ax
c00200ce:	01 00                	add    %eax,(%eax)
	jbe 1f
c00200d0:	76 06                	jbe    c00200d8 <start+0x20>
	mov $0x10000, %eax
c00200d2:	66 b8 00 00          	mov    $0x0,%ax
c00200d6:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c00200d8:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c00200dc:	67 66 a3 be 01       	addr16 mov %ax,0x1be
c00200e1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200e3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200e5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200e7:	75 fa                	jne    c00200e3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200e9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200eb:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ed:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200ef:	a8 02                	test   $0x2,%al
	jnz 1b
c00200f1:	75 fa                	jne    c00200ed <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200f3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200f5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200f7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200f9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200fb:	75 fa                	jne    c00200f7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200fd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c0020102:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c0020105:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c0020108:	66 b9 00 04          	mov    $0x400,%cx
c002010c:	00 00                	add    %al,(%eax)
	rep stosl
c002010e:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c0020111:	66 b8 07 00          	mov    $0x7,%ax
c0020115:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c0020117:	66 b9 11 00          	mov    $0x11,%cx
c002011b:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c002011d:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020120:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c0020127:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c0020128:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c002012b:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c0020132:	00 e2                	add    %ah,%dl
	loop 1b
c0020134:	eb b8                	jmp    c00200ee <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c0020136:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c0020138:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c002013a:	66 b8 07 00          	mov    $0x7,%ax
c002013e:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020140:	66 b9 00 40          	mov    $0x4000,%cx
c0020144:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020146:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020149:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020150:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020151:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020156:	e2 f1                	loop   c0020149 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020158:	66 b8 00 f0          	mov    $0xf000,%ax
c002015c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002015e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020161:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020162:	67 66 0f 01 15       	lgdtw  (%di)
c0020167:	b8 01 00 00 0f       	mov    $0xf000001,%eax
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002016c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002016e:	66 0d 05 00          	or     $0x5,%ax
c0020172:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020178:	ea 7f 01 02 c0 08 00 	ljmp   $0x8,$0xc002017f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002017f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020183:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020185:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020187:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020189:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002018b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002018d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020193:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020198:	e8 2f 01 00 00       	call   c00202cc <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002019d:	eb fe                	jmp    c002019d <start+0xe5>
	...

c00201a0 <gdt>:
	...
c00201a8:	ff                   	(bad)  
c00201a9:	ff 00                	incl   (%eax)
c00201ab:	00 00                	add    %al,(%eax)
c00201ad:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c00201b4:	00                   	.byte 0x0
c00201b5:	92                   	xchg   %eax,%edx
c00201b6:	cf                   	iret   
	...

c00201b8 <gdtdesc>:
c00201b8:	17                   	pop    %ss
c00201b9:	00                   	.byte 0x0
c00201ba:	a0                   	.byte 0xa0
c00201bb:	01 02                	add    %eax,(%edx)
c00201bd:	c0                   	.byte 0xc0

c00201be <init_ram_pages>:
c00201be:	00 00                	add    %al,(%eax)
	...

c00201c2 <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device (enum block_type role, const char *name)
{
c00201c2:	55                   	push   %ebp
c00201c3:	57                   	push   %edi
c00201c4:	56                   	push   %esi
c00201c5:	53                   	push   %ebx
c00201c6:	83 ec 0c             	sub    $0xc,%esp
c00201c9:	e8 75 ff 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00201ce:	81 c3 de da 01 00    	add    $0x1dade,%ebx
c00201d4:	89 c7                	mov    %eax,%edi
  struct block *block = NULL;

  if (name != NULL)
c00201d6:	85 d2                	test   %edx,%edx
c00201d8:	74 70                	je     c002024a <locate_block_device+0x88>
c00201da:	89 d5                	mov    %edx,%ebp
    {
      block = block_get_by_name (name);
c00201dc:	83 ec 0c             	sub    $0xc,%esp
c00201df:	52                   	push   %edx
c00201e0:	e8 55 50 00 00       	call   c002523a <block_get_by_name>
c00201e5:	89 c6                	mov    %eax,%esi
      if (block == NULL)
c00201e7:	83 c4 10             	add    $0x10,%esp
c00201ea:	85 c0                	test   %eax,%eax
c00201ec:	74 39                	je     c0020227 <locate_block_device+0x65>
          break;
    }

  if (block != NULL)
    {
      printf ("%s: using %s\n", block_type_name (role), block_name (block));
c00201ee:	83 ec 0c             	sub    $0xc,%esp
c00201f1:	56                   	push   %esi
c00201f2:	e8 5d 51 00 00       	call   c0025354 <block_name>
c00201f7:	89 c5                	mov    %eax,%ebp
c00201f9:	89 3c 24             	mov    %edi,(%esp)
c00201fc:	e8 e2 4e 00 00       	call   c00250e3 <block_type_name>
c0020201:	83 c4 0c             	add    $0xc,%esp
c0020204:	55                   	push   %ebp
c0020205:	50                   	push   %eax
c0020206:	8d 83 59 36 ff ff    	lea    -0xc9a7(%ebx),%eax
c002020c:	50                   	push   %eax
c002020d:	e8 bf 72 00 00       	call   c00274d1 <printf>
      block_set_role (role, block);
c0020212:	83 c4 08             	add    $0x8,%esp
c0020215:	56                   	push   %esi
c0020216:	57                   	push   %edi
c0020217:	e8 5b 4f 00 00       	call   c0025177 <block_set_role>
c002021c:	83 c4 10             	add    $0x10,%esp
    }
}
c002021f:	83 c4 0c             	add    $0xc,%esp
c0020222:	5b                   	pop    %ebx
c0020223:	5e                   	pop    %esi
c0020224:	5f                   	pop    %edi
c0020225:	5d                   	pop    %ebp
c0020226:	c3                   	ret    
        PANIC ("No such block device \"%s\"", name);
c0020227:	83 ec 0c             	sub    $0xc,%esp
c002022a:	55                   	push   %ebp
c002022b:	8d 83 2a 36 ff ff    	lea    -0xc9d6(%ebx),%eax
c0020231:	50                   	push   %eax
c0020232:	8d 83 c0 24 ff ff    	lea    -0xdb40(%ebx),%eax
c0020238:	50                   	push   %eax
c0020239:	68 ae 01 00 00       	push   $0x1ae
c002023e:	8d 83 44 36 ff ff    	lea    -0xc9bc(%ebx),%eax
c0020244:	50                   	push   %eax
c0020245:	e8 e3 8e 00 00       	call   c002912d <debug_panic>
      for (block = block_first (); block != NULL; block = block_next (block))
c002024a:	e8 76 4f 00 00       	call   c00251c5 <block_first>
c002024f:	89 c6                	mov    %eax,%esi
c0020251:	85 c0                	test   %eax,%eax
c0020253:	74 ca                	je     c002021f <locate_block_device+0x5d>
        if (block_type (block) == role)
c0020255:	83 ec 0c             	sub    $0xc,%esp
c0020258:	56                   	push   %esi
c0020259:	e8 fe 50 00 00       	call   c002535c <block_type>
c002025e:	83 c4 10             	add    $0x10,%esp
c0020261:	39 f8                	cmp    %edi,%eax
c0020263:	74 14                	je     c0020279 <locate_block_device+0xb7>
      for (block = block_first (); block != NULL; block = block_next (block))
c0020265:	83 ec 0c             	sub    $0xc,%esp
c0020268:	56                   	push   %esi
c0020269:	e8 91 4f 00 00       	call   c00251ff <block_next>
c002026e:	89 c6                	mov    %eax,%esi
c0020270:	83 c4 10             	add    $0x10,%esp
c0020273:	85 c0                	test   %eax,%eax
c0020275:	75 de                	jne    c0020255 <locate_block_device+0x93>
c0020277:	eb a6                	jmp    c002021f <locate_block_device+0x5d>
  if (block != NULL)
c0020279:	85 f6                	test   %esi,%esi
c002027b:	74 a2                	je     c002021f <locate_block_device+0x5d>
c002027d:	e9 6c ff ff ff       	jmp    c00201ee <locate_block_device+0x2c>

c0020282 <run_task>:
run_task(char **argv) {
c0020282:	56                   	push   %esi
c0020283:	53                   	push   %ebx
c0020284:	83 ec 0c             	sub    $0xc,%esp
c0020287:	e8 b7 fe 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002028c:	81 c3 20 da 01 00    	add    $0x1da20,%ebx
    const char *task = argv[1];
c0020292:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020296:	8b 70 04             	mov    0x4(%eax),%esi
    printf("Executing '%s':\n", task);
c0020299:	56                   	push   %esi
c002029a:	8d 83 67 36 ff ff    	lea    -0xc999(%ebx),%eax
c00202a0:	50                   	push   %eax
c00202a1:	e8 2b 72 00 00       	call   c00274d1 <printf>
    process_wait (process_execute (task));
c00202a6:	89 34 24             	mov    %esi,(%esp)
c00202a9:	e8 47 af 00 00       	call   c002b1f5 <process_execute>
c00202ae:	89 04 24             	mov    %eax,(%esp)
c00202b1:	e8 aa b0 00 00       	call   c002b360 <process_wait>
    printf("Execution of '%s' complete.\n", task);
c00202b6:	83 c4 08             	add    $0x8,%esp
c00202b9:	56                   	push   %esi
c00202ba:	8d 83 78 36 ff ff    	lea    -0xc988(%ebx),%eax
c00202c0:	50                   	push   %eax
c00202c1:	e8 0b 72 00 00       	call   c00274d1 <printf>
}
c00202c6:	83 c4 14             	add    $0x14,%esp
c00202c9:	5b                   	pop    %ebx
c00202ca:	5e                   	pop    %esi
c00202cb:	c3                   	ret    

c00202cc <pintos_init>:
pintos_init(void) {
c00202cc:	55                   	push   %ebp
c00202cd:	57                   	push   %edi
c00202ce:	56                   	push   %esi
c00202cf:	53                   	push   %ebx
c00202d0:	83 ec 40             	sub    $0x40,%esp
c00202d3:	e8 6b fe 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00202d8:	81 c3 d4 d9 01 00    	add    $0x1d9d4,%ebx
    memset(&_start_bss, 0, &_end_bss - &_start_bss);
c00202de:	c7 c2 ac dc 03 c0    	mov    $0xc003dcac,%edx
c00202e4:	c7 c0 d4 fc 03 c0    	mov    $0xc003fcd4,%eax
c00202ea:	29 d0                	sub    %edx,%eax
c00202ec:	50                   	push   %eax
c00202ed:	6a 00                	push   $0x0
c00202ef:	52                   	push   %edx
c00202f0:	e8 a7 83 00 00       	call   c002869c <memset>
    argc = *(uint32_t *) ptov(LOADER_ARG_CNT);
c00202f5:	8b 3d 3a 7d 00 c0    	mov    0xc0007d3a,%edi
c00202fb:	89 7c 24 14          	mov    %edi,0x14(%esp)
    for (i = 0; i < argc; i++) {
c00202ff:	83 c4 10             	add    $0x10,%esp
c0020302:	be 00 00 00 00       	mov    $0x0,%esi
    p = ptov(LOADER_ARGS);
c0020307:	bd 3e 7d 00 c0       	mov    $0xc0007d3e,%ebp
    for (i = 0; i < argc; i++) {
c002030c:	85 ff                	test   %edi,%edi
c002030e:	0f 8e 81 06 00 00    	jle    c0020995 <pintos_init+0x6c9>
        argv[i] = p;
c0020314:	89 ac b3 14 00 00 00 	mov    %ebp,0x14(%ebx,%esi,4)
        p += strnlen(p, end - p) + 1;
c002031b:	83 ec 08             	sub    $0x8,%esp
c002031e:	b8 be 7d 00 c0       	mov    $0xc0007dbe,%eax
c0020323:	29 e8                	sub    %ebp,%eax
c0020325:	50                   	push   %eax
c0020326:	55                   	push   %ebp
c0020327:	e8 17 84 00 00       	call   c0028743 <strnlen>
c002032c:	8d 6c 05 01          	lea    0x1(%ebp,%eax,1),%ebp
    for (i = 0; i < argc; i++) {
c0020330:	83 c6 01             	add    $0x1,%esi
c0020333:	83 c4 10             	add    $0x10,%esp
c0020336:	39 74 24 04          	cmp    %esi,0x4(%esp)
c002033a:	0f 84 16 06 00 00    	je     c0020956 <pintos_init+0x68a>
        if (p >= end)
c0020340:	81 fd bd 7d 00 c0    	cmp    $0xc0007dbd,%ebp
c0020346:	76 cc                	jbe    c0020314 <pintos_init+0x48>
            PANIC ("command line arguments overflow");
c0020348:	8d 83 74 37 ff ff    	lea    -0xc88c(%ebx),%eax
c002034e:	50                   	push   %eax
c002034f:	8d 83 f8 24 ff ff    	lea    -0xdb08(%ebx),%eax
c0020355:	50                   	push   %eax
c0020356:	68 e5 00 00 00       	push   $0xe5
c002035b:	8d 83 44 36 ff ff    	lea    -0xc9bc(%ebx),%eax
c0020361:	50                   	push   %eax
c0020362:	e8 c6 8d 00 00       	call   c002912d <debug_panic>
            printf(" %s", argv[i]);
c0020367:	83 ec 08             	sub    $0x8,%esp
c002036a:	57                   	push   %edi
c002036b:	ff 74 24 14          	pushl  0x14(%esp)
c002036f:	e8 5d 71 00 00       	call   c00274d1 <printf>
c0020374:	83 c4 10             	add    $0x10,%esp
c0020377:	83 c6 04             	add    $0x4,%esi
    for (i = 0; i < argc; i++)
c002037a:	39 74 24 04          	cmp    %esi,0x4(%esp)
c002037e:	0f 84 2e 06 00 00    	je     c00209b2 <pintos_init+0x6e6>
        if (strchr(argv[i], ' ') == NULL)
c0020384:	8b 3e                	mov    (%esi),%edi
c0020386:	83 ec 08             	sub    $0x8,%esp
c0020389:	6a 20                	push   $0x20
c002038b:	57                   	push   %edi
c002038c:	e8 bd 80 00 00       	call   c002844e <strchr>
c0020391:	83 c4 10             	add    $0x10,%esp
c0020394:	85 c0                	test   %eax,%eax
c0020396:	74 cf                	je     c0020367 <pintos_init+0x9b>
            printf(" '%s'", argv[i]);
c0020398:	83 ec 08             	sub    $0x8,%esp
c002039b:	57                   	push   %edi
c002039c:	55                   	push   %ebp
c002039d:	e8 2f 71 00 00       	call   c00274d1 <printf>
c00203a2:	83 c4 10             	add    $0x10,%esp
c00203a5:	eb d0                	jmp    c0020377 <pintos_init+0xab>
    printf("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00203a7:	83 ec 0c             	sub    $0xc,%esp
c00203aa:	8d 83 94 37 ff ff    	lea    -0xc86c(%ebx),%eax
c00203b0:	50                   	push   %eax
c00203b1:	e8 4d ad 00 00       	call   c002b103 <puts>
    shutdown_power_off();
c00203b6:	e8 fd 68 00 00       	call   c0026cb8 <shutdown_power_off>
            shutdown_configure(SHUTDOWN_POWER_OFF);
c00203bb:	83 ec 0c             	sub    $0xc,%esp
c00203be:	6a 01                	push   $0x1
c00203c0:	e8 62 68 00 00       	call   c0026c27 <shutdown_configure>
c00203c5:	83 c4 10             	add    $0x10,%esp
    for (; *argv != NULL && **argv == '-'; argv++) {
c00203c8:	83 44 24 04 04       	addl   $0x4,0x4(%esp)
c00203cd:	8b 44 24 04          	mov    0x4(%esp),%eax
c00203d1:	8b 00                	mov    (%eax),%eax
c00203d3:	85 c0                	test   %eax,%eax
c00203d5:	0f 84 f4 01 00 00    	je     c00205cf <pintos_init+0x303>
c00203db:	80 38 2d             	cmpb   $0x2d,(%eax)
c00203de:	0f 85 d5 01 00 00    	jne    c00205b9 <pintos_init+0x2ed>
        char *name = strtok_r(*argv, "=", &save_ptr);
c00203e4:	83 ec 04             	sub    $0x4,%esp
c00203e7:	8b 7c 24 10          	mov    0x10(%esp),%edi
c00203eb:	57                   	push   %edi
c00203ec:	8d 93 50 46 ff ff    	lea    -0xb9b0(%ebx),%edx
c00203f2:	52                   	push   %edx
c00203f3:	50                   	push   %eax
c00203f4:	e8 6f 81 00 00       	call   c0028568 <strtok_r>
c00203f9:	89 c5                	mov    %eax,%ebp
        char *value = strtok_r(NULL, "", &save_ptr);
c00203fb:	83 c4 0c             	add    $0xc,%esp
c00203fe:	57                   	push   %edi
c00203ff:	8d 83 ca 56 ff ff    	lea    -0xa936(%ebx),%eax
c0020405:	50                   	push   %eax
c0020406:	6a 00                	push   $0x0
c0020408:	e8 5b 81 00 00       	call   c0028568 <strtok_r>
c002040d:	89 44 24 18          	mov    %eax,0x18(%esp)
        if (!strcmp(name, "-h"))
c0020411:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020416:	8d bb 9b 36 ff ff    	lea    -0xc965(%ebx),%edi
c002041c:	89 ee                	mov    %ebp,%esi
c002041e:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020420:	0f 97 c0             	seta   %al
c0020423:	1c 00                	sbb    $0x0,%al
c0020425:	83 c4 10             	add    $0x10,%esp
c0020428:	84 c0                	test   %al,%al
c002042a:	0f 84 77 ff ff ff    	je     c00203a7 <pintos_init+0xdb>
        else if (!strcmp(name, "-q"))
c0020430:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020435:	8d bb 9e 36 ff ff    	lea    -0xc962(%ebx),%edi
c002043b:	89 ee                	mov    %ebp,%esi
c002043d:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002043f:	0f 97 c0             	seta   %al
c0020442:	1c 00                	sbb    $0x0,%al
c0020444:	84 c0                	test   %al,%al
c0020446:	0f 84 6f ff ff ff    	je     c00203bb <pintos_init+0xef>
        else if (!strcmp(name, "-r"))
c002044c:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020451:	8d bb a1 36 ff ff    	lea    -0xc95f(%ebx),%edi
c0020457:	89 ee                	mov    %ebp,%esi
c0020459:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002045b:	0f 97 c0             	seta   %al
c002045e:	1c 00                	sbb    $0x0,%al
c0020460:	84 c0                	test   %al,%al
c0020462:	74 24                	je     c0020488 <pintos_init+0x1bc>
            else if (!strcmp (name, "-f"))
c0020464:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020469:	8d bb a4 36 ff ff    	lea    -0xc95c(%ebx),%edi
c002046f:	89 ee                	mov    %ebp,%esi
c0020471:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020473:	0f 97 c0             	seta   %al
c0020476:	1c 00                	sbb    $0x0,%al
c0020478:	84 c0                	test   %al,%al
c002047a:	75 1e                	jne    c002049a <pintos_init+0x1ce>
              format_filesys = true;
c002047c:	c6 83 24 01 00 00 01 	movb   $0x1,0x124(%ebx)
c0020483:	e9 40 ff ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            shutdown_configure(SHUTDOWN_REBOOT);
c0020488:	83 ec 0c             	sub    $0xc,%esp
c002048b:	6a 02                	push   $0x2
c002048d:	e8 95 67 00 00       	call   c0026c27 <shutdown_configure>
c0020492:	83 c4 10             	add    $0x10,%esp
c0020495:	e9 2e ff ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            else if (!strcmp (name, "-filesys"))
c002049a:	b9 09 00 00 00       	mov    $0x9,%ecx
c002049f:	8d bb a7 36 ff ff    	lea    -0xc959(%ebx),%edi
c00204a5:	89 ee                	mov    %ebp,%esi
c00204a7:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204a9:	0f 97 c0             	seta   %al
c00204ac:	1c 00                	sbb    $0x0,%al
c00204ae:	84 c0                	test   %al,%al
c00204b0:	75 0f                	jne    c00204c1 <pintos_init+0x1f5>
              filesys_bdev_name = value;
c00204b2:	8b 44 24 08          	mov    0x8(%esp),%eax
c00204b6:	89 83 20 01 00 00    	mov    %eax,0x120(%ebx)
c00204bc:	e9 07 ff ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            else if (!strcmp (name, "-scratch"))
c00204c1:	b9 09 00 00 00       	mov    $0x9,%ecx
c00204c6:	8d bb b0 36 ff ff    	lea    -0xc950(%ebx),%edi
c00204cc:	89 ee                	mov    %ebp,%esi
c00204ce:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204d0:	0f 97 c0             	seta   %al
c00204d3:	1c 00                	sbb    $0x0,%al
c00204d5:	84 c0                	test   %al,%al
c00204d7:	75 0f                	jne    c00204e8 <pintos_init+0x21c>
              scratch_bdev_name = value;
c00204d9:	8b 44 24 08          	mov    0x8(%esp),%eax
c00204dd:	89 83 1c 01 00 00    	mov    %eax,0x11c(%ebx)
c00204e3:	e9 e0 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            else if (!strcmp (name, "-swap"))
c00204e8:	b9 06 00 00 00       	mov    $0x6,%ecx
c00204ed:	8d bb b9 36 ff ff    	lea    -0xc947(%ebx),%edi
c00204f3:	89 ee                	mov    %ebp,%esi
c00204f5:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204f7:	0f 97 c0             	seta   %al
c00204fa:	1c 00                	sbb    $0x0,%al
c00204fc:	84 c0                	test   %al,%al
c00204fe:	75 0f                	jne    c002050f <pintos_init+0x243>
              swap_bdev_name = value;
c0020500:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020504:	89 83 18 01 00 00    	mov    %eax,0x118(%ebx)
c002050a:	e9 b9 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
        else if (!strcmp(name, "-rs"))
c002050f:	83 ec 08             	sub    $0x8,%esp
c0020512:	8d 83 bf 36 ff ff    	lea    -0xc941(%ebx),%eax
c0020518:	50                   	push   %eax
c0020519:	55                   	push   %ebp
c002051a:	e8 c4 7e 00 00       	call   c00283e3 <strcmp>
c002051f:	83 c4 10             	add    $0x10,%esp
c0020522:	85 c0                	test   %eax,%eax
c0020524:	74 23                	je     c0020549 <pintos_init+0x27d>
        else if (!strcmp(name, "-mlfqs"))
c0020526:	83 ec 08             	sub    $0x8,%esp
c0020529:	8d 83 c3 36 ff ff    	lea    -0xc93d(%ebx),%eax
c002052f:	50                   	push   %eax
c0020530:	55                   	push   %ebp
c0020531:	e8 ad 7e 00 00       	call   c00283e3 <strcmp>
c0020536:	83 c4 10             	add    $0x10,%esp
c0020539:	85 c0                	test   %eax,%eax
c002053b:	75 28                	jne    c0020565 <pintos_init+0x299>
            thread_mlfqs = true;
c002053d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0020541:	c6 00 01             	movb   $0x1,(%eax)
c0020544:	e9 7f fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            random_init(atoi(value));
c0020549:	83 ec 0c             	sub    $0xc,%esp
c002054c:	ff 74 24 14          	pushl  0x14(%esp)
c0020550:	e8 21 7b 00 00       	call   c0028076 <atoi>
c0020555:	89 04 24             	mov    %eax,(%esp)
c0020558:	e8 82 69 00 00       	call   c0026edf <random_init>
c002055d:	83 c4 10             	add    $0x10,%esp
c0020560:	e9 63 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            else if (!strcmp (name, "-ul"))
c0020565:	83 ec 08             	sub    $0x8,%esp
c0020568:	8d 83 ca 36 ff ff    	lea    -0xc936(%ebx),%eax
c002056e:	50                   	push   %eax
c002056f:	55                   	push   %ebp
c0020570:	e8 6e 7e 00 00       	call   c00283e3 <strcmp>
c0020575:	83 c4 10             	add    $0x10,%esp
c0020578:	85 c0                	test   %eax,%eax
c002057a:	75 1a                	jne    c0020596 <pintos_init+0x2ca>
              user_page_limit = atoi (value);
c002057c:	83 ec 0c             	sub    $0xc,%esp
c002057f:	ff 74 24 14          	pushl  0x14(%esp)
c0020583:	e8 ee 7a 00 00       	call   c0028076 <atoi>
c0020588:	89 83 b8 fb ff ff    	mov    %eax,-0x448(%ebx)
c002058e:	83 c4 10             	add    $0x10,%esp
c0020591:	e9 32 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            PANIC ("unknown option `%s' (use -h for help)", name);
c0020596:	83 ec 0c             	sub    $0xc,%esp
c0020599:	55                   	push   %ebp
c002059a:	8d 83 f8 3b ff ff    	lea    -0xc408(%ebx),%eax
c00205a0:	50                   	push   %eax
c00205a1:	8d 83 e8 24 ff ff    	lea    -0xdb18(%ebx),%eax
c00205a7:	50                   	push   %eax
c00205a8:	68 1c 01 00 00       	push   $0x11c
c00205ad:	8d 83 44 36 ff ff    	lea    -0xc9bc(%ebx),%eax
c00205b3:	50                   	push   %eax
c00205b4:	e8 74 8b 00 00       	call   c002912d <debug_panic>
c00205b9:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c00205bd:	eb 14                	jmp    c00205d3 <pintos_init+0x307>
    for (; *argv != NULL && **argv == '-'; argv++) {
c00205bf:	8d ab 14 00 00 00    	lea    0x14(%ebx),%ebp
c00205c5:	eb 0c                	jmp    c00205d3 <pintos_init+0x307>
c00205c7:	8d ab 14 00 00 00    	lea    0x14(%ebx),%ebp
c00205cd:	eb 04                	jmp    c00205d3 <pintos_init+0x307>
c00205cf:	8b 6c 24 04          	mov    0x4(%esp),%ebp
    random_init(rtc_get_time());
c00205d3:	e8 e2 64 00 00       	call   c0026aba <rtc_get_time>
c00205d8:	83 ec 0c             	sub    $0xc,%esp
c00205db:	50                   	push   %eax
c00205dc:	e8 fe 68 00 00       	call   c0026edf <random_init>
    global_load_avg = fix_int(0);
c00205e1:	c7 c0 c8 fc 03 c0    	mov    $0xc003fcc8,%eax
c00205e7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    thread_init();
c00205ed:	e8 10 08 00 00       	call   c0020e02 <thread_init>
    console_init();
c00205f2:	e8 64 aa 00 00       	call   c002b05b <console_init>
    printf("Pintos booting with %'"PRIu32" kB RAM...\n",
c00205f7:	83 c4 08             	add    $0x8,%esp
           init_ram_pages * PGSIZE / 1024);
c00205fa:	c7 c6 be 01 02 c0    	mov    $0xc00201be,%esi
c0020600:	8b 06                	mov    (%esi),%eax
c0020602:	c1 e0 0c             	shl    $0xc,%eax
    printf("Pintos booting with %'"PRIu32" kB RAM...\n",
c0020605:	c1 e8 0a             	shr    $0xa,%eax
c0020608:	50                   	push   %eax
c0020609:	8d 83 20 3c ff ff    	lea    -0xc3e0(%ebx),%eax
c002060f:	50                   	push   %eax
c0020610:	e8 bc 6e 00 00       	call   c00274d1 <printf>
    palloc_init(user_page_limit);
c0020615:	83 c4 04             	add    $0x4,%esp
c0020618:	ff b3 b8 fb ff ff    	pushl  -0x448(%ebx)
c002061e:	e8 bc 32 00 00       	call   c00238df <palloc_init>
    malloc_init();
c0020623:	e8 35 37 00 00       	call   c0023d5d <malloc_init>
    pd = init_page_dir = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c0020628:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c002062f:	e8 08 34 00 00       	call   c0023a3c <palloc_get_page>
c0020634:	89 c1                	mov    %eax,%ecx
c0020636:	89 44 24 20          	mov    %eax,0x20(%esp)
c002063a:	c7 c0 c4 fc 03 c0    	mov    $0xc003fcc4,%eax
c0020640:	89 08                	mov    %ecx,(%eax)
    for (page = 0; page < init_ram_pages; page++) {
c0020642:	83 c4 10             	add    $0x10,%esp
c0020645:	83 3e 00             	cmpl   $0x0,(%esi)
c0020648:	0f 84 66 01 00 00    	je     c00207b4 <pintos_init+0x4e8>
c002064e:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
    pt = NULL;
c0020653:	b9 00 00 00 00       	mov    $0x0,%ecx
    for (page = 0; page < init_ram_pages; page++) {
c0020658:	ba 00 00 00 00       	mov    $0x0,%edx
        bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c002065d:	c7 c0 00 50 03 c0    	mov    $0xc0035000,%eax
c0020663:	89 44 24 14          	mov    %eax,0x14(%esp)
c0020667:	c7 c0 00 00 02 c0    	mov    $0xc0020000,%eax
c002066d:	89 44 24 18          	mov    %eax,0x18(%esp)
c0020671:	89 c8                	mov    %ecx,%eax
c0020673:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c0020677:	89 d5                	mov    %edx,%ebp
c0020679:	e9 9b 00 00 00       	jmp    c0020719 <pintos_init+0x44d>
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create(uint32_t *pt) {
    ASSERT (pg_ofs(pt) == 0);
c002067e:	83 ec 0c             	sub    $0xc,%esp
c0020681:	8d 83 ce 36 ff ff    	lea    -0xc932(%ebx),%eax
c0020687:	50                   	push   %eax
c0020688:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002068e:	50                   	push   %eax
c002068f:	8d 83 dc 24 ff ff    	lea    -0xdb24(%ebx),%eax
c0020695:	50                   	push   %eax
c0020696:	6a 48                	push   $0x48
c0020698:	8d 83 f5 36 ff ff    	lea    -0xc90b(%ebx),%eax
c002069e:	50                   	push   %eax
c002069f:	e8 89 8a 00 00       	call   c002912d <debug_panic>

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop(const void *vaddr) {
    ASSERT (is_kernel_vaddr(vaddr));
c00206a4:	83 ec 0c             	sub    $0xc,%esp
c00206a7:	8d 83 09 37 ff ff    	lea    -0xc8f7(%ebx),%eax
c00206ad:	50                   	push   %eax
c00206ae:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00206b4:	50                   	push   %eax
c00206b5:	8d 83 d4 24 ff ff    	lea    -0xdb2c(%ebx),%eax
c00206bb:	50                   	push   %eax
c00206bc:	6a 55                	push   $0x55
c00206be:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c00206c4:	50                   	push   %eax
c00206c5:	e8 63 8a 00 00       	call   c002912d <debug_panic>
        pt[pte_idx] = pte_create_kernel(vaddr, !in_kernel_text);
c00206ca:	8b 54 24 08          	mov    0x8(%esp),%edx
c00206ce:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
c00206d1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c00206d5:	81 7c 24 0c ff ff ff 	cmpl   $0xbfffffff,0xc(%esp)
c00206dc:	bf 
c00206dd:	0f 86 a7 00 00 00    	jbe    c002078a <pintos_init+0x4be>

    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00206e3:	89 e9                	mov    %ebp,%ecx
c00206e5:	c1 e1 0c             	shl    $0xc,%ecx
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel(void *page, bool writable) {
    ASSERT (pg_ofs(page) == 0);
    return vtop(page) | PTE_P | (writable ? PTE_W : 0);
c00206e8:	0f b6 74 24 04       	movzbl 0x4(%esp),%esi
c00206ed:	83 f6 01             	xor    $0x1,%esi
c00206f0:	89 f2                	mov    %esi,%edx
c00206f2:	0f b6 f2             	movzbl %dl,%esi
c00206f5:	01 f6                	add    %esi,%esi
c00206f7:	09 f1                	or     %esi,%ecx
c00206f9:	83 c9 01             	or     $0x1,%ecx
c00206fc:	8b 54 24 08          	mov    0x8(%esp),%edx
c0020700:	89 0a                	mov    %ecx,(%edx)
    for (page = 0; page < init_ram_pages; page++) {
c0020702:	83 c5 01             	add    $0x1,%ebp
c0020705:	81 c7 00 10 00 00    	add    $0x1000,%edi
c002070b:	c7 c2 be 01 02 c0    	mov    $0xc00201be,%edx
c0020711:	3b 2a                	cmp    (%edx),%ebp
c0020713:	0f 83 97 00 00 00    	jae    c00207b0 <pintos_init+0x4e4>
    return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c0020719:	89 fa                	mov    %edi,%edx
c002071b:	c1 ea 0c             	shr    $0xc,%edx
c002071e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c0020724:	89 54 24 08          	mov    %edx,0x8(%esp)
        bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020728:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c002072c:	3b 7c 24 14          	cmp    0x14(%esp),%edi
c0020730:	0f 92 c1             	setb   %cl
c0020733:	3b 7c 24 18          	cmp    0x18(%esp),%edi
c0020737:	0f 93 c2             	setae  %dl
c002073a:	21 d1                	and    %edx,%ecx
c002073c:	88 4c 24 04          	mov    %cl,0x4(%esp)
    return (uintptr_t) va >> PDSHIFT;
c0020740:	89 fa                	mov    %edi,%edx
c0020742:	c1 ea 16             	shr    $0x16,%edx
        if (pd[pde_idx] == 0) {
c0020745:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0020749:	8d 34 91             	lea    (%ecx,%edx,4),%esi
c002074c:	83 3e 00             	cmpl   $0x0,(%esi)
c002074f:	0f 85 75 ff ff ff    	jne    c00206ca <pintos_init+0x3fe>
            pt = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c0020755:	83 ec 0c             	sub    $0xc,%esp
c0020758:	6a 03                	push   $0x3
c002075a:	e8 dd 32 00 00       	call   c0023a3c <palloc_get_page>
    return (uintptr_t) va & PGMASK;
c002075f:	89 c2                	mov    %eax,%edx
    ASSERT (pg_ofs(pt) == 0);
c0020761:	83 c4 10             	add    $0x10,%esp
c0020764:	a9 ff 0f 00 00       	test   $0xfff,%eax
c0020769:	0f 85 0f ff ff ff    	jne    c002067e <pintos_init+0x3b2>
    ASSERT (is_kernel_vaddr(vaddr));
c002076f:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020774:	0f 86 2a ff ff ff    	jbe    c00206a4 <pintos_init+0x3d8>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002077a:	81 c2 00 00 00 40    	add    $0x40000000,%edx
    return vtop(pt) | PTE_U | PTE_P | PTE_W;
c0020780:	83 ca 07             	or     $0x7,%edx
c0020783:	89 16                	mov    %edx,(%esi)
c0020785:	e9 40 ff ff ff       	jmp    c00206ca <pintos_init+0x3fe>
    ASSERT (is_kernel_vaddr(vaddr));
c002078a:	83 ec 0c             	sub    $0xc,%esp
c002078d:	8d 83 09 37 ff ff    	lea    -0xc8f7(%ebx),%eax
c0020793:	50                   	push   %eax
c0020794:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002079a:	50                   	push   %eax
c002079b:	8d 83 d4 24 ff ff    	lea    -0xdb2c(%ebx),%eax
c00207a1:	50                   	push   %eax
c00207a2:	6a 55                	push   $0x55
c00207a4:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c00207aa:	50                   	push   %eax
c00207ab:	e8 7d 89 00 00       	call   c002912d <debug_panic>
c00207b0:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
    asm volatile ("movl %0, %%cr3" : : "r" (vtop(init_page_dir)));
c00207b4:	c7 c0 c4 fc 03 c0    	mov    $0xc003fcc4,%eax
c00207ba:	8b 00                	mov    (%eax),%eax
c00207bc:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00207c1:	0f 86 be 00 00 00    	jbe    c0020885 <pintos_init+0x5b9>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00207c7:	05 00 00 00 40       	add    $0x40000000,%eax
c00207cc:	0f 22 d8             	mov    %eax,%cr3
    frame_init();
c00207cf:	e8 92 ec 00 00       	call   c002f466 <frame_init>
    tss_init ();
c00207d4:	e8 99 d0 00 00       	call   c002d872 <tss_init>
    gdt_init ();
c00207d9:	e8 29 cf 00 00       	call   c002d707 <gdt_init>
    intr_init();
c00207de:	e8 a0 15 00 00       	call   c0021d83 <intr_init>
    timer_init();
c00207e3:	e8 ae 3c 00 00       	call   c0024496 <timer_init>
    kbd_init();
c00207e8:	e8 36 42 00 00       	call   c0024a23 <kbd_init>
    input_init();
c00207ed:	e8 5c 5d 00 00       	call   c002654e <input_init>
    exception_init ();
c00207f2:	e8 83 be 00 00       	call   c002c67a <exception_init>
    syscall_init ();
c00207f7:	e8 e7 bf 00 00       	call   c002c7e3 <syscall_init>
    thread_start();
c00207fc:	e8 02 11 00 00       	call   c0021903 <thread_start>
    serial_init_queue();
c0020801:	e8 cb 46 00 00       	call   c0024ed1 <serial_init_queue>
    timer_calibrate();
c0020806:	e8 c2 3c 00 00       	call   c00244cd <timer_calibrate>
    ide_init ();
c002080b:	e8 fe 57 00 00       	call   c002600e <ide_init>
  locate_block_device (BLOCK_FILESYS, filesys_bdev_name);
c0020810:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
c0020816:	b8 01 00 00 00       	mov    $0x1,%eax
c002081b:	e8 a2 f9 ff ff       	call   c00201c2 <locate_block_device>
  locate_block_device (BLOCK_SCRATCH, scratch_bdev_name);
c0020820:	8b 93 1c 01 00 00    	mov    0x11c(%ebx),%edx
c0020826:	b8 02 00 00 00       	mov    $0x2,%eax
c002082b:	e8 92 f9 ff ff       	call   c00201c2 <locate_block_device>
  locate_block_device (BLOCK_SWAP, swap_bdev_name);
c0020830:	8b 93 18 01 00 00    	mov    0x118(%ebx),%edx
c0020836:	b8 03 00 00 00       	mov    $0x3,%eax
c002083b:	e8 82 f9 ff ff       	call   c00201c2 <locate_block_device>
    filesys_init (format_filesys);
c0020840:	83 ec 0c             	sub    $0xc,%esp
c0020843:	0f b6 83 24 01 00 00 	movzbl 0x124(%ebx),%eax
c002084a:	50                   	push   %eax
c002084b:	e8 54 d0 00 00       	call   c002d8a4 <filesys_init>
	swap_init ();
c0020850:	e8 81 f0 00 00       	call   c002f8d6 <swap_init>
    printf("Boot complete.\n");
c0020855:	8d 83 36 37 ff ff    	lea    -0xc8ca(%ebx),%eax
c002085b:	89 04 24             	mov    %eax,(%esp)
c002085e:	e8 a0 a8 00 00       	call   c002b103 <puts>
    if (*argv != NULL) {
c0020863:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020866:	83 c4 10             	add    $0x10,%esp
            if (a->name == NULL)
c0020869:	8d 83 ef 3f ff ff    	lea    -0xc011(%ebx),%eax
c002086f:	89 44 24 04          	mov    %eax,0x4(%esp)
    if (*argv != NULL) {
c0020873:	85 ff                	test   %edi,%edi
c0020875:	0f 85 94 00 00 00    	jne    c002090f <pintos_init+0x643>
    shutdown();
c002087b:	e8 e0 64 00 00       	call   c0026d60 <shutdown>
    thread_exit();
c0020880:	e8 a3 0d 00 00       	call   c0021628 <thread_exit>
    ASSERT (is_kernel_vaddr(vaddr));
c0020885:	83 ec 0c             	sub    $0xc,%esp
c0020888:	8d 83 09 37 ff ff    	lea    -0xc8f7(%ebx),%eax
c002088e:	50                   	push   %eax
c002088f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020895:	50                   	push   %eax
c0020896:	8d 83 d4 24 ff ff    	lea    -0xdb2c(%ebx),%eax
c002089c:	50                   	push   %eax
c002089d:	6a 55                	push   $0x55
c002089f:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c00208a5:	50                   	push   %eax
c00208a6:	e8 82 88 00 00       	call   c002912d <debug_panic>
        for (i = 1; i < a->argc; i++)
c00208ab:	8b 56 04             	mov    0x4(%esi),%edx
c00208ae:	83 fa 01             	cmp    $0x1,%edx
c00208b1:	7e 40                	jle    c00208f3 <pintos_init+0x627>
            if (argv[i] == NULL)
c00208b3:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c00208b7:	74 13                	je     c00208cc <pintos_init+0x600>
        for (i = 1; i < a->argc; i++)
c00208b9:	b8 01 00 00 00       	mov    $0x1,%eax
c00208be:	83 c0 01             	add    $0x1,%eax
c00208c1:	39 c2                	cmp    %eax,%edx
c00208c3:	74 2e                	je     c00208f3 <pintos_init+0x627>
            if (argv[i] == NULL)
c00208c5:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c00208ca:	75 f2                	jne    c00208be <pintos_init+0x5f2>
                PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c00208cc:	83 ec 08             	sub    $0x8,%esp
c00208cf:	83 ea 01             	sub    $0x1,%edx
c00208d2:	52                   	push   %edx
c00208d3:	57                   	push   %edi
c00208d4:	8d 83 6c 3c ff ff    	lea    -0xc394(%ebx),%eax
c00208da:	50                   	push   %eax
c00208db:	8d 83 b4 24 ff ff    	lea    -0xdb4c(%ebx),%eax
c00208e1:	50                   	push   %eax
c00208e2:	68 62 01 00 00       	push   $0x162
c00208e7:	8d 83 44 36 ff ff    	lea    -0xc9bc(%ebx),%eax
c00208ed:	50                   	push   %eax
c00208ee:	e8 3a 88 00 00       	call   c002912d <debug_panic>
        a->function(argv);
c00208f3:	83 ec 0c             	sub    $0xc,%esp
c00208f6:	55                   	push   %ebp
c00208f7:	ff 56 08             	call   *0x8(%esi)
        argv += a->argc;
c00208fa:	8b 46 04             	mov    0x4(%esi),%eax
c00208fd:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
    while (*argv != NULL) {
c0020901:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020904:	83 c4 10             	add    $0x10,%esp
c0020907:	85 ff                	test   %edi,%edi
c0020909:	0f 84 6c ff ff ff    	je     c002087b <pintos_init+0x5af>
            if (a->name == NULL)
c002090f:	8b 44 24 04          	mov    0x4(%esp),%eax
        for (a = actions;; a++)
c0020913:	8d b3 f4 5e ff ff    	lea    -0xa10c(%ebx),%esi
            else if (!strcmp(*argv, a->name))
c0020919:	83 ec 08             	sub    $0x8,%esp
c002091c:	50                   	push   %eax
c002091d:	57                   	push   %edi
c002091e:	e8 c0 7a 00 00       	call   c00283e3 <strcmp>
c0020923:	83 c4 10             	add    $0x10,%esp
c0020926:	85 c0                	test   %eax,%eax
c0020928:	74 81                	je     c00208ab <pintos_init+0x5df>
        for (a = actions;; a++)
c002092a:	83 c6 0c             	add    $0xc,%esi
            if (a->name == NULL)
c002092d:	8b 06                	mov    (%esi),%eax
c002092f:	85 c0                	test   %eax,%eax
c0020931:	75 e6                	jne    c0020919 <pintos_init+0x64d>
                PANIC ("unknown action `%s' (use -h for help)", *argv);
c0020933:	83 ec 0c             	sub    $0xc,%esp
c0020936:	57                   	push   %edi
c0020937:	8d 83 44 3c ff ff    	lea    -0xc3bc(%ebx),%eax
c002093d:	50                   	push   %eax
c002093e:	8d 83 b4 24 ff ff    	lea    -0xdb4c(%ebx),%eax
c0020944:	50                   	push   %eax
c0020945:	68 5b 01 00 00       	push   $0x15b
c002094a:	8d 83 44 36 ff ff    	lea    -0xc9bc(%ebx),%eax
c0020950:	50                   	push   %eax
c0020951:	e8 d7 87 00 00       	call   c002912d <debug_panic>
    argv[argc] = NULL;
c0020956:	8d ab 14 00 00 00    	lea    0x14(%ebx),%ebp
c002095c:	c7 44 b5 00 00 00 00 	movl   $0x0,0x0(%ebp,%esi,4)
c0020963:	00 
    printf("Kernel command line:");
c0020964:	83 ec 0c             	sub    $0xc,%esp
c0020967:	8d 83 45 37 ff ff    	lea    -0xc8bb(%ebx),%eax
c002096d:	50                   	push   %eax
c002096e:	e8 5e 6b 00 00       	call   c00274d1 <printf>
    for (i = 0; i < argc; i++)
c0020973:	89 ee                	mov    %ebp,%esi
c0020975:	8d 44 bd 00          	lea    0x0(%ebp,%edi,4),%eax
c0020979:	89 44 24 14          	mov    %eax,0x14(%esp)
c002097d:	83 c4 10             	add    $0x10,%esp
            printf(" '%s'", argv[i]);
c0020980:	8d ab 95 36 ff ff    	lea    -0xc96b(%ebx),%ebp
            printf(" %s", argv[i]);
c0020986:	8d 83 bf 47 ff ff    	lea    -0xb841(%ebx),%eax
c002098c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0020990:	e9 ef f9 ff ff       	jmp    c0020384 <pintos_init+0xb8>
    argv[argc] = NULL;
c0020995:	c7 84 bb 14 00 00 00 	movl   $0x0,0x14(%ebx,%edi,4)
c002099c:	00 00 00 00 
    printf("Kernel command line:");
c00209a0:	83 ec 0c             	sub    $0xc,%esp
c00209a3:	8d 83 45 37 ff ff    	lea    -0xc8bb(%ebx),%eax
c00209a9:	50                   	push   %eax
c00209aa:	e8 22 6b 00 00       	call   c00274d1 <printf>
c00209af:	83 c4 10             	add    $0x10,%esp
    printf("\n");
c00209b2:	83 ec 0c             	sub    $0xc,%esp
c00209b5:	6a 0a                	push   $0xa
c00209b7:	e8 b9 a7 00 00       	call   c002b175 <putchar>
    for (; *argv != NULL && **argv == '-'; argv++) {
c00209bc:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
c00209c2:	83 c4 10             	add    $0x10,%esp
c00209c5:	85 c0                	test   %eax,%eax
c00209c7:	0f 84 f2 fb ff ff    	je     c00205bf <pintos_init+0x2f3>
c00209cd:	80 38 2d             	cmpb   $0x2d,(%eax)
c00209d0:	0f 85 f1 fb ff ff    	jne    c00205c7 <pintos_init+0x2fb>
c00209d6:	8d ab 14 00 00 00    	lea    0x14(%ebx),%ebp
        char *name = strtok_r(*argv, "=", &save_ptr);
c00209dc:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c00209e0:	89 54 24 0c          	mov    %edx,0xc(%esp)
            thread_mlfqs = true;
c00209e4:	c7 c1 cc fc 03 c0    	mov    $0xc003fccc,%ecx
c00209ea:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00209ee:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00209f2:	e9 ed f9 ff ff       	jmp    c00203e4 <pintos_init+0x118>

c00209f7 <thread_cmp_priority>:
bool thread_cmp_priority(const struct list_elem *a,
                         const struct list_elem *b,
                         void *aux) {
    int priority_a = list_entry(a, struct thread, elem)->priority;
    int priority_b = list_entry(b, struct thread, elem)->priority;
    return priority_a > priority_b;
c00209f7:	8b 54 24 04          	mov    0x4(%esp),%edx
c00209fb:	8b 44 24 08          	mov    0x8(%esp),%eax
c00209ff:	8b 80 1c ff ff ff    	mov    -0xe4(%eax),%eax
c0020a05:	39 82 1c ff ff ff    	cmp    %eax,-0xe4(%edx)
c0020a0b:	0f 9f c0             	setg   %al
}
c0020a0e:	c3                   	ret    

c0020a0f <lock_cmp_priority>:
bool lock_cmp_priority(const struct list_elem *a,
                       const struct list_elem *b,
                       void *aux) {
    int priority_a = list_entry(a, struct lock, elem)->max_priority;
    int priority_b = list_entry(b, struct lock, elem)->max_priority;
    return priority_a > priority_b;
c0020a0f:	8b 54 24 04          	mov    0x4(%esp),%edx
c0020a13:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020a17:	8b 40 08             	mov    0x8(%eax),%eax
c0020a1a:	39 42 08             	cmp    %eax,0x8(%edx)
c0020a1d:	0f 9f c0             	setg   %al
}
c0020a20:	c3                   	ret    

c0020a21 <update_thread_recent_cpu>:
void update_thread_recent_cpu(struct thread *t, void *aux) {
c0020a21:	55                   	push   %ebp
c0020a22:	57                   	push   %edi
c0020a23:	56                   	push   %esi
c0020a24:	53                   	push   %ebx
c0020a25:	83 ec 1c             	sub    $0x1c,%esp
c0020a28:	e8 16 f7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020a2d:	81 c3 7f d2 01 00    	add    $0x1d27f,%ebx
c0020a33:	8b 6c 24 30          	mov    0x30(%esp),%ebp

/* Returns X * Y. */
static inline fixed_point_t
fix_mul (fixed_point_t x, fixed_point_t y)
{
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0020a37:	c7 c0 c8 fc 03 c0    	mov    $0xc003fcc8,%eax
c0020a3d:	8b 00                	mov    (%eax),%eax
c0020a3f:	99                   	cltd   
c0020a40:	0f a4 c2 11          	shld   $0x11,%eax,%edx
c0020a44:	c1 e0 11             	shl    $0x11,%eax
c0020a47:	89 d1                	mov    %edx,%ecx
c0020a49:	c1 f9 1f             	sar    $0x1f,%ecx
c0020a4c:	0f b7 f1             	movzwl %cx,%esi
c0020a4f:	bf 00 00 00 00       	mov    $0x0,%edi
c0020a54:	01 c6                	add    %eax,%esi
c0020a56:	11 d7                	adc    %edx,%edi
c0020a58:	89 f0                	mov    %esi,%eax
c0020a5a:	0f ac f8 10          	shrd   $0x10,%edi,%eax

/* Returns X / Y. */
static inline fixed_point_t
fix_div (fixed_point_t x, fixed_point_t y)
{
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c0020a5e:	89 c1                	mov    %eax,%ecx
c0020a60:	c1 f9 1f             	sar    $0x1f,%ecx
c0020a63:	89 c6                	mov    %eax,%esi
c0020a65:	89 cf                	mov    %ecx,%edi
c0020a67:	0f a4 c7 10          	shld   $0x10,%eax,%edi
c0020a6b:	c1 e6 10             	shl    $0x10,%esi
    return __mk_fix (x.f + y.f);
c0020a6e:	05 00 00 01 00       	add    $0x10000,%eax
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c0020a73:	99                   	cltd   
c0020a74:	52                   	push   %edx
c0020a75:	50                   	push   %eax
c0020a76:	57                   	push   %edi
c0020a77:	56                   	push   %esi
c0020a78:	e8 7a 80 00 00       	call   c0028af7 <__divdi3>
c0020a7d:	83 c4 10             	add    $0x10,%esp
c0020a80:	89 04 24             	mov    %eax,(%esp)
    t->recent_cpu = fix_add(fix_mul(t->recent_cpu, tmp), fix_int(t->nice));
c0020a83:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0020a86:	89 54 24 0c          	mov    %edx,0xc(%esp)
    ASSERT (n >= FIX_MIN_INT && n <= FIX_MAX_INT);
c0020a8a:	81 c2 ff ff 00 00    	add    $0xffff,%edx
c0020a90:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
c0020a96:	77 65                	ja     c0020afd <update_thread_recent_cpu+0xdc>
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0020a98:	8b 45 20             	mov    0x20(%ebp),%eax
c0020a9b:	89 44 24 08          	mov    %eax,0x8(%esp)
c0020a9f:	89 c7                	mov    %eax,%edi
c0020aa1:	c1 ff 1f             	sar    $0x1f,%edi
c0020aa4:	8b 0c 24             	mov    (%esp),%ecx
c0020aa7:	89 cb                	mov    %ecx,%ebx
c0020aa9:	c1 fb 1f             	sar    $0x1f,%ebx
c0020aac:	89 fe                	mov    %edi,%esi
c0020aae:	0f af 34 24          	imul   (%esp),%esi
c0020ab2:	89 d9                	mov    %ebx,%ecx
c0020ab4:	0f af c8             	imul   %eax,%ecx
c0020ab7:	01 f1                	add    %esi,%ecx
c0020ab9:	8b 04 24             	mov    (%esp),%eax
c0020abc:	f7 64 24 08          	mull   0x8(%esp)
c0020ac0:	89 04 24             	mov    %eax,(%esp)
c0020ac3:	89 54 24 04          	mov    %edx,0x4(%esp)
c0020ac7:	01 4c 24 04          	add    %ecx,0x4(%esp)
c0020acb:	8b 74 24 04          	mov    0x4(%esp),%esi
c0020acf:	c1 fe 1f             	sar    $0x1f,%esi
c0020ad2:	0f b7 ce             	movzwl %si,%ecx
c0020ad5:	bb 00 00 00 00       	mov    $0x0,%ebx
c0020ada:	8b 04 24             	mov    (%esp),%eax
c0020add:	8b 54 24 04          	mov    0x4(%esp),%edx
c0020ae1:	01 c8                	add    %ecx,%eax
c0020ae3:	11 da                	adc    %ebx,%edx
c0020ae5:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return __mk_fix (n * FIX_F);
c0020ae9:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0020aed:	c1 e1 10             	shl    $0x10,%ecx
    return __mk_fix (x.f + y.f);
c0020af0:	01 c8                	add    %ecx,%eax
c0020af2:	89 45 20             	mov    %eax,0x20(%ebp)
}
c0020af5:	83 c4 1c             	add    $0x1c,%esp
c0020af8:	5b                   	pop    %ebx
c0020af9:	5e                   	pop    %esi
c0020afa:	5f                   	pop    %edi
c0020afb:	5d                   	pop    %ebp
c0020afc:	c3                   	ret    
    ASSERT (n >= FIX_MIN_INT && n <= FIX_MAX_INT);
c0020afd:	83 ec 0c             	sub    $0xc,%esp
c0020b00:	8d 83 90 3c ff ff    	lea    -0xc370(%ebx),%eax
c0020b06:	50                   	push   %eax
c0020b07:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020b0d:	50                   	push   %eax
c0020b0e:	8d 83 e4 25 ff ff    	lea    -0xda1c(%ebx),%eax
c0020b14:	50                   	push   %eax
c0020b15:	6a 27                	push   $0x27
c0020b17:	8d 83 9e 3d ff ff    	lea    -0xc262(%ebx),%eax
c0020b1d:	50                   	push   %eax
c0020b1e:	e8 0a 86 00 00       	call   c002912d <debug_panic>

c0020b23 <alloc_frame>:
alloc_frame(struct thread *t, size_t size) {
c0020b23:	53                   	push   %ebx
c0020b24:	83 ec 08             	sub    $0x8,%esp
c0020b27:	e8 17 f6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020b2c:	81 c3 80 d1 01 00    	add    $0x1d180,%ebx
    return t != NULL && t->magic == THREAD_MAGIC;
c0020b32:	85 c0                	test   %eax,%eax
c0020b34:	74 0c                	je     c0020b42 <alloc_frame+0x1f>
c0020b36:	81 b8 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%eax)
c0020b3d:	bf 6a cd 
c0020b40:	74 52                	je     c0020b94 <alloc_frame+0x71>
    ASSERT(is_thread(t));
c0020b42:	83 ec 0c             	sub    $0xc,%esp
c0020b45:	8d 83 ee 3d ff ff    	lea    -0xc212(%ebx),%eax
c0020b4b:	50                   	push   %eax
c0020b4c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020b52:	50                   	push   %eax
c0020b53:	8d 83 b8 25 ff ff    	lea    -0xda48(%ebx),%eax
c0020b59:	50                   	push   %eax
c0020b5a:	68 3d 02 00 00       	push   $0x23d
c0020b5f:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020b65:	50                   	push   %eax
c0020b66:	e8 c2 85 00 00       	call   c002912d <debug_panic>
    ASSERT(size % sizeof(uint32_t) == 0);
c0020b6b:	83 ec 0c             	sub    $0xc,%esp
c0020b6e:	8d 83 ba 3d ff ff    	lea    -0xc246(%ebx),%eax
c0020b74:	50                   	push   %eax
c0020b75:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020b7b:	50                   	push   %eax
c0020b7c:	8d 83 b8 25 ff ff    	lea    -0xda48(%ebx),%eax
c0020b82:	50                   	push   %eax
c0020b83:	68 3e 02 00 00       	push   $0x23e
c0020b88:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020b8e:	50                   	push   %eax
c0020b8f:	e8 99 85 00 00       	call   c002912d <debug_panic>
c0020b94:	f6 c2 03             	test   $0x3,%dl
c0020b97:	75 d2                	jne    c0020b6b <alloc_frame+0x48>
    t->stack -= size;
c0020b99:	8b 48 18             	mov    0x18(%eax),%ecx
c0020b9c:	29 d1                	sub    %edx,%ecx
c0020b9e:	89 48 18             	mov    %ecx,0x18(%eax)
}
c0020ba1:	89 c8                	mov    %ecx,%eax
c0020ba3:	83 c4 08             	add    $0x8,%esp
c0020ba6:	5b                   	pop    %ebx
c0020ba7:	c3                   	ret    

c0020ba8 <update_thread_priority_mlfqs>:
void update_thread_priority_mlfqs(struct thread *t, void *aux) {
c0020ba8:	57                   	push   %edi
c0020ba9:	56                   	push   %esi
c0020baa:	53                   	push   %ebx
c0020bab:	e8 93 f5 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020bb0:	81 c3 fc d0 01 00    	add    $0x1d0fc,%ebx
c0020bb6:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    ASSERT(thread_mlfqs);
c0020bba:	c7 c2 cc fc 03 c0    	mov    $0xc003fccc,%edx
c0020bc0:	80 3a 00             	cmpb   $0x0,(%edx)
c0020bc3:	74 58                	je     c0020c1d <update_thread_priority_mlfqs+0x75>
    if (t == idle_thread) {
c0020bc5:	39 8b 7c 01 00 00    	cmp    %ecx,0x17c(%ebx)
c0020bcb:	74 4c                	je     c0020c19 <update_thread_priority_mlfqs+0x71>
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c0020bcd:	8b 41 20             	mov    0x20(%ecx),%eax
c0020bd0:	99                   	cltd   
c0020bd1:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0020bd5:	c1 e0 10             	shl    $0x10,%eax
c0020bd8:	89 c6                	mov    %eax,%esi
c0020bda:	89 d7                	mov    %edx,%edi
c0020bdc:	89 d3                	mov    %edx,%ebx
c0020bde:	c1 fb 1f             	sar    $0x1f,%ebx
c0020be1:	81 e3 ff ff 03 00    	and    $0x3ffff,%ebx
c0020be7:	ba 00 00 00 00       	mov    $0x0,%edx
c0020bec:	01 de                	add    %ebx,%esi
c0020bee:	11 d7                	adc    %edx,%edi
c0020bf0:	89 f0                	mov    %esi,%eax
c0020bf2:	0f ac f8 12          	shrd   $0x12,%edi,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c0020bf6:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c0020bfc:	05 00 80 00 00       	add    $0x8000,%eax
c0020c01:	0f 49 d0             	cmovns %eax,%edx
c0020c04:	c1 fa 10             	sar    $0x10,%edx
    t->priority = PRI_MAX - fix_round(fix_div(t->recent_cpu, fix_int(4)))
c0020c07:	b8 3f 00 00 00       	mov    $0x3f,%eax
c0020c0c:	29 d0                	sub    %edx,%eax
                  - t->nice * 2;
c0020c0e:	8b 79 1c             	mov    0x1c(%ecx),%edi
c0020c11:	8d 14 3f             	lea    (%edi,%edi,1),%edx
c0020c14:	29 d0                	sub    %edx,%eax
c0020c16:	89 41 24             	mov    %eax,0x24(%ecx)
}
c0020c19:	5b                   	pop    %ebx
c0020c1a:	5e                   	pop    %esi
c0020c1b:	5f                   	pop    %edi
c0020c1c:	c3                   	ret    
    ASSERT(thread_mlfqs);
c0020c1d:	83 ec 0c             	sub    $0xc,%esp
c0020c20:	8d 93 fb 3d ff ff    	lea    -0xc205(%ebx),%edx
c0020c26:	52                   	push   %edx
c0020c27:	8d 93 de 36 ff ff    	lea    -0xc922(%ebx),%edx
c0020c2d:	52                   	push   %edx
c0020c2e:	8d 93 30 25 ff ff    	lea    -0xdad0(%ebx),%edx
c0020c34:	52                   	push   %edx
c0020c35:	68 91 01 00 00       	push   $0x191
c0020c3a:	8d 93 d7 3d ff ff    	lea    -0xc229(%ebx),%edx
c0020c40:	52                   	push   %edx
c0020c41:	e8 e7 84 00 00       	call   c002912d <debug_panic>

c0020c46 <init_thread>:
init_thread(struct thread *t, const char *name, int priority) {
c0020c46:	55                   	push   %ebp
c0020c47:	57                   	push   %edi
c0020c48:	56                   	push   %esi
c0020c49:	53                   	push   %ebx
c0020c4a:	83 ec 0c             	sub    $0xc,%esp
c0020c4d:	e8 f1 f4 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020c52:	81 c3 5a d0 01 00    	add    $0x1d05a,%ebx
    ASSERT(t != NULL);
c0020c58:	85 c0                	test   %eax,%eax
c0020c5a:	0f 84 06 01 00 00    	je     c0020d66 <init_thread+0x120>
c0020c60:	89 c6                	mov    %eax,%esi
c0020c62:	89 cd                	mov    %ecx,%ebp
    ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020c64:	83 f9 3f             	cmp    $0x3f,%ecx
c0020c67:	0f 87 22 01 00 00    	ja     c0020d8f <init_thread+0x149>
    ASSERT(name != NULL);
c0020c6d:	85 d2                	test   %edx,%edx
c0020c6f:	0f 84 43 01 00 00    	je     c0020db8 <init_thread+0x172>
    memset(t, 0, sizeof *t);
c0020c75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0020c7b:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%eax)
c0020c82:	00 00 00 
c0020c85:	8d 78 04             	lea    0x4(%eax),%edi
c0020c88:	83 e7 fc             	and    $0xfffffffc,%edi
c0020c8b:	89 c1                	mov    %eax,%ecx
c0020c8d:	29 f9                	sub    %edi,%ecx
c0020c8f:	81 c1 30 01 00 00    	add    $0x130,%ecx
c0020c95:	c1 e9 02             	shr    $0x2,%ecx
c0020c98:	b8 00 00 00 00       	mov    $0x0,%eax
c0020c9d:	f3 ab                	rep stos %eax,%es:(%edi)
    t->status = THREAD_BLOCKED;
c0020c9f:	c7 46 04 02 00 00 00 	movl   $0x2,0x4(%esi)
    t->ticks_blocked = 0;
c0020ca6:	c7 86 e4 00 00 00 00 	movl   $0x0,0xe4(%esi)
c0020cad:	00 00 00 
c0020cb0:	c7 86 e8 00 00 00 00 	movl   $0x0,0xe8(%esi)
c0020cb7:	00 00 00 
    strlcpy(t->name, name, sizeof t->name);
c0020cba:	83 ec 04             	sub    $0x4,%esp
c0020cbd:	6a 10                	push   $0x10
c0020cbf:	52                   	push   %edx
c0020cc0:	8d 46 08             	lea    0x8(%esi),%eax
c0020cc3:	50                   	push   %eax
c0020cc4:	e8 a6 7a 00 00       	call   c002876f <strlcpy>
    t->stack = (uint8_t *) t + PGSIZE;
c0020cc9:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
c0020ccf:	89 46 18             	mov    %eax,0x18(%esi)
    t->priority = priority;
c0020cd2:	89 6e 24             	mov    %ebp,0x24(%esi)
    t->original_priority = priority;
c0020cd5:	89 6e 28             	mov    %ebp,0x28(%esi)
    t->lock_waiting = NULL;
c0020cd8:	c7 86 04 01 00 00 00 	movl   $0x0,0x104(%esi)
c0020cdf:	00 00 00 
    list_init(&t->lock_list);
c0020ce2:	8d 86 f4 00 00 00    	lea    0xf4(%esi),%eax
c0020ce8:	89 04 24             	mov    %eax,(%esp)
c0020ceb:	e8 0a 85 00 00       	call   c00291fa <list_init>
    list_init(&t->child_list);
c0020cf0:	8d 86 cc 00 00 00    	lea    0xcc(%esi),%eax
c0020cf6:	89 04 24             	mov    %eax,(%esp)
c0020cf9:	e8 fc 84 00 00       	call   c00291fa <list_init>
    list_init(&t->file_descriptor_list);
c0020cfe:	8d 46 30             	lea    0x30(%esi),%eax
c0020d01:	89 04 24             	mov    %eax,(%esp)
c0020d04:	e8 f1 84 00 00       	call   c00291fa <list_init>
    list_init(&t->mmap_list);
c0020d09:	8d 86 1c 01 00 00    	lea    0x11c(%esi),%eax
c0020d0f:	89 04 24             	mov    %eax,(%esp)
c0020d12:	e8 e3 84 00 00       	call   c00291fa <list_init>
    t->magic = THREAD_MAGIC;
c0020d17:	c7 86 14 01 00 00 4b 	movl   $0xcd6abf4b,0x114(%esi)
c0020d1e:	bf 6a cd 
    if (thread_mlfqs) {
c0020d21:	83 c4 10             	add    $0x10,%esp
c0020d24:	c7 c0 cc fc 03 c0    	mov    $0xc003fccc,%eax
c0020d2a:	80 38 00             	cmpb   $0x0,(%eax)
c0020d2d:	0f 85 ae 00 00 00    	jne    c0020de1 <init_thread+0x19b>
    old_level = intr_disable();
c0020d33:	e8 2a 10 00 00       	call   c0021d62 <intr_disable>
c0020d38:	89 c7                	mov    %eax,%edi
    list_insert_ordered(&all_list, &t->allelem, (list_less_func *) &thread_cmp_priority, NULL);
c0020d3a:	6a 00                	push   $0x0
c0020d3c:	8d 83 4b 2d fe ff    	lea    -0x1d2b5(%ebx),%eax
c0020d42:	50                   	push   %eax
c0020d43:	81 c6 ec 00 00 00    	add    $0xec,%esi
c0020d49:	56                   	push   %esi
c0020d4a:	8d 83 80 01 00 00    	lea    0x180(%ebx),%eax
c0020d50:	50                   	push   %eax
c0020d51:	e8 9b 8f 00 00       	call   c0029cf1 <list_insert_ordered>
    intr_set_level(old_level);
c0020d56:	89 3c 24             	mov    %edi,(%esp)
c0020d59:	e8 0b 10 00 00       	call   c0021d69 <intr_set_level>
}
c0020d5e:	83 c4 1c             	add    $0x1c,%esp
c0020d61:	5b                   	pop    %ebx
c0020d62:	5e                   	pop    %esi
c0020d63:	5f                   	pop    %edi
c0020d64:	5d                   	pop    %ebp
c0020d65:	c3                   	ret    
    ASSERT(t != NULL);
c0020d66:	83 ec 0c             	sub    $0xc,%esp
c0020d69:	8d 83 0f 52 ff ff    	lea    -0xadf1(%ebx),%eax
c0020d6f:	50                   	push   %eax
c0020d70:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020d76:	50                   	push   %eax
c0020d77:	8d 83 ec 25 ff ff    	lea    -0xda14(%ebx),%eax
c0020d7d:	50                   	push   %eax
c0020d7e:	68 17 02 00 00       	push   $0x217
c0020d83:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020d89:	50                   	push   %eax
c0020d8a:	e8 9e 83 00 00       	call   c002912d <debug_panic>
    ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020d8f:	83 ec 0c             	sub    $0xc,%esp
c0020d92:	8d 83 b8 3c ff ff    	lea    -0xc348(%ebx),%eax
c0020d98:	50                   	push   %eax
c0020d99:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020d9f:	50                   	push   %eax
c0020da0:	8d 83 ec 25 ff ff    	lea    -0xda14(%ebx),%eax
c0020da6:	50                   	push   %eax
c0020da7:	68 18 02 00 00       	push   $0x218
c0020dac:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020db2:	50                   	push   %eax
c0020db3:	e8 75 83 00 00       	call   c002912d <debug_panic>
    ASSERT(name != NULL);
c0020db8:	83 ec 0c             	sub    $0xc,%esp
c0020dbb:	8d 83 08 3e ff ff    	lea    -0xc1f8(%ebx),%eax
c0020dc1:	50                   	push   %eax
c0020dc2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020dc8:	50                   	push   %eax
c0020dc9:	8d 83 ec 25 ff ff    	lea    -0xda14(%ebx),%eax
c0020dcf:	50                   	push   %eax
c0020dd0:	68 19 02 00 00       	push   $0x219
c0020dd5:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020ddb:	50                   	push   %eax
c0020ddc:	e8 4c 83 00 00       	call   c002912d <debug_panic>
        t->nice = 0;
c0020de1:	c7 46 1c 00 00 00 00 	movl   $0x0,0x1c(%esi)
        t->recent_cpu = fix_int(0);
c0020de8:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
        update_thread_priority_mlfqs(t, NULL);
c0020def:	83 ec 08             	sub    $0x8,%esp
c0020df2:	6a 00                	push   $0x0
c0020df4:	56                   	push   %esi
c0020df5:	e8 ae fd ff ff       	call   c0020ba8 <update_thread_priority_mlfqs>
c0020dfa:	83 c4 10             	add    $0x10,%esp
c0020dfd:	e9 31 ff ff ff       	jmp    c0020d33 <init_thread+0xed>

c0020e02 <thread_init>:
thread_init(void) {
c0020e02:	55                   	push   %ebp
c0020e03:	57                   	push   %edi
c0020e04:	56                   	push   %esi
c0020e05:	53                   	push   %ebx
c0020e06:	83 ec 0c             	sub    $0xc,%esp
c0020e09:	e8 35 f3 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020e0e:	81 c3 9e ce 01 00    	add    $0x1ce9e,%ebx
    ASSERT(intr_get_level() == INTR_OFF);
c0020e14:	e8 f7 0e 00 00       	call   c0021d10 <intr_get_level>
c0020e19:	85 c0                	test   %eax,%eax
c0020e1b:	75 7e                	jne    c0020e9b <thread_init+0x99>
    lock_init(&tid_lock);
c0020e1d:	83 ec 0c             	sub    $0xc,%esp
c0020e20:	8d b3 54 01 00 00    	lea    0x154(%ebx),%esi
c0020e26:	56                   	push   %esi
c0020e27:	e8 84 23 00 00       	call   c00231b0 <lock_init>
    list_init(&ready_list);
c0020e2c:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0020e32:	89 04 24             	mov    %eax,(%esp)
c0020e35:	e8 c0 83 00 00       	call   c00291fa <list_init>
    list_init(&all_list);
c0020e3a:	8d 83 80 01 00 00    	lea    0x180(%ebx),%eax
c0020e40:	89 04 24             	mov    %eax,(%esp)
c0020e43:	e8 b2 83 00 00       	call   c00291fa <list_init>
    asm ("mov %%esp, %0" : "=g" (esp));
c0020e48:	89 e0                	mov    %esp,%eax
    return (void *) ((uintptr_t) va & ~PGMASK);
c0020e4a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    initial_thread = running_thread();
c0020e4f:	89 83 78 01 00 00    	mov    %eax,0x178(%ebx)
    init_thread(initial_thread, "main", PRI_DEFAULT);
c0020e55:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020e5a:	8d 93 32 3e ff ff    	lea    -0xc1ce(%ebx),%edx
c0020e60:	e8 e1 fd ff ff       	call   c0020c46 <init_thread>
    initial_thread->status = THREAD_RUNNING;
c0020e65:	8b bb 78 01 00 00    	mov    0x178(%ebx),%edi
c0020e6b:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    lock_acquire(&tid_lock);
c0020e72:	89 34 24             	mov    %esi,(%esp)
c0020e75:	e8 e2 23 00 00       	call   c002325c <lock_acquire>
    tid = next_tid++;
c0020e7a:	8b ab bc fb ff ff    	mov    -0x444(%ebx),%ebp
c0020e80:	8d 45 01             	lea    0x1(%ebp),%eax
c0020e83:	89 83 bc fb ff ff    	mov    %eax,-0x444(%ebx)
    lock_release(&tid_lock);
c0020e89:	89 34 24             	mov    %esi,(%esp)
c0020e8c:	e8 cc 25 00 00       	call   c002345d <lock_release>
    initial_thread->tid = allocate_tid();
c0020e91:	89 2f                	mov    %ebp,(%edi)
}
c0020e93:	83 c4 1c             	add    $0x1c,%esp
c0020e96:	5b                   	pop    %ebx
c0020e97:	5e                   	pop    %esi
c0020e98:	5f                   	pop    %edi
c0020e99:	5d                   	pop    %ebp
c0020e9a:	c3                   	ret    
    ASSERT(intr_get_level() == INTR_OFF);
c0020e9b:	83 ec 0c             	sub    $0xc,%esp
c0020e9e:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c0020ea4:	50                   	push   %eax
c0020ea5:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020eab:	50                   	push   %eax
c0020eac:	8d 83 f8 25 ff ff    	lea    -0xda08(%ebx),%eax
c0020eb2:	50                   	push   %eax
c0020eb3:	6a 69                	push   $0x69
c0020eb5:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020ebb:	50                   	push   %eax
c0020ebc:	e8 6c 82 00 00       	call   c002912d <debug_panic>

c0020ec1 <thread_print_stats>:
thread_print_stats(void) {
c0020ec1:	53                   	push   %ebx
c0020ec2:	83 ec 0c             	sub    $0xc,%esp
c0020ec5:	e8 79 f2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020eca:	81 c3 e2 cd 01 00    	add    $0x1cde2,%ebx
    printf("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020ed0:	ff b3 40 01 00 00    	pushl  0x140(%ebx)
c0020ed6:	ff b3 3c 01 00 00    	pushl  0x13c(%ebx)
c0020edc:	ff b3 48 01 00 00    	pushl  0x148(%ebx)
c0020ee2:	ff b3 44 01 00 00    	pushl  0x144(%ebx)
c0020ee8:	ff b3 50 01 00 00    	pushl  0x150(%ebx)
c0020eee:	ff b3 4c 01 00 00    	pushl  0x14c(%ebx)
c0020ef4:	8d 83 e4 3c ff ff    	lea    -0xc31c(%ebx),%eax
c0020efa:	50                   	push   %eax
c0020efb:	e8 d1 65 00 00       	call   c00274d1 <printf>
}
c0020f00:	83 c4 28             	add    $0x28,%esp
c0020f03:	5b                   	pop    %ebx
c0020f04:	c3                   	ret    

c0020f05 <get_cmp_priority_func>:
list_less_func *get_cmp_priority_func() {
c0020f05:	e8 3d f2 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c0020f0a:	05 a2 cd 01 00       	add    $0x1cda2,%eax
    return (list_less_func *) &thread_cmp_priority;
c0020f0f:	8d 80 4b 2d fe ff    	lea    -0x1d2b5(%eax),%eax
}
c0020f15:	c3                   	ret    

c0020f16 <thread_unblock>:
thread_unblock(struct thread *t) {
c0020f16:	57                   	push   %edi
c0020f17:	56                   	push   %esi
c0020f18:	53                   	push   %ebx
c0020f19:	e8 25 f2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020f1e:	81 c3 8e cd 01 00    	add    $0x1cd8e,%ebx
c0020f24:	8b 74 24 10          	mov    0x10(%esp),%esi
    return t != NULL && t->magic == THREAD_MAGIC;
c0020f28:	85 f6                	test   %esi,%esi
c0020f2a:	74 0c                	je     c0020f38 <thread_unblock+0x22>
c0020f2c:	81 be 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%esi)
c0020f33:	bf 6a cd 
c0020f36:	74 52                	je     c0020f8a <thread_unblock+0x74>
    ASSERT(is_thread(t));
c0020f38:	83 ec 0c             	sub    $0xc,%esp
c0020f3b:	8d 83 ee 3d ff ff    	lea    -0xc212(%ebx),%eax
c0020f41:	50                   	push   %eax
c0020f42:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020f48:	50                   	push   %eax
c0020f49:	8d 83 8c 25 ff ff    	lea    -0xda74(%ebx),%eax
c0020f4f:	50                   	push   %eax
c0020f50:	68 12 01 00 00       	push   $0x112
c0020f55:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020f5b:	50                   	push   %eax
c0020f5c:	e8 cc 81 00 00       	call   c002912d <debug_panic>
    ASSERT(t->status == THREAD_BLOCKED);
c0020f61:	83 ec 0c             	sub    $0xc,%esp
c0020f64:	8d 83 37 3e ff ff    	lea    -0xc1c9(%ebx),%eax
c0020f6a:	50                   	push   %eax
c0020f6b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020f71:	50                   	push   %eax
c0020f72:	8d 83 8c 25 ff ff    	lea    -0xda74(%ebx),%eax
c0020f78:	50                   	push   %eax
c0020f79:	68 15 01 00 00       	push   $0x115
c0020f7e:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0020f84:	50                   	push   %eax
c0020f85:	e8 a3 81 00 00       	call   c002912d <debug_panic>
    old_level = intr_disable();
c0020f8a:	e8 d3 0d 00 00       	call   c0021d62 <intr_disable>
c0020f8f:	89 c7                	mov    %eax,%edi
    ASSERT(t->status == THREAD_BLOCKED);
c0020f91:	83 7e 04 02          	cmpl   $0x2,0x4(%esi)
c0020f95:	75 ca                	jne    c0020f61 <thread_unblock+0x4b>
    list_insert_ordered(&ready_list, &t->elem, (list_less_func *) &thread_cmp_priority, NULL);
c0020f97:	6a 00                	push   $0x0
c0020f99:	8d 83 4b 2d fe ff    	lea    -0x1d2b5(%ebx),%eax
c0020f9f:	50                   	push   %eax
c0020fa0:	8d 86 08 01 00 00    	lea    0x108(%esi),%eax
c0020fa6:	50                   	push   %eax
c0020fa7:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0020fad:	50                   	push   %eax
c0020fae:	e8 3e 8d 00 00       	call   c0029cf1 <list_insert_ordered>
    t->status = THREAD_READY;
c0020fb3:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
    intr_set_level(old_level);
c0020fba:	89 3c 24             	mov    %edi,(%esp)
c0020fbd:	e8 a7 0d 00 00       	call   c0021d69 <intr_set_level>
}
c0020fc2:	83 c4 10             	add    $0x10,%esp
c0020fc5:	5b                   	pop    %ebx
c0020fc6:	5e                   	pop    %esi
c0020fc7:	5f                   	pop    %edi
c0020fc8:	c3                   	ret    

c0020fc9 <thread_current>:
thread_current(void) {
c0020fc9:	53                   	push   %ebx
c0020fca:	83 ec 08             	sub    $0x8,%esp
c0020fcd:	e8 71 f1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0020fd2:	81 c3 da cc 01 00    	add    $0x1ccda,%ebx
    asm ("mov %%esp, %0" : "=g" (esp));
c0020fd8:	89 e0                	mov    %esp,%eax
    return t != NULL && t->magic == THREAD_MAGIC;
c0020fda:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0020fdf:	74 0c                	je     c0020fed <thread_current+0x24>
c0020fe1:	81 b8 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%eax)
c0020fe8:	bf 6a cd 
c0020feb:	74 52                	je     c002103f <thread_current+0x76>
    ASSERT(is_thread(t));
c0020fed:	83 ec 0c             	sub    $0xc,%esp
c0020ff0:	8d 83 ee 3d ff ff    	lea    -0xc212(%ebx),%eax
c0020ff6:	50                   	push   %eax
c0020ff7:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0020ffd:	50                   	push   %eax
c0020ffe:	8d 83 7c 25 ff ff    	lea    -0xda84(%ebx),%eax
c0021004:	50                   	push   %eax
c0021005:	68 2e 01 00 00       	push   $0x12e
c002100a:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0021010:	50                   	push   %eax
c0021011:	e8 17 81 00 00       	call   c002912d <debug_panic>
    ASSERT(t->status == THREAD_RUNNING);
c0021016:	83 ec 0c             	sub    $0xc,%esp
c0021019:	8d 83 53 3e ff ff    	lea    -0xc1ad(%ebx),%eax
c002101f:	50                   	push   %eax
c0021020:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021026:	50                   	push   %eax
c0021027:	8d 83 7c 25 ff ff    	lea    -0xda84(%ebx),%eax
c002102d:	50                   	push   %eax
c002102e:	68 2f 01 00 00       	push   $0x12f
c0021033:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0021039:	50                   	push   %eax
c002103a:	e8 ee 80 00 00       	call   c002912d <debug_panic>
c002103f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0021043:	75 d1                	jne    c0021016 <thread_current+0x4d>
}
c0021045:	83 c4 08             	add    $0x8,%esp
c0021048:	5b                   	pop    %ebx
c0021049:	c3                   	ret    

c002104a <thread_tick>:
thread_tick(void) {
c002104a:	53                   	push   %ebx
c002104b:	83 ec 08             	sub    $0x8,%esp
c002104e:	e8 f0 f0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021053:	81 c3 59 cc 01 00    	add    $0x1cc59,%ebx
    struct thread *t = thread_current();
c0021059:	e8 6b ff ff ff       	call   c0020fc9 <thread_current>
    if (t == idle_thread)
c002105e:	39 83 7c 01 00 00    	cmp    %eax,0x17c(%ebx)
c0021064:	74 30                	je     c0021096 <thread_tick+0x4c>
        else if (t->pagedir != NULL)
c0021066:	83 b8 10 01 00 00 00 	cmpl   $0x0,0x110(%eax)
c002106d:	74 37                	je     c00210a6 <thread_tick+0x5c>
          user_ticks++;
c002106f:	83 83 3c 01 00 00 01 	addl   $0x1,0x13c(%ebx)
c0021076:	83 93 40 01 00 00 00 	adcl   $0x0,0x140(%ebx)
    if (++thread_ticks >= TIME_SLICE)
c002107d:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
c0021083:	83 c0 01             	add    $0x1,%eax
c0021086:	89 83 34 01 00 00    	mov    %eax,0x134(%ebx)
c002108c:	83 f8 03             	cmp    $0x3,%eax
c002108f:	77 25                	ja     c00210b6 <thread_tick+0x6c>
}
c0021091:	83 c4 08             	add    $0x8,%esp
c0021094:	5b                   	pop    %ebx
c0021095:	c3                   	ret    
        idle_ticks++;
c0021096:	83 83 4c 01 00 00 01 	addl   $0x1,0x14c(%ebx)
c002109d:	83 93 50 01 00 00 00 	adcl   $0x0,0x150(%ebx)
c00210a4:	eb d7                	jmp    c002107d <thread_tick+0x33>
        kernel_ticks++;
c00210a6:	83 83 44 01 00 00 01 	addl   $0x1,0x144(%ebx)
c00210ad:	83 93 48 01 00 00 00 	adcl   $0x0,0x148(%ebx)
c00210b4:	eb c7                	jmp    c002107d <thread_tick+0x33>
        intr_yield_on_return();
c00210b6:	e8 5f 0f 00 00       	call   c002201a <intr_yield_on_return>
}
c00210bb:	eb d4                	jmp    c0021091 <thread_tick+0x47>

c00210bd <thread_name>:
thread_name(void) {
c00210bd:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->name;
c00210c0:	e8 04 ff ff ff       	call   c0020fc9 <thread_current>
c00210c5:	83 c0 08             	add    $0x8,%eax
}
c00210c8:	83 c4 0c             	add    $0xc,%esp
c00210cb:	c3                   	ret    

c00210cc <thread_tid>:
thread_tid(void) {
c00210cc:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->tid;
c00210cf:	e8 f5 fe ff ff       	call   c0020fc9 <thread_current>
c00210d4:	8b 00                	mov    (%eax),%eax
}
c00210d6:	83 c4 0c             	add    $0xc,%esp
c00210d9:	c3                   	ret    

c00210da <thread_foreach>:
thread_foreach(thread_action_func func, void *aux) {
c00210da:	55                   	push   %ebp
c00210db:	57                   	push   %edi
c00210dc:	56                   	push   %esi
c00210dd:	53                   	push   %ebx
c00210de:	83 ec 0c             	sub    $0xc,%esp
c00210e1:	e8 5d f0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00210e6:	81 c3 c6 cb 01 00    	add    $0x1cbc6,%ebx
c00210ec:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    ASSERT(intr_get_level() == INTR_OFF);
c00210f0:	e8 1b 0c 00 00       	call   c0021d10 <intr_get_level>
c00210f5:	85 c0                	test   %eax,%eax
c00210f7:	75 48                	jne    c0021141 <thread_foreach+0x67>
    for (e = list_begin(&all_list); e != list_end(&all_list);
c00210f9:	83 ec 0c             	sub    $0xc,%esp
c00210fc:	8d 83 80 01 00 00    	lea    0x180(%ebx),%eax
c0021102:	50                   	push   %eax
c0021103:	e8 4a 81 00 00       	call   c0029252 <list_begin>
c0021108:	89 c6                	mov    %eax,%esi
c002110a:	83 c4 10             	add    $0x10,%esp
c002110d:	8d bb 80 01 00 00    	lea    0x180(%ebx),%edi
c0021113:	83 ec 0c             	sub    $0xc,%esp
c0021116:	57                   	push   %edi
c0021117:	e8 d8 81 00 00       	call   c00292f4 <list_end>
c002111c:	83 c4 10             	add    $0x10,%esp
c002111f:	39 f0                	cmp    %esi,%eax
c0021121:	74 47                	je     c002116a <thread_foreach+0x90>
        func(t, aux);
c0021123:	83 ec 08             	sub    $0x8,%esp
c0021126:	55                   	push   %ebp
        struct thread *t = list_entry(e, struct thread, allelem);
c0021127:	8d 86 14 ff ff ff    	lea    -0xec(%esi),%eax
        func(t, aux);
c002112d:	50                   	push   %eax
c002112e:	ff 54 24 30          	call   *0x30(%esp)
         e = list_next(e)) {
c0021132:	89 34 24             	mov    %esi,(%esp)
c0021135:	e8 5d 81 00 00       	call   c0029297 <list_next>
c002113a:	89 c6                	mov    %eax,%esi
c002113c:	83 c4 10             	add    $0x10,%esp
c002113f:	eb d2                	jmp    c0021113 <thread_foreach+0x39>
    ASSERT(intr_get_level() == INTR_OFF);
c0021141:	83 ec 0c             	sub    $0xc,%esp
c0021144:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c002114a:	50                   	push   %eax
c002114b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021151:	50                   	push   %eax
c0021152:	8d 83 50 25 ff ff    	lea    -0xdab0(%ebx),%eax
c0021158:	50                   	push   %eax
c0021159:	68 65 01 00 00       	push   $0x165
c002115e:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0021164:	50                   	push   %eax
c0021165:	e8 c3 7f 00 00       	call   c002912d <debug_panic>
}
c002116a:	83 c4 0c             	add    $0xc,%esp
c002116d:	5b                   	pop    %ebx
c002116e:	5e                   	pop    %esi
c002116f:	5f                   	pop    %edi
c0021170:	5d                   	pop    %ebp
c0021171:	c3                   	ret    

c0021172 <thread_get_priority>:
thread_get_priority(void) {
c0021172:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->priority;
c0021175:	e8 4f fe ff ff       	call   c0020fc9 <thread_current>
c002117a:	8b 40 24             	mov    0x24(%eax),%eax
}
c002117d:	83 c4 0c             	add    $0xc,%esp
c0021180:	c3                   	ret    

c0021181 <get_ready_list_size>:
int get_ready_list_size(void) {
c0021181:	56                   	push   %esi
c0021182:	53                   	push   %ebx
c0021183:	83 ec 10             	sub    $0x10,%esp
c0021186:	e8 b8 ef 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002118b:	81 c3 21 cb 01 00    	add    $0x1cb21,%ebx
    return list_size(&ready_list) + ((thread_current() != idle_thread) ? 1 : 0);
c0021191:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0021197:	50                   	push   %eax
c0021198:	e8 be 86 00 00       	call   c002985b <list_size>
c002119d:	89 c6                	mov    %eax,%esi
c002119f:	e8 25 fe ff ff       	call   c0020fc9 <thread_current>
c00211a4:	39 83 7c 01 00 00    	cmp    %eax,0x17c(%ebx)
c00211aa:	0f 95 c0             	setne  %al
c00211ad:	0f b6 c0             	movzbl %al,%eax
c00211b0:	01 f0                	add    %esi,%eax
};
c00211b2:	83 c4 14             	add    $0x14,%esp
c00211b5:	5b                   	pop    %ebx
c00211b6:	5e                   	pop    %esi
c00211b7:	c3                   	ret    

c00211b8 <update_all_priority>:
void update_all_priority(void) {
c00211b8:	83 ec 14             	sub    $0x14,%esp
c00211bb:	e8 87 ef 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c00211c0:	05 ec ca 01 00       	add    $0x1caec,%eax
    thread_foreach((thread_action_func) &update_thread_priority_mlfqs, NULL);
c00211c5:	6a 00                	push   $0x0
c00211c7:	8d 80 fc 2e fe ff    	lea    -0x1d104(%eax),%eax
c00211cd:	50                   	push   %eax
c00211ce:	e8 07 ff ff ff       	call   c00210da <thread_foreach>
}
c00211d3:	83 c4 1c             	add    $0x1c,%esp
c00211d6:	c3                   	ret    

c00211d7 <update_all_recent_cpu>:
void update_all_recent_cpu(void) {
c00211d7:	83 ec 14             	sub    $0x14,%esp
c00211da:	e8 68 ef 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c00211df:	05 cd ca 01 00       	add    $0x1cacd,%eax
    thread_foreach((thread_action_func) &update_thread_recent_cpu, NULL);
c00211e4:	6a 00                	push   $0x0
c00211e6:	8d 80 75 2d fe ff    	lea    -0x1d28b(%eax),%eax
c00211ec:	50                   	push   %eax
c00211ed:	e8 e8 fe ff ff       	call   c00210da <thread_foreach>
}
c00211f2:	83 c4 1c             	add    $0x1c,%esp
c00211f5:	c3                   	ret    

c00211f6 <update_cur_thread_cpu>:
void update_cur_thread_cpu(void) {
c00211f6:	83 ec 0c             	sub    $0xc,%esp
    struct thread *cur = thread_current();
c00211f9:	e8 cb fd ff ff       	call   c0020fc9 <thread_current>
    return __mk_fix (x.f + y.f);
c00211fe:	81 40 20 00 00 01 00 	addl   $0x10000,0x20(%eax)
}
c0021205:	83 c4 0c             	add    $0xc,%esp
c0021208:	c3                   	ret    

c0021209 <thread_get_nice>:
thread_get_nice(void) {
c0021209:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->nice;
c002120c:	e8 b8 fd ff ff       	call   c0020fc9 <thread_current>
c0021211:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0021214:	83 c4 0c             	add    $0xc,%esp
c0021217:	c3                   	ret    

c0021218 <update_load_avg>:
void update_load_avg(void) {
c0021218:	55                   	push   %ebp
c0021219:	57                   	push   %edi
c002121a:	56                   	push   %esi
c002121b:	53                   	push   %ebx
c002121c:	83 ec 1c             	sub    $0x1c,%esp
c002121f:	e8 1f ef 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021224:	81 c3 88 ca 01 00    	add    $0x1ca88,%ebx
    fixed_point_t a = fix_frac(get_ready_list_size(), 60);
c002122a:	e8 52 ff ff ff       	call   c0021181 <get_ready_list_size>
c002122f:	89 c1                	mov    %eax,%ecx
    ASSERT (n / d >= FIX_MIN_INT && n / d <= FIX_MAX_INT);
c0021231:	ba 89 88 88 88       	mov    $0x88888889,%edx
c0021236:	f7 ea                	imul   %edx
c0021238:	01 ca                	add    %ecx,%edx
c002123a:	c1 fa 05             	sar    $0x5,%edx
c002123d:	89 c8                	mov    %ecx,%eax
c002123f:	c1 f8 1f             	sar    $0x1f,%eax
c0021242:	29 c2                	sub    %eax,%edx
c0021244:	81 c2 ff ff 00 00    	add    $0xffff,%edx
c002124a:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
c0021250:	77 77                	ja     c00212c9 <update_load_avg+0xb1>
    global_load_avg = fix_add(a, b);
c0021252:	c7 c5 c8 fc 03 c0    	mov    $0xc003fcc8,%ebp
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0021258:	8b 45 00             	mov    0x0(%ebp),%eax
c002125b:	89 c7                	mov    %eax,%edi
c002125d:	c1 ff 1f             	sar    $0x1f,%edi
c0021260:	69 ff bb fb 00 00    	imul   $0xfbbb,%edi,%edi
c0021266:	be bb fb 00 00       	mov    $0xfbbb,%esi
c002126b:	f7 e6                	mul    %esi
c002126d:	89 04 24             	mov    %eax,(%esp)
c0021270:	89 54 24 04          	mov    %edx,0x4(%esp)
c0021274:	01 7c 24 04          	add    %edi,0x4(%esp)
c0021278:	8b 74 24 04          	mov    0x4(%esp),%esi
c002127c:	c1 fe 1f             	sar    $0x1f,%esi
c002127f:	89 f0                	mov    %esi,%eax
c0021281:	25 ff ff 00 00       	and    $0xffff,%eax
c0021286:	89 44 24 08          	mov    %eax,0x8(%esp)
c002128a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0021291:	00 
c0021292:	8b 04 24             	mov    (%esp),%eax
c0021295:	8b 54 24 04          	mov    0x4(%esp),%edx
c0021299:	03 44 24 08          	add    0x8(%esp),%eax
c002129d:	13 54 24 0c          	adc    0xc(%esp),%edx
c00212a1:	0f ac d0 10          	shrd   $0x10,%edx,%eax
c00212a5:	89 c6                	mov    %eax,%esi
    return __mk_fix ((long long) n * FIX_F / d);
c00212a7:	89 c8                	mov    %ecx,%eax
c00212a9:	99                   	cltd   
c00212aa:	0f a4 ca 10          	shld   $0x10,%ecx,%edx
c00212ae:	c1 e0 10             	shl    $0x10,%eax
c00212b1:	6a 00                	push   $0x0
c00212b3:	6a 3c                	push   $0x3c
c00212b5:	52                   	push   %edx
c00212b6:	50                   	push   %eax
c00212b7:	e8 3b 78 00 00       	call   c0028af7 <__divdi3>
    return __mk_fix (x.f + y.f);
c00212bc:	01 c6                	add    %eax,%esi
c00212be:	89 75 00             	mov    %esi,0x0(%ebp)
}
c00212c1:	83 c4 2c             	add    $0x2c,%esp
c00212c4:	5b                   	pop    %ebx
c00212c5:	5e                   	pop    %esi
c00212c6:	5f                   	pop    %edi
c00212c7:	5d                   	pop    %ebp
c00212c8:	c3                   	ret    
    ASSERT (n / d >= FIX_MIN_INT && n / d <= FIX_MAX_INT);
c00212c9:	83 ec 0c             	sub    $0xc,%esp
c00212cc:	8d 83 24 3d ff ff    	lea    -0xc2dc(%ebx),%eax
c00212d2:	50                   	push   %eax
c00212d3:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00212d9:	50                   	push   %eax
c00212da:	8d 83 24 25 ff ff    	lea    -0xdadc(%ebx),%eax
c00212e0:	50                   	push   %eax
c00212e1:	6a 30                	push   $0x30
c00212e3:	8d 83 9e 3d ff ff    	lea    -0xc262(%ebx),%eax
c00212e9:	50                   	push   %eax
c00212ea:	e8 3e 7e 00 00       	call   c002912d <debug_panic>

c00212ef <thread_get_load_avg>:
thread_get_load_avg(void) {
c00212ef:	55                   	push   %ebp
c00212f0:	57                   	push   %edi
c00212f1:	56                   	push   %esi
c00212f2:	53                   	push   %ebx
c00212f3:	e8 4f ee 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c00212f8:	05 b4 c9 01 00       	add    $0x1c9b4,%eax
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c00212fd:	c7 c0 c8 fc 03 c0    	mov    $0xc003fcc8,%eax
c0021303:	8b 38                	mov    (%eax),%edi
c0021305:	89 fb                	mov    %edi,%ebx
c0021307:	c1 fb 1f             	sar    $0x1f,%ebx
c002130a:	69 f3 00 00 64 00    	imul   $0x640000,%ebx,%esi
c0021310:	b9 00 00 64 00       	mov    $0x640000,%ecx
c0021315:	89 f8                	mov    %edi,%eax
c0021317:	f7 e1                	mul    %ecx
c0021319:	89 c7                	mov    %eax,%edi
c002131b:	89 d5                	mov    %edx,%ebp
c002131d:	01 f5                	add    %esi,%ebp
c002131f:	89 ee                	mov    %ebp,%esi
c0021321:	c1 fe 1f             	sar    $0x1f,%esi
c0021324:	0f b7 c6             	movzwl %si,%eax
c0021327:	ba 00 00 00 00       	mov    $0x0,%edx
c002132c:	01 f8                	add    %edi,%eax
c002132e:	11 ea                	adc    %ebp,%edx
c0021330:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c0021334:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c002133a:	05 00 80 00 00       	add    $0x8000,%eax
c002133f:	0f 48 c2             	cmovs  %edx,%eax
c0021342:	c1 f8 10             	sar    $0x10,%eax
}
c0021345:	5b                   	pop    %ebx
c0021346:	5e                   	pop    %esi
c0021347:	5f                   	pop    %edi
c0021348:	5d                   	pop    %ebp
c0021349:	c3                   	ret    

c002134a <thread_get_recent_cpu>:
thread_get_recent_cpu(void) {
c002134a:	55                   	push   %ebp
c002134b:	57                   	push   %edi
c002134c:	56                   	push   %esi
c002134d:	53                   	push   %ebx
c002134e:	83 ec 0c             	sub    $0xc,%esp
    return fix_round(fix_mul(fix_int(100), thread_current()->recent_cpu));
c0021351:	e8 73 fc ff ff       	call   c0020fc9 <thread_current>
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0021356:	8b 78 20             	mov    0x20(%eax),%edi
c0021359:	89 fb                	mov    %edi,%ebx
c002135b:	c1 fb 1f             	sar    $0x1f,%ebx
c002135e:	69 f3 00 00 64 00    	imul   $0x640000,%ebx,%esi
c0021364:	b9 00 00 64 00       	mov    $0x640000,%ecx
c0021369:	89 f8                	mov    %edi,%eax
c002136b:	f7 e1                	mul    %ecx
c002136d:	89 c7                	mov    %eax,%edi
c002136f:	89 d5                	mov    %edx,%ebp
c0021371:	01 f5                	add    %esi,%ebp
c0021373:	89 ee                	mov    %ebp,%esi
c0021375:	c1 fe 1f             	sar    $0x1f,%esi
c0021378:	0f b7 c6             	movzwl %si,%eax
c002137b:	ba 00 00 00 00       	mov    $0x0,%edx
c0021380:	01 f8                	add    %edi,%eax
c0021382:	11 ea                	adc    %ebp,%edx
c0021384:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c0021388:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c002138e:	05 00 80 00 00       	add    $0x8000,%eax
c0021393:	0f 48 c2             	cmovs  %edx,%eax
c0021396:	c1 f8 10             	sar    $0x10,%eax
}
c0021399:	83 c4 0c             	add    $0xc,%esp
c002139c:	5b                   	pop    %ebx
c002139d:	5e                   	pop    %esi
c002139e:	5f                   	pop    %edi
c002139f:	5d                   	pop    %ebp
c00213a0:	c3                   	ret    

c00213a1 <thread_schedule_tail>:
thread_schedule_tail(struct thread *prev) {
c00213a1:	57                   	push   %edi
c00213a2:	56                   	push   %esi
c00213a3:	53                   	push   %ebx
c00213a4:	e8 9a ed 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00213a9:	81 c3 03 c9 01 00    	add    $0x1c903,%ebx
c00213af:	8b 7c 24 10          	mov    0x10(%esp),%edi
    asm ("mov %%esp, %0" : "=g" (esp));
c00213b3:	89 e6                	mov    %esp,%esi
c00213b5:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    ASSERT(intr_get_level() == INTR_OFF);
c00213bb:	e8 50 09 00 00       	call   c0021d10 <intr_get_level>
c00213c0:	85 c0                	test   %eax,%eax
c00213c2:	75 24                	jne    c00213e8 <thread_schedule_tail+0x47>
    cur->status = THREAD_RUNNING;
c00213c4:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    thread_ticks = 0;
c00213cb:	c7 83 34 01 00 00 00 	movl   $0x0,0x134(%ebx)
c00213d2:	00 00 00 
     process_activate();
c00213d5:	e8 4d a1 00 00       	call   c002b527 <process_activate>
    if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) {
c00213da:	85 ff                	test   %edi,%edi
c00213dc:	74 06                	je     c00213e4 <thread_schedule_tail+0x43>
c00213de:	83 7f 04 03          	cmpl   $0x3,0x4(%edi)
c00213e2:	74 2d                	je     c0021411 <thread_schedule_tail+0x70>
}
c00213e4:	5b                   	pop    %ebx
c00213e5:	5e                   	pop    %esi
c00213e6:	5f                   	pop    %edi
c00213e7:	c3                   	ret    
    ASSERT(intr_get_level() == INTR_OFF);
c00213e8:	83 ec 0c             	sub    $0xc,%esp
c00213eb:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c00213f1:	50                   	push   %eax
c00213f2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00213f8:	50                   	push   %eax
c00213f9:	8d 83 0c 25 ff ff    	lea    -0xdaf4(%ebx),%eax
c00213ff:	50                   	push   %eax
c0021400:	68 68 02 00 00       	push   $0x268
c0021405:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c002140b:	50                   	push   %eax
c002140c:	e8 1c 7d 00 00       	call   c002912d <debug_panic>
    if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) {
c0021411:	39 bb 78 01 00 00    	cmp    %edi,0x178(%ebx)
c0021417:	74 cb                	je     c00213e4 <thread_schedule_tail+0x43>
        ASSERT(prev != cur);
c0021419:	39 f7                	cmp    %esi,%edi
c002141b:	74 0e                	je     c002142b <thread_schedule_tail+0x8a>
        palloc_free_page(prev);
c002141d:	83 ec 0c             	sub    $0xc,%esp
c0021420:	57                   	push   %edi
c0021421:	e8 81 27 00 00       	call   c0023ba7 <palloc_free_page>
c0021426:	83 c4 10             	add    $0x10,%esp
}
c0021429:	eb b9                	jmp    c00213e4 <thread_schedule_tail+0x43>
        ASSERT(prev != cur);
c002142b:	83 ec 0c             	sub    $0xc,%esp
c002142e:	8d 83 6f 3e ff ff    	lea    -0xc191(%ebx),%eax
c0021434:	50                   	push   %eax
c0021435:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002143b:	50                   	push   %eax
c002143c:	8d 83 0c 25 ff ff    	lea    -0xdaf4(%ebx),%eax
c0021442:	50                   	push   %eax
c0021443:	68 7b 02 00 00       	push   $0x27b
c0021448:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c002144e:	50                   	push   %eax
c002144f:	e8 d9 7c 00 00       	call   c002912d <debug_panic>

c0021454 <schedule>:
schedule(void) {
c0021454:	57                   	push   %edi
c0021455:	56                   	push   %esi
c0021456:	53                   	push   %ebx
c0021457:	e8 e7 ec 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002145c:	81 c3 50 c8 01 00    	add    $0x1c850,%ebx
    asm ("mov %%esp, %0" : "=g" (esp));
c0021462:	89 e6                	mov    %esp,%esi
c0021464:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    if (list_empty(&ready_list))
c002146a:	83 ec 0c             	sub    $0xc,%esp
c002146d:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0021473:	50                   	push   %eax
c0021474:	e8 25 84 00 00       	call   c002989e <list_empty>
c0021479:	83 c4 10             	add    $0x10,%esp
c002147c:	84 c0                	test   %al,%al
c002147e:	74 56                	je     c00214d6 <schedule+0x82>
        return idle_thread;
c0021480:	8b bb 7c 01 00 00    	mov    0x17c(%ebx),%edi
    ASSERT(intr_get_level() == INTR_OFF);
c0021486:	e8 85 08 00 00       	call   c0021d10 <intr_get_level>
c002148b:	85 c0                	test   %eax,%eax
c002148d:	75 61                	jne    c00214f0 <schedule+0x9c>
    ASSERT(cur->status != THREAD_RUNNING);
c002148f:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0021493:	0f 84 80 00 00 00    	je     c0021519 <schedule+0xc5>
    return t != NULL && t->magic == THREAD_MAGIC;
c0021499:	85 ff                	test   %edi,%edi
c002149b:	74 10                	je     c00214ad <schedule+0x59>
c002149d:	81 bf 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%edi)
c00214a4:	bf 6a cd 
c00214a7:	0f 84 95 00 00 00    	je     c0021542 <schedule+0xee>
    ASSERT(is_thread(next));
c00214ad:	83 ec 0c             	sub    $0xc,%esp
c00214b0:	8d 83 99 3e ff ff    	lea    -0xc167(%ebx),%eax
c00214b6:	50                   	push   %eax
c00214b7:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00214bd:	50                   	push   %eax
c00214be:	8d 83 9c 25 ff ff    	lea    -0xda64(%ebx),%eax
c00214c4:	50                   	push   %eax
c00214c5:	68 8f 02 00 00       	push   $0x28f
c00214ca:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c00214d0:	50                   	push   %eax
c00214d1:	e8 57 7c 00 00       	call   c002912d <debug_panic>
        return list_entry(list_pop_front(&ready_list),
c00214d6:	83 ec 0c             	sub    $0xc,%esp
c00214d9:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c00214df:	50                   	push   %eax
c00214e0:	e8 30 84 00 00       	call   c0029915 <list_pop_front>
c00214e5:	8d b8 f8 fe ff ff    	lea    -0x108(%eax),%edi
c00214eb:	83 c4 10             	add    $0x10,%esp
c00214ee:	eb 96                	jmp    c0021486 <schedule+0x32>
    ASSERT(intr_get_level() == INTR_OFF);
c00214f0:	83 ec 0c             	sub    $0xc,%esp
c00214f3:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c00214f9:	50                   	push   %eax
c00214fa:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021500:	50                   	push   %eax
c0021501:	8d 83 9c 25 ff ff    	lea    -0xda64(%ebx),%eax
c0021507:	50                   	push   %eax
c0021508:	68 8d 02 00 00       	push   $0x28d
c002150d:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0021513:	50                   	push   %eax
c0021514:	e8 14 7c 00 00       	call   c002912d <debug_panic>
    ASSERT(cur->status != THREAD_RUNNING);
c0021519:	83 ec 0c             	sub    $0xc,%esp
c002151c:	8d 83 7b 3e ff ff    	lea    -0xc185(%ebx),%eax
c0021522:	50                   	push   %eax
c0021523:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021529:	50                   	push   %eax
c002152a:	8d 83 9c 25 ff ff    	lea    -0xda64(%ebx),%eax
c0021530:	50                   	push   %eax
c0021531:	68 8e 02 00 00       	push   $0x28e
c0021536:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c002153c:	50                   	push   %eax
c002153d:	e8 eb 7b 00 00       	call   c002912d <debug_panic>
    struct thread *prev = NULL;
c0021542:	b8 00 00 00 00       	mov    $0x0,%eax
    if (cur != next)
c0021547:	39 f7                	cmp    %esi,%edi
c0021549:	74 0d                	je     c0021558 <schedule+0x104>
        prev = switch_threads(cur, next);
c002154b:	83 ec 08             	sub    $0x8,%esp
c002154e:	57                   	push   %edi
c002154f:	56                   	push   %esi
c0021550:	e8 3a 06 00 00       	call   c0021b8f <switch_threads>
c0021555:	83 c4 10             	add    $0x10,%esp
    thread_schedule_tail(prev);
c0021558:	83 ec 0c             	sub    $0xc,%esp
c002155b:	50                   	push   %eax
c002155c:	e8 40 fe ff ff       	call   c00213a1 <thread_schedule_tail>
}
c0021561:	83 c4 10             	add    $0x10,%esp
c0021564:	5b                   	pop    %ebx
c0021565:	5e                   	pop    %esi
c0021566:	5f                   	pop    %edi
c0021567:	c3                   	ret    

c0021568 <thread_block>:
thread_block(void) {
c0021568:	53                   	push   %ebx
c0021569:	83 ec 08             	sub    $0x8,%esp
c002156c:	e8 d2 eb 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021571:	81 c3 3b c7 01 00    	add    $0x1c73b,%ebx
    ASSERT(!intr_context());
c0021577:	e8 8c 0a 00 00       	call   c0022008 <intr_context>
c002157c:	84 c0                	test   %al,%al
c002157e:	75 1f                	jne    c002159f <thread_block+0x37>
    ASSERT(intr_get_level() == INTR_OFF);
c0021580:	e8 8b 07 00 00       	call   c0021d10 <intr_get_level>
c0021585:	85 c0                	test   %eax,%eax
c0021587:	75 3f                	jne    c00215c8 <thread_block+0x60>
    thread_current()->status = THREAD_BLOCKED;
c0021589:	e8 3b fa ff ff       	call   c0020fc9 <thread_current>
c002158e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    schedule();
c0021595:	e8 ba fe ff ff       	call   c0021454 <schedule>
}
c002159a:	83 c4 08             	add    $0x8,%esp
c002159d:	5b                   	pop    %ebx
c002159e:	c3                   	ret    
    ASSERT(!intr_context());
c002159f:	83 ec 0c             	sub    $0xc,%esp
c00215a2:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c00215a8:	50                   	push   %eax
c00215a9:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00215af:	50                   	push   %eax
c00215b0:	8d 83 a8 25 ff ff    	lea    -0xda58(%ebx),%eax
c00215b6:	50                   	push   %eax
c00215b7:	68 f1 00 00 00       	push   $0xf1
c00215bc:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c00215c2:	50                   	push   %eax
c00215c3:	e8 65 7b 00 00       	call   c002912d <debug_panic>
    ASSERT(intr_get_level() == INTR_OFF);
c00215c8:	83 ec 0c             	sub    $0xc,%esp
c00215cb:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c00215d1:	50                   	push   %eax
c00215d2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00215d8:	50                   	push   %eax
c00215d9:	8d 83 a8 25 ff ff    	lea    -0xda58(%ebx),%eax
c00215df:	50                   	push   %eax
c00215e0:	68 f2 00 00 00       	push   $0xf2
c00215e5:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c00215eb:	50                   	push   %eax
c00215ec:	e8 3c 7b 00 00       	call   c002912d <debug_panic>

c00215f1 <idle>:
idle(void *idle_started_ UNUSED) {
c00215f1:	53                   	push   %ebx
c00215f2:	83 ec 08             	sub    $0x8,%esp
c00215f5:	e8 49 eb 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00215fa:	81 c3 b2 c6 01 00    	add    $0x1c6b2,%ebx
    idle_thread = thread_current();
c0021600:	e8 c4 f9 ff ff       	call   c0020fc9 <thread_current>
c0021605:	89 83 7c 01 00 00    	mov    %eax,0x17c(%ebx)
    sema_up(idle_started);
c002160b:	83 ec 0c             	sub    $0xc,%esp
c002160e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0021612:	e8 47 1a 00 00       	call   c002305e <sema_up>
c0021617:	83 c4 10             	add    $0x10,%esp
        intr_disable();
c002161a:	e8 43 07 00 00       	call   c0021d62 <intr_disable>
        thread_block();
c002161f:	e8 44 ff ff ff       	call   c0021568 <thread_block>
        asm volatile ("sti; hlt" : : : "memory");
c0021624:	fb                   	sti    
c0021625:	f4                   	hlt    
c0021626:	eb f2                	jmp    c002161a <idle+0x29>

c0021628 <thread_exit>:
thread_exit(void) {
c0021628:	53                   	push   %ebx
c0021629:	83 ec 08             	sub    $0x8,%esp
c002162c:	e8 12 eb 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021631:	81 c3 7b c6 01 00    	add    $0x1c67b,%ebx
    ASSERT(!intr_context());
c0021637:	e8 cc 09 00 00       	call   c0022008 <intr_context>
c002163c:	84 c0                	test   %al,%al
c002163e:	74 29                	je     c0021669 <thread_exit+0x41>
c0021640:	83 ec 0c             	sub    $0xc,%esp
c0021643:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c0021649:	50                   	push   %eax
c002164a:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021650:	50                   	push   %eax
c0021651:	8d 83 70 25 ff ff    	lea    -0xda90(%ebx),%eax
c0021657:	50                   	push   %eax
c0021658:	68 3e 01 00 00       	push   $0x13e
c002165d:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0021663:	50                   	push   %eax
c0021664:	e8 c4 7a 00 00       	call   c002912d <debug_panic>
    process_exit ();
c0021669:	e8 e3 9d 00 00       	call   c002b451 <process_exit>
    intr_disable();
c002166e:	e8 ef 06 00 00       	call   c0021d62 <intr_disable>
    list_remove(&thread_current()->allelem);
c0021673:	e8 51 f9 ff ff       	call   c0020fc9 <thread_current>
c0021678:	83 ec 0c             	sub    $0xc,%esp
c002167b:	05 ec 00 00 00       	add    $0xec,%eax
c0021680:	50                   	push   %eax
c0021681:	e8 76 81 00 00       	call   c00297fc <list_remove>
    thread_current()->status = THREAD_DYING;
c0021686:	e8 3e f9 ff ff       	call   c0020fc9 <thread_current>
c002168b:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    schedule();
c0021692:	e8 bd fd ff ff       	call   c0021454 <schedule>
    NOT_REACHED();
c0021697:	8d 83 54 3d ff ff    	lea    -0xc2ac(%ebx),%eax
c002169d:	50                   	push   %eax
c002169e:	8d 83 70 25 ff ff    	lea    -0xda90(%ebx),%eax
c00216a4:	50                   	push   %eax
c00216a5:	68 4b 01 00 00       	push   $0x14b
c00216aa:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c00216b0:	50                   	push   %eax
c00216b1:	e8 77 7a 00 00       	call   c002912d <debug_panic>

c00216b6 <kernel_thread>:
kernel_thread(thread_func *function, void *aux) {
c00216b6:	56                   	push   %esi
c00216b7:	53                   	push   %ebx
c00216b8:	83 ec 04             	sub    $0x4,%esp
c00216bb:	e8 83 ea 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00216c0:	81 c3 ec c5 01 00    	add    $0x1c5ec,%ebx
c00216c6:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT(function != NULL);
c00216ca:	85 f6                	test   %esi,%esi
c00216cc:	74 13                	je     c00216e1 <kernel_thread+0x2b>
    intr_enable();       /* The scheduler runs with interrupts off. */
c00216ce:	e8 46 06 00 00       	call   c0021d19 <intr_enable>
    function(aux);       /* Execute the thread function. */
c00216d3:	83 ec 0c             	sub    $0xc,%esp
c00216d6:	ff 74 24 20          	pushl  0x20(%esp)
c00216da:	ff d6                	call   *%esi
    thread_exit();       /* If function() returns, kill the thread. */
c00216dc:	e8 47 ff ff ff       	call   c0021628 <thread_exit>
    ASSERT(function != NULL);
c00216e1:	83 ec 0c             	sub    $0xc,%esp
c00216e4:	8d 83 b9 3e ff ff    	lea    -0xc147(%ebx),%eax
c00216ea:	50                   	push   %eax
c00216eb:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00216f1:	50                   	push   %eax
c00216f2:	8d 83 c4 25 ff ff    	lea    -0xda3c(%ebx),%eax
c00216f8:	50                   	push   %eax
c00216f9:	68 f4 01 00 00       	push   $0x1f4
c00216fe:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0021704:	50                   	push   %eax
c0021705:	e8 23 7a 00 00       	call   c002912d <debug_panic>

c002170a <thread_yield>:
thread_yield(void) {
c002170a:	57                   	push   %edi
c002170b:	56                   	push   %esi
c002170c:	53                   	push   %ebx
c002170d:	e8 31 ea 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021712:	81 c3 9a c5 01 00    	add    $0x1c59a,%ebx
    struct thread *cur = thread_current();
c0021718:	e8 ac f8 ff ff       	call   c0020fc9 <thread_current>
c002171d:	89 c6                	mov    %eax,%esi
    ASSERT(!intr_context()); // int from inside
c002171f:	e8 e4 08 00 00       	call   c0022008 <intr_context>
c0021724:	84 c0                	test   %al,%al
c0021726:	75 4a                	jne    c0021772 <thread_yield+0x68>
    old_level = intr_disable(); // interrupt to schedule
c0021728:	e8 35 06 00 00       	call   c0021d62 <intr_disable>
c002172d:	89 c7                	mov    %eax,%edi
    if (cur != idle_thread)
c002172f:	39 b3 7c 01 00 00    	cmp    %esi,0x17c(%ebx)
c0021735:	74 1f                	je     c0021756 <thread_yield+0x4c>
        list_insert_ordered(&ready_list, &cur->elem, (list_less_func *) &thread_cmp_priority, NULL);
c0021737:	6a 00                	push   $0x0
c0021739:	8d 83 4b 2d fe ff    	lea    -0x1d2b5(%ebx),%eax
c002173f:	50                   	push   %eax
c0021740:	8d 86 08 01 00 00    	lea    0x108(%esi),%eax
c0021746:	50                   	push   %eax
c0021747:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c002174d:	50                   	push   %eax
c002174e:	e8 9e 85 00 00       	call   c0029cf1 <list_insert_ordered>
c0021753:	83 c4 10             	add    $0x10,%esp
    cur->status = THREAD_READY;
c0021756:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
    schedule();
c002175d:	e8 f2 fc ff ff       	call   c0021454 <schedule>
    intr_set_level(old_level);
c0021762:	83 ec 0c             	sub    $0xc,%esp
c0021765:	57                   	push   %edi
c0021766:	e8 fe 05 00 00       	call   c0021d69 <intr_set_level>
}
c002176b:	83 c4 10             	add    $0x10,%esp
c002176e:	5b                   	pop    %ebx
c002176f:	5e                   	pop    %esi
c0021770:	5f                   	pop    %edi
c0021771:	c3                   	ret    
    ASSERT(!intr_context()); // int from inside
c0021772:	83 ec 0c             	sub    $0xc,%esp
c0021775:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c002177b:	50                   	push   %eax
c002177c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021782:	50                   	push   %eax
c0021783:	8d 83 60 25 ff ff    	lea    -0xdaa0(%ebx),%eax
c0021789:	50                   	push   %eax
c002178a:	68 55 01 00 00       	push   $0x155
c002178f:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c0021795:	50                   	push   %eax
c0021796:	e8 92 79 00 00       	call   c002912d <debug_panic>

c002179b <thread_create>:
              thread_func *function, void *aux) {
c002179b:	55                   	push   %ebp
c002179c:	57                   	push   %edi
c002179d:	56                   	push   %esi
c002179e:	53                   	push   %ebx
c002179f:	83 ec 0c             	sub    $0xc,%esp
c00217a2:	e8 9c e9 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00217a7:	81 c3 05 c5 01 00    	add    $0x1c505,%ebx
    ASSERT(function != NULL);
c00217ad:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c00217b2:	0f 84 01 01 00 00    	je     c00218b9 <thread_create+0x11e>
    t = palloc_get_page(PAL_ZERO);
c00217b8:	83 ec 0c             	sub    $0xc,%esp
c00217bb:	6a 02                	push   $0x2
c00217bd:	e8 7a 22 00 00       	call   c0023a3c <palloc_get_page>
c00217c2:	89 c6                	mov    %eax,%esi
    if (t == NULL)
c00217c4:	83 c4 10             	add    $0x10,%esp
c00217c7:	85 c0                	test   %eax,%eax
c00217c9:	0f 84 2d 01 00 00    	je     c00218fc <thread_create+0x161>
    init_thread(t, name, priority);
c00217cf:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c00217d3:	8b 54 24 20          	mov    0x20(%esp),%edx
c00217d7:	e8 6a f4 ff ff       	call   c0020c46 <init_thread>
    lock_acquire(&tid_lock);
c00217dc:	83 ec 0c             	sub    $0xc,%esp
c00217df:	8d ab 54 01 00 00    	lea    0x154(%ebx),%ebp
c00217e5:	55                   	push   %ebp
c00217e6:	e8 71 1a 00 00       	call   c002325c <lock_acquire>
    tid = next_tid++;
c00217eb:	8b bb bc fb ff ff    	mov    -0x444(%ebx),%edi
c00217f1:	8d 47 01             	lea    0x1(%edi),%eax
c00217f4:	89 83 bc fb ff ff    	mov    %eax,-0x444(%ebx)
    lock_release(&tid_lock);
c00217fa:	89 2c 24             	mov    %ebp,(%esp)
c00217fd:	e8 5b 1c 00 00       	call   c002345d <lock_release>
    tid = t->tid = allocate_tid();
c0021802:	89 3e                	mov    %edi,(%esi)
    if (thread_current() != NULL) {
c0021804:	e8 c0 f7 ff ff       	call   c0020fc9 <thread_current>
c0021809:	89 c5                	mov    %eax,%ebp
c002180b:	83 c4 10             	add    $0x10,%esp
c002180e:	85 c0                	test   %eax,%eax
c0021810:	74 33                	je     c0021845 <thread_create+0xaa>
        t->parent = parent;
c0021812:	89 86 dc 00 00 00    	mov    %eax,0xdc(%esi)
        struct process_info *info_t = (struct process_info *) malloc(sizeof(struct process_info));
c0021818:	83 ec 0c             	sub    $0xc,%esp
c002181b:	6a 18                	push   $0x18
c002181d:	e8 2c 26 00 00       	call   c0023e4e <malloc>
        info_t->is_waiting = false;
c0021822:	c6 00 00             	movb   $0x0,(%eax)
        info_t->has_exited = false;
c0021825:	c6 40 01 00          	movb   $0x0,0x1(%eax)
        info_t->tid = tid;
c0021829:	89 78 04             	mov    %edi,0x4(%eax)
        info_t->thread_ = t;
c002182c:	89 70 14             	mov    %esi,0x14(%eax)
        list_push_back(&parent->child_list, &info_t->elem);
c002182f:	83 c4 08             	add    $0x8,%esp
c0021832:	83 c0 0c             	add    $0xc,%eax
c0021835:	50                   	push   %eax
c0021836:	81 c5 cc 00 00 00    	add    $0xcc,%ebp
c002183c:	55                   	push   %ebp
c002183d:	e8 9d 7f 00 00       	call   c00297df <list_push_back>
c0021842:	83 c4 10             	add    $0x10,%esp
    kf = alloc_frame(t, sizeof *kf);
c0021845:	ba 0c 00 00 00       	mov    $0xc,%edx
c002184a:	89 f0                	mov    %esi,%eax
c002184c:	e8 d2 f2 ff ff       	call   c0020b23 <alloc_frame>
    kf->eip = NULL;
c0021851:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    kf->function = function;
c0021857:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c002185b:	89 48 04             	mov    %ecx,0x4(%eax)
    kf->aux = aux;
c002185e:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0021862:	89 50 08             	mov    %edx,0x8(%eax)
    ef = alloc_frame(t, sizeof *ef);
c0021865:	ba 04 00 00 00       	mov    $0x4,%edx
c002186a:	89 f0                	mov    %esi,%eax
c002186c:	e8 b2 f2 ff ff       	call   c0020b23 <alloc_frame>
    ef->eip = (void (*)(void)) kernel_thread;
c0021871:	8d 93 0a 3a fe ff    	lea    -0x1c5f6(%ebx),%edx
c0021877:	89 10                	mov    %edx,(%eax)
    sf = alloc_frame(t, sizeof *sf);
c0021879:	ba 1c 00 00 00       	mov    $0x1c,%edx
c002187e:	89 f0                	mov    %esi,%eax
c0021880:	e8 9e f2 ff ff       	call   c0020b23 <alloc_frame>
    sf->eip = switch_entry;
c0021885:	c7 c2 ac 1b 02 c0    	mov    $0xc0021bac,%edx
c002188b:	89 50 10             	mov    %edx,0x10(%eax)
    sf->ebp = 0;
c002188e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    thread_unblock(t);
c0021895:	83 ec 0c             	sub    $0xc,%esp
c0021898:	56                   	push   %esi
c0021899:	e8 78 f6 ff ff       	call   c0020f16 <thread_unblock>
    if (thread_current()->priority < priority) {
c002189e:	e8 26 f7 ff ff       	call   c0020fc9 <thread_current>
c00218a3:	83 c4 10             	add    $0x10,%esp
c00218a6:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c00218aa:	39 48 24             	cmp    %ecx,0x24(%eax)
c00218ad:	7c 33                	jl     c00218e2 <thread_create+0x147>
}
c00218af:	89 f8                	mov    %edi,%eax
c00218b1:	83 c4 0c             	add    $0xc,%esp
c00218b4:	5b                   	pop    %ebx
c00218b5:	5e                   	pop    %esi
c00218b6:	5f                   	pop    %edi
c00218b7:	5d                   	pop    %ebp
c00218b8:	c3                   	ret    
    ASSERT(function != NULL);
c00218b9:	83 ec 0c             	sub    $0xc,%esp
c00218bc:	8d 83 b9 3e ff ff    	lea    -0xc147(%ebx),%eax
c00218c2:	50                   	push   %eax
c00218c3:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00218c9:	50                   	push   %eax
c00218ca:	8d 83 d4 25 ff ff    	lea    -0xda2c(%ebx),%eax
c00218d0:	50                   	push   %eax
c00218d1:	68 ba 00 00 00       	push   $0xba
c00218d6:	8d 83 d7 3d ff ff    	lea    -0xc229(%ebx),%eax
c00218dc:	50                   	push   %eax
c00218dd:	e8 4b 78 00 00       	call   c002912d <debug_panic>
        enum intr_level old_level = intr_disable();
c00218e2:	e8 7b 04 00 00       	call   c0021d62 <intr_disable>
c00218e7:	89 c6                	mov    %eax,%esi
        thread_yield();
c00218e9:	e8 1c fe ff ff       	call   c002170a <thread_yield>
        intr_set_level(old_level);
c00218ee:	83 ec 0c             	sub    $0xc,%esp
c00218f1:	56                   	push   %esi
c00218f2:	e8 72 04 00 00       	call   c0021d69 <intr_set_level>
c00218f7:	83 c4 10             	add    $0x10,%esp
c00218fa:	eb b3                	jmp    c00218af <thread_create+0x114>
        return TID_ERROR;
c00218fc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c0021901:	eb ac                	jmp    c00218af <thread_create+0x114>

c0021903 <thread_start>:
thread_start(void) {
c0021903:	56                   	push   %esi
c0021904:	53                   	push   %ebx
c0021905:	83 ec 2c             	sub    $0x2c,%esp
c0021908:	e8 36 e8 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002190d:	81 c3 9f c3 01 00    	add    $0x1c39f,%ebx
    sema_init(&idle_started, 0);
c0021913:	6a 00                	push   $0x0
c0021915:	8d 74 24 18          	lea    0x18(%esp),%esi
c0021919:	56                   	push   %esi
c002191a:	e8 c0 15 00 00       	call   c0022edf <sema_init>
    thread_create("idle", PRI_MIN, idle, &idle_started);
c002191f:	56                   	push   %esi
c0021920:	8d 83 45 39 fe ff    	lea    -0x1c6bb(%ebx),%eax
c0021926:	50                   	push   %eax
c0021927:	6a 00                	push   $0x0
c0021929:	8d 83 ca 3e ff ff    	lea    -0xc136(%ebx),%eax
c002192f:	50                   	push   %eax
c0021930:	e8 66 fe ff ff       	call   c002179b <thread_create>
    intr_enable();
c0021935:	83 c4 20             	add    $0x20,%esp
c0021938:	e8 dc 03 00 00       	call   c0021d19 <intr_enable>
    sema_down(&idle_started);
c002193d:	83 ec 0c             	sub    $0xc,%esp
c0021940:	56                   	push   %esi
c0021941:	e8 ed 15 00 00       	call   c0022f33 <sema_down>
}
c0021946:	83 c4 34             	add    $0x34,%esp
c0021949:	5b                   	pop    %ebx
c002194a:	5e                   	pop    %esi
c002194b:	c3                   	ret    

c002194c <thread_set_priority>:
thread_set_priority(int new_priority) {
c002194c:	55                   	push   %ebp
c002194d:	57                   	push   %edi
c002194e:	56                   	push   %esi
c002194f:	53                   	push   %ebx
c0021950:	83 ec 0c             	sub    $0xc,%esp
c0021953:	e8 eb e7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021958:	81 c3 54 c3 01 00    	add    $0x1c354,%ebx
    struct thread *cur = thread_current();
c002195e:	e8 66 f6 ff ff       	call   c0020fc9 <thread_current>
c0021963:	89 c6                	mov    %eax,%esi
    if (thread_mlfqs) {
c0021965:	c7 c0 cc fc 03 c0    	mov    $0xc003fccc,%eax
c002196b:	80 38 00             	cmpb   $0x0,(%eax)
c002196e:	75 4d                	jne    c00219bd <thread_set_priority+0x71>
    enum intr_level old_level = intr_disable();
c0021970:	e8 ed 03 00 00       	call   c0021d62 <intr_disable>
c0021975:	89 c7                	mov    %eax,%edi
    int old_priority = cur->priority;
c0021977:	8b 6e 24             	mov    0x24(%esi),%ebp
    cur->original_priority = new_priority;
c002197a:	8b 44 24 20          	mov    0x20(%esp),%eax
c002197e:	89 46 28             	mov    %eax,0x28(%esi)
    if (list_empty(&cur->lock_list) || new_priority > old_priority) {
c0021981:	83 ec 0c             	sub    $0xc,%esp
c0021984:	8d 86 f4 00 00 00    	lea    0xf4(%esi),%eax
c002198a:	50                   	push   %eax
c002198b:	e8 0e 7f 00 00       	call   c002989e <list_empty>
c0021990:	83 c4 10             	add    $0x10,%esp
c0021993:	3b 6c 24 20          	cmp    0x20(%esp),%ebp
c0021997:	7c 04                	jl     c002199d <thread_set_priority+0x51>
c0021999:	84 c0                	test   %al,%al
c002199b:	74 0c                	je     c00219a9 <thread_set_priority+0x5d>
        cur->priority = new_priority;
c002199d:	8b 44 24 20          	mov    0x20(%esp),%eax
c00219a1:	89 46 24             	mov    %eax,0x24(%esi)
        thread_yield();
c00219a4:	e8 61 fd ff ff       	call   c002170a <thread_yield>
    intr_set_level(old_level);
c00219a9:	83 ec 0c             	sub    $0xc,%esp
c00219ac:	57                   	push   %edi
c00219ad:	e8 b7 03 00 00       	call   c0021d69 <intr_set_level>
c00219b2:	83 c4 10             	add    $0x10,%esp
}
c00219b5:	83 c4 0c             	add    $0xc,%esp
c00219b8:	5b                   	pop    %ebx
c00219b9:	5e                   	pop    %esi
c00219ba:	5f                   	pop    %edi
c00219bb:	5d                   	pop    %ebp
c00219bc:	c3                   	ret    
        printf("\n\n !!!mlfqs should not set priority\n\n\n");
c00219bd:	83 ec 0c             	sub    $0xc,%esp
c00219c0:	8d 83 78 3d ff ff    	lea    -0xc288(%ebx),%eax
c00219c6:	50                   	push   %eax
c00219c7:	e8 37 97 00 00       	call   c002b103 <puts>
        return;
c00219cc:	83 c4 10             	add    $0x10,%esp
c00219cf:	eb e4                	jmp    c00219b5 <thread_set_priority+0x69>

c00219d1 <thread_set_nice>:
thread_set_nice(int new_nice) {
c00219d1:	56                   	push   %esi
c00219d2:	53                   	push   %ebx
c00219d3:	83 ec 04             	sub    $0x4,%esp
c00219d6:	e8 68 e7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00219db:	81 c3 d1 c2 01 00    	add    $0x1c2d1,%ebx
    struct thread *cur = thread_current();
c00219e1:	e8 e3 f5 ff ff       	call   c0020fc9 <thread_current>
    cur->nice = new_nice;
c00219e6:	8b 54 24 10          	mov    0x10(%esp),%edx
c00219ea:	89 50 1c             	mov    %edx,0x1c(%eax)
    update_thread_priority_mlfqs(cur, NULL);
c00219ed:	83 ec 08             	sub    $0x8,%esp
c00219f0:	6a 00                	push   $0x0
c00219f2:	50                   	push   %eax
c00219f3:	e8 b0 f1 ff ff       	call   c0020ba8 <update_thread_priority_mlfqs>
    enum intr_level old_level = intr_disable();
c00219f8:	e8 65 03 00 00       	call   c0021d62 <intr_disable>
c00219fd:	89 c6                	mov    %eax,%esi
    thread_yield();
c00219ff:	e8 06 fd ff ff       	call   c002170a <thread_yield>
    intr_set_level(old_level);
c0021a04:	89 34 24             	mov    %esi,(%esp)
c0021a07:	e8 5d 03 00 00       	call   c0021d69 <intr_set_level>
}
c0021a0c:	83 c4 14             	add    $0x14,%esp
c0021a0f:	5b                   	pop    %ebx
c0021a10:	5e                   	pop    %esi
c0021a11:	c3                   	ret    

c0021a12 <thread_update_priority>:


void
thread_update_priority(struct thread *t) {
c0021a12:	55                   	push   %ebp
c0021a13:	57                   	push   %edi
c0021a14:	56                   	push   %esi
c0021a15:	53                   	push   %ebx
c0021a16:	83 ec 1c             	sub    $0x1c,%esp
c0021a19:	e8 25 e7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021a1e:	81 c3 8e c2 01 00    	add    $0x1c28e,%ebx
c0021a24:	8b 74 24 30          	mov    0x30(%esp),%esi
    enum intr_level old_level = intr_disable();
c0021a28:	e8 35 03 00 00       	call   c0021d62 <intr_disable>
c0021a2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int max_priority = t->original_priority;
c0021a31:	8b 7e 28             	mov    0x28(%esi),%edi
    int lock_priority;

    if (!list_empty(&t->lock_list)) {
c0021a34:	8d ae f4 00 00 00    	lea    0xf4(%esi),%ebp
c0021a3a:	83 ec 0c             	sub    $0xc,%esp
c0021a3d:	55                   	push   %ebp
c0021a3e:	e8 5b 7e 00 00       	call   c002989e <list_empty>
c0021a43:	83 c4 10             	add    $0x10,%esp
c0021a46:	84 c0                	test   %al,%al
c0021a48:	74 17                	je     c0021a61 <thread_update_priority+0x4f>
        lock_priority = list_entry (list_front(&t->lock_list), struct lock, elem)->max_priority;
        if (lock_priority > max_priority)
            max_priority = lock_priority;
    }

    t->priority = max_priority;
c0021a4a:	89 7e 24             	mov    %edi,0x24(%esi)
    intr_set_level(old_level);
c0021a4d:	83 ec 0c             	sub    $0xc,%esp
c0021a50:	ff 74 24 18          	pushl  0x18(%esp)
c0021a54:	e8 10 03 00 00       	call   c0021d69 <intr_set_level>
}
c0021a59:	83 c4 2c             	add    $0x2c,%esp
c0021a5c:	5b                   	pop    %ebx
c0021a5d:	5e                   	pop    %esi
c0021a5e:	5f                   	pop    %edi
c0021a5f:	5d                   	pop    %ebp
c0021a60:	c3                   	ret    
        list_sort(&t->lock_list, lock_cmp_priority, NULL);
c0021a61:	83 ec 04             	sub    $0x4,%esp
c0021a64:	6a 00                	push   $0x0
c0021a66:	8d 83 63 2d fe ff    	lea    -0x1d29d(%ebx),%eax
c0021a6c:	50                   	push   %eax
c0021a6d:	55                   	push   %ebp
c0021a6e:	e8 91 7f 00 00       	call   c0029a04 <list_sort>
        lock_priority = list_entry (list_front(&t->lock_list), struct lock, elem)->max_priority;
c0021a73:	89 2c 24             	mov    %ebp,(%esp)
c0021a76:	e8 47 7e 00 00       	call   c00298c2 <list_front>
        if (lock_priority > max_priority)
c0021a7b:	8b 40 08             	mov    0x8(%eax),%eax
c0021a7e:	83 c4 10             	add    $0x10,%esp
c0021a81:	39 c7                	cmp    %eax,%edi
c0021a83:	0f 4c f8             	cmovl  %eax,%edi
c0021a86:	eb c2                	jmp    c0021a4a <thread_update_priority+0x38>

c0021a88 <thread_donate_priority>:


/* Donate current priority to thread t. */
void
thread_donate_priority(struct thread *t) {
c0021a88:	57                   	push   %edi
c0021a89:	56                   	push   %esi
c0021a8a:	53                   	push   %ebx
c0021a8b:	e8 b3 e6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021a90:	81 c3 1c c2 01 00    	add    $0x1c21c,%ebx
c0021a96:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0021a9a:	e8 c3 02 00 00       	call   c0021d62 <intr_disable>
c0021a9f:	89 c7                	mov    %eax,%edi
    thread_update_priority(t);
c0021aa1:	83 ec 0c             	sub    $0xc,%esp
c0021aa4:	56                   	push   %esi
c0021aa5:	e8 68 ff ff ff       	call   c0021a12 <thread_update_priority>

    if (t->status == THREAD_READY) {
c0021aaa:	83 c4 10             	add    $0x10,%esp
c0021aad:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
c0021ab1:	74 10                	je     c0021ac3 <thread_donate_priority+0x3b>
        list_remove(&t->elem);
        list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
    }
    intr_set_level(old_level);
c0021ab3:	83 ec 0c             	sub    $0xc,%esp
c0021ab6:	57                   	push   %edi
c0021ab7:	e8 ad 02 00 00       	call   c0021d69 <intr_set_level>
}
c0021abc:	83 c4 10             	add    $0x10,%esp
c0021abf:	5b                   	pop    %ebx
c0021ac0:	5e                   	pop    %esi
c0021ac1:	5f                   	pop    %edi
c0021ac2:	c3                   	ret    
        list_remove(&t->elem);
c0021ac3:	81 c6 08 01 00 00    	add    $0x108,%esi
c0021ac9:	83 ec 0c             	sub    $0xc,%esp
c0021acc:	56                   	push   %esi
c0021acd:	e8 2a 7d 00 00       	call   c00297fc <list_remove>
        list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
c0021ad2:	6a 00                	push   $0x0
c0021ad4:	8d 83 4b 2d fe ff    	lea    -0x1d2b5(%ebx),%eax
c0021ada:	50                   	push   %eax
c0021adb:	56                   	push   %esi
c0021adc:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0021ae2:	50                   	push   %eax
c0021ae3:	e8 09 82 00 00       	call   c0029cf1 <list_insert_ordered>
c0021ae8:	83 c4 20             	add    $0x20,%esp
c0021aeb:	eb c6                	jmp    c0021ab3 <thread_donate_priority+0x2b>

c0021aed <thread_remove_lock>:

void thread_remove_lock(struct lock *lock) {
c0021aed:	56                   	push   %esi
c0021aee:	53                   	push   %ebx
c0021aef:	83 ec 04             	sub    $0x4,%esp
c0021af2:	e8 4c e6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021af7:	81 c3 b5 c1 01 00    	add    $0x1c1b5,%ebx
    enum intr_level old_level = intr_disable();
c0021afd:	e8 60 02 00 00       	call   c0021d62 <intr_disable>
c0021b02:	89 c6                	mov    %eax,%esi
    list_remove(&lock->elem);
c0021b04:	83 ec 0c             	sub    $0xc,%esp
c0021b07:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0021b0b:	83 c0 18             	add    $0x18,%eax
c0021b0e:	50                   	push   %eax
c0021b0f:	e8 e8 7c 00 00       	call   c00297fc <list_remove>
    thread_update_priority(thread_current());
c0021b14:	e8 b0 f4 ff ff       	call   c0020fc9 <thread_current>
c0021b19:	89 04 24             	mov    %eax,(%esp)
c0021b1c:	e8 f1 fe ff ff       	call   c0021a12 <thread_update_priority>
    intr_set_level(old_level);
c0021b21:	89 34 24             	mov    %esi,(%esp)
c0021b24:	e8 40 02 00 00       	call   c0021d69 <intr_set_level>
}
c0021b29:	83 c4 14             	add    $0x14,%esp
c0021b2c:	5b                   	pop    %ebx
c0021b2d:	5e                   	pop    %esi
c0021b2e:	c3                   	ret    

c0021b2f <thread_hold_the_lock>:

void thread_hold_the_lock(struct lock *lock) {
c0021b2f:	57                   	push   %edi
c0021b30:	56                   	push   %esi
c0021b31:	53                   	push   %ebx
c0021b32:	e8 0c e6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021b37:	81 c3 75 c1 01 00    	add    $0x1c175,%ebx
c0021b3d:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0021b41:	e8 1c 02 00 00       	call   c0021d62 <intr_disable>
c0021b46:	89 c7                	mov    %eax,%edi
    list_insert_ordered(&thread_current()->lock_list, &lock->elem, lock_cmp_priority, NULL);
c0021b48:	e8 7c f4 ff ff       	call   c0020fc9 <thread_current>
c0021b4d:	6a 00                	push   $0x0
c0021b4f:	8d 93 63 2d fe ff    	lea    -0x1d29d(%ebx),%edx
c0021b55:	52                   	push   %edx
c0021b56:	8d 56 18             	lea    0x18(%esi),%edx
c0021b59:	52                   	push   %edx
c0021b5a:	05 f4 00 00 00       	add    $0xf4,%eax
c0021b5f:	50                   	push   %eax
c0021b60:	e8 8c 81 00 00       	call   c0029cf1 <list_insert_ordered>

    if (lock->max_priority > thread_current()->priority) {
c0021b65:	8b 76 20             	mov    0x20(%esi),%esi
c0021b68:	e8 5c f4 ff ff       	call   c0020fc9 <thread_current>
c0021b6d:	83 c4 10             	add    $0x10,%esp
c0021b70:	3b 70 24             	cmp    0x24(%eax),%esi
c0021b73:	7f 10                	jg     c0021b85 <thread_hold_the_lock+0x56>
        thread_current()->priority = lock->max_priority;
        thread_yield();
    }

    intr_set_level(old_level);
c0021b75:	83 ec 0c             	sub    $0xc,%esp
c0021b78:	57                   	push   %edi
c0021b79:	e8 eb 01 00 00       	call   c0021d69 <intr_set_level>
}
c0021b7e:	83 c4 10             	add    $0x10,%esp
c0021b81:	5b                   	pop    %ebx
c0021b82:	5e                   	pop    %esi
c0021b83:	5f                   	pop    %edi
c0021b84:	c3                   	ret    
        thread_current()->priority = lock->max_priority;
c0021b85:	89 70 24             	mov    %esi,0x24(%eax)
        thread_yield();
c0021b88:	e8 7d fb ff ff       	call   c002170a <thread_yield>
c0021b8d:	eb e6                	jmp    c0021b75 <thread_hold_the_lock+0x46>

c0021b8f <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021b8f:	53                   	push   %ebx
	pushl %ebp
c0021b90:	55                   	push   %ebp
	pushl %esi
c0021b91:	56                   	push   %esi
	pushl %edi
c0021b92:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021b93:	8b 15 6c d8 03 c0    	mov    0xc003d86c,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021b99:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021b9d:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021ba0:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021ba4:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021ba7:	5f                   	pop    %edi
	popl %esi
c0021ba8:	5e                   	pop    %esi
	popl %ebp
c0021ba9:	5d                   	pop    %ebp
	popl %ebx
c0021baa:	5b                   	pop    %ebx
        ret
c0021bab:	c3                   	ret    

c0021bac <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021bac:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021baf:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021bb0:	e8 ec f7 ff ff       	call   c00213a1 <thread_schedule_tail>
	addl $4, %esp
c0021bb5:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021bb8:	c3                   	ret    

c0021bb9 <make_gate>:
   trap gate).  The difference is that entering an interrupt gate
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate(void (*function)(void), int dpl, int type) {
c0021bb9:	53                   	push   %ebx
c0021bba:	83 ec 08             	sub    $0x8,%esp
c0021bbd:	e8 81 e5 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021bc2:	81 c3 ea c0 01 00    	add    $0x1c0ea,%ebx
    uint32_t e0, e1;

    ASSERT (function != NULL);
c0021bc8:	85 c0                	test   %eax,%eax
c0021bca:	74 2c                	je     c0021bf8 <make_gate+0x3f>
    ASSERT (dpl >= 0 && dpl <= 3);
c0021bcc:	83 fa 03             	cmp    $0x3,%edx
c0021bcf:	77 50                	ja     c0021c21 <make_gate+0x68>
    ASSERT (type >= 0 && type <= 15);
c0021bd1:	83 f9 0f             	cmp    $0xf,%ecx
c0021bd4:	77 74                	ja     c0021c4a <make_gate+0x91>

    e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
          | (SEL_KCSEG << 16));              /* Target code segment. */

    e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021bd6:	89 c3                	mov    %eax,%ebx
c0021bd8:	66 bb 00 00          	mov    $0x0,%bx
          | (1 << 15)                        /* Present. */
          | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
          | (0 << 12)                        /* System. */
          | ((uint32_t) type << 8));         /* Gate type. */
c0021bdc:	c1 e1 08             	shl    $0x8,%ecx
c0021bdf:	09 cb                	or     %ecx,%ebx
          | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c0021be1:	c1 e2 0d             	shl    $0xd,%edx
          | ((uint32_t) type << 8));         /* Gate type. */
c0021be4:	09 d3                	or     %edx,%ebx
    e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021be6:	89 da                	mov    %ebx,%edx
c0021be8:	80 ce 80             	or     $0x80,%dh
    e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021beb:	0f b7 c0             	movzwl %ax,%eax
c0021bee:	0d 00 00 08 00       	or     $0x80000,%eax

    return e0 | ((uint64_t) e1 << 32);
}
c0021bf3:	83 c4 08             	add    $0x8,%esp
c0021bf6:	5b                   	pop    %ebx
c0021bf7:	c3                   	ret    
    ASSERT (function != NULL);
c0021bf8:	83 ec 0c             	sub    $0xc,%esp
c0021bfb:	8d 83 b9 3e ff ff    	lea    -0xc147(%ebx),%eax
c0021c01:	50                   	push   %eax
c0021c02:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021c08:	50                   	push   %eax
c0021c09:	8d 83 80 26 ff ff    	lea    -0xd980(%ebx),%eax
c0021c0f:	50                   	push   %eax
c0021c10:	68 1d 01 00 00       	push   $0x11d
c0021c15:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0021c1b:	50                   	push   %eax
c0021c1c:	e8 0c 75 00 00       	call   c002912d <debug_panic>
    ASSERT (dpl >= 0 && dpl <= 3);
c0021c21:	83 ec 0c             	sub    $0xc,%esp
c0021c24:	8d 83 e9 3e ff ff    	lea    -0xc117(%ebx),%eax
c0021c2a:	50                   	push   %eax
c0021c2b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021c31:	50                   	push   %eax
c0021c32:	8d 83 80 26 ff ff    	lea    -0xd980(%ebx),%eax
c0021c38:	50                   	push   %eax
c0021c39:	68 1e 01 00 00       	push   $0x11e
c0021c3e:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0021c44:	50                   	push   %eax
c0021c45:	e8 e3 74 00 00       	call   c002912d <debug_panic>
    ASSERT (type >= 0 && type <= 15);
c0021c4a:	83 ec 0c             	sub    $0xc,%esp
c0021c4d:	8d 83 fe 3e ff ff    	lea    -0xc102(%ebx),%eax
c0021c53:	50                   	push   %eax
c0021c54:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021c5a:	50                   	push   %eax
c0021c5b:	8d 83 80 26 ff ff    	lea    -0xd980(%ebx),%eax
c0021c61:	50                   	push   %eax
c0021c62:	68 1f 01 00 00       	push   $0x11f
c0021c67:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0021c6d:	50                   	push   %eax
c0021c6e:	e8 ba 74 00 00       	call   c002912d <debug_panic>

c0021c73 <register_handler>:
                 intr_handler_func *handler, const char *name) {
c0021c73:	56                   	push   %esi
c0021c74:	53                   	push   %ebx
c0021c75:	83 ec 04             	sub    $0x4,%esp
c0021c78:	e8 c6 e4 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021c7d:	81 c3 2f c0 01 00    	add    $0x1c02f,%ebx
    ASSERT (intr_handlers[vec_no] == NULL);
c0021c83:	0f b6 f0             	movzbl %al,%esi
c0021c86:	83 bc b3 d4 09 00 00 	cmpl   $0x0,0x9d4(%ebx,%esi,4)
c0021c8d:	00 
c0021c8e:	75 42                	jne    c0021cd2 <register_handler+0x5f>
    if (level == INTR_ON)
c0021c90:	83 f9 01             	cmp    $0x1,%ecx
c0021c93:	74 66                	je     c0021cfb <register_handler+0x88>
        idt[vec_no] = make_intr_gate(intr_stubs[vec_no], dpl);
c0021c95:	c7 c0 70 d8 03 c0    	mov    $0xc003d870,%eax

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate(void (*function)(void), int dpl) {
    return make_gate(function, dpl, 14);
c0021c9b:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021c9e:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021ca3:	e8 11 ff ff ff       	call   c0021bb9 <make_gate>
c0021ca8:	89 84 f3 d4 0d 00 00 	mov    %eax,0xdd4(%ebx,%esi,8)
c0021caf:	89 94 f3 d8 0d 00 00 	mov    %edx,0xdd8(%ebx,%esi,8)
    intr_handlers[vec_no] = handler;
c0021cb6:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021cba:	89 84 b3 d4 09 00 00 	mov    %eax,0x9d4(%ebx,%esi,4)
    intr_names[vec_no] = name;
c0021cc1:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021cc5:	89 84 b3 d4 05 00 00 	mov    %eax,0x5d4(%ebx,%esi,4)
}
c0021ccc:	83 c4 04             	add    $0x4,%esp
c0021ccf:	5b                   	pop    %ebx
c0021cd0:	5e                   	pop    %esi
c0021cd1:	c3                   	ret    
    ASSERT (intr_handlers[vec_no] == NULL);
c0021cd2:	83 ec 0c             	sub    $0xc,%esp
c0021cd5:	8d 83 16 3f ff ff    	lea    -0xc0ea(%ebx),%eax
c0021cdb:	50                   	push   %eax
c0021cdc:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021ce2:	50                   	push   %eax
c0021ce3:	8d 83 58 26 ff ff    	lea    -0xd9a8(%ebx),%eax
c0021ce9:	50                   	push   %eax
c0021cea:	68 a2 00 00 00       	push   $0xa2
c0021cef:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0021cf5:	50                   	push   %eax
c0021cf6:	e8 32 74 00 00       	call   c002912d <debug_panic>
        idt[vec_no] = make_trap_gate(intr_stubs[vec_no], dpl);
c0021cfb:	c7 c0 70 d8 03 c0    	mov    $0xc003d870,%eax

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate(void (*function)(void), int dpl) {
    return make_gate(function, dpl, 15);
c0021d01:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021d04:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021d09:	e8 ab fe ff ff       	call   c0021bb9 <make_gate>
c0021d0e:	eb 98                	jmp    c0021ca8 <register_handler+0x35>

c0021d10 <intr_get_level>:
    asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021d10:	9c                   	pushf  
c0021d11:	58                   	pop    %eax
    return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021d12:	c1 e8 09             	shr    $0x9,%eax
c0021d15:	83 e0 01             	and    $0x1,%eax
}
c0021d18:	c3                   	ret    

c0021d19 <intr_enable>:
intr_enable(void) {
c0021d19:	53                   	push   %ebx
c0021d1a:	83 ec 08             	sub    $0x8,%esp
c0021d1d:	e8 21 e4 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021d22:	81 c3 8a bf 01 00    	add    $0x1bf8a,%ebx
    enum intr_level old_level = intr_get_level();
c0021d28:	e8 e3 ff ff ff       	call   c0021d10 <intr_get_level>
    ASSERT (!intr_context());
c0021d2d:	80 bb b5 01 00 00 00 	cmpb   $0x0,0x1b5(%ebx)
c0021d34:	75 06                	jne    c0021d3c <intr_enable+0x23>
    asm volatile ("sti");
c0021d36:	fb                   	sti    
}
c0021d37:	83 c4 08             	add    $0x8,%esp
c0021d3a:	5b                   	pop    %ebx
c0021d3b:	c3                   	ret    
    ASSERT (!intr_context());
c0021d3c:	83 ec 0c             	sub    $0xc,%esp
c0021d3f:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c0021d45:	50                   	push   %eax
c0021d46:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021d4c:	50                   	push   %eax
c0021d4d:	8d 83 8c 26 ff ff    	lea    -0xd974(%ebx),%eax
c0021d53:	50                   	push   %eax
c0021d54:	6a 5e                	push   $0x5e
c0021d56:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0021d5c:	50                   	push   %eax
c0021d5d:	e8 cb 73 00 00       	call   c002912d <debug_panic>

c0021d62 <intr_disable>:
    enum intr_level old_level = intr_get_level();
c0021d62:	e8 a9 ff ff ff       	call   c0021d10 <intr_get_level>
    asm volatile ("cli" : : : "memory"); // clear interrupt
c0021d67:	fa                   	cli    
}
c0021d68:	c3                   	ret    

c0021d69 <intr_set_level>:
intr_set_level(enum intr_level level) {
c0021d69:	83 ec 0c             	sub    $0xc,%esp
    return level == INTR_ON ? intr_enable() : intr_disable();
c0021d6c:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021d71:	74 09                	je     c0021d7c <intr_set_level+0x13>
c0021d73:	e8 ea ff ff ff       	call   c0021d62 <intr_disable>
}
c0021d78:	83 c4 0c             	add    $0xc,%esp
c0021d7b:	c3                   	ret    
    return level == INTR_ON ? intr_enable() : intr_disable();
c0021d7c:	e8 98 ff ff ff       	call   c0021d19 <intr_enable>
c0021d81:	eb f5                	jmp    c0021d78 <intr_set_level+0xf>

c0021d83 <intr_init>:
intr_init(void) {
c0021d83:	55                   	push   %ebp
c0021d84:	57                   	push   %edi
c0021d85:	56                   	push   %esi
c0021d86:	53                   	push   %ebx
c0021d87:	83 ec 2c             	sub    $0x2c,%esp
c0021d8a:	e8 bc e3 00 00       	call   c003014b <__x86.get_pc_thunk.bp>
c0021d8f:	81 c5 1d bf 01 00    	add    $0x1bf1d,%ebp

/* Writes byte DATA to PORT. */
static inline void
outb(uint16_t port, uint8_t data) {
    /* See [IA32-v2b] "OUT". */
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021d95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0021d9a:	e6 21                	out    %al,$0x21
c0021d9c:	e6 a1                	out    %al,$0xa1
c0021d9e:	b9 11 00 00 00       	mov    $0x11,%ecx
c0021da3:	89 c8                	mov    %ecx,%eax
c0021da5:	e6 20                	out    %al,$0x20
c0021da7:	b8 20 00 00 00       	mov    $0x20,%eax
c0021dac:	e6 21                	out    %al,$0x21
c0021dae:	b8 04 00 00 00       	mov    $0x4,%eax
c0021db3:	e6 21                	out    %al,$0x21
c0021db5:	ba 01 00 00 00       	mov    $0x1,%edx
c0021dba:	89 d0                	mov    %edx,%eax
c0021dbc:	e6 21                	out    %al,$0x21
c0021dbe:	89 c8                	mov    %ecx,%eax
c0021dc0:	e6 a0                	out    %al,$0xa0
c0021dc2:	b8 28 00 00 00       	mov    $0x28,%eax
c0021dc7:	e6 a1                	out    %al,$0xa1
c0021dc9:	b8 02 00 00 00       	mov    $0x2,%eax
c0021dce:	e6 a1                	out    %al,$0xa1
c0021dd0:	89 d0                	mov    %edx,%eax
c0021dd2:	e6 a1                	out    %al,$0xa1
c0021dd4:	b8 00 00 00 00       	mov    $0x0,%eax
c0021dd9:	e6 21                	out    %al,$0x21
c0021ddb:	e6 a1                	out    %al,$0xa1
c0021ddd:	c7 c3 70 d8 03 c0    	mov    $0xc003d870,%ebx
c0021de3:	8d 85 d4 0d 00 00    	lea    0xdd4(%ebp),%eax
c0021de9:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0021ded:	8d bb 00 04 00 00    	lea    0x400(%ebx),%edi
c0021df3:	89 c6                	mov    %eax,%esi
    return make_gate(function, dpl, 14);
c0021df5:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021dfa:	ba 00 00 00 00       	mov    $0x0,%edx
c0021dff:	8b 03                	mov    (%ebx),%eax
c0021e01:	e8 b3 fd ff ff       	call   c0021bb9 <make_gate>
        idt[i] = make_intr_gate(intr_stubs[i], 0);
c0021e06:	89 06                	mov    %eax,(%esi)
c0021e08:	89 56 04             	mov    %edx,0x4(%esi)
c0021e0b:	83 c3 04             	add    $0x4,%ebx
c0021e0e:	83 c6 08             	add    $0x8,%esi
    for (i = 0; i < INTR_CNT; i++)
c0021e11:	39 fb                	cmp    %edi,%ebx
c0021e13:	75 e0                	jne    c0021df5 <intr_init+0x72>

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand(uint16_t limit, void *base) {
    return limit | ((uint64_t) (uint32_t) base << 16);
c0021e15:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0021e19:	ba 00 00 00 00       	mov    $0x0,%edx
c0021e1e:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021e22:	c1 e0 10             	shl    $0x10,%eax
c0021e25:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021e2a:	89 44 24 18          	mov    %eax,0x18(%esp)
c0021e2e:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021e32:	0f 01 5c 24 18       	lidtl  0x18(%esp)
    for (i = 0; i < INTR_CNT; i++)
c0021e37:	8d 85 d4 05 00 00    	lea    0x5d4(%ebp),%eax
c0021e3d:	8d 8d d4 09 00 00    	lea    0x9d4(%ebp),%ecx
        intr_names[i] = "unknown";
c0021e43:	8d 95 34 3f ff ff    	lea    -0xc0cc(%ebp),%edx
c0021e49:	89 10                	mov    %edx,(%eax)
c0021e4b:	83 c0 04             	add    $0x4,%eax
    for (i = 0; i < INTR_CNT; i++)
c0021e4e:	39 c1                	cmp    %eax,%ecx
c0021e50:	75 f7                	jne    c0021e49 <intr_init+0xc6>
    intr_names[0] = "#DE Divide Error";
c0021e52:	8d 85 3c 3f ff ff    	lea    -0xc0c4(%ebp),%eax
c0021e58:	89 85 d4 05 00 00    	mov    %eax,0x5d4(%ebp)
    intr_names[1] = "#DB Debug Exception";
c0021e5e:	8d 85 4d 3f ff ff    	lea    -0xc0b3(%ebp),%eax
c0021e64:	89 85 d8 05 00 00    	mov    %eax,0x5d8(%ebp)
    intr_names[2] = "NMI Interrupt";
c0021e6a:	8d 85 61 3f ff ff    	lea    -0xc09f(%ebp),%eax
c0021e70:	89 85 dc 05 00 00    	mov    %eax,0x5dc(%ebp)
    intr_names[3] = "#BP Breakpoint Exception";
c0021e76:	8d 85 6f 3f ff ff    	lea    -0xc091(%ebp),%eax
c0021e7c:	89 85 e0 05 00 00    	mov    %eax,0x5e0(%ebp)
    intr_names[4] = "#OF Overflow Exception";
c0021e82:	8d 85 88 3f ff ff    	lea    -0xc078(%ebp),%eax
c0021e88:	89 85 e4 05 00 00    	mov    %eax,0x5e4(%ebp)
    intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021e8e:	8d 85 c4 40 ff ff    	lea    -0xbf3c(%ebp),%eax
c0021e94:	89 85 e8 05 00 00    	mov    %eax,0x5e8(%ebp)
    intr_names[6] = "#UD Invalid Opcode Exception";
c0021e9a:	8d 85 9f 3f ff ff    	lea    -0xc061(%ebp),%eax
c0021ea0:	89 85 ec 05 00 00    	mov    %eax,0x5ec(%ebp)
    intr_names[7] = "#NM Device Not Available Exception";
c0021ea6:	8d 85 e8 40 ff ff    	lea    -0xbf18(%ebp),%eax
c0021eac:	89 85 f0 05 00 00    	mov    %eax,0x5f0(%ebp)
    intr_names[8] = "#DF Double Fault Exception";
c0021eb2:	8d 85 bc 3f ff ff    	lea    -0xc044(%ebp),%eax
c0021eb8:	89 85 f4 05 00 00    	mov    %eax,0x5f4(%ebp)
    intr_names[9] = "Coprocessor Segment Overrun";
c0021ebe:	8d 85 d7 3f ff ff    	lea    -0xc029(%ebp),%eax
c0021ec4:	89 85 f8 05 00 00    	mov    %eax,0x5f8(%ebp)
    intr_names[10] = "#TS Invalid TSS Exception";
c0021eca:	8d 85 f3 3f ff ff    	lea    -0xc00d(%ebp),%eax
c0021ed0:	89 85 fc 05 00 00    	mov    %eax,0x5fc(%ebp)
    intr_names[11] = "#NP Segment Not Present";
c0021ed6:	8d 85 0d 40 ff ff    	lea    -0xbff3(%ebp),%eax
c0021edc:	89 85 00 06 00 00    	mov    %eax,0x600(%ebp)
    intr_names[12] = "#SS Stack Fault Exception";
c0021ee2:	8d 85 25 40 ff ff    	lea    -0xbfdb(%ebp),%eax
c0021ee8:	89 85 04 06 00 00    	mov    %eax,0x604(%ebp)
    intr_names[13] = "#GP General Protection Exception";
c0021eee:	8d 85 0c 41 ff ff    	lea    -0xbef4(%ebp),%eax
c0021ef4:	89 85 08 06 00 00    	mov    %eax,0x608(%ebp)
    intr_names[14] = "#PF Page-Fault Exception";
c0021efa:	8d 85 3f 40 ff ff    	lea    -0xbfc1(%ebp),%eax
c0021f00:	89 85 0c 06 00 00    	mov    %eax,0x60c(%ebp)
    intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021f06:	8d 85 30 41 ff ff    	lea    -0xbed0(%ebp),%eax
c0021f0c:	89 85 14 06 00 00    	mov    %eax,0x614(%ebp)
    intr_names[17] = "#AC Alignment Check Exception";
c0021f12:	8d 85 58 40 ff ff    	lea    -0xbfa8(%ebp),%eax
c0021f18:	89 85 18 06 00 00    	mov    %eax,0x618(%ebp)
    intr_names[18] = "#MC Machine-Check Exception";
c0021f1e:	8d 85 76 40 ff ff    	lea    -0xbf8a(%ebp),%eax
c0021f24:	89 85 1c 06 00 00    	mov    %eax,0x61c(%ebp)
    intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021f2a:	8d 85 54 41 ff ff    	lea    -0xbeac(%ebp),%eax
c0021f30:	89 85 20 06 00 00    	mov    %eax,0x620(%ebp)
}
c0021f36:	83 c4 2c             	add    $0x2c,%esp
c0021f39:	5b                   	pop    %ebx
c0021f3a:	5e                   	pop    %esi
c0021f3b:	5f                   	pop    %edi
c0021f3c:	5d                   	pop    %ebp
c0021f3d:	c3                   	ret    

c0021f3e <intr_register_ext>:
                  const char *name) {
c0021f3e:	53                   	push   %ebx
c0021f3f:	83 ec 08             	sub    $0x8,%esp
c0021f42:	e8 fc e1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021f47:	81 c3 65 bd 01 00    	add    $0x1bd65,%ebx
c0021f4d:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021f51:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021f54:	80 fa 0f             	cmp    $0xf,%dl
c0021f57:	77 22                	ja     c0021f7b <intr_register_ext+0x3d>
    register_handler(vec_no, 0, INTR_OFF, handler, name);
c0021f59:	0f b6 c0             	movzbl %al,%eax
c0021f5c:	83 ec 08             	sub    $0x8,%esp
c0021f5f:	ff 74 24 20          	pushl  0x20(%esp)
c0021f63:	ff 74 24 20          	pushl  0x20(%esp)
c0021f67:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021f6c:	ba 00 00 00 00       	mov    $0x0,%edx
c0021f71:	e8 fd fc ff ff       	call   c0021c73 <register_handler>
}
c0021f76:	83 c4 18             	add    $0x18,%esp
c0021f79:	5b                   	pop    %ebx
c0021f7a:	c3                   	ret    
    ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021f7b:	83 ec 0c             	sub    $0xc,%esp
c0021f7e:	8d 83 78 41 ff ff    	lea    -0xbe88(%ebx),%eax
c0021f84:	50                   	push   %eax
c0021f85:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021f8b:	50                   	push   %eax
c0021f8c:	8d 83 6c 26 ff ff    	lea    -0xd994(%ebx),%eax
c0021f92:	50                   	push   %eax
c0021f93:	68 b1 00 00 00       	push   $0xb1
c0021f98:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0021f9e:	50                   	push   %eax
c0021f9f:	e8 89 71 00 00       	call   c002912d <debug_panic>

c0021fa4 <intr_register_int>:
                  intr_handler_func *handler, const char *name) {
c0021fa4:	53                   	push   %ebx
c0021fa5:	83 ec 08             	sub    $0x8,%esp
c0021fa8:	e8 96 e1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0021fad:	81 c3 ff bc 01 00    	add    $0x1bcff,%ebx
c0021fb3:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021fb7:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021fba:	80 fa 0f             	cmp    $0xf,%dl
c0021fbd:	76 20                	jbe    c0021fdf <intr_register_int+0x3b>
    register_handler(vec_no, dpl, level, handler, name);
c0021fbf:	0f b6 c0             	movzbl %al,%eax
c0021fc2:	83 ec 08             	sub    $0x8,%esp
c0021fc5:	ff 74 24 28          	pushl  0x28(%esp)
c0021fc9:	ff 74 24 28          	pushl  0x28(%esp)
c0021fcd:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0021fd1:	8b 54 24 24          	mov    0x24(%esp),%edx
c0021fd5:	e8 99 fc ff ff       	call   c0021c73 <register_handler>
}
c0021fda:	83 c4 18             	add    $0x18,%esp
c0021fdd:	5b                   	pop    %ebx
c0021fde:	c3                   	ret    
    ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021fdf:	83 ec 0c             	sub    $0xc,%esp
c0021fe2:	8d 83 9c 41 ff ff    	lea    -0xbe64(%ebx),%eax
c0021fe8:	50                   	push   %eax
c0021fe9:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0021fef:	50                   	push   %eax
c0021ff0:	8d 83 44 26 ff ff    	lea    -0xd9bc(%ebx),%eax
c0021ff6:	50                   	push   %eax
c0021ff7:	68 c5 00 00 00       	push   $0xc5
c0021ffc:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0022002:	50                   	push   %eax
c0022003:	e8 25 71 00 00       	call   c002912d <debug_panic>

c0022008 <intr_context>:
intr_context(void) {
c0022008:	e8 3a e1 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c002200d:	05 9f bc 01 00       	add    $0x1bc9f,%eax
    return in_external_intr;
c0022012:	0f b6 80 b5 01 00 00 	movzbl 0x1b5(%eax),%eax
}
c0022019:	c3                   	ret    

c002201a <intr_yield_on_return>:
intr_yield_on_return(void) {
c002201a:	53                   	push   %ebx
c002201b:	83 ec 08             	sub    $0x8,%esp
c002201e:	e8 20 e1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0022023:	81 c3 89 bc 01 00    	add    $0x1bc89,%ebx
    ASSERT (intr_context());
c0022029:	80 bb b5 01 00 00 00 	cmpb   $0x0,0x1b5(%ebx)
c0022030:	74 0c                	je     c002203e <intr_yield_on_return+0x24>
    yield_on_return = true;
c0022032:	c6 83 b4 01 00 00 01 	movb   $0x1,0x1b4(%ebx)
}
c0022039:	83 c4 08             	add    $0x8,%esp
c002203c:	5b                   	pop    %ebx
c002203d:	c3                   	ret    
    ASSERT (intr_context());
c002203e:	83 ec 0c             	sub    $0xc,%esp
c0022041:	8d 93 aa 3e ff ff    	lea    -0xc156(%ebx),%edx
c0022047:	52                   	push   %edx
c0022048:	8d 93 de 36 ff ff    	lea    -0xc922(%ebx),%edx
c002204e:	52                   	push   %edx
c002204f:	8d 93 2c 26 ff ff    	lea    -0xd9d4(%ebx),%edx
c0022055:	52                   	push   %edx
c0022056:	68 d6 00 00 00       	push   $0xd6
c002205b:	8d 93 cf 3e ff ff    	lea    -0xc131(%ebx),%edx
c0022061:	52                   	push   %edx
c0022062:	e8 c6 70 00 00       	call   c002912d <debug_panic>

c0022067 <intr_handler>:
/* Handler for all interrupts, faults, and exceptions.  This
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler(struct intr_frame *frame) {
c0022067:	55                   	push   %ebp
c0022068:	57                   	push   %edi
c0022069:	56                   	push   %esi
c002206a:	53                   	push   %ebx
c002206b:	83 ec 0c             	sub    $0xc,%esp
c002206e:	e8 d0 e0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0022073:	81 c3 39 bc 01 00    	add    $0x1bc39,%ebx
c0022079:	8b 7c 24 20          	mov    0x20(%esp),%edi

    /* External interrupts are special.
       We only handle one at a time (so interrupts must be off)
       and they need to be acknowledged on the PIC (see below).
       An external interrupt handler cannot sleep. */
    external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c002207d:	8b 47 30             	mov    0x30(%edi),%eax
c0022080:	8d 70 e0             	lea    -0x20(%eax),%esi
    if (external) {
c0022083:	83 fe 0f             	cmp    $0xf,%esi
c0022086:	76 2c                	jbe    c00220b4 <intr_handler+0x4d>
        in_external_intr = true;
        yield_on_return = false;
    }

    /* Invoke the interrupt's handler. */
    handler = intr_handlers[frame->vec_no];
c0022088:	8b 57 30             	mov    0x30(%edi),%edx
c002208b:	8b 84 93 d4 09 00 00 	mov    0x9d4(%ebx,%edx,4),%eax
    if (handler != NULL)
c0022092:	85 c0                	test   %eax,%eax
c0022094:	0f 84 8e 00 00 00    	je     c0022128 <intr_handler+0xc1>
        handler(frame);
c002209a:	83 ec 0c             	sub    $0xc,%esp
c002209d:	57                   	push   %edi
c002209e:	ff d0                	call   *%eax
c00220a0:	83 c4 10             	add    $0x10,%esp
           condition.  Ignore it. */
    } else
        unexpected_interrupt(frame);

    /* Complete the processing of an external interrupt. */
    if (external) {
c00220a3:	83 fe 0f             	cmp    $0xf,%esi
c00220a6:	0f 86 c2 00 00 00    	jbe    c002216e <intr_handler+0x107>
        pic_end_of_interrupt(frame->vec_no);

        if (yield_on_return)
            thread_yield();
    }
}
c00220ac:	83 c4 0c             	add    $0xc,%esp
c00220af:	5b                   	pop    %ebx
c00220b0:	5e                   	pop    %esi
c00220b1:	5f                   	pop    %edi
c00220b2:	5d                   	pop    %ebp
c00220b3:	c3                   	ret    
        ASSERT (intr_get_level() == INTR_OFF);
c00220b4:	e8 57 fc ff ff       	call   c0021d10 <intr_get_level>
c00220b9:	85 c0                	test   %eax,%eax
c00220bb:	75 19                	jne    c00220d6 <intr_handler+0x6f>
        ASSERT (!intr_context());
c00220bd:	80 bb b5 01 00 00 00 	cmpb   $0x0,0x1b5(%ebx)
c00220c4:	75 39                	jne    c00220ff <intr_handler+0x98>
        in_external_intr = true;
c00220c6:	c6 83 b5 01 00 00 01 	movb   $0x1,0x1b5(%ebx)
        yield_on_return = false;
c00220cd:	c6 83 b4 01 00 00 00 	movb   $0x0,0x1b4(%ebx)
c00220d4:	eb b2                	jmp    c0022088 <intr_handler+0x21>
        ASSERT (intr_get_level() == INTR_OFF);
c00220d6:	83 ec 0c             	sub    $0xc,%esp
c00220d9:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c00220df:	50                   	push   %eax
c00220e0:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00220e6:	50                   	push   %eax
c00220e7:	8d 83 1c 26 ff ff    	lea    -0xd9e4(%ebx),%eax
c00220ed:	50                   	push   %eax
c00220ee:	68 53 01 00 00       	push   $0x153
c00220f3:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c00220f9:	50                   	push   %eax
c00220fa:	e8 2e 70 00 00       	call   c002912d <debug_panic>
        ASSERT (!intr_context());
c00220ff:	83 ec 0c             	sub    $0xc,%esp
c0022102:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c0022108:	50                   	push   %eax
c0022109:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002210f:	50                   	push   %eax
c0022110:	8d 83 1c 26 ff ff    	lea    -0xd9e4(%ebx),%eax
c0022116:	50                   	push   %eax
c0022117:	68 54 01 00 00       	push   $0x154
c002211c:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0022122:	50                   	push   %eax
c0022123:	e8 05 70 00 00       	call   c002912d <debug_panic>
    else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f) {
c0022128:	89 d0                	mov    %edx,%eax
c002212a:	83 e0 f7             	and    $0xfffffff7,%eax
c002212d:	83 f8 27             	cmp    $0x27,%eax
c0022130:	0f 84 6d ff ff ff    	je     c00220a3 <intr_handler+0x3c>
/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt(const struct intr_frame *f) {
    /* Count the number so far. */
    unsigned int n = ++unexpected_cnt[f->vec_no];
c0022136:	8d ab d4 01 00 00    	lea    0x1d4(%ebx),%ebp
c002213c:	8b 4c 95 00          	mov    0x0(%ebp,%edx,4),%ecx
c0022140:	8d 41 01             	lea    0x1(%ecx),%eax
c0022143:	89 44 95 00          	mov    %eax,0x0(%ebp,%edx,4)
    /* If the number is a power of 2, print a message.  This rate
       limiting means that we get information about an uncommon
       unexpected interrupt the first time and fairly often after
       that, but one that occurs many times will not overwhelm the
       console. */
    if ((n & (n - 1)) == 0)
c0022147:	85 c1                	test   %eax,%ecx
c0022149:	0f 85 54 ff ff ff    	jne    c00220a3 <intr_handler+0x3c>
        printf("Unexpected interrupt %#04x (%s)\n",
c002214f:	83 ec 04             	sub    $0x4,%esp
c0022152:	ff b4 93 d4 05 00 00 	pushl  0x5d4(%ebx,%edx,4)
c0022159:	52                   	push   %edx
c002215a:	8d 83 bc 41 ff ff    	lea    -0xbe44(%ebx),%eax
c0022160:	50                   	push   %eax
c0022161:	e8 6b 53 00 00       	call   c00274d1 <printf>
c0022166:	83 c4 10             	add    $0x10,%esp
c0022169:	e9 35 ff ff ff       	jmp    c00220a3 <intr_handler+0x3c>
        ASSERT (intr_get_level() == INTR_OFF);
c002216e:	e8 9d fb ff ff       	call   c0021d10 <intr_get_level>
c0022173:	85 c0                	test   %eax,%eax
c0022175:	75 40                	jne    c00221b7 <intr_handler+0x150>
        ASSERT (intr_context());
c0022177:	80 bb b5 01 00 00 00 	cmpb   $0x0,0x1b5(%ebx)
c002217e:	74 60                	je     c00221e0 <intr_handler+0x179>
        in_external_intr = false;
c0022180:	c6 83 b5 01 00 00 00 	movb   $0x0,0x1b5(%ebx)
        pic_end_of_interrupt(frame->vec_no);
c0022187:	8b 57 30             	mov    0x30(%edi),%edx
    ASSERT (irq >= 0x20 && irq < 0x30);
c002218a:	8d 42 e0             	lea    -0x20(%edx),%eax
c002218d:	83 f8 0f             	cmp    $0xf,%eax
c0022190:	77 77                	ja     c0022209 <intr_handler+0x1a2>
c0022192:	b8 20 00 00 00       	mov    $0x20,%eax
c0022197:	e6 20                	out    %al,$0x20
    if (irq >= 0x28)
c0022199:	83 fa 27             	cmp    $0x27,%edx
c002219c:	7e 02                	jle    c00221a0 <intr_handler+0x139>
c002219e:	e6 a0                	out    %al,$0xa0
        if (yield_on_return)
c00221a0:	80 bb b4 01 00 00 00 	cmpb   $0x0,0x1b4(%ebx)
c00221a7:	0f 84 ff fe ff ff    	je     c00220ac <intr_handler+0x45>
            thread_yield();
c00221ad:	e8 58 f5 ff ff       	call   c002170a <thread_yield>
}
c00221b2:	e9 f5 fe ff ff       	jmp    c00220ac <intr_handler+0x45>
        ASSERT (intr_get_level() == INTR_OFF);
c00221b7:	83 ec 0c             	sub    $0xc,%esp
c00221ba:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c00221c0:	50                   	push   %eax
c00221c1:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00221c7:	50                   	push   %eax
c00221c8:	8d 83 1c 26 ff ff    	lea    -0xd9e4(%ebx),%eax
c00221ce:	50                   	push   %eax
c00221cf:	68 67 01 00 00       	push   $0x167
c00221d4:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c00221da:	50                   	push   %eax
c00221db:	e8 4d 6f 00 00       	call   c002912d <debug_panic>
        ASSERT (intr_context());
c00221e0:	83 ec 0c             	sub    $0xc,%esp
c00221e3:	8d 83 aa 3e ff ff    	lea    -0xc156(%ebx),%eax
c00221e9:	50                   	push   %eax
c00221ea:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00221f0:	50                   	push   %eax
c00221f1:	8d 83 1c 26 ff ff    	lea    -0xd9e4(%ebx),%eax
c00221f7:	50                   	push   %eax
c00221f8:	68 68 01 00 00       	push   $0x168
c00221fd:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c0022203:	50                   	push   %eax
c0022204:	e8 24 6f 00 00       	call   c002912d <debug_panic>
    ASSERT (irq >= 0x20 && irq < 0x30);
c0022209:	83 ec 0c             	sub    $0xc,%esp
c002220c:	8d 83 92 40 ff ff    	lea    -0xbf6e(%ebx),%eax
c0022212:	50                   	push   %eax
c0022213:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0022219:	50                   	push   %eax
c002221a:	8d 83 04 26 ff ff    	lea    -0xd9fc(%ebx),%eax
c0022220:	50                   	push   %eax
c0022221:	68 ff 00 00 00       	push   $0xff
c0022226:	8d 83 cf 3e ff ff    	lea    -0xc131(%ebx),%eax
c002222c:	50                   	push   %eax
c002222d:	e8 fb 6e 00 00       	call   c002912d <debug_panic>

c0022232 <intr_dump_frame>:
               f->vec_no, intr_names[f->vec_no]);
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame(const struct intr_frame *f) {
c0022232:	57                   	push   %edi
c0022233:	56                   	push   %esi
c0022234:	53                   	push   %ebx
c0022235:	e8 09 df 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002223a:	81 c3 72 ba 01 00    	add    $0x1ba72,%ebx
c0022240:	8b 74 24 10          	mov    0x10(%esp),%esi
    /* Store current value of CR2 into `cr2'.
       CR2 is the linear address of the last page fault.
       See [IA32-v2a] "MOV--Move to/from Control Registers" and
       [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
       (#PF)". */
    asm ("movl %%cr2, %0" : "=r" (cr2));
c0022244:	0f 20 d7             	mov    %cr2,%edi

    printf("Interrupt %#04x (%s) at eip=%p\n",
           f->vec_no, intr_names[f->vec_no], f->eip);
c0022247:	8b 46 30             	mov    0x30(%esi),%eax
    printf("Interrupt %#04x (%s) at eip=%p\n",
c002224a:	ff 76 3c             	pushl  0x3c(%esi)
c002224d:	ff b4 83 d4 05 00 00 	pushl  0x5d4(%ebx,%eax,4)
c0022254:	50                   	push   %eax
c0022255:	8d 83 e0 41 ff ff    	lea    -0xbe20(%ebx),%eax
c002225b:	50                   	push   %eax
c002225c:	e8 70 52 00 00       	call   c00274d1 <printf>
    printf(" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0022261:	83 c4 0c             	add    $0xc,%esp
c0022264:	ff 76 34             	pushl  0x34(%esi)
c0022267:	57                   	push   %edi
c0022268:	8d 83 ac 40 ff ff    	lea    -0xbf54(%ebx),%eax
c002226e:	50                   	push   %eax
c002226f:	e8 5d 52 00 00       	call   c00274d1 <printf>
    printf(" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0022274:	83 c4 04             	add    $0x4,%esp
c0022277:	ff 76 14             	pushl  0x14(%esi)
c002227a:	ff 76 18             	pushl  0x18(%esi)
c002227d:	ff 76 10             	pushl  0x10(%esi)
c0022280:	ff 76 1c             	pushl  0x1c(%esi)
c0022283:	8d 83 00 42 ff ff    	lea    -0xbe00(%ebx),%eax
c0022289:	50                   	push   %eax
c002228a:	e8 42 52 00 00       	call   c00274d1 <printf>
           f->eax, f->ebx, f->ecx, f->edx);
    printf(" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c002228f:	83 c4 14             	add    $0x14,%esp
c0022292:	ff 76 08             	pushl  0x8(%esi)
c0022295:	ff 76 48             	pushl  0x48(%esi)
c0022298:	ff 36                	pushl  (%esi)
c002229a:	ff 76 04             	pushl  0x4(%esi)
c002229d:	8d 83 28 42 ff ff    	lea    -0xbdd8(%ebx),%eax
c00222a3:	50                   	push   %eax
c00222a4:	e8 28 52 00 00       	call   c00274d1 <printf>
           f->esi, f->edi, (uint32_t) f->esp, f->ebp);
    printf(" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c00222a9:	83 c4 14             	add    $0x14,%esp
c00222ac:	0f b7 46 4c          	movzwl 0x4c(%esi),%eax
c00222b0:	50                   	push   %eax
c00222b1:	0f b7 46 28          	movzwl 0x28(%esi),%eax
c00222b5:	50                   	push   %eax
c00222b6:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
c00222ba:	50                   	push   %eax
c00222bb:	0f b7 46 40          	movzwl 0x40(%esi),%eax
c00222bf:	50                   	push   %eax
c00222c0:	8d 83 50 42 ff ff    	lea    -0xbdb0(%ebx),%eax
c00222c6:	50                   	push   %eax
c00222c7:	e8 05 52 00 00       	call   c00274d1 <printf>
           f->cs, f->ds, f->es, f->ss);
}
c00222cc:	83 c4 20             	add    $0x20,%esp
c00222cf:	5b                   	pop    %ebx
c00222d0:	5e                   	pop    %esi
c00222d1:	5f                   	pop    %edi
c00222d2:	c3                   	ret    

c00222d3 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name(uint8_t vec) {
c00222d3:	e8 6f de 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c00222d8:	05 d4 b9 01 00       	add    $0x1b9d4,%eax
    return intr_names[vec];
c00222dd:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c00222e2:	8b 84 90 d4 05 00 00 	mov    0x5d4(%eax,%edx,4),%eax
}
c00222e9:	c3                   	ret    

c00222ea <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c00222ea:	1e                   	push   %ds
	pushl %es
c00222eb:	06                   	push   %es
	pushl %fs
c00222ec:	0f a0                	push   %fs
	pushl %gs
c00222ee:	0f a8                	push   %gs
	pushal
c00222f0:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c00222f1:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c00222f2:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c00222f7:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c00222f9:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c00222fb:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c00222ff:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0022300:	e8 62 fd ff ff       	call   c0022067 <intr_handler>
	addl $4, %esp
c0022305:	83 c4 04             	add    $0x4,%esp

c0022308 <intr_exit>:
        	EBX = Pop();
        	EDX = Pop();
        	ECX = Pop();
        	EAX = Pop();
        */
	popal
c0022308:	61                   	popa   
	popl %gs
c0022309:	0f a9                	pop    %gs
	popl %fs
c002230b:	0f a1                	pop    %fs
	popl %es
c002230d:	07                   	pop    %es
	popl %ds
c002230e:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c002230f:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0022312:	cf                   	iret   

c0022313 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0022313:	55                   	push   %ebp
c0022314:	6a 00                	push   $0x0
c0022316:	6a 00                	push   $0x0
c0022318:	eb d0                	jmp    c00222ea <intr_entry>

c002231a <intr01_stub>:
c002231a:	55                   	push   %ebp
c002231b:	6a 00                	push   $0x0
c002231d:	6a 01                	push   $0x1
c002231f:	eb c9                	jmp    c00222ea <intr_entry>

c0022321 <intr02_stub>:
c0022321:	55                   	push   %ebp
c0022322:	6a 00                	push   $0x0
c0022324:	6a 02                	push   $0x2
c0022326:	eb c2                	jmp    c00222ea <intr_entry>

c0022328 <intr03_stub>:
c0022328:	55                   	push   %ebp
c0022329:	6a 00                	push   $0x0
c002232b:	6a 03                	push   $0x3
c002232d:	eb bb                	jmp    c00222ea <intr_entry>

c002232f <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c002232f:	55                   	push   %ebp
c0022330:	6a 00                	push   $0x0
c0022332:	6a 04                	push   $0x4
c0022334:	eb b4                	jmp    c00222ea <intr_entry>

c0022336 <intr05_stub>:
c0022336:	55                   	push   %ebp
c0022337:	6a 00                	push   $0x0
c0022339:	6a 05                	push   $0x5
c002233b:	eb ad                	jmp    c00222ea <intr_entry>

c002233d <intr06_stub>:
c002233d:	55                   	push   %ebp
c002233e:	6a 00                	push   $0x0
c0022340:	6a 06                	push   $0x6
c0022342:	eb a6                	jmp    c00222ea <intr_entry>

c0022344 <intr07_stub>:
c0022344:	55                   	push   %ebp
c0022345:	6a 00                	push   $0x0
c0022347:	6a 07                	push   $0x7
c0022349:	eb 9f                	jmp    c00222ea <intr_entry>

c002234b <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c002234b:	ff 34 24             	pushl  (%esp)
c002234e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022352:	6a 08                	push   $0x8
c0022354:	eb 94                	jmp    c00222ea <intr_entry>

c0022356 <intr09_stub>:
c0022356:	55                   	push   %ebp
c0022357:	6a 00                	push   $0x0
c0022359:	6a 09                	push   $0x9
c002235b:	eb 8d                	jmp    c00222ea <intr_entry>

c002235d <intr0a_stub>:
c002235d:	ff 34 24             	pushl  (%esp)
c0022360:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022364:	6a 0a                	push   $0xa
c0022366:	eb 82                	jmp    c00222ea <intr_entry>

c0022368 <intr0b_stub>:
c0022368:	ff 34 24             	pushl  (%esp)
c002236b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002236f:	6a 0b                	push   $0xb
c0022371:	e9 74 ff ff ff       	jmp    c00222ea <intr_entry>

c0022376 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0022376:	55                   	push   %ebp
c0022377:	6a 00                	push   $0x0
c0022379:	6a 0c                	push   $0xc
c002237b:	e9 6a ff ff ff       	jmp    c00222ea <intr_entry>

c0022380 <intr0d_stub>:
c0022380:	ff 34 24             	pushl  (%esp)
c0022383:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022387:	6a 0d                	push   $0xd
c0022389:	e9 5c ff ff ff       	jmp    c00222ea <intr_entry>

c002238e <intr0e_stub>:
c002238e:	ff 34 24             	pushl  (%esp)
c0022391:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022395:	6a 0e                	push   $0xe
c0022397:	e9 4e ff ff ff       	jmp    c00222ea <intr_entry>

c002239c <intr0f_stub>:
c002239c:	55                   	push   %ebp
c002239d:	6a 00                	push   $0x0
c002239f:	6a 0f                	push   $0xf
c00223a1:	e9 44 ff ff ff       	jmp    c00222ea <intr_entry>

c00223a6 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c00223a6:	55                   	push   %ebp
c00223a7:	6a 00                	push   $0x0
c00223a9:	6a 10                	push   $0x10
c00223ab:	e9 3a ff ff ff       	jmp    c00222ea <intr_entry>

c00223b0 <intr11_stub>:
c00223b0:	ff 34 24             	pushl  (%esp)
c00223b3:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00223b7:	6a 11                	push   $0x11
c00223b9:	e9 2c ff ff ff       	jmp    c00222ea <intr_entry>

c00223be <intr12_stub>:
c00223be:	55                   	push   %ebp
c00223bf:	6a 00                	push   $0x0
c00223c1:	6a 12                	push   $0x12
c00223c3:	e9 22 ff ff ff       	jmp    c00222ea <intr_entry>

c00223c8 <intr13_stub>:
c00223c8:	55                   	push   %ebp
c00223c9:	6a 00                	push   $0x0
c00223cb:	6a 13                	push   $0x13
c00223cd:	e9 18 ff ff ff       	jmp    c00222ea <intr_entry>

c00223d2 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c00223d2:	55                   	push   %ebp
c00223d3:	6a 00                	push   $0x0
c00223d5:	6a 14                	push   $0x14
c00223d7:	e9 0e ff ff ff       	jmp    c00222ea <intr_entry>

c00223dc <intr15_stub>:
c00223dc:	55                   	push   %ebp
c00223dd:	6a 00                	push   $0x0
c00223df:	6a 15                	push   $0x15
c00223e1:	e9 04 ff ff ff       	jmp    c00222ea <intr_entry>

c00223e6 <intr16_stub>:
c00223e6:	55                   	push   %ebp
c00223e7:	6a 00                	push   $0x0
c00223e9:	6a 16                	push   $0x16
c00223eb:	e9 fa fe ff ff       	jmp    c00222ea <intr_entry>

c00223f0 <intr17_stub>:
c00223f0:	55                   	push   %ebp
c00223f1:	6a 00                	push   $0x0
c00223f3:	6a 17                	push   $0x17
c00223f5:	e9 f0 fe ff ff       	jmp    c00222ea <intr_entry>

c00223fa <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c00223fa:	ff 34 24             	pushl  (%esp)
c00223fd:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022401:	6a 18                	push   $0x18
c0022403:	e9 e2 fe ff ff       	jmp    c00222ea <intr_entry>

c0022408 <intr19_stub>:
c0022408:	55                   	push   %ebp
c0022409:	6a 00                	push   $0x0
c002240b:	6a 19                	push   $0x19
c002240d:	e9 d8 fe ff ff       	jmp    c00222ea <intr_entry>

c0022412 <intr1a_stub>:
c0022412:	ff 34 24             	pushl  (%esp)
c0022415:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022419:	6a 1a                	push   $0x1a
c002241b:	e9 ca fe ff ff       	jmp    c00222ea <intr_entry>

c0022420 <intr1b_stub>:
c0022420:	ff 34 24             	pushl  (%esp)
c0022423:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022427:	6a 1b                	push   $0x1b
c0022429:	e9 bc fe ff ff       	jmp    c00222ea <intr_entry>

c002242e <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c002242e:	55                   	push   %ebp
c002242f:	6a 00                	push   $0x0
c0022431:	6a 1c                	push   $0x1c
c0022433:	e9 b2 fe ff ff       	jmp    c00222ea <intr_entry>

c0022438 <intr1d_stub>:
c0022438:	ff 34 24             	pushl  (%esp)
c002243b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002243f:	6a 1d                	push   $0x1d
c0022441:	e9 a4 fe ff ff       	jmp    c00222ea <intr_entry>

c0022446 <intr1e_stub>:
c0022446:	ff 34 24             	pushl  (%esp)
c0022449:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002244d:	6a 1e                	push   $0x1e
c002244f:	e9 96 fe ff ff       	jmp    c00222ea <intr_entry>

c0022454 <intr1f_stub>:
c0022454:	55                   	push   %ebp
c0022455:	6a 00                	push   $0x0
c0022457:	6a 1f                	push   $0x1f
c0022459:	e9 8c fe ff ff       	jmp    c00222ea <intr_entry>

c002245e <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c002245e:	55                   	push   %ebp
c002245f:	6a 00                	push   $0x0
c0022461:	6a 20                	push   $0x20
c0022463:	e9 82 fe ff ff       	jmp    c00222ea <intr_entry>

c0022468 <intr21_stub>:
c0022468:	55                   	push   %ebp
c0022469:	6a 00                	push   $0x0
c002246b:	6a 21                	push   $0x21
c002246d:	e9 78 fe ff ff       	jmp    c00222ea <intr_entry>

c0022472 <intr22_stub>:
c0022472:	55                   	push   %ebp
c0022473:	6a 00                	push   $0x0
c0022475:	6a 22                	push   $0x22
c0022477:	e9 6e fe ff ff       	jmp    c00222ea <intr_entry>

c002247c <intr23_stub>:
c002247c:	55                   	push   %ebp
c002247d:	6a 00                	push   $0x0
c002247f:	6a 23                	push   $0x23
c0022481:	e9 64 fe ff ff       	jmp    c00222ea <intr_entry>

c0022486 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0022486:	55                   	push   %ebp
c0022487:	6a 00                	push   $0x0
c0022489:	6a 24                	push   $0x24
c002248b:	e9 5a fe ff ff       	jmp    c00222ea <intr_entry>

c0022490 <intr25_stub>:
c0022490:	55                   	push   %ebp
c0022491:	6a 00                	push   $0x0
c0022493:	6a 25                	push   $0x25
c0022495:	e9 50 fe ff ff       	jmp    c00222ea <intr_entry>

c002249a <intr26_stub>:
c002249a:	55                   	push   %ebp
c002249b:	6a 00                	push   $0x0
c002249d:	6a 26                	push   $0x26
c002249f:	e9 46 fe ff ff       	jmp    c00222ea <intr_entry>

c00224a4 <intr27_stub>:
c00224a4:	55                   	push   %ebp
c00224a5:	6a 00                	push   $0x0
c00224a7:	6a 27                	push   $0x27
c00224a9:	e9 3c fe ff ff       	jmp    c00222ea <intr_entry>

c00224ae <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c00224ae:	55                   	push   %ebp
c00224af:	6a 00                	push   $0x0
c00224b1:	6a 28                	push   $0x28
c00224b3:	e9 32 fe ff ff       	jmp    c00222ea <intr_entry>

c00224b8 <intr29_stub>:
c00224b8:	55                   	push   %ebp
c00224b9:	6a 00                	push   $0x0
c00224bb:	6a 29                	push   $0x29
c00224bd:	e9 28 fe ff ff       	jmp    c00222ea <intr_entry>

c00224c2 <intr2a_stub>:
c00224c2:	55                   	push   %ebp
c00224c3:	6a 00                	push   $0x0
c00224c5:	6a 2a                	push   $0x2a
c00224c7:	e9 1e fe ff ff       	jmp    c00222ea <intr_entry>

c00224cc <intr2b_stub>:
c00224cc:	55                   	push   %ebp
c00224cd:	6a 00                	push   $0x0
c00224cf:	6a 2b                	push   $0x2b
c00224d1:	e9 14 fe ff ff       	jmp    c00222ea <intr_entry>

c00224d6 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c00224d6:	55                   	push   %ebp
c00224d7:	6a 00                	push   $0x0
c00224d9:	6a 2c                	push   $0x2c
c00224db:	e9 0a fe ff ff       	jmp    c00222ea <intr_entry>

c00224e0 <intr2d_stub>:
c00224e0:	55                   	push   %ebp
c00224e1:	6a 00                	push   $0x0
c00224e3:	6a 2d                	push   $0x2d
c00224e5:	e9 00 fe ff ff       	jmp    c00222ea <intr_entry>

c00224ea <intr2e_stub>:
c00224ea:	55                   	push   %ebp
c00224eb:	6a 00                	push   $0x0
c00224ed:	6a 2e                	push   $0x2e
c00224ef:	e9 f6 fd ff ff       	jmp    c00222ea <intr_entry>

c00224f4 <intr2f_stub>:
c00224f4:	55                   	push   %ebp
c00224f5:	6a 00                	push   $0x0
c00224f7:	6a 2f                	push   $0x2f
c00224f9:	e9 ec fd ff ff       	jmp    c00222ea <intr_entry>

c00224fe <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00224fe:	55                   	push   %ebp
c00224ff:	6a 00                	push   $0x0
c0022501:	6a 30                	push   $0x30
c0022503:	e9 e2 fd ff ff       	jmp    c00222ea <intr_entry>

c0022508 <intr31_stub>:
c0022508:	55                   	push   %ebp
c0022509:	6a 00                	push   $0x0
c002250b:	6a 31                	push   $0x31
c002250d:	e9 d8 fd ff ff       	jmp    c00222ea <intr_entry>

c0022512 <intr32_stub>:
c0022512:	55                   	push   %ebp
c0022513:	6a 00                	push   $0x0
c0022515:	6a 32                	push   $0x32
c0022517:	e9 ce fd ff ff       	jmp    c00222ea <intr_entry>

c002251c <intr33_stub>:
c002251c:	55                   	push   %ebp
c002251d:	6a 00                	push   $0x0
c002251f:	6a 33                	push   $0x33
c0022521:	e9 c4 fd ff ff       	jmp    c00222ea <intr_entry>

c0022526 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0022526:	55                   	push   %ebp
c0022527:	6a 00                	push   $0x0
c0022529:	6a 34                	push   $0x34
c002252b:	e9 ba fd ff ff       	jmp    c00222ea <intr_entry>

c0022530 <intr35_stub>:
c0022530:	55                   	push   %ebp
c0022531:	6a 00                	push   $0x0
c0022533:	6a 35                	push   $0x35
c0022535:	e9 b0 fd ff ff       	jmp    c00222ea <intr_entry>

c002253a <intr36_stub>:
c002253a:	55                   	push   %ebp
c002253b:	6a 00                	push   $0x0
c002253d:	6a 36                	push   $0x36
c002253f:	e9 a6 fd ff ff       	jmp    c00222ea <intr_entry>

c0022544 <intr37_stub>:
c0022544:	55                   	push   %ebp
c0022545:	6a 00                	push   $0x0
c0022547:	6a 37                	push   $0x37
c0022549:	e9 9c fd ff ff       	jmp    c00222ea <intr_entry>

c002254e <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c002254e:	55                   	push   %ebp
c002254f:	6a 00                	push   $0x0
c0022551:	6a 38                	push   $0x38
c0022553:	e9 92 fd ff ff       	jmp    c00222ea <intr_entry>

c0022558 <intr39_stub>:
c0022558:	55                   	push   %ebp
c0022559:	6a 00                	push   $0x0
c002255b:	6a 39                	push   $0x39
c002255d:	e9 88 fd ff ff       	jmp    c00222ea <intr_entry>

c0022562 <intr3a_stub>:
c0022562:	55                   	push   %ebp
c0022563:	6a 00                	push   $0x0
c0022565:	6a 3a                	push   $0x3a
c0022567:	e9 7e fd ff ff       	jmp    c00222ea <intr_entry>

c002256c <intr3b_stub>:
c002256c:	55                   	push   %ebp
c002256d:	6a 00                	push   $0x0
c002256f:	6a 3b                	push   $0x3b
c0022571:	e9 74 fd ff ff       	jmp    c00222ea <intr_entry>

c0022576 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0022576:	55                   	push   %ebp
c0022577:	6a 00                	push   $0x0
c0022579:	6a 3c                	push   $0x3c
c002257b:	e9 6a fd ff ff       	jmp    c00222ea <intr_entry>

c0022580 <intr3d_stub>:
c0022580:	55                   	push   %ebp
c0022581:	6a 00                	push   $0x0
c0022583:	6a 3d                	push   $0x3d
c0022585:	e9 60 fd ff ff       	jmp    c00222ea <intr_entry>

c002258a <intr3e_stub>:
c002258a:	55                   	push   %ebp
c002258b:	6a 00                	push   $0x0
c002258d:	6a 3e                	push   $0x3e
c002258f:	e9 56 fd ff ff       	jmp    c00222ea <intr_entry>

c0022594 <intr3f_stub>:
c0022594:	55                   	push   %ebp
c0022595:	6a 00                	push   $0x0
c0022597:	6a 3f                	push   $0x3f
c0022599:	e9 4c fd ff ff       	jmp    c00222ea <intr_entry>

c002259e <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c002259e:	55                   	push   %ebp
c002259f:	6a 00                	push   $0x0
c00225a1:	6a 40                	push   $0x40
c00225a3:	e9 42 fd ff ff       	jmp    c00222ea <intr_entry>

c00225a8 <intr41_stub>:
c00225a8:	55                   	push   %ebp
c00225a9:	6a 00                	push   $0x0
c00225ab:	6a 41                	push   $0x41
c00225ad:	e9 38 fd ff ff       	jmp    c00222ea <intr_entry>

c00225b2 <intr42_stub>:
c00225b2:	55                   	push   %ebp
c00225b3:	6a 00                	push   $0x0
c00225b5:	6a 42                	push   $0x42
c00225b7:	e9 2e fd ff ff       	jmp    c00222ea <intr_entry>

c00225bc <intr43_stub>:
c00225bc:	55                   	push   %ebp
c00225bd:	6a 00                	push   $0x0
c00225bf:	6a 43                	push   $0x43
c00225c1:	e9 24 fd ff ff       	jmp    c00222ea <intr_entry>

c00225c6 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c00225c6:	55                   	push   %ebp
c00225c7:	6a 00                	push   $0x0
c00225c9:	6a 44                	push   $0x44
c00225cb:	e9 1a fd ff ff       	jmp    c00222ea <intr_entry>

c00225d0 <intr45_stub>:
c00225d0:	55                   	push   %ebp
c00225d1:	6a 00                	push   $0x0
c00225d3:	6a 45                	push   $0x45
c00225d5:	e9 10 fd ff ff       	jmp    c00222ea <intr_entry>

c00225da <intr46_stub>:
c00225da:	55                   	push   %ebp
c00225db:	6a 00                	push   $0x0
c00225dd:	6a 46                	push   $0x46
c00225df:	e9 06 fd ff ff       	jmp    c00222ea <intr_entry>

c00225e4 <intr47_stub>:
c00225e4:	55                   	push   %ebp
c00225e5:	6a 00                	push   $0x0
c00225e7:	6a 47                	push   $0x47
c00225e9:	e9 fc fc ff ff       	jmp    c00222ea <intr_entry>

c00225ee <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c00225ee:	55                   	push   %ebp
c00225ef:	6a 00                	push   $0x0
c00225f1:	6a 48                	push   $0x48
c00225f3:	e9 f2 fc ff ff       	jmp    c00222ea <intr_entry>

c00225f8 <intr49_stub>:
c00225f8:	55                   	push   %ebp
c00225f9:	6a 00                	push   $0x0
c00225fb:	6a 49                	push   $0x49
c00225fd:	e9 e8 fc ff ff       	jmp    c00222ea <intr_entry>

c0022602 <intr4a_stub>:
c0022602:	55                   	push   %ebp
c0022603:	6a 00                	push   $0x0
c0022605:	6a 4a                	push   $0x4a
c0022607:	e9 de fc ff ff       	jmp    c00222ea <intr_entry>

c002260c <intr4b_stub>:
c002260c:	55                   	push   %ebp
c002260d:	6a 00                	push   $0x0
c002260f:	6a 4b                	push   $0x4b
c0022611:	e9 d4 fc ff ff       	jmp    c00222ea <intr_entry>

c0022616 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c0022616:	55                   	push   %ebp
c0022617:	6a 00                	push   $0x0
c0022619:	6a 4c                	push   $0x4c
c002261b:	e9 ca fc ff ff       	jmp    c00222ea <intr_entry>

c0022620 <intr4d_stub>:
c0022620:	55                   	push   %ebp
c0022621:	6a 00                	push   $0x0
c0022623:	6a 4d                	push   $0x4d
c0022625:	e9 c0 fc ff ff       	jmp    c00222ea <intr_entry>

c002262a <intr4e_stub>:
c002262a:	55                   	push   %ebp
c002262b:	6a 00                	push   $0x0
c002262d:	6a 4e                	push   $0x4e
c002262f:	e9 b6 fc ff ff       	jmp    c00222ea <intr_entry>

c0022634 <intr4f_stub>:
c0022634:	55                   	push   %ebp
c0022635:	6a 00                	push   $0x0
c0022637:	6a 4f                	push   $0x4f
c0022639:	e9 ac fc ff ff       	jmp    c00222ea <intr_entry>

c002263e <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c002263e:	55                   	push   %ebp
c002263f:	6a 00                	push   $0x0
c0022641:	6a 50                	push   $0x50
c0022643:	e9 a2 fc ff ff       	jmp    c00222ea <intr_entry>

c0022648 <intr51_stub>:
c0022648:	55                   	push   %ebp
c0022649:	6a 00                	push   $0x0
c002264b:	6a 51                	push   $0x51
c002264d:	e9 98 fc ff ff       	jmp    c00222ea <intr_entry>

c0022652 <intr52_stub>:
c0022652:	55                   	push   %ebp
c0022653:	6a 00                	push   $0x0
c0022655:	6a 52                	push   $0x52
c0022657:	e9 8e fc ff ff       	jmp    c00222ea <intr_entry>

c002265c <intr53_stub>:
c002265c:	55                   	push   %ebp
c002265d:	6a 00                	push   $0x0
c002265f:	6a 53                	push   $0x53
c0022661:	e9 84 fc ff ff       	jmp    c00222ea <intr_entry>

c0022666 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0022666:	55                   	push   %ebp
c0022667:	6a 00                	push   $0x0
c0022669:	6a 54                	push   $0x54
c002266b:	e9 7a fc ff ff       	jmp    c00222ea <intr_entry>

c0022670 <intr55_stub>:
c0022670:	55                   	push   %ebp
c0022671:	6a 00                	push   $0x0
c0022673:	6a 55                	push   $0x55
c0022675:	e9 70 fc ff ff       	jmp    c00222ea <intr_entry>

c002267a <intr56_stub>:
c002267a:	55                   	push   %ebp
c002267b:	6a 00                	push   $0x0
c002267d:	6a 56                	push   $0x56
c002267f:	e9 66 fc ff ff       	jmp    c00222ea <intr_entry>

c0022684 <intr57_stub>:
c0022684:	55                   	push   %ebp
c0022685:	6a 00                	push   $0x0
c0022687:	6a 57                	push   $0x57
c0022689:	e9 5c fc ff ff       	jmp    c00222ea <intr_entry>

c002268e <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c002268e:	55                   	push   %ebp
c002268f:	6a 00                	push   $0x0
c0022691:	6a 58                	push   $0x58
c0022693:	e9 52 fc ff ff       	jmp    c00222ea <intr_entry>

c0022698 <intr59_stub>:
c0022698:	55                   	push   %ebp
c0022699:	6a 00                	push   $0x0
c002269b:	6a 59                	push   $0x59
c002269d:	e9 48 fc ff ff       	jmp    c00222ea <intr_entry>

c00226a2 <intr5a_stub>:
c00226a2:	55                   	push   %ebp
c00226a3:	6a 00                	push   $0x0
c00226a5:	6a 5a                	push   $0x5a
c00226a7:	e9 3e fc ff ff       	jmp    c00222ea <intr_entry>

c00226ac <intr5b_stub>:
c00226ac:	55                   	push   %ebp
c00226ad:	6a 00                	push   $0x0
c00226af:	6a 5b                	push   $0x5b
c00226b1:	e9 34 fc ff ff       	jmp    c00222ea <intr_entry>

c00226b6 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c00226b6:	55                   	push   %ebp
c00226b7:	6a 00                	push   $0x0
c00226b9:	6a 5c                	push   $0x5c
c00226bb:	e9 2a fc ff ff       	jmp    c00222ea <intr_entry>

c00226c0 <intr5d_stub>:
c00226c0:	55                   	push   %ebp
c00226c1:	6a 00                	push   $0x0
c00226c3:	6a 5d                	push   $0x5d
c00226c5:	e9 20 fc ff ff       	jmp    c00222ea <intr_entry>

c00226ca <intr5e_stub>:
c00226ca:	55                   	push   %ebp
c00226cb:	6a 00                	push   $0x0
c00226cd:	6a 5e                	push   $0x5e
c00226cf:	e9 16 fc ff ff       	jmp    c00222ea <intr_entry>

c00226d4 <intr5f_stub>:
c00226d4:	55                   	push   %ebp
c00226d5:	6a 00                	push   $0x0
c00226d7:	6a 5f                	push   $0x5f
c00226d9:	e9 0c fc ff ff       	jmp    c00222ea <intr_entry>

c00226de <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c00226de:	55                   	push   %ebp
c00226df:	6a 00                	push   $0x0
c00226e1:	6a 60                	push   $0x60
c00226e3:	e9 02 fc ff ff       	jmp    c00222ea <intr_entry>

c00226e8 <intr61_stub>:
c00226e8:	55                   	push   %ebp
c00226e9:	6a 00                	push   $0x0
c00226eb:	6a 61                	push   $0x61
c00226ed:	e9 f8 fb ff ff       	jmp    c00222ea <intr_entry>

c00226f2 <intr62_stub>:
c00226f2:	55                   	push   %ebp
c00226f3:	6a 00                	push   $0x0
c00226f5:	6a 62                	push   $0x62
c00226f7:	e9 ee fb ff ff       	jmp    c00222ea <intr_entry>

c00226fc <intr63_stub>:
c00226fc:	55                   	push   %ebp
c00226fd:	6a 00                	push   $0x0
c00226ff:	6a 63                	push   $0x63
c0022701:	e9 e4 fb ff ff       	jmp    c00222ea <intr_entry>

c0022706 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c0022706:	55                   	push   %ebp
c0022707:	6a 00                	push   $0x0
c0022709:	6a 64                	push   $0x64
c002270b:	e9 da fb ff ff       	jmp    c00222ea <intr_entry>

c0022710 <intr65_stub>:
c0022710:	55                   	push   %ebp
c0022711:	6a 00                	push   $0x0
c0022713:	6a 65                	push   $0x65
c0022715:	e9 d0 fb ff ff       	jmp    c00222ea <intr_entry>

c002271a <intr66_stub>:
c002271a:	55                   	push   %ebp
c002271b:	6a 00                	push   $0x0
c002271d:	6a 66                	push   $0x66
c002271f:	e9 c6 fb ff ff       	jmp    c00222ea <intr_entry>

c0022724 <intr67_stub>:
c0022724:	55                   	push   %ebp
c0022725:	6a 00                	push   $0x0
c0022727:	6a 67                	push   $0x67
c0022729:	e9 bc fb ff ff       	jmp    c00222ea <intr_entry>

c002272e <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c002272e:	55                   	push   %ebp
c002272f:	6a 00                	push   $0x0
c0022731:	6a 68                	push   $0x68
c0022733:	e9 b2 fb ff ff       	jmp    c00222ea <intr_entry>

c0022738 <intr69_stub>:
c0022738:	55                   	push   %ebp
c0022739:	6a 00                	push   $0x0
c002273b:	6a 69                	push   $0x69
c002273d:	e9 a8 fb ff ff       	jmp    c00222ea <intr_entry>

c0022742 <intr6a_stub>:
c0022742:	55                   	push   %ebp
c0022743:	6a 00                	push   $0x0
c0022745:	6a 6a                	push   $0x6a
c0022747:	e9 9e fb ff ff       	jmp    c00222ea <intr_entry>

c002274c <intr6b_stub>:
c002274c:	55                   	push   %ebp
c002274d:	6a 00                	push   $0x0
c002274f:	6a 6b                	push   $0x6b
c0022751:	e9 94 fb ff ff       	jmp    c00222ea <intr_entry>

c0022756 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022756:	55                   	push   %ebp
c0022757:	6a 00                	push   $0x0
c0022759:	6a 6c                	push   $0x6c
c002275b:	e9 8a fb ff ff       	jmp    c00222ea <intr_entry>

c0022760 <intr6d_stub>:
c0022760:	55                   	push   %ebp
c0022761:	6a 00                	push   $0x0
c0022763:	6a 6d                	push   $0x6d
c0022765:	e9 80 fb ff ff       	jmp    c00222ea <intr_entry>

c002276a <intr6e_stub>:
c002276a:	55                   	push   %ebp
c002276b:	6a 00                	push   $0x0
c002276d:	6a 6e                	push   $0x6e
c002276f:	e9 76 fb ff ff       	jmp    c00222ea <intr_entry>

c0022774 <intr6f_stub>:
c0022774:	55                   	push   %ebp
c0022775:	6a 00                	push   $0x0
c0022777:	6a 6f                	push   $0x6f
c0022779:	e9 6c fb ff ff       	jmp    c00222ea <intr_entry>

c002277e <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c002277e:	55                   	push   %ebp
c002277f:	6a 00                	push   $0x0
c0022781:	6a 70                	push   $0x70
c0022783:	e9 62 fb ff ff       	jmp    c00222ea <intr_entry>

c0022788 <intr71_stub>:
c0022788:	55                   	push   %ebp
c0022789:	6a 00                	push   $0x0
c002278b:	6a 71                	push   $0x71
c002278d:	e9 58 fb ff ff       	jmp    c00222ea <intr_entry>

c0022792 <intr72_stub>:
c0022792:	55                   	push   %ebp
c0022793:	6a 00                	push   $0x0
c0022795:	6a 72                	push   $0x72
c0022797:	e9 4e fb ff ff       	jmp    c00222ea <intr_entry>

c002279c <intr73_stub>:
c002279c:	55                   	push   %ebp
c002279d:	6a 00                	push   $0x0
c002279f:	6a 73                	push   $0x73
c00227a1:	e9 44 fb ff ff       	jmp    c00222ea <intr_entry>

c00227a6 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c00227a6:	55                   	push   %ebp
c00227a7:	6a 00                	push   $0x0
c00227a9:	6a 74                	push   $0x74
c00227ab:	e9 3a fb ff ff       	jmp    c00222ea <intr_entry>

c00227b0 <intr75_stub>:
c00227b0:	55                   	push   %ebp
c00227b1:	6a 00                	push   $0x0
c00227b3:	6a 75                	push   $0x75
c00227b5:	e9 30 fb ff ff       	jmp    c00222ea <intr_entry>

c00227ba <intr76_stub>:
c00227ba:	55                   	push   %ebp
c00227bb:	6a 00                	push   $0x0
c00227bd:	6a 76                	push   $0x76
c00227bf:	e9 26 fb ff ff       	jmp    c00222ea <intr_entry>

c00227c4 <intr77_stub>:
c00227c4:	55                   	push   %ebp
c00227c5:	6a 00                	push   $0x0
c00227c7:	6a 77                	push   $0x77
c00227c9:	e9 1c fb ff ff       	jmp    c00222ea <intr_entry>

c00227ce <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00227ce:	55                   	push   %ebp
c00227cf:	6a 00                	push   $0x0
c00227d1:	6a 78                	push   $0x78
c00227d3:	e9 12 fb ff ff       	jmp    c00222ea <intr_entry>

c00227d8 <intr79_stub>:
c00227d8:	55                   	push   %ebp
c00227d9:	6a 00                	push   $0x0
c00227db:	6a 79                	push   $0x79
c00227dd:	e9 08 fb ff ff       	jmp    c00222ea <intr_entry>

c00227e2 <intr7a_stub>:
c00227e2:	55                   	push   %ebp
c00227e3:	6a 00                	push   $0x0
c00227e5:	6a 7a                	push   $0x7a
c00227e7:	e9 fe fa ff ff       	jmp    c00222ea <intr_entry>

c00227ec <intr7b_stub>:
c00227ec:	55                   	push   %ebp
c00227ed:	6a 00                	push   $0x0
c00227ef:	6a 7b                	push   $0x7b
c00227f1:	e9 f4 fa ff ff       	jmp    c00222ea <intr_entry>

c00227f6 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00227f6:	55                   	push   %ebp
c00227f7:	6a 00                	push   $0x0
c00227f9:	6a 7c                	push   $0x7c
c00227fb:	e9 ea fa ff ff       	jmp    c00222ea <intr_entry>

c0022800 <intr7d_stub>:
c0022800:	55                   	push   %ebp
c0022801:	6a 00                	push   $0x0
c0022803:	6a 7d                	push   $0x7d
c0022805:	e9 e0 fa ff ff       	jmp    c00222ea <intr_entry>

c002280a <intr7e_stub>:
c002280a:	55                   	push   %ebp
c002280b:	6a 00                	push   $0x0
c002280d:	6a 7e                	push   $0x7e
c002280f:	e9 d6 fa ff ff       	jmp    c00222ea <intr_entry>

c0022814 <intr7f_stub>:
c0022814:	55                   	push   %ebp
c0022815:	6a 00                	push   $0x0
c0022817:	6a 7f                	push   $0x7f
c0022819:	e9 cc fa ff ff       	jmp    c00222ea <intr_entry>

c002281e <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c002281e:	55                   	push   %ebp
c002281f:	6a 00                	push   $0x0
c0022821:	68 80 00 00 00       	push   $0x80
c0022826:	e9 bf fa ff ff       	jmp    c00222ea <intr_entry>

c002282b <intr81_stub>:
c002282b:	55                   	push   %ebp
c002282c:	6a 00                	push   $0x0
c002282e:	68 81 00 00 00       	push   $0x81
c0022833:	e9 b2 fa ff ff       	jmp    c00222ea <intr_entry>

c0022838 <intr82_stub>:
c0022838:	55                   	push   %ebp
c0022839:	6a 00                	push   $0x0
c002283b:	68 82 00 00 00       	push   $0x82
c0022840:	e9 a5 fa ff ff       	jmp    c00222ea <intr_entry>

c0022845 <intr83_stub>:
c0022845:	55                   	push   %ebp
c0022846:	6a 00                	push   $0x0
c0022848:	68 83 00 00 00       	push   $0x83
c002284d:	e9 98 fa ff ff       	jmp    c00222ea <intr_entry>

c0022852 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022852:	55                   	push   %ebp
c0022853:	6a 00                	push   $0x0
c0022855:	68 84 00 00 00       	push   $0x84
c002285a:	e9 8b fa ff ff       	jmp    c00222ea <intr_entry>

c002285f <intr85_stub>:
c002285f:	55                   	push   %ebp
c0022860:	6a 00                	push   $0x0
c0022862:	68 85 00 00 00       	push   $0x85
c0022867:	e9 7e fa ff ff       	jmp    c00222ea <intr_entry>

c002286c <intr86_stub>:
c002286c:	55                   	push   %ebp
c002286d:	6a 00                	push   $0x0
c002286f:	68 86 00 00 00       	push   $0x86
c0022874:	e9 71 fa ff ff       	jmp    c00222ea <intr_entry>

c0022879 <intr87_stub>:
c0022879:	55                   	push   %ebp
c002287a:	6a 00                	push   $0x0
c002287c:	68 87 00 00 00       	push   $0x87
c0022881:	e9 64 fa ff ff       	jmp    c00222ea <intr_entry>

c0022886 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022886:	55                   	push   %ebp
c0022887:	6a 00                	push   $0x0
c0022889:	68 88 00 00 00       	push   $0x88
c002288e:	e9 57 fa ff ff       	jmp    c00222ea <intr_entry>

c0022893 <intr89_stub>:
c0022893:	55                   	push   %ebp
c0022894:	6a 00                	push   $0x0
c0022896:	68 89 00 00 00       	push   $0x89
c002289b:	e9 4a fa ff ff       	jmp    c00222ea <intr_entry>

c00228a0 <intr8a_stub>:
c00228a0:	55                   	push   %ebp
c00228a1:	6a 00                	push   $0x0
c00228a3:	68 8a 00 00 00       	push   $0x8a
c00228a8:	e9 3d fa ff ff       	jmp    c00222ea <intr_entry>

c00228ad <intr8b_stub>:
c00228ad:	55                   	push   %ebp
c00228ae:	6a 00                	push   $0x0
c00228b0:	68 8b 00 00 00       	push   $0x8b
c00228b5:	e9 30 fa ff ff       	jmp    c00222ea <intr_entry>

c00228ba <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00228ba:	55                   	push   %ebp
c00228bb:	6a 00                	push   $0x0
c00228bd:	68 8c 00 00 00       	push   $0x8c
c00228c2:	e9 23 fa ff ff       	jmp    c00222ea <intr_entry>

c00228c7 <intr8d_stub>:
c00228c7:	55                   	push   %ebp
c00228c8:	6a 00                	push   $0x0
c00228ca:	68 8d 00 00 00       	push   $0x8d
c00228cf:	e9 16 fa ff ff       	jmp    c00222ea <intr_entry>

c00228d4 <intr8e_stub>:
c00228d4:	55                   	push   %ebp
c00228d5:	6a 00                	push   $0x0
c00228d7:	68 8e 00 00 00       	push   $0x8e
c00228dc:	e9 09 fa ff ff       	jmp    c00222ea <intr_entry>

c00228e1 <intr8f_stub>:
c00228e1:	55                   	push   %ebp
c00228e2:	6a 00                	push   $0x0
c00228e4:	68 8f 00 00 00       	push   $0x8f
c00228e9:	e9 fc f9 ff ff       	jmp    c00222ea <intr_entry>

c00228ee <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00228ee:	55                   	push   %ebp
c00228ef:	6a 00                	push   $0x0
c00228f1:	68 90 00 00 00       	push   $0x90
c00228f6:	e9 ef f9 ff ff       	jmp    c00222ea <intr_entry>

c00228fb <intr91_stub>:
c00228fb:	55                   	push   %ebp
c00228fc:	6a 00                	push   $0x0
c00228fe:	68 91 00 00 00       	push   $0x91
c0022903:	e9 e2 f9 ff ff       	jmp    c00222ea <intr_entry>

c0022908 <intr92_stub>:
c0022908:	55                   	push   %ebp
c0022909:	6a 00                	push   $0x0
c002290b:	68 92 00 00 00       	push   $0x92
c0022910:	e9 d5 f9 ff ff       	jmp    c00222ea <intr_entry>

c0022915 <intr93_stub>:
c0022915:	55                   	push   %ebp
c0022916:	6a 00                	push   $0x0
c0022918:	68 93 00 00 00       	push   $0x93
c002291d:	e9 c8 f9 ff ff       	jmp    c00222ea <intr_entry>

c0022922 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022922:	55                   	push   %ebp
c0022923:	6a 00                	push   $0x0
c0022925:	68 94 00 00 00       	push   $0x94
c002292a:	e9 bb f9 ff ff       	jmp    c00222ea <intr_entry>

c002292f <intr95_stub>:
c002292f:	55                   	push   %ebp
c0022930:	6a 00                	push   $0x0
c0022932:	68 95 00 00 00       	push   $0x95
c0022937:	e9 ae f9 ff ff       	jmp    c00222ea <intr_entry>

c002293c <intr96_stub>:
c002293c:	55                   	push   %ebp
c002293d:	6a 00                	push   $0x0
c002293f:	68 96 00 00 00       	push   $0x96
c0022944:	e9 a1 f9 ff ff       	jmp    c00222ea <intr_entry>

c0022949 <intr97_stub>:
c0022949:	55                   	push   %ebp
c002294a:	6a 00                	push   $0x0
c002294c:	68 97 00 00 00       	push   $0x97
c0022951:	e9 94 f9 ff ff       	jmp    c00222ea <intr_entry>

c0022956 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022956:	55                   	push   %ebp
c0022957:	6a 00                	push   $0x0
c0022959:	68 98 00 00 00       	push   $0x98
c002295e:	e9 87 f9 ff ff       	jmp    c00222ea <intr_entry>

c0022963 <intr99_stub>:
c0022963:	55                   	push   %ebp
c0022964:	6a 00                	push   $0x0
c0022966:	68 99 00 00 00       	push   $0x99
c002296b:	e9 7a f9 ff ff       	jmp    c00222ea <intr_entry>

c0022970 <intr9a_stub>:
c0022970:	55                   	push   %ebp
c0022971:	6a 00                	push   $0x0
c0022973:	68 9a 00 00 00       	push   $0x9a
c0022978:	e9 6d f9 ff ff       	jmp    c00222ea <intr_entry>

c002297d <intr9b_stub>:
c002297d:	55                   	push   %ebp
c002297e:	6a 00                	push   $0x0
c0022980:	68 9b 00 00 00       	push   $0x9b
c0022985:	e9 60 f9 ff ff       	jmp    c00222ea <intr_entry>

c002298a <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c002298a:	55                   	push   %ebp
c002298b:	6a 00                	push   $0x0
c002298d:	68 9c 00 00 00       	push   $0x9c
c0022992:	e9 53 f9 ff ff       	jmp    c00222ea <intr_entry>

c0022997 <intr9d_stub>:
c0022997:	55                   	push   %ebp
c0022998:	6a 00                	push   $0x0
c002299a:	68 9d 00 00 00       	push   $0x9d
c002299f:	e9 46 f9 ff ff       	jmp    c00222ea <intr_entry>

c00229a4 <intr9e_stub>:
c00229a4:	55                   	push   %ebp
c00229a5:	6a 00                	push   $0x0
c00229a7:	68 9e 00 00 00       	push   $0x9e
c00229ac:	e9 39 f9 ff ff       	jmp    c00222ea <intr_entry>

c00229b1 <intr9f_stub>:
c00229b1:	55                   	push   %ebp
c00229b2:	6a 00                	push   $0x0
c00229b4:	68 9f 00 00 00       	push   $0x9f
c00229b9:	e9 2c f9 ff ff       	jmp    c00222ea <intr_entry>

c00229be <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00229be:	55                   	push   %ebp
c00229bf:	6a 00                	push   $0x0
c00229c1:	68 a0 00 00 00       	push   $0xa0
c00229c6:	e9 1f f9 ff ff       	jmp    c00222ea <intr_entry>

c00229cb <intra1_stub>:
c00229cb:	55                   	push   %ebp
c00229cc:	6a 00                	push   $0x0
c00229ce:	68 a1 00 00 00       	push   $0xa1
c00229d3:	e9 12 f9 ff ff       	jmp    c00222ea <intr_entry>

c00229d8 <intra2_stub>:
c00229d8:	55                   	push   %ebp
c00229d9:	6a 00                	push   $0x0
c00229db:	68 a2 00 00 00       	push   $0xa2
c00229e0:	e9 05 f9 ff ff       	jmp    c00222ea <intr_entry>

c00229e5 <intra3_stub>:
c00229e5:	55                   	push   %ebp
c00229e6:	6a 00                	push   $0x0
c00229e8:	68 a3 00 00 00       	push   $0xa3
c00229ed:	e9 f8 f8 ff ff       	jmp    c00222ea <intr_entry>

c00229f2 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c00229f2:	55                   	push   %ebp
c00229f3:	6a 00                	push   $0x0
c00229f5:	68 a4 00 00 00       	push   $0xa4
c00229fa:	e9 eb f8 ff ff       	jmp    c00222ea <intr_entry>

c00229ff <intra5_stub>:
c00229ff:	55                   	push   %ebp
c0022a00:	6a 00                	push   $0x0
c0022a02:	68 a5 00 00 00       	push   $0xa5
c0022a07:	e9 de f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a0c <intra6_stub>:
c0022a0c:	55                   	push   %ebp
c0022a0d:	6a 00                	push   $0x0
c0022a0f:	68 a6 00 00 00       	push   $0xa6
c0022a14:	e9 d1 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a19 <intra7_stub>:
c0022a19:	55                   	push   %ebp
c0022a1a:	6a 00                	push   $0x0
c0022a1c:	68 a7 00 00 00       	push   $0xa7
c0022a21:	e9 c4 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a26 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022a26:	55                   	push   %ebp
c0022a27:	6a 00                	push   $0x0
c0022a29:	68 a8 00 00 00       	push   $0xa8
c0022a2e:	e9 b7 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a33 <intra9_stub>:
c0022a33:	55                   	push   %ebp
c0022a34:	6a 00                	push   $0x0
c0022a36:	68 a9 00 00 00       	push   $0xa9
c0022a3b:	e9 aa f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a40 <intraa_stub>:
c0022a40:	55                   	push   %ebp
c0022a41:	6a 00                	push   $0x0
c0022a43:	68 aa 00 00 00       	push   $0xaa
c0022a48:	e9 9d f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a4d <intrab_stub>:
c0022a4d:	55                   	push   %ebp
c0022a4e:	6a 00                	push   $0x0
c0022a50:	68 ab 00 00 00       	push   $0xab
c0022a55:	e9 90 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a5a <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022a5a:	55                   	push   %ebp
c0022a5b:	6a 00                	push   $0x0
c0022a5d:	68 ac 00 00 00       	push   $0xac
c0022a62:	e9 83 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a67 <intrad_stub>:
c0022a67:	55                   	push   %ebp
c0022a68:	6a 00                	push   $0x0
c0022a6a:	68 ad 00 00 00       	push   $0xad
c0022a6f:	e9 76 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a74 <intrae_stub>:
c0022a74:	55                   	push   %ebp
c0022a75:	6a 00                	push   $0x0
c0022a77:	68 ae 00 00 00       	push   $0xae
c0022a7c:	e9 69 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a81 <intraf_stub>:
c0022a81:	55                   	push   %ebp
c0022a82:	6a 00                	push   $0x0
c0022a84:	68 af 00 00 00       	push   $0xaf
c0022a89:	e9 5c f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a8e <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022a8e:	55                   	push   %ebp
c0022a8f:	6a 00                	push   $0x0
c0022a91:	68 b0 00 00 00       	push   $0xb0
c0022a96:	e9 4f f8 ff ff       	jmp    c00222ea <intr_entry>

c0022a9b <intrb1_stub>:
c0022a9b:	55                   	push   %ebp
c0022a9c:	6a 00                	push   $0x0
c0022a9e:	68 b1 00 00 00       	push   $0xb1
c0022aa3:	e9 42 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022aa8 <intrb2_stub>:
c0022aa8:	55                   	push   %ebp
c0022aa9:	6a 00                	push   $0x0
c0022aab:	68 b2 00 00 00       	push   $0xb2
c0022ab0:	e9 35 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022ab5 <intrb3_stub>:
c0022ab5:	55                   	push   %ebp
c0022ab6:	6a 00                	push   $0x0
c0022ab8:	68 b3 00 00 00       	push   $0xb3
c0022abd:	e9 28 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022ac2 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022ac2:	55                   	push   %ebp
c0022ac3:	6a 00                	push   $0x0
c0022ac5:	68 b4 00 00 00       	push   $0xb4
c0022aca:	e9 1b f8 ff ff       	jmp    c00222ea <intr_entry>

c0022acf <intrb5_stub>:
c0022acf:	55                   	push   %ebp
c0022ad0:	6a 00                	push   $0x0
c0022ad2:	68 b5 00 00 00       	push   $0xb5
c0022ad7:	e9 0e f8 ff ff       	jmp    c00222ea <intr_entry>

c0022adc <intrb6_stub>:
c0022adc:	55                   	push   %ebp
c0022add:	6a 00                	push   $0x0
c0022adf:	68 b6 00 00 00       	push   $0xb6
c0022ae4:	e9 01 f8 ff ff       	jmp    c00222ea <intr_entry>

c0022ae9 <intrb7_stub>:
c0022ae9:	55                   	push   %ebp
c0022aea:	6a 00                	push   $0x0
c0022aec:	68 b7 00 00 00       	push   $0xb7
c0022af1:	e9 f4 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022af6 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022af6:	55                   	push   %ebp
c0022af7:	6a 00                	push   $0x0
c0022af9:	68 b8 00 00 00       	push   $0xb8
c0022afe:	e9 e7 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b03 <intrb9_stub>:
c0022b03:	55                   	push   %ebp
c0022b04:	6a 00                	push   $0x0
c0022b06:	68 b9 00 00 00       	push   $0xb9
c0022b0b:	e9 da f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b10 <intrba_stub>:
c0022b10:	55                   	push   %ebp
c0022b11:	6a 00                	push   $0x0
c0022b13:	68 ba 00 00 00       	push   $0xba
c0022b18:	e9 cd f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b1d <intrbb_stub>:
c0022b1d:	55                   	push   %ebp
c0022b1e:	6a 00                	push   $0x0
c0022b20:	68 bb 00 00 00       	push   $0xbb
c0022b25:	e9 c0 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b2a <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022b2a:	55                   	push   %ebp
c0022b2b:	6a 00                	push   $0x0
c0022b2d:	68 bc 00 00 00       	push   $0xbc
c0022b32:	e9 b3 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b37 <intrbd_stub>:
c0022b37:	55                   	push   %ebp
c0022b38:	6a 00                	push   $0x0
c0022b3a:	68 bd 00 00 00       	push   $0xbd
c0022b3f:	e9 a6 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b44 <intrbe_stub>:
c0022b44:	55                   	push   %ebp
c0022b45:	6a 00                	push   $0x0
c0022b47:	68 be 00 00 00       	push   $0xbe
c0022b4c:	e9 99 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b51 <intrbf_stub>:
c0022b51:	55                   	push   %ebp
c0022b52:	6a 00                	push   $0x0
c0022b54:	68 bf 00 00 00       	push   $0xbf
c0022b59:	e9 8c f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b5e <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022b5e:	55                   	push   %ebp
c0022b5f:	6a 00                	push   $0x0
c0022b61:	68 c0 00 00 00       	push   $0xc0
c0022b66:	e9 7f f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b6b <intrc1_stub>:
c0022b6b:	55                   	push   %ebp
c0022b6c:	6a 00                	push   $0x0
c0022b6e:	68 c1 00 00 00       	push   $0xc1
c0022b73:	e9 72 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b78 <intrc2_stub>:
c0022b78:	55                   	push   %ebp
c0022b79:	6a 00                	push   $0x0
c0022b7b:	68 c2 00 00 00       	push   $0xc2
c0022b80:	e9 65 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b85 <intrc3_stub>:
c0022b85:	55                   	push   %ebp
c0022b86:	6a 00                	push   $0x0
c0022b88:	68 c3 00 00 00       	push   $0xc3
c0022b8d:	e9 58 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b92 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022b92:	55                   	push   %ebp
c0022b93:	6a 00                	push   $0x0
c0022b95:	68 c4 00 00 00       	push   $0xc4
c0022b9a:	e9 4b f7 ff ff       	jmp    c00222ea <intr_entry>

c0022b9f <intrc5_stub>:
c0022b9f:	55                   	push   %ebp
c0022ba0:	6a 00                	push   $0x0
c0022ba2:	68 c5 00 00 00       	push   $0xc5
c0022ba7:	e9 3e f7 ff ff       	jmp    c00222ea <intr_entry>

c0022bac <intrc6_stub>:
c0022bac:	55                   	push   %ebp
c0022bad:	6a 00                	push   $0x0
c0022baf:	68 c6 00 00 00       	push   $0xc6
c0022bb4:	e9 31 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022bb9 <intrc7_stub>:
c0022bb9:	55                   	push   %ebp
c0022bba:	6a 00                	push   $0x0
c0022bbc:	68 c7 00 00 00       	push   $0xc7
c0022bc1:	e9 24 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022bc6 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022bc6:	55                   	push   %ebp
c0022bc7:	6a 00                	push   $0x0
c0022bc9:	68 c8 00 00 00       	push   $0xc8
c0022bce:	e9 17 f7 ff ff       	jmp    c00222ea <intr_entry>

c0022bd3 <intrc9_stub>:
c0022bd3:	55                   	push   %ebp
c0022bd4:	6a 00                	push   $0x0
c0022bd6:	68 c9 00 00 00       	push   $0xc9
c0022bdb:	e9 0a f7 ff ff       	jmp    c00222ea <intr_entry>

c0022be0 <intrca_stub>:
c0022be0:	55                   	push   %ebp
c0022be1:	6a 00                	push   $0x0
c0022be3:	68 ca 00 00 00       	push   $0xca
c0022be8:	e9 fd f6 ff ff       	jmp    c00222ea <intr_entry>

c0022bed <intrcb_stub>:
c0022bed:	55                   	push   %ebp
c0022bee:	6a 00                	push   $0x0
c0022bf0:	68 cb 00 00 00       	push   $0xcb
c0022bf5:	e9 f0 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022bfa <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022bfa:	55                   	push   %ebp
c0022bfb:	6a 00                	push   $0x0
c0022bfd:	68 cc 00 00 00       	push   $0xcc
c0022c02:	e9 e3 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c07 <intrcd_stub>:
c0022c07:	55                   	push   %ebp
c0022c08:	6a 00                	push   $0x0
c0022c0a:	68 cd 00 00 00       	push   $0xcd
c0022c0f:	e9 d6 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c14 <intrce_stub>:
c0022c14:	55                   	push   %ebp
c0022c15:	6a 00                	push   $0x0
c0022c17:	68 ce 00 00 00       	push   $0xce
c0022c1c:	e9 c9 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c21 <intrcf_stub>:
c0022c21:	55                   	push   %ebp
c0022c22:	6a 00                	push   $0x0
c0022c24:	68 cf 00 00 00       	push   $0xcf
c0022c29:	e9 bc f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c2e <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022c2e:	55                   	push   %ebp
c0022c2f:	6a 00                	push   $0x0
c0022c31:	68 d0 00 00 00       	push   $0xd0
c0022c36:	e9 af f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c3b <intrd1_stub>:
c0022c3b:	55                   	push   %ebp
c0022c3c:	6a 00                	push   $0x0
c0022c3e:	68 d1 00 00 00       	push   $0xd1
c0022c43:	e9 a2 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c48 <intrd2_stub>:
c0022c48:	55                   	push   %ebp
c0022c49:	6a 00                	push   $0x0
c0022c4b:	68 d2 00 00 00       	push   $0xd2
c0022c50:	e9 95 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c55 <intrd3_stub>:
c0022c55:	55                   	push   %ebp
c0022c56:	6a 00                	push   $0x0
c0022c58:	68 d3 00 00 00       	push   $0xd3
c0022c5d:	e9 88 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c62 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022c62:	55                   	push   %ebp
c0022c63:	6a 00                	push   $0x0
c0022c65:	68 d4 00 00 00       	push   $0xd4
c0022c6a:	e9 7b f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c6f <intrd5_stub>:
c0022c6f:	55                   	push   %ebp
c0022c70:	6a 00                	push   $0x0
c0022c72:	68 d5 00 00 00       	push   $0xd5
c0022c77:	e9 6e f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c7c <intrd6_stub>:
c0022c7c:	55                   	push   %ebp
c0022c7d:	6a 00                	push   $0x0
c0022c7f:	68 d6 00 00 00       	push   $0xd6
c0022c84:	e9 61 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c89 <intrd7_stub>:
c0022c89:	55                   	push   %ebp
c0022c8a:	6a 00                	push   $0x0
c0022c8c:	68 d7 00 00 00       	push   $0xd7
c0022c91:	e9 54 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022c96 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022c96:	55                   	push   %ebp
c0022c97:	6a 00                	push   $0x0
c0022c99:	68 d8 00 00 00       	push   $0xd8
c0022c9e:	e9 47 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022ca3 <intrd9_stub>:
c0022ca3:	55                   	push   %ebp
c0022ca4:	6a 00                	push   $0x0
c0022ca6:	68 d9 00 00 00       	push   $0xd9
c0022cab:	e9 3a f6 ff ff       	jmp    c00222ea <intr_entry>

c0022cb0 <intrda_stub>:
c0022cb0:	55                   	push   %ebp
c0022cb1:	6a 00                	push   $0x0
c0022cb3:	68 da 00 00 00       	push   $0xda
c0022cb8:	e9 2d f6 ff ff       	jmp    c00222ea <intr_entry>

c0022cbd <intrdb_stub>:
c0022cbd:	55                   	push   %ebp
c0022cbe:	6a 00                	push   $0x0
c0022cc0:	68 db 00 00 00       	push   $0xdb
c0022cc5:	e9 20 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022cca <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022cca:	55                   	push   %ebp
c0022ccb:	6a 00                	push   $0x0
c0022ccd:	68 dc 00 00 00       	push   $0xdc
c0022cd2:	e9 13 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022cd7 <intrdd_stub>:
c0022cd7:	55                   	push   %ebp
c0022cd8:	6a 00                	push   $0x0
c0022cda:	68 dd 00 00 00       	push   $0xdd
c0022cdf:	e9 06 f6 ff ff       	jmp    c00222ea <intr_entry>

c0022ce4 <intrde_stub>:
c0022ce4:	55                   	push   %ebp
c0022ce5:	6a 00                	push   $0x0
c0022ce7:	68 de 00 00 00       	push   $0xde
c0022cec:	e9 f9 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022cf1 <intrdf_stub>:
c0022cf1:	55                   	push   %ebp
c0022cf2:	6a 00                	push   $0x0
c0022cf4:	68 df 00 00 00       	push   $0xdf
c0022cf9:	e9 ec f5 ff ff       	jmp    c00222ea <intr_entry>

c0022cfe <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022cfe:	55                   	push   %ebp
c0022cff:	6a 00                	push   $0x0
c0022d01:	68 e0 00 00 00       	push   $0xe0
c0022d06:	e9 df f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d0b <intre1_stub>:
c0022d0b:	55                   	push   %ebp
c0022d0c:	6a 00                	push   $0x0
c0022d0e:	68 e1 00 00 00       	push   $0xe1
c0022d13:	e9 d2 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d18 <intre2_stub>:
c0022d18:	55                   	push   %ebp
c0022d19:	6a 00                	push   $0x0
c0022d1b:	68 e2 00 00 00       	push   $0xe2
c0022d20:	e9 c5 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d25 <intre3_stub>:
c0022d25:	55                   	push   %ebp
c0022d26:	6a 00                	push   $0x0
c0022d28:	68 e3 00 00 00       	push   $0xe3
c0022d2d:	e9 b8 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d32 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022d32:	55                   	push   %ebp
c0022d33:	6a 00                	push   $0x0
c0022d35:	68 e4 00 00 00       	push   $0xe4
c0022d3a:	e9 ab f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d3f <intre5_stub>:
c0022d3f:	55                   	push   %ebp
c0022d40:	6a 00                	push   $0x0
c0022d42:	68 e5 00 00 00       	push   $0xe5
c0022d47:	e9 9e f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d4c <intre6_stub>:
c0022d4c:	55                   	push   %ebp
c0022d4d:	6a 00                	push   $0x0
c0022d4f:	68 e6 00 00 00       	push   $0xe6
c0022d54:	e9 91 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d59 <intre7_stub>:
c0022d59:	55                   	push   %ebp
c0022d5a:	6a 00                	push   $0x0
c0022d5c:	68 e7 00 00 00       	push   $0xe7
c0022d61:	e9 84 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d66 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022d66:	55                   	push   %ebp
c0022d67:	6a 00                	push   $0x0
c0022d69:	68 e8 00 00 00       	push   $0xe8
c0022d6e:	e9 77 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d73 <intre9_stub>:
c0022d73:	55                   	push   %ebp
c0022d74:	6a 00                	push   $0x0
c0022d76:	68 e9 00 00 00       	push   $0xe9
c0022d7b:	e9 6a f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d80 <intrea_stub>:
c0022d80:	55                   	push   %ebp
c0022d81:	6a 00                	push   $0x0
c0022d83:	68 ea 00 00 00       	push   $0xea
c0022d88:	e9 5d f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d8d <intreb_stub>:
c0022d8d:	55                   	push   %ebp
c0022d8e:	6a 00                	push   $0x0
c0022d90:	68 eb 00 00 00       	push   $0xeb
c0022d95:	e9 50 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022d9a <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022d9a:	55                   	push   %ebp
c0022d9b:	6a 00                	push   $0x0
c0022d9d:	68 ec 00 00 00       	push   $0xec
c0022da2:	e9 43 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022da7 <intred_stub>:
c0022da7:	55                   	push   %ebp
c0022da8:	6a 00                	push   $0x0
c0022daa:	68 ed 00 00 00       	push   $0xed
c0022daf:	e9 36 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022db4 <intree_stub>:
c0022db4:	55                   	push   %ebp
c0022db5:	6a 00                	push   $0x0
c0022db7:	68 ee 00 00 00       	push   $0xee
c0022dbc:	e9 29 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022dc1 <intref_stub>:
c0022dc1:	55                   	push   %ebp
c0022dc2:	6a 00                	push   $0x0
c0022dc4:	68 ef 00 00 00       	push   $0xef
c0022dc9:	e9 1c f5 ff ff       	jmp    c00222ea <intr_entry>

c0022dce <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022dce:	55                   	push   %ebp
c0022dcf:	6a 00                	push   $0x0
c0022dd1:	68 f0 00 00 00       	push   $0xf0
c0022dd6:	e9 0f f5 ff ff       	jmp    c00222ea <intr_entry>

c0022ddb <intrf1_stub>:
c0022ddb:	55                   	push   %ebp
c0022ddc:	6a 00                	push   $0x0
c0022dde:	68 f1 00 00 00       	push   $0xf1
c0022de3:	e9 02 f5 ff ff       	jmp    c00222ea <intr_entry>

c0022de8 <intrf2_stub>:
c0022de8:	55                   	push   %ebp
c0022de9:	6a 00                	push   $0x0
c0022deb:	68 f2 00 00 00       	push   $0xf2
c0022df0:	e9 f5 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022df5 <intrf3_stub>:
c0022df5:	55                   	push   %ebp
c0022df6:	6a 00                	push   $0x0
c0022df8:	68 f3 00 00 00       	push   $0xf3
c0022dfd:	e9 e8 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e02 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022e02:	55                   	push   %ebp
c0022e03:	6a 00                	push   $0x0
c0022e05:	68 f4 00 00 00       	push   $0xf4
c0022e0a:	e9 db f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e0f <intrf5_stub>:
c0022e0f:	55                   	push   %ebp
c0022e10:	6a 00                	push   $0x0
c0022e12:	68 f5 00 00 00       	push   $0xf5
c0022e17:	e9 ce f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e1c <intrf6_stub>:
c0022e1c:	55                   	push   %ebp
c0022e1d:	6a 00                	push   $0x0
c0022e1f:	68 f6 00 00 00       	push   $0xf6
c0022e24:	e9 c1 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e29 <intrf7_stub>:
c0022e29:	55                   	push   %ebp
c0022e2a:	6a 00                	push   $0x0
c0022e2c:	68 f7 00 00 00       	push   $0xf7
c0022e31:	e9 b4 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e36 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022e36:	55                   	push   %ebp
c0022e37:	6a 00                	push   $0x0
c0022e39:	68 f8 00 00 00       	push   $0xf8
c0022e3e:	e9 a7 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e43 <intrf9_stub>:
c0022e43:	55                   	push   %ebp
c0022e44:	6a 00                	push   $0x0
c0022e46:	68 f9 00 00 00       	push   $0xf9
c0022e4b:	e9 9a f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e50 <intrfa_stub>:
c0022e50:	55                   	push   %ebp
c0022e51:	6a 00                	push   $0x0
c0022e53:	68 fa 00 00 00       	push   $0xfa
c0022e58:	e9 8d f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e5d <intrfb_stub>:
c0022e5d:	55                   	push   %ebp
c0022e5e:	6a 00                	push   $0x0
c0022e60:	68 fb 00 00 00       	push   $0xfb
c0022e65:	e9 80 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e6a <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022e6a:	55                   	push   %ebp
c0022e6b:	6a 00                	push   $0x0
c0022e6d:	68 fc 00 00 00       	push   $0xfc
c0022e72:	e9 73 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e77 <intrfd_stub>:
c0022e77:	55                   	push   %ebp
c0022e78:	6a 00                	push   $0x0
c0022e7a:	68 fd 00 00 00       	push   $0xfd
c0022e7f:	e9 66 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e84 <intrfe_stub>:
c0022e84:	55                   	push   %ebp
c0022e85:	6a 00                	push   $0x0
c0022e87:	68 fe 00 00 00       	push   $0xfe
c0022e8c:	e9 59 f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e91 <intrff_stub>:
c0022e91:	55                   	push   %ebp
c0022e92:	6a 00                	push   $0x0
c0022e94:	68 ff 00 00 00       	push   $0xff
c0022e99:	e9 4c f4 ff ff       	jmp    c00222ea <intr_entry>

c0022e9e <sema_cmp_priority>:
    lock_acquire(lock);
}

bool sema_cmp_priority(const struct list_elem *a,
                       const struct list_elem *b,
                       void *aux) {
c0022e9e:	56                   	push   %esi
c0022e9f:	53                   	push   %ebx
c0022ea0:	83 ec 10             	sub    $0x10,%esp
c0022ea3:	e8 9b d2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0022ea8:	81 c3 04 ae 01 00    	add    $0x1ae04,%ebx
    struct semaphore_elem *sema_a = list_entry(a, struct semaphore_elem, elem);
    struct semaphore_elem *sema_b = list_entry(b, struct semaphore_elem, elem);
    int priority_a = list_entry(list_front(&sema_a->semaphore.waiters), struct thread, elem)->priority;
c0022eae:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0022eb2:	83 c0 0c             	add    $0xc,%eax
c0022eb5:	50                   	push   %eax
c0022eb6:	e8 07 6a 00 00       	call   c00298c2 <list_front>
c0022ebb:	8b b0 1c ff ff ff    	mov    -0xe4(%eax),%esi
    int priority_b = list_entry(list_front(&sema_b->semaphore.waiters), struct thread, elem)->priority;
c0022ec1:	8b 44 24 24          	mov    0x24(%esp),%eax
c0022ec5:	83 c0 0c             	add    $0xc,%eax
c0022ec8:	89 04 24             	mov    %eax,(%esp)
c0022ecb:	e8 f2 69 00 00       	call   c00298c2 <list_front>
    return priority_a > priority_b;
c0022ed0:	3b b0 1c ff ff ff    	cmp    -0xe4(%eax),%esi
c0022ed6:	0f 9f c0             	setg   %al
}
c0022ed9:	83 c4 14             	add    $0x14,%esp
c0022edc:	5b                   	pop    %ebx
c0022edd:	5e                   	pop    %esi
c0022ede:	c3                   	ret    

c0022edf <sema_init>:
sema_init(struct semaphore *sema, unsigned value) {
c0022edf:	53                   	push   %ebx
c0022ee0:	83 ec 08             	sub    $0x8,%esp
c0022ee3:	e8 5b d2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0022ee8:	81 c3 c4 ad 01 00    	add    $0x1adc4,%ebx
c0022eee:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (sema != NULL);
c0022ef2:	85 c0                	test   %eax,%eax
c0022ef4:	74 17                	je     c0022f0d <sema_init+0x2e>
    sema->value = value;
c0022ef6:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022efa:	89 10                	mov    %edx,(%eax)
    list_init(&sema->waiters);
c0022efc:	83 ec 0c             	sub    $0xc,%esp
c0022eff:	83 c0 04             	add    $0x4,%eax
c0022f02:	50                   	push   %eax
c0022f03:	e8 f2 62 00 00       	call   c00291fa <list_init>
}
c0022f08:	83 c4 18             	add    $0x18,%esp
c0022f0b:	5b                   	pop    %ebx
c0022f0c:	c3                   	ret    
    ASSERT (sema != NULL);
c0022f0d:	83 ec 0c             	sub    $0xc,%esp
c0022f10:	8d 83 76 42 ff ff    	lea    -0xbd8a(%ebx),%eax
c0022f16:	50                   	push   %eax
c0022f17:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0022f1d:	50                   	push   %eax
c0022f1e:	8d 83 4c 27 ff ff    	lea    -0xd8b4(%ebx),%eax
c0022f24:	50                   	push   %eax
c0022f25:	6a 2e                	push   $0x2e
c0022f27:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0022f2d:	50                   	push   %eax
c0022f2e:	e8 fa 61 00 00       	call   c002912d <debug_panic>

c0022f33 <sema_down>:
sema_down(struct semaphore *sema) {
c0022f33:	55                   	push   %ebp
c0022f34:	57                   	push   %edi
c0022f35:	56                   	push   %esi
c0022f36:	53                   	push   %ebx
c0022f37:	83 ec 1c             	sub    $0x1c,%esp
c0022f3a:	e8 04 d2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0022f3f:	81 c3 6d ad 01 00    	add    $0x1ad6d,%ebx
c0022f45:	8b 7c 24 30          	mov    0x30(%esp),%edi
    ASSERT (sema != NULL);
c0022f49:	85 ff                	test   %edi,%edi
c0022f4b:	74 5d                	je     c0022faa <sema_down+0x77>
    ASSERT (!intr_context());
c0022f4d:	e8 b6 f0 ff ff       	call   c0022008 <intr_context>
c0022f52:	84 c0                	test   %al,%al
c0022f54:	75 7a                	jne    c0022fd0 <sema_down+0x9d>
    old_level = intr_disable();
c0022f56:	e8 07 ee ff ff       	call   c0021d62 <intr_disable>
c0022f5b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    while (sema->value == 0) {
c0022f5f:	8b 07                	mov    (%edi),%eax
c0022f61:	85 c0                	test   %eax,%eax
c0022f63:	75 2c                	jne    c0022f91 <sema_down+0x5e>
        list_insert_ordered(&sema->waiters, &thread_current()->elem, get_cmp_priority_func(), NULL);
c0022f65:	8d 6f 04             	lea    0x4(%edi),%ebp
c0022f68:	e8 98 df ff ff       	call   c0020f05 <get_cmp_priority_func>
c0022f6d:	89 c6                	mov    %eax,%esi
c0022f6f:	e8 55 e0 ff ff       	call   c0020fc9 <thread_current>
c0022f74:	6a 00                	push   $0x0
c0022f76:	56                   	push   %esi
c0022f77:	05 08 01 00 00       	add    $0x108,%eax
c0022f7c:	50                   	push   %eax
c0022f7d:	55                   	push   %ebp
c0022f7e:	e8 6e 6d 00 00       	call   c0029cf1 <list_insert_ordered>
        thread_block();
c0022f83:	e8 e0 e5 ff ff       	call   c0021568 <thread_block>
    while (sema->value == 0) {
c0022f88:	8b 07                	mov    (%edi),%eax
c0022f8a:	83 c4 10             	add    $0x10,%esp
c0022f8d:	85 c0                	test   %eax,%eax
c0022f8f:	74 d7                	je     c0022f68 <sema_down+0x35>
    sema->value--;
c0022f91:	83 e8 01             	sub    $0x1,%eax
c0022f94:	89 07                	mov    %eax,(%edi)
    intr_set_level(old_level);
c0022f96:	83 ec 0c             	sub    $0xc,%esp
c0022f99:	ff 74 24 18          	pushl  0x18(%esp)
c0022f9d:	e8 c7 ed ff ff       	call   c0021d69 <intr_set_level>
}
c0022fa2:	83 c4 2c             	add    $0x2c,%esp
c0022fa5:	5b                   	pop    %ebx
c0022fa6:	5e                   	pop    %esi
c0022fa7:	5f                   	pop    %edi
c0022fa8:	5d                   	pop    %ebp
c0022fa9:	c3                   	ret    
    ASSERT (sema != NULL);
c0022faa:	83 ec 0c             	sub    $0xc,%esp
c0022fad:	8d 83 76 42 ff ff    	lea    -0xbd8a(%ebx),%eax
c0022fb3:	50                   	push   %eax
c0022fb4:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0022fba:	50                   	push   %eax
c0022fbb:	8d 83 40 27 ff ff    	lea    -0xd8c0(%ebx),%eax
c0022fc1:	50                   	push   %eax
c0022fc2:	6a 3f                	push   $0x3f
c0022fc4:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0022fca:	50                   	push   %eax
c0022fcb:	e8 5d 61 00 00       	call   c002912d <debug_panic>
    ASSERT (!intr_context());
c0022fd0:	83 ec 0c             	sub    $0xc,%esp
c0022fd3:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c0022fd9:	50                   	push   %eax
c0022fda:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0022fe0:	50                   	push   %eax
c0022fe1:	8d 83 40 27 ff ff    	lea    -0xd8c0(%ebx),%eax
c0022fe7:	50                   	push   %eax
c0022fe8:	6a 40                	push   $0x40
c0022fea:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0022ff0:	50                   	push   %eax
c0022ff1:	e8 37 61 00 00       	call   c002912d <debug_panic>

c0022ff6 <sema_try_down>:
sema_try_down(struct semaphore *sema) {
c0022ff6:	57                   	push   %edi
c0022ff7:	56                   	push   %esi
c0022ff8:	53                   	push   %ebx
c0022ff9:	e8 45 d1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0022ffe:	81 c3 ae ac 01 00    	add    $0x1acae,%ebx
c0023004:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (sema != NULL);
c0023008:	85 f6                	test   %esi,%esi
c002300a:	74 2c                	je     c0023038 <sema_try_down+0x42>
    old_level = intr_disable();
c002300c:	e8 51 ed ff ff       	call   c0021d62 <intr_disable>
    if (sema->value > 0) {
c0023011:	8b 16                	mov    (%esi),%edx
        success = false;
c0023013:	bf 00 00 00 00       	mov    $0x0,%edi
    if (sema->value > 0) {
c0023018:	85 d2                	test   %edx,%edx
c002301a:	74 0a                	je     c0023026 <sema_try_down+0x30>
        sema->value--;
c002301c:	83 ea 01             	sub    $0x1,%edx
c002301f:	89 16                	mov    %edx,(%esi)
        success = true;
c0023021:	bf 01 00 00 00       	mov    $0x1,%edi
    intr_set_level(old_level);
c0023026:	83 ec 0c             	sub    $0xc,%esp
c0023029:	50                   	push   %eax
c002302a:	e8 3a ed ff ff       	call   c0021d69 <intr_set_level>
    return success;
c002302f:	83 c4 10             	add    $0x10,%esp
}
c0023032:	89 f8                	mov    %edi,%eax
c0023034:	5b                   	pop    %ebx
c0023035:	5e                   	pop    %esi
c0023036:	5f                   	pop    %edi
c0023037:	c3                   	ret    
    ASSERT (sema != NULL);
c0023038:	83 ec 0c             	sub    $0xc,%esp
c002303b:	8d 83 76 42 ff ff    	lea    -0xbd8a(%ebx),%eax
c0023041:	50                   	push   %eax
c0023042:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023048:	50                   	push   %eax
c0023049:	8d 83 30 27 ff ff    	lea    -0xd8d0(%ebx),%eax
c002304f:	50                   	push   %eax
c0023050:	6a 55                	push   $0x55
c0023052:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023058:	50                   	push   %eax
c0023059:	e8 cf 60 00 00       	call   c002912d <debug_panic>

c002305e <sema_up>:
sema_up(struct semaphore *sema) {
c002305e:	57                   	push   %edi
c002305f:	56                   	push   %esi
c0023060:	53                   	push   %ebx
c0023061:	e8 dd d0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023066:	81 c3 46 ac 01 00    	add    $0x1ac46,%ebx
c002306c:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (sema != NULL);
c0023070:	85 f6                	test   %esi,%esi
c0023072:	74 2d                	je     c00230a1 <sema_up+0x43>
    old_level = intr_disable();
c0023074:	e8 e9 ec ff ff       	call   c0021d62 <intr_disable>
c0023079:	89 c7                	mov    %eax,%edi
    sema->value++;
c002307b:	83 06 01             	addl   $0x1,(%esi)
    if (!list_empty(&sema->waiters)) {
c002307e:	83 c6 04             	add    $0x4,%esi
c0023081:	83 ec 0c             	sub    $0xc,%esp
c0023084:	56                   	push   %esi
c0023085:	e8 14 68 00 00       	call   c002989e <list_empty>
c002308a:	83 c4 10             	add    $0x10,%esp
c002308d:	84 c0                	test   %al,%al
c002308f:	74 36                	je     c00230c7 <sema_up+0x69>
    intr_set_level(old_level);
c0023091:	83 ec 0c             	sub    $0xc,%esp
c0023094:	57                   	push   %edi
c0023095:	e8 cf ec ff ff       	call   c0021d69 <intr_set_level>
}
c002309a:	83 c4 10             	add    $0x10,%esp
c002309d:	5b                   	pop    %ebx
c002309e:	5e                   	pop    %esi
c002309f:	5f                   	pop    %edi
c00230a0:	c3                   	ret    
    ASSERT (sema != NULL);
c00230a1:	83 ec 0c             	sub    $0xc,%esp
c00230a4:	8d 83 76 42 ff ff    	lea    -0xbd8a(%ebx),%eax
c00230aa:	50                   	push   %eax
c00230ab:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00230b1:	50                   	push   %eax
c00230b2:	8d 83 28 27 ff ff    	lea    -0xd8d8(%ebx),%eax
c00230b8:	50                   	push   %eax
c00230b9:	6a 6d                	push   $0x6d
c00230bb:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c00230c1:	50                   	push   %eax
c00230c2:	e8 66 60 00 00       	call   c002912d <debug_panic>
        list_sort(&sema->waiters, get_cmp_priority_func(), NULL);
c00230c7:	e8 39 de ff ff       	call   c0020f05 <get_cmp_priority_func>
c00230cc:	83 ec 04             	sub    $0x4,%esp
c00230cf:	6a 00                	push   $0x0
c00230d1:	50                   	push   %eax
c00230d2:	56                   	push   %esi
c00230d3:	e8 2c 69 00 00       	call   c0029a04 <list_sort>
        thread_unblock(list_entry (list_pop_front(&sema->waiters),
c00230d8:	89 34 24             	mov    %esi,(%esp)
c00230db:	e8 35 68 00 00       	call   c0029915 <list_pop_front>
c00230e0:	2d 08 01 00 00       	sub    $0x108,%eax
c00230e5:	89 04 24             	mov    %eax,(%esp)
c00230e8:	e8 29 de ff ff       	call   c0020f16 <thread_unblock>
c00230ed:	83 c4 10             	add    $0x10,%esp
c00230f0:	eb 9f                	jmp    c0023091 <sema_up+0x33>

c00230f2 <sema_test_helper>:
sema_test_helper(void *sema_) {
c00230f2:	57                   	push   %edi
c00230f3:	56                   	push   %esi
c00230f4:	53                   	push   %ebx
c00230f5:	8b 74 24 10          	mov    0x10(%esp),%esi
c00230f9:	bb 0a 00 00 00       	mov    $0xa,%ebx
        sema_up(&sema[1]);
c00230fe:	8d 7e 14             	lea    0x14(%esi),%edi
        sema_down(&sema[0]);
c0023101:	83 ec 0c             	sub    $0xc,%esp
c0023104:	56                   	push   %esi
c0023105:	e8 29 fe ff ff       	call   c0022f33 <sema_down>
        sema_up(&sema[1]);
c002310a:	89 3c 24             	mov    %edi,(%esp)
c002310d:	e8 4c ff ff ff       	call   c002305e <sema_up>
    for (i = 0; i < 10; i++) {
c0023112:	83 c4 10             	add    $0x10,%esp
c0023115:	83 eb 01             	sub    $0x1,%ebx
c0023118:	75 e7                	jne    c0023101 <sema_test_helper+0xf>
}
c002311a:	5b                   	pop    %ebx
c002311b:	5e                   	pop    %esi
c002311c:	5f                   	pop    %edi
c002311d:	c3                   	ret    

c002311e <sema_self_test>:
sema_self_test(void) {
c002311e:	55                   	push   %ebp
c002311f:	57                   	push   %edi
c0023120:	56                   	push   %esi
c0023121:	53                   	push   %ebx
c0023122:	83 ec 48             	sub    $0x48,%esp
c0023125:	e8 19 d0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002312a:	81 c3 82 ab 01 00    	add    $0x1ab82,%ebx
    printf("Testing semaphores...");
c0023130:	8d 83 99 42 ff ff    	lea    -0xbd67(%ebx),%eax
c0023136:	50                   	push   %eax
c0023137:	e8 95 43 00 00       	call   c00274d1 <printf>
    sema_init(&sema[0], 0);
c002313c:	83 c4 08             	add    $0x8,%esp
c002313f:	6a 00                	push   $0x0
c0023141:	8d 74 24 14          	lea    0x14(%esp),%esi
c0023145:	56                   	push   %esi
c0023146:	e8 94 fd ff ff       	call   c0022edf <sema_init>
    sema_init(&sema[1], 0);
c002314b:	83 c4 08             	add    $0x8,%esp
c002314e:	6a 00                	push   $0x0
c0023150:	8d 44 24 28          	lea    0x28(%esp),%eax
c0023154:	50                   	push   %eax
c0023155:	e8 85 fd ff ff       	call   c0022edf <sema_init>
    thread_create("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c002315a:	56                   	push   %esi
c002315b:	8d 83 46 54 fe ff    	lea    -0x1abba(%ebx),%eax
c0023161:	50                   	push   %eax
c0023162:	6a 1f                	push   $0x1f
c0023164:	8d 83 af 42 ff ff    	lea    -0xbd51(%ebx),%eax
c002316a:	50                   	push   %eax
c002316b:	e8 2b e6 ff ff       	call   c002179b <thread_create>
c0023170:	83 c4 20             	add    $0x20,%esp
c0023173:	be 0a 00 00 00       	mov    $0xa,%esi
        sema_up(&sema[0]);
c0023178:	8d 6c 24 08          	lea    0x8(%esp),%ebp
        sema_down(&sema[1]);
c002317c:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
        sema_up(&sema[0]);
c0023180:	83 ec 0c             	sub    $0xc,%esp
c0023183:	55                   	push   %ebp
c0023184:	e8 d5 fe ff ff       	call   c002305e <sema_up>
        sema_down(&sema[1]);
c0023189:	89 3c 24             	mov    %edi,(%esp)
c002318c:	e8 a2 fd ff ff       	call   c0022f33 <sema_down>
    for (i = 0; i < 10; i++) {
c0023191:	83 c4 10             	add    $0x10,%esp
c0023194:	83 ee 01             	sub    $0x1,%esi
c0023197:	75 e7                	jne    c0023180 <sema_self_test+0x62>
    printf("done.\n");
c0023199:	83 ec 0c             	sub    $0xc,%esp
c002319c:	8d 83 b9 42 ff ff    	lea    -0xbd47(%ebx),%eax
c00231a2:	50                   	push   %eax
c00231a3:	e8 5b 7f 00 00       	call   c002b103 <puts>
}
c00231a8:	83 c4 4c             	add    $0x4c,%esp
c00231ab:	5b                   	pop    %ebx
c00231ac:	5e                   	pop    %esi
c00231ad:	5f                   	pop    %edi
c00231ae:	5d                   	pop    %ebp
c00231af:	c3                   	ret    

c00231b0 <lock_init>:
lock_init(struct lock *lock) {
c00231b0:	53                   	push   %ebx
c00231b1:	83 ec 08             	sub    $0x8,%esp
c00231b4:	e8 8a cf 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00231b9:	81 c3 f3 aa 01 00    	add    $0x1aaf3,%ebx
c00231bf:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (lock != NULL);
c00231c3:	85 c0                	test   %eax,%eax
c00231c5:	74 19                	je     c00231e0 <lock_init+0x30>
    lock->holder = NULL;
c00231c7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    sema_init(&lock->semaphore, 1);
c00231cd:	83 ec 08             	sub    $0x8,%esp
c00231d0:	6a 01                	push   $0x1
c00231d2:	83 c0 04             	add    $0x4,%eax
c00231d5:	50                   	push   %eax
c00231d6:	e8 04 fd ff ff       	call   c0022edf <sema_init>
}
c00231db:	83 c4 18             	add    $0x18,%esp
c00231de:	5b                   	pop    %ebx
c00231df:	c3                   	ret    
    ASSERT (lock != NULL);
c00231e0:	83 ec 0c             	sub    $0xc,%esp
c00231e3:	8d 83 bf 42 ff ff    	lea    -0xbd41(%ebx),%eax
c00231e9:	50                   	push   %eax
c00231ea:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00231f0:	50                   	push   %eax
c00231f1:	8d 83 1c 27 ff ff    	lea    -0xd8e4(%ebx),%eax
c00231f7:	50                   	push   %eax
c00231f8:	68 b3 00 00 00       	push   $0xb3
c00231fd:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023203:	50                   	push   %eax
c0023204:	e8 24 5f 00 00       	call   c002912d <debug_panic>

c0023209 <lock_held_by_current_thread>:
lock_held_by_current_thread(const struct lock *lock) {
c0023209:	56                   	push   %esi
c002320a:	53                   	push   %ebx
c002320b:	83 ec 04             	sub    $0x4,%esp
c002320e:	e8 30 cf 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023213:	81 c3 99 aa 01 00    	add    $0x1aa99,%ebx
c0023219:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (lock != NULL);
c002321d:	85 c0                	test   %eax,%eax
c002321f:	74 12                	je     c0023233 <lock_held_by_current_thread+0x2a>
    return lock->holder == thread_current();
c0023221:	8b 30                	mov    (%eax),%esi
c0023223:	e8 a1 dd ff ff       	call   c0020fc9 <thread_current>
c0023228:	39 c6                	cmp    %eax,%esi
c002322a:	0f 94 c0             	sete   %al
}
c002322d:	83 c4 04             	add    $0x4,%esp
c0023230:	5b                   	pop    %ebx
c0023231:	5e                   	pop    %esi
c0023232:	c3                   	ret    
    ASSERT (lock != NULL);
c0023233:	83 ec 0c             	sub    $0xc,%esp
c0023236:	8d 83 bf 42 ff ff    	lea    -0xbd41(%ebx),%eax
c002323c:	50                   	push   %eax
c002323d:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023243:	50                   	push   %eax
c0023244:	8d 83 cc 26 ff ff    	lea    -0xd934(%ebx),%eax
c002324a:	50                   	push   %eax
c002324b:	68 0d 01 00 00       	push   $0x10d
c0023250:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023256:	50                   	push   %eax
c0023257:	e8 d1 5e 00 00       	call   c002912d <debug_panic>

c002325c <lock_acquire>:
lock_acquire(struct lock *lock) {
c002325c:	55                   	push   %ebp
c002325d:	57                   	push   %edi
c002325e:	56                   	push   %esi
c002325f:	53                   	push   %ebx
c0023260:	83 ec 0c             	sub    $0xc,%esp
c0023263:	e8 db ce 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023268:	81 c3 44 aa 01 00    	add    $0x1aa44,%ebx
c002326e:	8b 7c 24 20          	mov    0x20(%esp),%edi
    struct thread *current_thread = thread_current();
c0023272:	e8 52 dd ff ff       	call   c0020fc9 <thread_current>
    ASSERT (lock != NULL);
c0023277:	85 ff                	test   %edi,%edi
c0023279:	0f 84 a6 00 00 00    	je     c0023325 <lock_acquire+0xc9>
c002327f:	89 c5                	mov    %eax,%ebp
    ASSERT (!intr_context());
c0023281:	e8 82 ed ff ff       	call   c0022008 <intr_context>
c0023286:	84 c0                	test   %al,%al
c0023288:	0f 85 c0 00 00 00    	jne    c002334e <lock_acquire+0xf2>
    ASSERT (!lock_held_by_current_thread(lock));
c002328e:	83 ec 0c             	sub    $0xc,%esp
c0023291:	57                   	push   %edi
c0023292:	e8 72 ff ff ff       	call   c0023209 <lock_held_by_current_thread>
c0023297:	83 c4 10             	add    $0x10,%esp
c002329a:	84 c0                	test   %al,%al
c002329c:	0f 85 d5 00 00 00    	jne    c0023377 <lock_acquire+0x11b>
    if (lock->holder != NULL && !thread_mlfqs) {
c00232a2:	83 3f 00             	cmpl   $0x0,(%edi)
c00232a5:	74 3f                	je     c00232e6 <lock_acquire+0x8a>
c00232a7:	c7 c0 cc fc 03 c0    	mov    $0xc003fccc,%eax
c00232ad:	80 38 00             	cmpb   $0x0,(%eax)
c00232b0:	75 34                	jne    c00232e6 <lock_acquire+0x8a>
        current_thread->lock_waiting = lock;
c00232b2:	89 bd 04 01 00 00    	mov    %edi,0x104(%ebp)
        while (l && current_thread->priority > l->max_priority) {
c00232b8:	8b 45 24             	mov    0x24(%ebp),%eax
c00232bb:	3b 47 20             	cmp    0x20(%edi),%eax
c00232be:	7e 26                	jle    c00232e6 <lock_acquire+0x8a>
        l = lock;
c00232c0:	89 fe                	mov    %edi,%esi
            l->max_priority = current_thread->priority;
c00232c2:	89 46 20             	mov    %eax,0x20(%esi)
            thread_donate_priority(l->holder);
c00232c5:	83 ec 0c             	sub    $0xc,%esp
c00232c8:	ff 36                	pushl  (%esi)
c00232ca:	e8 b9 e7 ff ff       	call   c0021a88 <thread_donate_priority>
            l = l->holder->lock_waiting;
c00232cf:	8b 06                	mov    (%esi),%eax
c00232d1:	8b b0 04 01 00 00    	mov    0x104(%eax),%esi
        while (l && current_thread->priority > l->max_priority) {
c00232d7:	83 c4 10             	add    $0x10,%esp
c00232da:	85 f6                	test   %esi,%esi
c00232dc:	74 08                	je     c00232e6 <lock_acquire+0x8a>
c00232de:	8b 45 24             	mov    0x24(%ebp),%eax
c00232e1:	3b 46 20             	cmp    0x20(%esi),%eax
c00232e4:	7f dc                	jg     c00232c2 <lock_acquire+0x66>
    sema_down(&lock->semaphore);
c00232e6:	83 ec 0c             	sub    $0xc,%esp
c00232e9:	8d 47 04             	lea    0x4(%edi),%eax
c00232ec:	50                   	push   %eax
c00232ed:	e8 41 fc ff ff       	call   c0022f33 <sema_down>
    enum intr_level old_level = intr_disable();
c00232f2:	e8 6b ea ff ff       	call   c0021d62 <intr_disable>
c00232f7:	89 c5                	mov    %eax,%ebp
    current_thread = thread_current();
c00232f9:	e8 cb dc ff ff       	call   c0020fc9 <thread_current>
c00232fe:	89 c6                	mov    %eax,%esi
    if (!thread_mlfqs) {
c0023300:	83 c4 10             	add    $0x10,%esp
c0023303:	c7 c0 cc fc 03 c0    	mov    $0xc003fccc,%eax
c0023309:	80 38 00             	cmpb   $0x0,(%eax)
c002330c:	0f 84 8e 00 00 00    	je     c00233a0 <lock_acquire+0x144>
    lock->holder = current_thread;
c0023312:	89 37                	mov    %esi,(%edi)
    intr_set_level(old_level);
c0023314:	83 ec 0c             	sub    $0xc,%esp
c0023317:	55                   	push   %ebp
c0023318:	e8 4c ea ff ff       	call   c0021d69 <intr_set_level>
}
c002331d:	83 c4 1c             	add    $0x1c,%esp
c0023320:	5b                   	pop    %ebx
c0023321:	5e                   	pop    %esi
c0023322:	5f                   	pop    %edi
c0023323:	5d                   	pop    %ebp
c0023324:	c3                   	ret    
    ASSERT (lock != NULL);
c0023325:	83 ec 0c             	sub    $0xc,%esp
c0023328:	8d 83 bf 42 ff ff    	lea    -0xbd41(%ebx),%eax
c002332e:	50                   	push   %eax
c002332f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023335:	50                   	push   %eax
c0023336:	8d 83 0c 27 ff ff    	lea    -0xd8f4(%ebx),%eax
c002333c:	50                   	push   %eax
c002333d:	68 c6 00 00 00       	push   $0xc6
c0023342:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023348:	50                   	push   %eax
c0023349:	e8 df 5d 00 00       	call   c002912d <debug_panic>
    ASSERT (!intr_context());
c002334e:	83 ec 0c             	sub    $0xc,%esp
c0023351:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c0023357:	50                   	push   %eax
c0023358:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002335e:	50                   	push   %eax
c002335f:	8d 83 0c 27 ff ff    	lea    -0xd8f4(%ebx),%eax
c0023365:	50                   	push   %eax
c0023366:	68 c7 00 00 00       	push   $0xc7
c002336b:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023371:	50                   	push   %eax
c0023372:	e8 b6 5d 00 00       	call   c002912d <debug_panic>
    ASSERT (!lock_held_by_current_thread(lock));
c0023377:	83 ec 0c             	sub    $0xc,%esp
c002337a:	8d 83 dc 42 ff ff    	lea    -0xbd24(%ebx),%eax
c0023380:	50                   	push   %eax
c0023381:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023387:	50                   	push   %eax
c0023388:	8d 83 0c 27 ff ff    	lea    -0xd8f4(%ebx),%eax
c002338e:	50                   	push   %eax
c002338f:	68 c8 00 00 00       	push   $0xc8
c0023394:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c002339a:	50                   	push   %eax
c002339b:	e8 8d 5d 00 00       	call   c002912d <debug_panic>
        current_thread->lock_waiting = NULL;
c00233a0:	c7 86 04 01 00 00 00 	movl   $0x0,0x104(%esi)
c00233a7:	00 00 00 
        lock->max_priority = current_thread->priority;
c00233aa:	8b 46 24             	mov    0x24(%esi),%eax
c00233ad:	89 47 20             	mov    %eax,0x20(%edi)
        thread_hold_the_lock(lock);
c00233b0:	83 ec 0c             	sub    $0xc,%esp
c00233b3:	57                   	push   %edi
c00233b4:	e8 76 e7 ff ff       	call   c0021b2f <thread_hold_the_lock>
c00233b9:	83 c4 10             	add    $0x10,%esp
c00233bc:	e9 51 ff ff ff       	jmp    c0023312 <lock_acquire+0xb6>

c00233c1 <lock_try_acquire>:
lock_try_acquire(struct lock *lock) {
c00233c1:	57                   	push   %edi
c00233c2:	56                   	push   %esi
c00233c3:	53                   	push   %ebx
c00233c4:	e8 7a cd 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00233c9:	81 c3 e3 a8 01 00    	add    $0x1a8e3,%ebx
c00233cf:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (lock != NULL);
c00233d3:	85 f6                	test   %esi,%esi
c00233d5:	74 2b                	je     c0023402 <lock_try_acquire+0x41>
    ASSERT (!lock_held_by_current_thread(lock));
c00233d7:	83 ec 0c             	sub    $0xc,%esp
c00233da:	56                   	push   %esi
c00233db:	e8 29 fe ff ff       	call   c0023209 <lock_held_by_current_thread>
c00233e0:	83 c4 10             	add    $0x10,%esp
c00233e3:	84 c0                	test   %al,%al
c00233e5:	75 44                	jne    c002342b <lock_try_acquire+0x6a>
    success = sema_try_down(&lock->semaphore);
c00233e7:	83 ec 0c             	sub    $0xc,%esp
c00233ea:	8d 46 04             	lea    0x4(%esi),%eax
c00233ed:	50                   	push   %eax
c00233ee:	e8 03 fc ff ff       	call   c0022ff6 <sema_try_down>
c00233f3:	89 c7                	mov    %eax,%edi
    if (success)
c00233f5:	83 c4 10             	add    $0x10,%esp
c00233f8:	84 c0                	test   %al,%al
c00233fa:	75 58                	jne    c0023454 <lock_try_acquire+0x93>
}
c00233fc:	89 f8                	mov    %edi,%eax
c00233fe:	5b                   	pop    %ebx
c00233ff:	5e                   	pop    %esi
c0023400:	5f                   	pop    %edi
c0023401:	c3                   	ret    
    ASSERT (lock != NULL);
c0023402:	83 ec 0c             	sub    $0xc,%esp
c0023405:	8d 83 bf 42 ff ff    	lea    -0xbd41(%ebx),%eax
c002340b:	50                   	push   %eax
c002340c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023412:	50                   	push   %eax
c0023413:	8d 83 f8 26 ff ff    	lea    -0xd908(%ebx),%eax
c0023419:	50                   	push   %eax
c002341a:	68 ee 00 00 00       	push   $0xee
c002341f:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023425:	50                   	push   %eax
c0023426:	e8 02 5d 00 00       	call   c002912d <debug_panic>
    ASSERT (!lock_held_by_current_thread(lock));
c002342b:	83 ec 0c             	sub    $0xc,%esp
c002342e:	8d 83 dc 42 ff ff    	lea    -0xbd24(%ebx),%eax
c0023434:	50                   	push   %eax
c0023435:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002343b:	50                   	push   %eax
c002343c:	8d 83 f8 26 ff ff    	lea    -0xd908(%ebx),%eax
c0023442:	50                   	push   %eax
c0023443:	68 ef 00 00 00       	push   $0xef
c0023448:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c002344e:	50                   	push   %eax
c002344f:	e8 d9 5c 00 00       	call   c002912d <debug_panic>
        lock->holder = thread_current();
c0023454:	e8 70 db ff ff       	call   c0020fc9 <thread_current>
c0023459:	89 06                	mov    %eax,(%esi)
    return success;
c002345b:	eb 9f                	jmp    c00233fc <lock_try_acquire+0x3b>

c002345d <lock_release>:
lock_release(struct lock *lock) {
c002345d:	56                   	push   %esi
c002345e:	53                   	push   %ebx
c002345f:	83 ec 04             	sub    $0x4,%esp
c0023462:	e8 dc cc 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023467:	81 c3 45 a8 01 00    	add    $0x1a845,%ebx
c002346d:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (lock != NULL);
c0023471:	85 f6                	test   %esi,%esi
c0023473:	74 33                	je     c00234a8 <lock_release+0x4b>
    ASSERT (lock_held_by_current_thread(lock));
c0023475:	83 ec 0c             	sub    $0xc,%esp
c0023478:	56                   	push   %esi
c0023479:	e8 8b fd ff ff       	call   c0023209 <lock_held_by_current_thread>
c002347e:	83 c4 10             	add    $0x10,%esp
c0023481:	84 c0                	test   %al,%al
c0023483:	74 4c                	je     c00234d1 <lock_release+0x74>
    lock->holder = NULL;
c0023485:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    if (!thread_mlfqs)
c002348b:	c7 c0 cc fc 03 c0    	mov    $0xc003fccc,%eax
c0023491:	80 38 00             	cmpb   $0x0,(%eax)
c0023494:	74 64                	je     c00234fa <lock_release+0x9d>
    sema_up(&lock->semaphore);
c0023496:	83 ec 0c             	sub    $0xc,%esp
c0023499:	83 c6 04             	add    $0x4,%esi
c002349c:	56                   	push   %esi
c002349d:	e8 bc fb ff ff       	call   c002305e <sema_up>
}
c00234a2:	83 c4 14             	add    $0x14,%esp
c00234a5:	5b                   	pop    %ebx
c00234a6:	5e                   	pop    %esi
c00234a7:	c3                   	ret    
    ASSERT (lock != NULL);
c00234a8:	83 ec 0c             	sub    $0xc,%esp
c00234ab:	8d 83 bf 42 ff ff    	lea    -0xbd41(%ebx),%eax
c00234b1:	50                   	push   %eax
c00234b2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00234b8:	50                   	push   %eax
c00234b9:	8d 83 e8 26 ff ff    	lea    -0xd918(%ebx),%eax
c00234bf:	50                   	push   %eax
c00234c0:	68 fe 00 00 00       	push   $0xfe
c00234c5:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c00234cb:	50                   	push   %eax
c00234cc:	e8 5c 5c 00 00       	call   c002912d <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c00234d1:	83 ec 0c             	sub    $0xc,%esp
c00234d4:	8d 83 00 43 ff ff    	lea    -0xbd00(%ebx),%eax
c00234da:	50                   	push   %eax
c00234db:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00234e1:	50                   	push   %eax
c00234e2:	8d 83 e8 26 ff ff    	lea    -0xd918(%ebx),%eax
c00234e8:	50                   	push   %eax
c00234e9:	68 ff 00 00 00       	push   $0xff
c00234ee:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c00234f4:	50                   	push   %eax
c00234f5:	e8 33 5c 00 00       	call   c002912d <debug_panic>
        thread_remove_lock(lock);
c00234fa:	83 ec 0c             	sub    $0xc,%esp
c00234fd:	56                   	push   %esi
c00234fe:	e8 ea e5 ff ff       	call   c0021aed <thread_remove_lock>
c0023503:	83 c4 10             	add    $0x10,%esp
c0023506:	eb 8e                	jmp    c0023496 <lock_release+0x39>

c0023508 <cond_init>:
cond_init(struct condition *cond) {
c0023508:	53                   	push   %ebx
c0023509:	83 ec 08             	sub    $0x8,%esp
c002350c:	e8 32 cc 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023511:	81 c3 9b a7 01 00    	add    $0x1a79b,%ebx
c0023517:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (cond != NULL);
c002351b:	85 c0                	test   %eax,%eax
c002351d:	74 0e                	je     c002352d <cond_init+0x25>
    list_init(&cond->waiters);
c002351f:	83 ec 0c             	sub    $0xc,%esp
c0023522:	50                   	push   %eax
c0023523:	e8 d2 5c 00 00       	call   c00291fa <list_init>
}
c0023528:	83 c4 18             	add    $0x18,%esp
c002352b:	5b                   	pop    %ebx
c002352c:	c3                   	ret    
    ASSERT (cond != NULL);
c002352d:	83 ec 0c             	sub    $0xc,%esp
c0023530:	8d 83 cc 42 ff ff    	lea    -0xbd34(%ebx),%eax
c0023536:	50                   	push   %eax
c0023537:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002353d:	50                   	push   %eax
c002353e:	8d 83 c0 26 ff ff    	lea    -0xd940(%ebx),%eax
c0023544:	50                   	push   %eax
c0023545:	68 1d 01 00 00       	push   $0x11d
c002354a:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023550:	50                   	push   %eax
c0023551:	e8 d7 5b 00 00       	call   c002912d <debug_panic>

c0023556 <cond_wait>:
cond_wait(struct condition *cond, struct lock *lock) {
c0023556:	55                   	push   %ebp
c0023557:	57                   	push   %edi
c0023558:	56                   	push   %esi
c0023559:	53                   	push   %ebx
c002355a:	83 ec 2c             	sub    $0x2c,%esp
c002355d:	e8 ed cb 00 00       	call   c003014f <__x86.get_pc_thunk.di>
c0023562:	81 c7 4a a7 01 00    	add    $0x1a74a,%edi
c0023568:	8b 74 24 44          	mov    0x44(%esp),%esi
    ASSERT (cond != NULL);
c002356c:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c0023571:	74 6d                	je     c00235e0 <cond_wait+0x8a>
    ASSERT (lock != NULL);
c0023573:	85 f6                	test   %esi,%esi
c0023575:	0f 84 90 00 00 00    	je     c002360b <cond_wait+0xb5>
    ASSERT (!intr_context());
c002357b:	89 fb                	mov    %edi,%ebx
c002357d:	e8 86 ea ff ff       	call   c0022008 <intr_context>
c0023582:	84 c0                	test   %al,%al
c0023584:	0f 85 ac 00 00 00    	jne    c0023636 <cond_wait+0xe0>
    ASSERT (lock_held_by_current_thread(lock));
c002358a:	83 ec 0c             	sub    $0xc,%esp
c002358d:	56                   	push   %esi
c002358e:	e8 76 fc ff ff       	call   c0023209 <lock_held_by_current_thread>
c0023593:	83 c4 10             	add    $0x10,%esp
c0023596:	84 c0                	test   %al,%al
c0023598:	0f 84 c1 00 00 00    	je     c002365f <cond_wait+0x109>
    sema_init(&waiter.semaphore, 0);
c002359e:	83 ec 08             	sub    $0x8,%esp
c00235a1:	6a 00                	push   $0x0
c00235a3:	8d 5c 24 10          	lea    0x10(%esp),%ebx
c00235a7:	8d 6c 24 18          	lea    0x18(%esp),%ebp
c00235ab:	55                   	push   %ebp
c00235ac:	e8 2e f9 ff ff       	call   c0022edf <sema_init>
    list_push_back(&cond->waiters, &waiter.elem);
c00235b1:	83 c4 08             	add    $0x8,%esp
c00235b4:	53                   	push   %ebx
c00235b5:	ff 74 24 4c          	pushl  0x4c(%esp)
c00235b9:	89 fb                	mov    %edi,%ebx
c00235bb:	e8 1f 62 00 00       	call   c00297df <list_push_back>
    lock_release(lock);
c00235c0:	89 34 24             	mov    %esi,(%esp)
c00235c3:	e8 95 fe ff ff       	call   c002345d <lock_release>
    sema_down(&waiter.semaphore);
c00235c8:	89 2c 24             	mov    %ebp,(%esp)
c00235cb:	e8 63 f9 ff ff       	call   c0022f33 <sema_down>
    lock_acquire(lock);
c00235d0:	89 34 24             	mov    %esi,(%esp)
c00235d3:	e8 84 fc ff ff       	call   c002325c <lock_acquire>
}
c00235d8:	83 c4 3c             	add    $0x3c,%esp
c00235db:	5b                   	pop    %ebx
c00235dc:	5e                   	pop    %esi
c00235dd:	5f                   	pop    %edi
c00235de:	5d                   	pop    %ebp
c00235df:	c3                   	ret    
    ASSERT (cond != NULL);
c00235e0:	83 ec 0c             	sub    $0xc,%esp
c00235e3:	8d 87 cc 42 ff ff    	lea    -0xbd34(%edi),%eax
c00235e9:	50                   	push   %eax
c00235ea:	8d 87 de 36 ff ff    	lea    -0xc922(%edi),%eax
c00235f0:	50                   	push   %eax
c00235f1:	8d 87 b4 26 ff ff    	lea    -0xd94c(%edi),%eax
c00235f7:	50                   	push   %eax
c00235f8:	68 3a 01 00 00       	push   $0x13a
c00235fd:	8d 87 83 42 ff ff    	lea    -0xbd7d(%edi),%eax
c0023603:	50                   	push   %eax
c0023604:	89 fb                	mov    %edi,%ebx
c0023606:	e8 22 5b 00 00       	call   c002912d <debug_panic>
    ASSERT (lock != NULL);
c002360b:	83 ec 0c             	sub    $0xc,%esp
c002360e:	8d 87 bf 42 ff ff    	lea    -0xbd41(%edi),%eax
c0023614:	50                   	push   %eax
c0023615:	8d 87 de 36 ff ff    	lea    -0xc922(%edi),%eax
c002361b:	50                   	push   %eax
c002361c:	8d 87 b4 26 ff ff    	lea    -0xd94c(%edi),%eax
c0023622:	50                   	push   %eax
c0023623:	68 3b 01 00 00       	push   $0x13b
c0023628:	8d 87 83 42 ff ff    	lea    -0xbd7d(%edi),%eax
c002362e:	50                   	push   %eax
c002362f:	89 fb                	mov    %edi,%ebx
c0023631:	e8 f7 5a 00 00       	call   c002912d <debug_panic>
    ASSERT (!intr_context());
c0023636:	83 ec 0c             	sub    $0xc,%esp
c0023639:	8d 87 a9 3e ff ff    	lea    -0xc157(%edi),%eax
c002363f:	50                   	push   %eax
c0023640:	8d 87 de 36 ff ff    	lea    -0xc922(%edi),%eax
c0023646:	50                   	push   %eax
c0023647:	8d 87 b4 26 ff ff    	lea    -0xd94c(%edi),%eax
c002364d:	50                   	push   %eax
c002364e:	68 3c 01 00 00       	push   $0x13c
c0023653:	8d 87 83 42 ff ff    	lea    -0xbd7d(%edi),%eax
c0023659:	50                   	push   %eax
c002365a:	e8 ce 5a 00 00       	call   c002912d <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c002365f:	83 ec 0c             	sub    $0xc,%esp
c0023662:	8d 87 00 43 ff ff    	lea    -0xbd00(%edi),%eax
c0023668:	50                   	push   %eax
c0023669:	8d 87 de 36 ff ff    	lea    -0xc922(%edi),%eax
c002366f:	50                   	push   %eax
c0023670:	8d 87 b4 26 ff ff    	lea    -0xd94c(%edi),%eax
c0023676:	50                   	push   %eax
c0023677:	68 3d 01 00 00       	push   $0x13d
c002367c:	8d 87 83 42 ff ff    	lea    -0xbd7d(%edi),%eax
c0023682:	50                   	push   %eax
c0023683:	e8 a5 5a 00 00       	call   c002912d <debug_panic>

c0023688 <cond_signal>:

   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal(struct condition *cond, struct lock *lock UNUSED) {
c0023688:	57                   	push   %edi
c0023689:	56                   	push   %esi
c002368a:	53                   	push   %ebx
c002368b:	e8 b3 ca 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023690:	81 c3 1c a6 01 00    	add    $0x1a61c,%ebx
c0023696:	8b 74 24 10          	mov    0x10(%esp),%esi
c002369a:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (cond != NULL);
c002369e:	85 f6                	test   %esi,%esi
c00236a0:	74 4e                	je     c00236f0 <cond_signal+0x68>
    ASSERT (lock != NULL);
c00236a2:	85 ff                	test   %edi,%edi
c00236a4:	74 73                	je     c0023719 <cond_signal+0x91>
    ASSERT (!intr_context());
c00236a6:	e8 5d e9 ff ff       	call   c0022008 <intr_context>
c00236ab:	84 c0                	test   %al,%al
c00236ad:	0f 85 8f 00 00 00    	jne    c0023742 <cond_signal+0xba>
    ASSERT (lock_held_by_current_thread(lock));
c00236b3:	83 ec 0c             	sub    $0xc,%esp
c00236b6:	57                   	push   %edi
c00236b7:	e8 4d fb ff ff       	call   c0023209 <lock_held_by_current_thread>
c00236bc:	83 c4 10             	add    $0x10,%esp
c00236bf:	84 c0                	test   %al,%al
c00236c1:	0f 84 a4 00 00 00    	je     c002376b <cond_signal+0xe3>
    list_sort(&cond->waiters, sema_cmp_priority, NULL);
c00236c7:	83 ec 04             	sub    $0x4,%esp
c00236ca:	6a 00                	push   $0x0
c00236cc:	8d 83 f2 51 fe ff    	lea    -0x1ae0e(%ebx),%eax
c00236d2:	50                   	push   %eax
c00236d3:	56                   	push   %esi
c00236d4:	e8 2b 63 00 00       	call   c0029a04 <list_sort>
    // put the one with least sema value at front
    if (!list_empty(&cond->waiters))
c00236d9:	89 34 24             	mov    %esi,(%esp)
c00236dc:	e8 bd 61 00 00       	call   c002989e <list_empty>
c00236e1:	83 c4 10             	add    $0x10,%esp
c00236e4:	84 c0                	test   %al,%al
c00236e6:	0f 84 a8 00 00 00    	je     c0023794 <cond_signal+0x10c>
        sema_up(&list_entry (list_pop_front(&cond->waiters),
                             struct semaphore_elem, elem)->semaphore);
}
c00236ec:	5b                   	pop    %ebx
c00236ed:	5e                   	pop    %esi
c00236ee:	5f                   	pop    %edi
c00236ef:	c3                   	ret    
    ASSERT (cond != NULL);
c00236f0:	83 ec 0c             	sub    $0xc,%esp
c00236f3:	8d 83 cc 42 ff ff    	lea    -0xbd34(%ebx),%eax
c00236f9:	50                   	push   %eax
c00236fa:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023700:	50                   	push   %eax
c0023701:	8d 83 a8 26 ff ff    	lea    -0xd958(%ebx),%eax
c0023707:	50                   	push   %eax
c0023708:	68 59 01 00 00       	push   $0x159
c002370d:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023713:	50                   	push   %eax
c0023714:	e8 14 5a 00 00       	call   c002912d <debug_panic>
    ASSERT (lock != NULL);
c0023719:	83 ec 0c             	sub    $0xc,%esp
c002371c:	8d 83 bf 42 ff ff    	lea    -0xbd41(%ebx),%eax
c0023722:	50                   	push   %eax
c0023723:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023729:	50                   	push   %eax
c002372a:	8d 83 a8 26 ff ff    	lea    -0xd958(%ebx),%eax
c0023730:	50                   	push   %eax
c0023731:	68 5a 01 00 00       	push   $0x15a
c0023736:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c002373c:	50                   	push   %eax
c002373d:	e8 eb 59 00 00       	call   c002912d <debug_panic>
    ASSERT (!intr_context());
c0023742:	83 ec 0c             	sub    $0xc,%esp
c0023745:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c002374b:	50                   	push   %eax
c002374c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023752:	50                   	push   %eax
c0023753:	8d 83 a8 26 ff ff    	lea    -0xd958(%ebx),%eax
c0023759:	50                   	push   %eax
c002375a:	68 5b 01 00 00       	push   $0x15b
c002375f:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023765:	50                   	push   %eax
c0023766:	e8 c2 59 00 00       	call   c002912d <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c002376b:	83 ec 0c             	sub    $0xc,%esp
c002376e:	8d 83 00 43 ff ff    	lea    -0xbd00(%ebx),%eax
c0023774:	50                   	push   %eax
c0023775:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002377b:	50                   	push   %eax
c002377c:	8d 83 a8 26 ff ff    	lea    -0xd958(%ebx),%eax
c0023782:	50                   	push   %eax
c0023783:	68 5c 01 00 00       	push   $0x15c
c0023788:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c002378e:	50                   	push   %eax
c002378f:	e8 99 59 00 00       	call   c002912d <debug_panic>
        sema_up(&list_entry (list_pop_front(&cond->waiters),
c0023794:	83 ec 0c             	sub    $0xc,%esp
c0023797:	56                   	push   %esi
c0023798:	e8 78 61 00 00       	call   c0029915 <list_pop_front>
c002379d:	83 c0 08             	add    $0x8,%eax
c00237a0:	89 04 24             	mov    %eax,(%esp)
c00237a3:	e8 b6 f8 ff ff       	call   c002305e <sema_up>
c00237a8:	83 c4 10             	add    $0x10,%esp
}
c00237ab:	e9 3c ff ff ff       	jmp    c00236ec <cond_signal+0x64>

c00237b0 <cond_broadcast>:

   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast(struct condition *cond, struct lock *lock) {
c00237b0:	57                   	push   %edi
c00237b1:	56                   	push   %esi
c00237b2:	53                   	push   %ebx
c00237b3:	e8 8b c9 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00237b8:	81 c3 f4 a4 01 00    	add    $0x1a4f4,%ebx
c00237be:	8b 74 24 10          	mov    0x10(%esp),%esi
c00237c2:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (cond != NULL);
c00237c6:	85 f6                	test   %esi,%esi
c00237c8:	74 23                	je     c00237ed <cond_broadcast+0x3d>
    ASSERT (lock != NULL);
c00237ca:	85 ff                	test   %edi,%edi
c00237cc:	74 48                	je     c0023816 <cond_broadcast+0x66>

    while (!list_empty(&cond->waiters))
c00237ce:	83 ec 0c             	sub    $0xc,%esp
c00237d1:	56                   	push   %esi
c00237d2:	e8 c7 60 00 00       	call   c002989e <list_empty>
c00237d7:	83 c4 10             	add    $0x10,%esp
c00237da:	84 c0                	test   %al,%al
c00237dc:	75 61                	jne    c002383f <cond_broadcast+0x8f>
        cond_signal(cond, lock);
c00237de:	83 ec 08             	sub    $0x8,%esp
c00237e1:	57                   	push   %edi
c00237e2:	56                   	push   %esi
c00237e3:	e8 a0 fe ff ff       	call   c0023688 <cond_signal>
c00237e8:	83 c4 10             	add    $0x10,%esp
c00237eb:	eb e1                	jmp    c00237ce <cond_broadcast+0x1e>
    ASSERT (cond != NULL);
c00237ed:	83 ec 0c             	sub    $0xc,%esp
c00237f0:	8d 83 cc 42 ff ff    	lea    -0xbd34(%ebx),%eax
c00237f6:	50                   	push   %eax
c00237f7:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00237fd:	50                   	push   %eax
c00237fe:	8d 83 98 26 ff ff    	lea    -0xd968(%ebx),%eax
c0023804:	50                   	push   %eax
c0023805:	68 6c 01 00 00       	push   $0x16c
c002380a:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023810:	50                   	push   %eax
c0023811:	e8 17 59 00 00       	call   c002912d <debug_panic>
    ASSERT (lock != NULL);
c0023816:	83 ec 0c             	sub    $0xc,%esp
c0023819:	8d 83 bf 42 ff ff    	lea    -0xbd41(%ebx),%eax
c002381f:	50                   	push   %eax
c0023820:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023826:	50                   	push   %eax
c0023827:	8d 83 98 26 ff ff    	lea    -0xd968(%ebx),%eax
c002382d:	50                   	push   %eax
c002382e:	68 6d 01 00 00       	push   $0x16d
c0023833:	8d 83 83 42 ff ff    	lea    -0xbd7d(%ebx),%eax
c0023839:	50                   	push   %eax
c002383a:	e8 ee 58 00 00       	call   c002912d <debug_panic>
}
c002383f:	5b                   	pop    %ebx
c0023840:	5e                   	pop    %esi
c0023841:	5f                   	pop    %edi
c0023842:	c3                   	ret    

c0023843 <init_pool>:
}

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool(struct pool *p, void *base, size_t page_cnt, const char *name) {
c0023843:	55                   	push   %ebp
c0023844:	57                   	push   %edi
c0023845:	56                   	push   %esi
c0023846:	53                   	push   %ebx
c0023847:	83 ec 28             	sub    $0x28,%esp
c002384a:	e8 f4 c8 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002384f:	81 c3 5d a4 01 00    	add    $0x1a45d,%ebx
c0023855:	89 c5                	mov    %eax,%ebp
c0023857:	89 54 24 18          	mov    %edx,0x18(%esp)
c002385b:	89 cf                	mov    %ecx,%edi
    /* We'll put the pool's used_map at its base.
       Calculate the space needed for the bitmap
       and subtract it from the pool's size. */
    size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size(page_cnt), PGSIZE); // page_id = size / pgsize
c002385d:	51                   	push   %ecx
c002385e:	e8 72 67 00 00       	call   c0029fd5 <bitmap_buf_size>
c0023863:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
c0023869:	89 f0                	mov    %esi,%eax
c002386b:	c1 e8 0c             	shr    $0xc,%eax
    if (bm_pages > page_cnt)
c002386e:	83 c4 10             	add    $0x10,%esp
c0023871:	39 c7                	cmp    %eax,%edi
c0023873:	72 44                	jb     c00238b9 <init_pool+0x76>
        PANIC ("Not enough memory in %s for bitmap.", name);
    page_cnt -= bm_pages;
c0023875:	29 c7                	sub    %eax,%edi

    printf("%zu pages available in %s.\n", page_cnt, name);
c0023877:	83 ec 04             	sub    $0x4,%esp
c002387a:	ff 74 24 34          	pushl  0x34(%esp)
c002387e:	57                   	push   %edi
c002387f:	8d 83 8e 43 ff ff    	lea    -0xbc72(%ebx),%eax
c0023885:	50                   	push   %eax
c0023886:	e8 46 3c 00 00       	call   c00274d1 <printf>

    /* Initialize the pool. */
    lock_init(&p->lock);
c002388b:	89 2c 24             	mov    %ebp,(%esp)
c002388e:	e8 1d f9 ff ff       	call   c00231b0 <lock_init>
    p->used_map = bitmap_create_in_buf(page_cnt, base, bm_pages * PGSIZE);
c0023893:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c0023899:	83 c4 0c             	add    $0xc,%esp
c002389c:	56                   	push   %esi
c002389d:	ff 74 24 14          	pushl  0x14(%esp)
c00238a1:	57                   	push   %edi
c00238a2:	e8 97 6a 00 00       	call   c002a33e <bitmap_create_in_buf>
c00238a7:	89 45 24             	mov    %eax,0x24(%ebp)
    p->base = base + bm_pages * PGSIZE;
c00238aa:	03 74 24 1c          	add    0x1c(%esp),%esi
c00238ae:	89 75 28             	mov    %esi,0x28(%ebp)
}
c00238b1:	83 c4 2c             	add    $0x2c,%esp
c00238b4:	5b                   	pop    %ebx
c00238b5:	5e                   	pop    %esi
c00238b6:	5f                   	pop    %edi
c00238b7:	5d                   	pop    %ebp
c00238b8:	c3                   	ret    
        PANIC ("Not enough memory in %s for bitmap.", name);
c00238b9:	83 ec 0c             	sub    $0xc,%esp
c00238bc:	ff 74 24 3c          	pushl  0x3c(%esp)
c00238c0:	8d 83 24 43 ff ff    	lea    -0xbcdc(%ebx),%eax
c00238c6:	50                   	push   %eax
c00238c7:	8d 83 84 27 ff ff    	lea    -0xd87c(%ebx),%eax
c00238cd:	50                   	push   %eax
c00238ce:	68 98 00 00 00       	push   $0x98
c00238d3:	8d 83 77 43 ff ff    	lea    -0xbc89(%ebx),%eax
c00238d9:	50                   	push   %eax
c00238da:	e8 4e 58 00 00       	call   c002912d <debug_panic>

c00238df <palloc_init>:
palloc_init(size_t user_page_limit) {
c00238df:	57                   	push   %edi
c00238e0:	56                   	push   %esi
c00238e1:	53                   	push   %ebx
c00238e2:	e8 5c c8 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00238e7:	81 c3 c5 a3 01 00    	add    $0x1a3c5,%ebx
c00238ed:	8b 54 24 10          	mov    0x10(%esp),%edx
    uint8_t *free_end = ptov(init_ram_pages * PGSIZE); // num * 4KB
c00238f1:	c7 c0 be 01 02 c0    	mov    $0xc00201be,%eax
c00238f7:	8b 00                	mov    (%eax),%eax
c00238f9:	c1 e0 0c             	shl    $0xc,%eax
    ASSERT ((void *) paddr < PHYS_BASE);
c00238fc:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0023901:	77 5e                	ja     c0023961 <palloc_init+0x82>
    size_t free_pages = (free_end - free_start) / PGSIZE;
c0023903:	8d b0 ff 0f f0 ff    	lea    -0xff001(%eax),%esi
c0023909:	2d 00 00 10 00       	sub    $0x100000,%eax
c002390e:	0f 49 f0             	cmovns %eax,%esi
c0023911:	c1 fe 0c             	sar    $0xc,%esi
    size_t user_pages = free_pages / 2;
c0023914:	89 f7                	mov    %esi,%edi
c0023916:	d1 ef                	shr    %edi
    if (user_pages > user_page_limit)
c0023918:	39 d7                	cmp    %edx,%edi
c002391a:	0f 47 fa             	cmova  %edx,%edi
    kernel_pages = free_pages - user_pages;
c002391d:	29 fe                	sub    %edi,%esi
    init_pool(&kernel_pool, free_start, kernel_pages, "kernel pool");
c002391f:	83 ec 0c             	sub    $0xc,%esp
c0023922:	8d 83 c5 43 ff ff    	lea    -0xbc3b(%ebx),%eax
c0023928:	50                   	push   %eax
c0023929:	89 f1                	mov    %esi,%ecx
c002392b:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c0023930:	8d 83 14 16 00 00    	lea    0x1614(%ebx),%eax
c0023936:	e8 08 ff ff ff       	call   c0023843 <init_pool>
    init_pool(&user_pool, free_start + kernel_pages * PGSIZE,
c002393b:	c1 e6 0c             	shl    $0xc,%esi
c002393e:	8d 96 00 00 10 c0    	lea    -0x3ff00000(%esi),%edx
c0023944:	8d 83 d1 43 ff ff    	lea    -0xbc2f(%ebx),%eax
c002394a:	89 04 24             	mov    %eax,(%esp)
c002394d:	89 f9                	mov    %edi,%ecx
c002394f:	8d 83 d4 15 00 00    	lea    0x15d4(%ebx),%eax
c0023955:	e8 e9 fe ff ff       	call   c0023843 <init_pool>
}
c002395a:	83 c4 10             	add    $0x10,%esp
c002395d:	5b                   	pop    %ebx
c002395e:	5e                   	pop    %esi
c002395f:	5f                   	pop    %edi
c0023960:	c3                   	ret    
c0023961:	83 ec 0c             	sub    $0xc,%esp
c0023964:	8d 83 aa 43 ff ff    	lea    -0xbc56(%ebx),%eax
c002396a:	50                   	push   %eax
c002396b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023971:	50                   	push   %eax
c0023972:	8d 83 90 27 ff ff    	lea    -0xd870(%ebx),%eax
c0023978:	50                   	push   %eax
c0023979:	6a 4c                	push   $0x4c
c002397b:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c0023981:	50                   	push   %eax
c0023982:	e8 a6 57 00 00       	call   c002912d <debug_panic>

c0023987 <palloc_get_multiple>:
palloc_get_multiple(enum palloc_flags flags, size_t page_cnt) {
c0023987:	55                   	push   %ebp
c0023988:	57                   	push   %edi
c0023989:	56                   	push   %esi
c002398a:	53                   	push   %ebx
c002398b:	83 ec 0c             	sub    $0xc,%esp
c002398e:	e8 b0 c7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023993:	81 c3 19 a3 01 00    	add    $0x1a319,%ebx
c0023999:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002399d:	8b 44 24 20          	mov    0x20(%esp),%eax
c00239a1:	83 e0 04             	and    $0x4,%eax
c00239a4:	8d b3 d4 15 00 00    	lea    0x15d4(%ebx),%esi
c00239aa:	8d 83 14 16 00 00    	lea    0x1614(%ebx),%eax
c00239b0:	0f 44 f0             	cmove  %eax,%esi
    if (page_cnt == 0)
c00239b3:	85 ed                	test   %ebp,%ebp
c00239b5:	74 7e                	je     c0023a35 <palloc_get_multiple+0xae>
    lock_acquire(&pool->lock);
c00239b7:	83 ec 0c             	sub    $0xc,%esp
c00239ba:	56                   	push   %esi
c00239bb:	e8 9c f8 ff ff       	call   c002325c <lock_acquire>
    page_idx = bitmap_scan_and_flip(pool->used_map, 0, page_cnt, false);
c00239c0:	6a 00                	push   $0x0
c00239c2:	55                   	push   %ebp
c00239c3:	6a 00                	push   $0x0
c00239c5:	ff 76 24             	pushl  0x24(%esi)
c00239c8:	e8 de 6c 00 00       	call   c002a6ab <bitmap_scan_and_flip>
c00239cd:	89 c7                	mov    %eax,%edi
    lock_release(&pool->lock);
c00239cf:	83 c4 14             	add    $0x14,%esp
c00239d2:	56                   	push   %esi
c00239d3:	e8 85 fa ff ff       	call   c002345d <lock_release>
    if (page_idx != BITMAP_ERROR)
c00239d8:	83 c4 10             	add    $0x10,%esp
c00239db:	83 ff ff             	cmp    $0xffffffff,%edi
c00239de:	74 23                	je     c0023a03 <palloc_get_multiple+0x7c>
        pages = pool->base + PGSIZE * page_idx;
c00239e0:	c1 e7 0c             	shl    $0xc,%edi
    if (pages != NULL) {
c00239e3:	03 7e 28             	add    0x28(%esi),%edi
c00239e6:	74 1b                	je     c0023a03 <palloc_get_multiple+0x7c>
        if (flags & PAL_ZERO)
c00239e8:	f6 44 24 20 02       	testb  $0x2,0x20(%esp)
c00239ed:	74 20                	je     c0023a0f <palloc_get_multiple+0x88>
            memset(pages, 0, PGSIZE * page_cnt);
c00239ef:	c1 e5 0c             	shl    $0xc,%ebp
c00239f2:	83 ec 04             	sub    $0x4,%esp
c00239f5:	55                   	push   %ebp
c00239f6:	6a 00                	push   $0x0
c00239f8:	57                   	push   %edi
c00239f9:	e8 9e 4c 00 00       	call   c002869c <memset>
c00239fe:	83 c4 10             	add    $0x10,%esp
c0023a01:	eb 0c                	jmp    c0023a0f <palloc_get_multiple+0x88>
        if (flags & PAL_ASSERT)
c0023a03:	f6 44 24 20 01       	testb  $0x1,0x20(%esp)
c0023a08:	75 0f                	jne    c0023a19 <palloc_get_multiple+0x92>
c0023a0a:	bf 00 00 00 00       	mov    $0x0,%edi
}
c0023a0f:	89 f8                	mov    %edi,%eax
c0023a11:	83 c4 0c             	add    $0xc,%esp
c0023a14:	5b                   	pop    %ebx
c0023a15:	5e                   	pop    %esi
c0023a16:	5f                   	pop    %edi
c0023a17:	5d                   	pop    %ebp
c0023a18:	c3                   	ret    
            PANIC ("palloc_get: out of pages");
c0023a19:	8d 83 db 43 ff ff    	lea    -0xbc25(%ebx),%eax
c0023a1f:	50                   	push   %eax
c0023a20:	8d 83 70 27 ff ff    	lea    -0xd890(%ebx),%eax
c0023a26:	50                   	push   %eax
c0023a27:	6a 5c                	push   $0x5c
c0023a29:	8d 83 77 43 ff ff    	lea    -0xbc89(%ebx),%eax
c0023a2f:	50                   	push   %eax
c0023a30:	e8 f8 56 00 00       	call   c002912d <debug_panic>
        return NULL;
c0023a35:	bf 00 00 00 00       	mov    $0x0,%edi
c0023a3a:	eb d3                	jmp    c0023a0f <palloc_get_multiple+0x88>

c0023a3c <palloc_get_page>:
palloc_get_page(enum palloc_flags flags) {
c0023a3c:	83 ec 14             	sub    $0x14,%esp
    return palloc_get_multiple(flags, 1);
c0023a3f:	6a 01                	push   $0x1
c0023a41:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023a45:	e8 3d ff ff ff       	call   c0023987 <palloc_get_multiple>
}
c0023a4a:	83 c4 1c             	add    $0x1c,%esp
c0023a4d:	c3                   	ret    

c0023a4e <palloc_free_multiple>:
palloc_free_multiple(void *pages, size_t page_cnt) {
c0023a4e:	55                   	push   %ebp
c0023a4f:	57                   	push   %edi
c0023a50:	56                   	push   %esi
c0023a51:	53                   	push   %ebx
c0023a52:	83 ec 0c             	sub    $0xc,%esp
c0023a55:	e8 e9 c6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023a5a:	81 c3 52 a2 01 00    	add    $0x1a252,%ebx
c0023a60:	8b 74 24 20          	mov    0x20(%esp),%esi
    ASSERT (pg_ofs(pages) == 0);
c0023a64:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c0023a6a:	0f 85 9d 00 00 00    	jne    c0023b0d <palloc_free_multiple+0xbf>
    if (pages == NULL || page_cnt == 0)
c0023a70:	85 f6                	test   %esi,%esi
c0023a72:	0f 84 8d 00 00 00    	je     c0023b05 <palloc_free_multiple+0xb7>
c0023a78:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0023a7d:	0f 84 82 00 00 00    	je     c0023b05 <palloc_free_multiple+0xb7>
    return (uintptr_t) va >> PGBITS;
c0023a83:	89 f7                	mov    %esi,%edi
c0023a85:	c1 ef 0c             	shr    $0xc,%edi
c0023a88:	8b 83 3c 16 00 00    	mov    0x163c(%ebx),%eax
c0023a8e:	c1 e8 0c             	shr    $0xc,%eax
c0023a91:	89 c5                	mov    %eax,%ebp
   false otherwise. */
static bool
page_from_pool(const struct pool *pool, void *page) {
    size_t page_no = pg_no(page);
    size_t start_page = pg_no(pool->base);
    size_t end_page = start_page + bitmap_size(pool->used_map);
c0023a93:	83 ec 0c             	sub    $0xc,%esp
c0023a96:	ff b3 38 16 00 00    	pushl  0x1638(%ebx)
c0023a9c:	e8 7a 65 00 00       	call   c002a01b <bitmap_size>
c0023aa1:	89 ea                	mov    %ebp,%edx
c0023aa3:	01 e8                	add    %ebp,%eax

    return page_no >= start_page && page_no < end_page;
c0023aa5:	83 c4 10             	add    $0x10,%esp
    if (page_from_pool(&kernel_pool, pages))
c0023aa8:	39 c7                	cmp    %eax,%edi
c0023aaa:	0f 83 83 00 00 00    	jae    c0023b33 <palloc_free_multiple+0xe5>
        pool = &kernel_pool;
c0023ab0:	8d ab 14 16 00 00    	lea    0x1614(%ebx),%ebp
    if (page_from_pool(&kernel_pool, pages))
c0023ab6:	39 d7                	cmp    %edx,%edi
c0023ab8:	72 79                	jb     c0023b33 <palloc_free_multiple+0xe5>
c0023aba:	8b 45 28             	mov    0x28(%ebp),%eax
c0023abd:	c1 e8 0c             	shr    $0xc,%eax
    page_idx = pg_no(pages) - pg_no(pool->base);
c0023ac0:	29 c7                	sub    %eax,%edi
    memset(pages, 0xcc, PGSIZE * page_cnt);
c0023ac2:	83 ec 04             	sub    $0x4,%esp
c0023ac5:	8b 44 24 28          	mov    0x28(%esp),%eax
c0023ac9:	c1 e0 0c             	shl    $0xc,%eax
c0023acc:	50                   	push   %eax
c0023acd:	68 cc 00 00 00       	push   $0xcc
c0023ad2:	56                   	push   %esi
c0023ad3:	e8 c4 4b 00 00       	call   c002869c <memset>
    ASSERT (bitmap_all(pool->used_map, page_idx, page_cnt));
c0023ad8:	83 c4 0c             	add    $0xc,%esp
c0023adb:	ff 74 24 28          	pushl  0x28(%esp)
c0023adf:	57                   	push   %edi
c0023ae0:	ff 75 24             	pushl  0x24(%ebp)
c0023ae3:	e8 d6 6a 00 00       	call   c002a5be <bitmap_all>
c0023ae8:	83 c4 10             	add    $0x10,%esp
c0023aeb:	84 c0                	test   %al,%al
c0023aed:	0f 84 8b 00 00 00    	je     c0023b7e <palloc_free_multiple+0x130>
    bitmap_set_multiple(pool->used_map, page_idx, page_cnt, false);
c0023af3:	6a 00                	push   $0x0
c0023af5:	ff 74 24 28          	pushl  0x28(%esp)
c0023af9:	57                   	push   %edi
c0023afa:	ff 75 24             	pushl  0x24(%ebp)
c0023afd:	e8 9e 66 00 00       	call   c002a1a0 <bitmap_set_multiple>
c0023b02:	83 c4 10             	add    $0x10,%esp
}
c0023b05:	83 c4 0c             	add    $0xc,%esp
c0023b08:	5b                   	pop    %ebx
c0023b09:	5e                   	pop    %esi
c0023b0a:	5f                   	pop    %edi
c0023b0b:	5d                   	pop    %ebp
c0023b0c:	c3                   	ret    
    ASSERT (pg_ofs(pages) == 0);
c0023b0d:	83 ec 0c             	sub    $0xc,%esp
c0023b10:	8d 83 f4 43 ff ff    	lea    -0xbc0c(%ebx),%eax
c0023b16:	50                   	push   %eax
c0023b17:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023b1d:	50                   	push   %eax
c0023b1e:	8d 83 58 27 ff ff    	lea    -0xd8a8(%ebx),%eax
c0023b24:	50                   	push   %eax
c0023b25:	6a 74                	push   $0x74
c0023b27:	8d 83 77 43 ff ff    	lea    -0xbc89(%ebx),%eax
c0023b2d:	50                   	push   %eax
c0023b2e:	e8 fa 55 00 00       	call   c002912d <debug_panic>
c0023b33:	8b ab fc 15 00 00    	mov    0x15fc(%ebx),%ebp
c0023b39:	c1 ed 0c             	shr    $0xc,%ebp
    size_t end_page = start_page + bitmap_size(pool->used_map);
c0023b3c:	83 ec 0c             	sub    $0xc,%esp
c0023b3f:	ff b3 f8 15 00 00    	pushl  0x15f8(%ebx)
c0023b45:	e8 d1 64 00 00       	call   c002a01b <bitmap_size>
c0023b4a:	01 e8                	add    %ebp,%eax
    return page_no >= start_page && page_no < end_page;
c0023b4c:	83 c4 10             	add    $0x10,%esp
    else if (page_from_pool(&user_pool, pages))
c0023b4f:	39 c7                	cmp    %eax,%edi
c0023b51:	73 0f                	jae    c0023b62 <palloc_free_multiple+0x114>
c0023b53:	39 ef                	cmp    %ebp,%edi
c0023b55:	72 0b                	jb     c0023b62 <palloc_free_multiple+0x114>
        pool = &user_pool;
c0023b57:	8d ab d4 15 00 00    	lea    0x15d4(%ebx),%ebp
c0023b5d:	e9 58 ff ff ff       	jmp    c0023aba <palloc_free_multiple+0x6c>
        NOT_REACHED ();
c0023b62:	8d 83 54 3d ff ff    	lea    -0xc2ac(%ebx),%eax
c0023b68:	50                   	push   %eax
c0023b69:	8d 83 58 27 ff ff    	lea    -0xd8a8(%ebx),%eax
c0023b6f:	50                   	push   %eax
c0023b70:	6a 7d                	push   $0x7d
c0023b72:	8d 83 77 43 ff ff    	lea    -0xbc89(%ebx),%eax
c0023b78:	50                   	push   %eax
c0023b79:	e8 af 55 00 00       	call   c002912d <debug_panic>
    ASSERT (bitmap_all(pool->used_map, page_idx, page_cnt));
c0023b7e:	83 ec 0c             	sub    $0xc,%esp
c0023b81:	8d 83 48 43 ff ff    	lea    -0xbcb8(%ebx),%eax
c0023b87:	50                   	push   %eax
c0023b88:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023b8e:	50                   	push   %eax
c0023b8f:	8d 83 58 27 ff ff    	lea    -0xd8a8(%ebx),%eax
c0023b95:	50                   	push   %eax
c0023b96:	68 85 00 00 00       	push   $0x85
c0023b9b:	8d 83 77 43 ff ff    	lea    -0xbc89(%ebx),%eax
c0023ba1:	50                   	push   %eax
c0023ba2:	e8 86 55 00 00       	call   c002912d <debug_panic>

c0023ba7 <palloc_free_page>:
palloc_free_page(void *page) {
c0023ba7:	83 ec 14             	sub    $0x14,%esp
    palloc_free_multiple(page, 1);
c0023baa:	6a 01                	push   $0x1
c0023bac:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023bb0:	e8 99 fe ff ff       	call   c0023a4e <palloc_free_multiple>
}
c0023bb5:	83 c4 1c             	add    $0x1c,%esp
c0023bb8:	c3                   	ret    

c0023bb9 <arena_to_block>:
    return a;
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block(struct arena *a, size_t idx) {
c0023bb9:	53                   	push   %ebx
c0023bba:	83 ec 08             	sub    $0x8,%esp
c0023bbd:	e8 81 c5 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023bc2:	81 c3 ea a0 01 00    	add    $0x1a0ea,%ebx
    ASSERT (a != NULL);
c0023bc8:	85 c0                	test   %eax,%eax
c0023bca:	74 1c                	je     c0023be8 <arena_to_block+0x2f>
    ASSERT (a->magic == ARENA_MAGIC);
c0023bcc:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c0023bd2:	75 3d                	jne    c0023c11 <arena_to_block+0x58>
    ASSERT (idx < a->desc->blocks_per_arena);
c0023bd4:	8b 48 04             	mov    0x4(%eax),%ecx
c0023bd7:	39 51 04             	cmp    %edx,0x4(%ecx)
c0023bda:	76 5e                	jbe    c0023c3a <arena_to_block+0x81>
    return (struct block *) ((uint8_t *) a
                             + sizeof *a
                             + idx * a->desc->block_size);
c0023bdc:	0f af 11             	imul   (%ecx),%edx
    return (struct block *) ((uint8_t *) a
c0023bdf:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c0023be3:	83 c4 08             	add    $0x8,%esp
c0023be6:	5b                   	pop    %ebx
c0023be7:	c3                   	ret    
    ASSERT (a != NULL);
c0023be8:	83 ec 0c             	sub    $0xc,%esp
c0023beb:	8d 83 79 42 ff ff    	lea    -0xbd87(%ebx),%eax
c0023bf1:	50                   	push   %eax
c0023bf2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023bf8:	50                   	push   %eax
c0023bf9:	8d 83 b0 27 ff ff    	lea    -0xd850(%ebx),%eax
c0023bff:	50                   	push   %eax
c0023c00:	68 07 01 00 00       	push   $0x107
c0023c05:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023c0b:	50                   	push   %eax
c0023c0c:	e8 1c 55 00 00       	call   c002912d <debug_panic>
    ASSERT (a->magic == ARENA_MAGIC);
c0023c11:	83 ec 0c             	sub    $0xc,%esp
c0023c14:	8d 83 1e 44 ff ff    	lea    -0xbbe2(%ebx),%eax
c0023c1a:	50                   	push   %eax
c0023c1b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023c21:	50                   	push   %eax
c0023c22:	8d 83 b0 27 ff ff    	lea    -0xd850(%ebx),%eax
c0023c28:	50                   	push   %eax
c0023c29:	68 08 01 00 00       	push   $0x108
c0023c2e:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023c34:	50                   	push   %eax
c0023c35:	e8 f3 54 00 00       	call   c002912d <debug_panic>
    ASSERT (idx < a->desc->blocks_per_arena);
c0023c3a:	83 ec 0c             	sub    $0xc,%esp
c0023c3d:	8d 83 38 44 ff ff    	lea    -0xbbc8(%ebx),%eax
c0023c43:	50                   	push   %eax
c0023c44:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023c4a:	50                   	push   %eax
c0023c4b:	8d 83 b0 27 ff ff    	lea    -0xd850(%ebx),%eax
c0023c51:	50                   	push   %eax
c0023c52:	68 09 01 00 00       	push   $0x109
c0023c57:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023c5d:	50                   	push   %eax
c0023c5e:	e8 ca 54 00 00       	call   c002912d <debug_panic>

c0023c63 <block_to_arena>:
block_to_arena(struct block *b) {
c0023c63:	56                   	push   %esi
c0023c64:	53                   	push   %ebx
c0023c65:	83 ec 04             	sub    $0x4,%esp
c0023c68:	e8 d6 c4 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023c6d:	81 c3 3f a0 01 00    	add    $0x1a03f,%ebx
    ASSERT (a != NULL);
c0023c73:	89 c1                	mov    %eax,%ecx
c0023c75:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0023c7b:	74 2e                	je     c0023cab <block_to_arena+0x48>
    ASSERT (a->magic == ARENA_MAGIC);
c0023c7d:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023c83:	75 4f                	jne    c0023cd4 <block_to_arena+0x71>
    ASSERT (a->desc == NULL
c0023c85:	8b 71 04             	mov    0x4(%ecx),%esi
c0023c88:	85 f6                	test   %esi,%esi
c0023c8a:	0f 84 96 00 00 00    	je     c0023d26 <block_to_arena+0xc3>
    return (uintptr_t) va & PGMASK;
c0023c90:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023c95:	83 e8 0c             	sub    $0xc,%eax
c0023c98:	ba 00 00 00 00       	mov    $0x0,%edx
c0023c9d:	f7 36                	divl   (%esi)
c0023c9f:	85 d2                	test   %edx,%edx
c0023ca1:	75 5a                	jne    c0023cfd <block_to_arena+0x9a>
}
c0023ca3:	89 c8                	mov    %ecx,%eax
c0023ca5:	83 c4 04             	add    $0x4,%esp
c0023ca8:	5b                   	pop    %ebx
c0023ca9:	5e                   	pop    %esi
c0023caa:	c3                   	ret    
    ASSERT (a != NULL);
c0023cab:	83 ec 0c             	sub    $0xc,%esp
c0023cae:	8d 83 79 42 ff ff    	lea    -0xbd87(%ebx),%eax
c0023cb4:	50                   	push   %eax
c0023cb5:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023cbb:	50                   	push   %eax
c0023cbc:	8d 83 a0 27 ff ff    	lea    -0xd860(%ebx),%eax
c0023cc2:	50                   	push   %eax
c0023cc3:	68 f9 00 00 00       	push   $0xf9
c0023cc8:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023cce:	50                   	push   %eax
c0023ccf:	e8 59 54 00 00       	call   c002912d <debug_panic>
    ASSERT (a->magic == ARENA_MAGIC);
c0023cd4:	83 ec 0c             	sub    $0xc,%esp
c0023cd7:	8d 83 1e 44 ff ff    	lea    -0xbbe2(%ebx),%eax
c0023cdd:	50                   	push   %eax
c0023cde:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023ce4:	50                   	push   %eax
c0023ce5:	8d 83 a0 27 ff ff    	lea    -0xd860(%ebx),%eax
c0023ceb:	50                   	push   %eax
c0023cec:	68 fa 00 00 00       	push   $0xfa
c0023cf1:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023cf7:	50                   	push   %eax
c0023cf8:	e8 30 54 00 00       	call   c002912d <debug_panic>
    ASSERT (a->desc == NULL
c0023cfd:	83 ec 0c             	sub    $0xc,%esp
c0023d00:	8d 83 58 44 ff ff    	lea    -0xbba8(%ebx),%eax
c0023d06:	50                   	push   %eax
c0023d07:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023d0d:	50                   	push   %eax
c0023d0e:	8d 83 a0 27 ff ff    	lea    -0xd860(%ebx),%eax
c0023d14:	50                   	push   %eax
c0023d15:	68 fe 00 00 00       	push   $0xfe
c0023d1a:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023d20:	50                   	push   %eax
c0023d21:	e8 07 54 00 00       	call   c002912d <debug_panic>
c0023d26:	25 ff 0f 00 00       	and    $0xfff,%eax
    ASSERT (a->desc != NULL || pg_ofs(b) == sizeof *a);
c0023d2b:	83 f8 0c             	cmp    $0xc,%eax
c0023d2e:	0f 84 6f ff ff ff    	je     c0023ca3 <block_to_arena+0x40>
c0023d34:	83 ec 0c             	sub    $0xc,%esp
c0023d37:	8d 83 a0 44 ff ff    	lea    -0xbb60(%ebx),%eax
c0023d3d:	50                   	push   %eax
c0023d3e:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023d44:	50                   	push   %eax
c0023d45:	8d 83 a0 27 ff ff    	lea    -0xd860(%ebx),%eax
c0023d4b:	50                   	push   %eax
c0023d4c:	68 ff 00 00 00       	push   $0xff
c0023d51:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023d57:	50                   	push   %eax
c0023d58:	e8 d0 53 00 00       	call   c002912d <debug_panic>

c0023d5d <malloc_init>:
malloc_init(void) {
c0023d5d:	55                   	push   %ebp
c0023d5e:	57                   	push   %edi
c0023d5f:	56                   	push   %esi
c0023d60:	53                   	push   %ebx
c0023d61:	83 ec 0c             	sub    $0xc,%esp
c0023d64:	e8 da c3 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023d69:	81 c3 43 9f 01 00    	add    $0x19f43,%ebx
        struct desc *d = &descs[desc_cnt++];
c0023d6f:	8b b3 54 16 00 00    	mov    0x1654(%ebx),%esi
c0023d75:	8d 46 01             	lea    0x1(%esi),%eax
c0023d78:	89 83 54 16 00 00    	mov    %eax,0x1654(%ebx)
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023d7e:	83 f8 0a             	cmp    $0xa,%eax
c0023d81:	0f 87 a1 00 00 00    	ja     c0023e28 <malloc_init+0xcb>
        d->block_size = block_size;
c0023d87:	8d bb 74 16 00 00    	lea    0x1674(%ebx),%edi
c0023d8d:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023d90:	c7 84 33 74 16 00 00 	movl   $0x10,0x1674(%ebx,%esi,1)
c0023d97:	10 00 00 00 
        d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c0023d9b:	c7 84 33 78 16 00 00 	movl   $0xff,0x1678(%ebx,%esi,1)
c0023da2:	ff 00 00 00 
        list_init(&d->free_list);
c0023da6:	83 ec 0c             	sub    $0xc,%esp
c0023da9:	8d 44 37 08          	lea    0x8(%edi,%esi,1),%eax
c0023dad:	50                   	push   %eax
c0023dae:	e8 47 54 00 00       	call   c00291fa <list_init>
        lock_init(&d->lock);
c0023db3:	8d 44 37 18          	lea    0x18(%edi,%esi,1),%eax
c0023db7:	89 04 24             	mov    %eax,(%esp)
c0023dba:	e8 f1 f3 ff ff       	call   c00231b0 <lock_init>
c0023dbf:	83 c4 10             	add    $0x10,%esp
    for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2) {
c0023dc2:	bf 20 00 00 00       	mov    $0x20,%edi
        d->block_size = block_size;
c0023dc7:	8d ab 74 16 00 00    	lea    0x1674(%ebx),%ebp
        struct desc *d = &descs[desc_cnt++];
c0023dcd:	8b b3 54 16 00 00    	mov    0x1654(%ebx),%esi
c0023dd3:	8d 46 01             	lea    0x1(%esi),%eax
c0023dd6:	89 83 54 16 00 00    	mov    %eax,0x1654(%ebx)
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023ddc:	83 f8 0a             	cmp    $0xa,%eax
c0023ddf:	77 47                	ja     c0023e28 <malloc_init+0xcb>
        d->block_size = block_size;
c0023de1:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023de4:	89 3c 2e             	mov    %edi,(%esi,%ebp,1)
        d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c0023de7:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023dec:	ba 00 00 00 00       	mov    $0x0,%edx
c0023df1:	f7 f7                	div    %edi
c0023df3:	89 84 33 78 16 00 00 	mov    %eax,0x1678(%ebx,%esi,1)
        list_init(&d->free_list);
c0023dfa:	83 ec 0c             	sub    $0xc,%esp
c0023dfd:	8d 44 2e 08          	lea    0x8(%esi,%ebp,1),%eax
c0023e01:	50                   	push   %eax
c0023e02:	e8 f3 53 00 00       	call   c00291fa <list_init>
        lock_init(&d->lock);
c0023e07:	8d 44 2e 18          	lea    0x18(%esi,%ebp,1),%eax
c0023e0b:	89 04 24             	mov    %eax,(%esp)
c0023e0e:	e8 9d f3 ff ff       	call   c00231b0 <lock_init>
    for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2) {
c0023e13:	01 ff                	add    %edi,%edi
c0023e15:	83 c4 10             	add    $0x10,%esp
c0023e18:	81 ff ff 07 00 00    	cmp    $0x7ff,%edi
c0023e1e:	76 ad                	jbe    c0023dcd <malloc_init+0x70>
}
c0023e20:	83 c4 0c             	add    $0xc,%esp
c0023e23:	5b                   	pop    %ebx
c0023e24:	5e                   	pop    %esi
c0023e25:	5f                   	pop    %edi
c0023e26:	5d                   	pop    %ebp
c0023e27:	c3                   	ret    
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023e28:	83 ec 0c             	sub    $0xc,%esp
c0023e2b:	8d 83 cc 44 ff ff    	lea    -0xbb34(%ebx),%eax
c0023e31:	50                   	push   %eax
c0023e32:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0023e38:	50                   	push   %eax
c0023e39:	8d 83 c0 27 ff ff    	lea    -0xd840(%ebx),%eax
c0023e3f:	50                   	push   %eax
c0023e40:	6a 4b                	push   $0x4b
c0023e42:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c0023e48:	50                   	push   %eax
c0023e49:	e8 df 52 00 00       	call   c002912d <debug_panic>

c0023e4e <malloc>:
malloc(size_t size) {
c0023e4e:	55                   	push   %ebp
c0023e4f:	57                   	push   %edi
c0023e50:	56                   	push   %esi
c0023e51:	53                   	push   %ebx
c0023e52:	83 ec 1c             	sub    $0x1c,%esp
c0023e55:	e8 e9 c2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023e5a:	81 c3 52 9e 01 00    	add    $0x19e52,%ebx
c0023e60:	8b 44 24 30          	mov    0x30(%esp),%eax
    if (size == 0)
c0023e64:	85 c0                	test   %eax,%eax
c0023e66:	0f 84 2d 01 00 00    	je     c0023f99 <malloc+0x14b>
    for (d = descs; d < descs + desc_cnt; d++)
c0023e6c:	6b 93 54 16 00 00 3c 	imul   $0x3c,0x1654(%ebx),%edx
c0023e73:	8d 8b 74 16 00 00    	lea    0x1674(%ebx),%ecx
c0023e79:	01 ca                	add    %ecx,%edx
c0023e7b:	39 ca                	cmp    %ecx,%edx
c0023e7d:	0f 86 c5 00 00 00    	jbe    c0023f48 <malloc+0xfa>
        if (d->block_size >= size)
c0023e83:	3b 83 74 16 00 00    	cmp    0x1674(%ebx),%eax
c0023e89:	0f 86 11 01 00 00    	jbe    c0023fa0 <malloc+0x152>
    for (d = descs; d < descs + desc_cnt; d++)
c0023e8f:	89 ce                	mov    %ecx,%esi
c0023e91:	83 c6 3c             	add    $0x3c,%esi
c0023e94:	39 d6                	cmp    %edx,%esi
c0023e96:	0f 83 b2 00 00 00    	jae    c0023f4e <malloc+0x100>
        if (d->block_size >= size)
c0023e9c:	39 06                	cmp    %eax,(%esi)
c0023e9e:	72 f1                	jb     c0023e91 <malloc+0x43>
    lock_acquire(&d->lock);
c0023ea0:	8d 46 18             	lea    0x18(%esi),%eax
c0023ea3:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023ea7:	83 ec 0c             	sub    $0xc,%esp
c0023eaa:	50                   	push   %eax
c0023eab:	e8 ac f3 ff ff       	call   c002325c <lock_acquire>
    if (list_empty(&d->free_list)) {
c0023eb0:	8d 46 08             	lea    0x8(%esi),%eax
c0023eb3:	89 44 24 18          	mov    %eax,0x18(%esp)
c0023eb7:	89 04 24             	mov    %eax,(%esp)
c0023eba:	e8 df 59 00 00       	call   c002989e <list_empty>
c0023ebf:	83 c4 10             	add    $0x10,%esp
c0023ec2:	84 c0                	test   %al,%al
c0023ec4:	74 52                	je     c0023f18 <malloc+0xca>
        a = palloc_get_page(0);
c0023ec6:	83 ec 0c             	sub    $0xc,%esp
c0023ec9:	6a 00                	push   $0x0
c0023ecb:	e8 6c fb ff ff       	call   c0023a3c <palloc_get_page>
c0023ed0:	89 c5                	mov    %eax,%ebp
        if (a == NULL) {
c0023ed2:	83 c4 10             	add    $0x10,%esp
c0023ed5:	85 c0                	test   %eax,%eax
c0023ed7:	0f 84 ab 00 00 00    	je     c0023f88 <malloc+0x13a>
        a->magic = ARENA_MAGIC;
c0023edd:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
        a->desc = d;
c0023ee3:	89 70 04             	mov    %esi,0x4(%eax)
        a->free_cnt = d->blocks_per_arena;
c0023ee6:	8b 46 04             	mov    0x4(%esi),%eax
c0023ee9:	89 45 08             	mov    %eax,0x8(%ebp)
        for (i = 0; i < d->blocks_per_arena; i++) {
c0023eec:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0023ef0:	74 26                	je     c0023f18 <malloc+0xca>
c0023ef2:	bf 00 00 00 00       	mov    $0x0,%edi
            struct block *b = arena_to_block(a, i);
c0023ef7:	89 fa                	mov    %edi,%edx
c0023ef9:	89 e8                	mov    %ebp,%eax
c0023efb:	e8 b9 fc ff ff       	call   c0023bb9 <arena_to_block>
            list_push_back(&d->free_list, &b->free_elem);
c0023f00:	83 ec 08             	sub    $0x8,%esp
c0023f03:	50                   	push   %eax
c0023f04:	ff 74 24 14          	pushl  0x14(%esp)
c0023f08:	e8 d2 58 00 00       	call   c00297df <list_push_back>
        for (i = 0; i < d->blocks_per_arena; i++) {
c0023f0d:	83 c7 01             	add    $0x1,%edi
c0023f10:	83 c4 10             	add    $0x10,%esp
c0023f13:	39 7e 04             	cmp    %edi,0x4(%esi)
c0023f16:	77 df                	ja     c0023ef7 <malloc+0xa9>
    b = list_entry (list_pop_front(&d->free_list), struct block, free_elem);
c0023f18:	83 ec 0c             	sub    $0xc,%esp
c0023f1b:	ff 74 24 14          	pushl  0x14(%esp)
c0023f1f:	e8 f1 59 00 00       	call   c0029915 <list_pop_front>
c0023f24:	89 c5                	mov    %eax,%ebp
    a = block_to_arena(b);
c0023f26:	e8 38 fd ff ff       	call   c0023c63 <block_to_arena>
    a->free_cnt--;
c0023f2b:	83 68 08 01          	subl   $0x1,0x8(%eax)
    lock_release(&d->lock);
c0023f2f:	83 c4 04             	add    $0x4,%esp
c0023f32:	ff 74 24 18          	pushl  0x18(%esp)
c0023f36:	e8 22 f5 ff ff       	call   c002345d <lock_release>
    return b;
c0023f3b:	83 c4 10             	add    $0x10,%esp
}
c0023f3e:	89 e8                	mov    %ebp,%eax
c0023f40:	83 c4 1c             	add    $0x1c,%esp
c0023f43:	5b                   	pop    %ebx
c0023f44:	5e                   	pop    %esi
c0023f45:	5f                   	pop    %edi
c0023f46:	5d                   	pop    %ebp
c0023f47:	c3                   	ret    
    for (d = descs; d < descs + desc_cnt; d++)
c0023f48:	8d b3 74 16 00 00    	lea    0x1674(%ebx),%esi
    if (d == descs + desc_cnt) {
c0023f4e:	39 f2                	cmp    %esi,%edx
c0023f50:	0f 85 4a ff ff ff    	jne    c0023ea0 <malloc+0x52>
        size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023f56:	8d b0 0b 10 00 00    	lea    0x100b(%eax),%esi
c0023f5c:	c1 ee 0c             	shr    $0xc,%esi
        a = palloc_get_multiple(0, page_cnt);
c0023f5f:	83 ec 08             	sub    $0x8,%esp
c0023f62:	56                   	push   %esi
c0023f63:	6a 00                	push   $0x0
c0023f65:	e8 1d fa ff ff       	call   c0023987 <palloc_get_multiple>
c0023f6a:	89 c5                	mov    %eax,%ebp
        if (a == NULL)
c0023f6c:	83 c4 10             	add    $0x10,%esp
c0023f6f:	85 c0                	test   %eax,%eax
c0023f71:	74 cb                	je     c0023f3e <malloc+0xf0>
        a->magic = ARENA_MAGIC;
c0023f73:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
        a->desc = NULL;
c0023f79:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        a->free_cnt = page_cnt;
c0023f80:	89 70 08             	mov    %esi,0x8(%eax)
        return a + 1;
c0023f83:	83 c5 0c             	add    $0xc,%ebp
c0023f86:	eb b6                	jmp    c0023f3e <malloc+0xf0>
            lock_release(&d->lock);
c0023f88:	83 ec 0c             	sub    $0xc,%esp
c0023f8b:	ff 74 24 18          	pushl  0x18(%esp)
c0023f8f:	e8 c9 f4 ff ff       	call   c002345d <lock_release>
            return NULL;
c0023f94:	83 c4 10             	add    $0x10,%esp
c0023f97:	eb a5                	jmp    c0023f3e <malloc+0xf0>
        return NULL;
c0023f99:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023f9e:	eb 9e                	jmp    c0023f3e <malloc+0xf0>
    for (d = descs; d < descs + desc_cnt; d++)
c0023fa0:	8d b3 74 16 00 00    	lea    0x1674(%ebx),%esi
    if (d == descs + desc_cnt) {
c0023fa6:	e9 f5 fe ff ff       	jmp    c0023ea0 <malloc+0x52>

c0023fab <calloc>:
calloc(size_t a, size_t b) {
c0023fab:	57                   	push   %edi
c0023fac:	56                   	push   %esi
c0023fad:	53                   	push   %ebx
c0023fae:	e8 90 c1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0023fb3:	81 c3 f9 9c 01 00    	add    $0x19cf9,%ebx
c0023fb9:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023fbd:	8b 54 24 14          	mov    0x14(%esp),%edx
    size = a * b;
c0023fc1:	89 c6                	mov    %eax,%esi
c0023fc3:	0f af f2             	imul   %edx,%esi
    if (size < a || size < b)
c0023fc6:	39 f0                	cmp    %esi,%eax
c0023fc8:	77 2b                	ja     c0023ff5 <calloc+0x4a>
c0023fca:	39 f2                	cmp    %esi,%edx
c0023fcc:	77 27                	ja     c0023ff5 <calloc+0x4a>
    p = malloc(size);
c0023fce:	83 ec 0c             	sub    $0xc,%esp
c0023fd1:	56                   	push   %esi
c0023fd2:	e8 77 fe ff ff       	call   c0023e4e <malloc>
c0023fd7:	89 c7                	mov    %eax,%edi
    if (p != NULL)
c0023fd9:	83 c4 10             	add    $0x10,%esp
c0023fdc:	85 c0                	test   %eax,%eax
c0023fde:	74 0f                	je     c0023fef <calloc+0x44>
        memset(p, 0, size);
c0023fe0:	83 ec 04             	sub    $0x4,%esp
c0023fe3:	56                   	push   %esi
c0023fe4:	6a 00                	push   $0x0
c0023fe6:	50                   	push   %eax
c0023fe7:	e8 b0 46 00 00       	call   c002869c <memset>
c0023fec:	83 c4 10             	add    $0x10,%esp
}
c0023fef:	89 f8                	mov    %edi,%eax
c0023ff1:	5b                   	pop    %ebx
c0023ff2:	5e                   	pop    %esi
c0023ff3:	5f                   	pop    %edi
c0023ff4:	c3                   	ret    
        return NULL;
c0023ff5:	bf 00 00 00 00       	mov    $0x0,%edi
c0023ffa:	eb f3                	jmp    c0023fef <calloc+0x44>

c0023ffc <free>:
free(void *p) {
c0023ffc:	55                   	push   %ebp
c0023ffd:	57                   	push   %edi
c0023ffe:	56                   	push   %esi
c0023fff:	53                   	push   %ebx
c0024000:	83 ec 1c             	sub    $0x1c,%esp
c0024003:	e8 3b c1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024008:	81 c3 a4 9c 01 00    	add    $0x19ca4,%ebx
c002400e:	8b 74 24 30          	mov    0x30(%esp),%esi
    if (p != NULL) {
c0024012:	85 f6                	test   %esi,%esi
c0024014:	0f 84 96 00 00 00    	je     c00240b0 <free+0xb4>
        struct arena *a = block_to_arena(b);
c002401a:	89 f0                	mov    %esi,%eax
c002401c:	e8 42 fc ff ff       	call   c0023c63 <block_to_arena>
c0024021:	89 c5                	mov    %eax,%ebp
        struct desc *d = a->desc;
c0024023:	8b 78 04             	mov    0x4(%eax),%edi
        if (d != NULL) {
c0024026:	85 ff                	test   %edi,%edi
c0024028:	0f 84 b3 00 00 00    	je     c00240e1 <free+0xe5>
            memset(b, 0xcc, d->block_size);
c002402e:	83 ec 04             	sub    $0x4,%esp
c0024031:	ff 37                	pushl  (%edi)
c0024033:	68 cc 00 00 00       	push   $0xcc
c0024038:	56                   	push   %esi
c0024039:	e8 5e 46 00 00       	call   c002869c <memset>
            lock_acquire(&d->lock);
c002403e:	8d 47 18             	lea    0x18(%edi),%eax
c0024041:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0024045:	89 04 24             	mov    %eax,(%esp)
c0024048:	e8 0f f2 ff ff       	call   c002325c <lock_acquire>
            list_push_front(&d->free_list, &b->free_elem);
c002404d:	83 c4 08             	add    $0x8,%esp
c0024050:	56                   	push   %esi
c0024051:	8d 47 08             	lea    0x8(%edi),%eax
c0024054:	50                   	push   %eax
c0024055:	e8 68 57 00 00       	call   c00297c2 <list_push_front>
            if (++a->free_cnt >= d->blocks_per_arena) {
c002405a:	8b 45 08             	mov    0x8(%ebp),%eax
c002405d:	83 c0 01             	add    $0x1,%eax
c0024060:	89 45 08             	mov    %eax,0x8(%ebp)
c0024063:	8b 57 04             	mov    0x4(%edi),%edx
c0024066:	83 c4 10             	add    $0x10,%esp
c0024069:	39 d0                	cmp    %edx,%eax
c002406b:	72 34                	jb     c00240a1 <free+0xa5>
                ASSERT (a->free_cnt == d->blocks_per_arena);
c002406d:	75 49                	jne    c00240b8 <free+0xbc>
                for (i = 0; i < d->blocks_per_arena; i++) {
c002406f:	be 00 00 00 00       	mov    $0x0,%esi
c0024074:	85 d2                	test   %edx,%edx
c0024076:	74 1d                	je     c0024095 <free+0x99>
                    struct block *b = arena_to_block(a, i);
c0024078:	89 f2                	mov    %esi,%edx
c002407a:	89 e8                	mov    %ebp,%eax
c002407c:	e8 38 fb ff ff       	call   c0023bb9 <arena_to_block>
                    list_remove(&b->free_elem);
c0024081:	83 ec 0c             	sub    $0xc,%esp
c0024084:	50                   	push   %eax
c0024085:	e8 72 57 00 00       	call   c00297fc <list_remove>
                for (i = 0; i < d->blocks_per_arena; i++) {
c002408a:	83 c6 01             	add    $0x1,%esi
c002408d:	83 c4 10             	add    $0x10,%esp
c0024090:	39 77 04             	cmp    %esi,0x4(%edi)
c0024093:	77 e3                	ja     c0024078 <free+0x7c>
                palloc_free_page(a);
c0024095:	83 ec 0c             	sub    $0xc,%esp
c0024098:	55                   	push   %ebp
c0024099:	e8 09 fb ff ff       	call   c0023ba7 <palloc_free_page>
c002409e:	83 c4 10             	add    $0x10,%esp
            lock_release(&d->lock);
c00240a1:	83 ec 0c             	sub    $0xc,%esp
c00240a4:	ff 74 24 18          	pushl  0x18(%esp)
c00240a8:	e8 b0 f3 ff ff       	call   c002345d <lock_release>
c00240ad:	83 c4 10             	add    $0x10,%esp
}
c00240b0:	83 c4 1c             	add    $0x1c,%esp
c00240b3:	5b                   	pop    %ebx
c00240b4:	5e                   	pop    %esi
c00240b5:	5f                   	pop    %edi
c00240b6:	5d                   	pop    %ebp
c00240b7:	c3                   	ret    
                ASSERT (a->free_cnt == d->blocks_per_arena);
c00240b8:	83 ec 0c             	sub    $0xc,%esp
c00240bb:	8d 83 f8 44 ff ff    	lea    -0xbb08(%ebx),%eax
c00240c1:	50                   	push   %eax
c00240c2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00240c8:	50                   	push   %eax
c00240c9:	8d 83 98 27 ff ff    	lea    -0xd868(%ebx),%eax
c00240cf:	50                   	push   %eax
c00240d0:	68 e2 00 00 00       	push   $0xe2
c00240d5:	8d 83 07 44 ff ff    	lea    -0xbbf9(%ebx),%eax
c00240db:	50                   	push   %eax
c00240dc:	e8 4c 50 00 00       	call   c002912d <debug_panic>
            palloc_free_multiple(a, a->free_cnt);
c00240e1:	83 ec 08             	sub    $0x8,%esp
c00240e4:	ff 70 08             	pushl  0x8(%eax)
c00240e7:	50                   	push   %eax
c00240e8:	e8 61 f9 ff ff       	call   c0023a4e <palloc_free_multiple>
            return;
c00240ed:	83 c4 10             	add    $0x10,%esp
c00240f0:	eb be                	jmp    c00240b0 <free+0xb4>

c00240f2 <realloc>:
realloc(void *old_block, size_t new_size) {
c00240f2:	55                   	push   %ebp
c00240f3:	57                   	push   %edi
c00240f4:	56                   	push   %esi
c00240f5:	53                   	push   %ebx
c00240f6:	83 ec 0c             	sub    $0xc,%esp
c00240f9:	e8 45 c0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00240fe:	81 c3 ae 9b 01 00    	add    $0x19bae,%ebx
c0024104:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0024108:	8b 74 24 24          	mov    0x24(%esp),%esi
    if (new_size == 0) {
c002410c:	85 f6                	test   %esi,%esi
c002410e:	74 43                	je     c0024153 <realloc+0x61>
        void *new_block = malloc(new_size);
c0024110:	83 ec 0c             	sub    $0xc,%esp
c0024113:	56                   	push   %esi
c0024114:	e8 35 fd ff ff       	call   c0023e4e <malloc>
c0024119:	89 c5                	mov    %eax,%ebp
        if (old_block != NULL && new_block != NULL) {
c002411b:	83 c4 10             	add    $0x10,%esp
c002411e:	85 ff                	test   %edi,%edi
c0024120:	74 42                	je     c0024164 <realloc+0x72>
c0024122:	85 c0                	test   %eax,%eax
c0024124:	74 3e                	je     c0024164 <realloc+0x72>
    struct arena *a = block_to_arena(b);
c0024126:	89 f8                	mov    %edi,%eax
c0024128:	e8 36 fb ff ff       	call   c0023c63 <block_to_arena>
    struct desc *d = a->desc;
c002412d:	8b 50 04             	mov    0x4(%eax),%edx
    return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c0024130:	85 d2                	test   %edx,%edx
c0024132:	74 3a                	je     c002416e <realloc+0x7c>
c0024134:	8b 02                	mov    (%edx),%eax
            size_t min_size = new_size < old_size ? new_size : old_size;
c0024136:	39 c6                	cmp    %eax,%esi
c0024138:	0f 47 f0             	cmova  %eax,%esi
            memcpy(new_block, old_block, min_size);
c002413b:	83 ec 04             	sub    $0x4,%esp
c002413e:	56                   	push   %esi
c002413f:	57                   	push   %edi
c0024140:	55                   	push   %ebp
c0024141:	e8 d6 41 00 00       	call   c002831c <memcpy>
            free(old_block);
c0024146:	89 3c 24             	mov    %edi,(%esp)
c0024149:	e8 ae fe ff ff       	call   c0023ffc <free>
c002414e:	83 c4 10             	add    $0x10,%esp
c0024151:	eb 11                	jmp    c0024164 <realloc+0x72>
        free(old_block);
c0024153:	83 ec 0c             	sub    $0xc,%esp
c0024156:	57                   	push   %edi
c0024157:	e8 a0 fe ff ff       	call   c0023ffc <free>
        return NULL;
c002415c:	83 c4 10             	add    $0x10,%esp
c002415f:	bd 00 00 00 00       	mov    $0x0,%ebp
}
c0024164:	89 e8                	mov    %ebp,%eax
c0024166:	83 c4 0c             	add    $0xc,%esp
c0024169:	5b                   	pop    %ebx
c002416a:	5e                   	pop    %esi
c002416b:	5f                   	pop    %edi
c002416c:	5d                   	pop    %ebp
c002416d:	c3                   	ret    
    return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c002416e:	8b 40 08             	mov    0x8(%eax),%eax
c0024171:	c1 e0 0c             	shl    $0xc,%eax
c0024174:	89 fa                	mov    %edi,%edx
c0024176:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c002417c:	29 d0                	sub    %edx,%eax
c002417e:	eb b6                	jmp    c0024136 <realloc+0x44>

c0024180 <pit_configure_channel>:

     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel(int channel, int mode, int frequency) {
c0024180:	55                   	push   %ebp
c0024181:	57                   	push   %edi
c0024182:	56                   	push   %esi
c0024183:	53                   	push   %ebx
c0024184:	83 ec 0c             	sub    $0xc,%esp
c0024187:	e8 b7 bf 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002418c:	81 c3 20 9b 01 00    	add    $0x19b20,%ebx
c0024192:	8b 74 24 20          	mov    0x20(%esp),%esi
c0024196:	8b 6c 24 24          	mov    0x24(%esp),%ebp
c002419a:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    uint16_t count;
    enum intr_level old_level;

    ASSERT (channel == 0 || channel == 2);
c002419e:	f7 c6 fd ff ff ff    	test   $0xfffffffd,%esi
c00241a4:	75 69                	jne    c002420f <pit_configure_channel+0x8f>
    ASSERT (mode == 2 || mode == 3);
c00241a6:	8d 45 fe             	lea    -0x2(%ebp),%eax
c00241a9:	83 f8 01             	cmp    $0x1,%eax
c00241ac:	0f 87 83 00 00 00    	ja     c0024235 <pit_configure_channel+0xb5>
    if (frequency < 19) {
        /* Frequency is too low: the quotient would overflow the
           16-bit counter.  Force it to 0, which the PIT treats as
           65536, the highest possible count.  This yields a 18.2
           Hz timer, approximately. */
        count = 0;
c00241b2:	bf 00 00 00 00       	mov    $0x0,%edi
    if (frequency < 19) {
c00241b7:	83 f9 12             	cmp    $0x12,%ecx
c00241ba:	7e 20                	jle    c00241dc <pit_configure_channel+0x5c>
        /* Frequency is too high: the quotient would underflow to
           0, which the PIT would interpret as 65536.  A count of 1
           is illegal in mode 2, so we force it to 2, which yields
           a 596.590 kHz timer, approximately.  (This timer rate is
           probably too fast to be useful anyhow.) */
        count = 2;
c00241bc:	bf 02 00 00 00       	mov    $0x2,%edi
    } else if (frequency > PIT_HZ) {
c00241c1:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c00241c7:	7f 13                	jg     c00241dc <pit_configure_channel+0x5c>
    } else
        count = (PIT_HZ + frequency / 2) / frequency;
c00241c9:	89 c8                	mov    %ecx,%eax
c00241cb:	c1 e8 1f             	shr    $0x1f,%eax
c00241ce:	01 c8                	add    %ecx,%eax
c00241d0:	d1 f8                	sar    %eax
c00241d2:	05 dc 34 12 00       	add    $0x1234dc,%eax
c00241d7:	99                   	cltd   
c00241d8:	f7 f9                	idiv   %ecx
c00241da:	89 c7                	mov    %eax,%edi

    /* Configure the PIT mode and load its counters. */
    old_level = intr_disable();
c00241dc:	e8 81 db ff ff       	call   c0021d62 <intr_disable>
c00241e1:	89 c1                	mov    %eax,%ecx
    outb(PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c00241e3:	89 f0                	mov    %esi,%eax
c00241e5:	c1 e0 06             	shl    $0x6,%eax
c00241e8:	01 ed                	add    %ebp,%ebp
c00241ea:	09 e8                	or     %ebp,%eax
c00241ec:	83 c8 30             	or     $0x30,%eax
c00241ef:	e6 43                	out    %al,$0x43
    outb(PIT_PORT_COUNTER (channel), count);
c00241f1:	8d 56 40             	lea    0x40(%esi),%edx
c00241f4:	89 f8                	mov    %edi,%eax
c00241f6:	ee                   	out    %al,(%dx)
    outb(PIT_PORT_COUNTER (channel), count >> 8);
c00241f7:	89 f8                	mov    %edi,%eax
c00241f9:	66 c1 e8 08          	shr    $0x8,%ax
c00241fd:	ee                   	out    %al,(%dx)
    intr_set_level(old_level);
c00241fe:	83 ec 0c             	sub    $0xc,%esp
c0024201:	51                   	push   %ecx
c0024202:	e8 62 db ff ff       	call   c0021d69 <intr_set_level>
}
c0024207:	83 c4 1c             	add    $0x1c,%esp
c002420a:	5b                   	pop    %ebx
c002420b:	5e                   	pop    %esi
c002420c:	5f                   	pop    %edi
c002420d:	5d                   	pop    %ebp
c002420e:	c3                   	ret    
    ASSERT (channel == 0 || channel == 2);
c002420f:	83 ec 0c             	sub    $0xc,%esp
c0024212:	8d 83 1b 45 ff ff    	lea    -0xbae5(%ebx),%eax
c0024218:	50                   	push   %eax
c0024219:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002421f:	50                   	push   %eax
c0024220:	8d 83 cc 27 ff ff    	lea    -0xd834(%ebx),%eax
c0024226:	50                   	push   %eax
c0024227:	6a 32                	push   $0x32
c0024229:	8d 83 38 45 ff ff    	lea    -0xbac8(%ebx),%eax
c002422f:	50                   	push   %eax
c0024230:	e8 f8 4e 00 00       	call   c002912d <debug_panic>
    ASSERT (mode == 2 || mode == 3);
c0024235:	83 ec 0c             	sub    $0xc,%esp
c0024238:	8d 83 4c 45 ff ff    	lea    -0xbab4(%ebx),%eax
c002423e:	50                   	push   %eax
c002423f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0024245:	50                   	push   %eax
c0024246:	8d 83 cc 27 ff ff    	lea    -0xd834(%ebx),%eax
c002424c:	50                   	push   %eax
c002424d:	6a 33                	push   $0x33
c002424f:	8d 83 38 45 ff ff    	lea    -0xbac8(%ebx),%eax
c0024255:	50                   	push   %eax
c0024256:	e8 d2 4e 00 00       	call   c002912d <debug_panic>

c002425b <busy_wait>:
   Marked NO_INLINE because code alignment can significantly
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait(int64_t loops) {
c002425b:	56                   	push   %esi
c002425c:	53                   	push   %ebx
    while (loops-- > 0)
c002425d:	89 c1                	mov    %eax,%ecx
c002425f:	89 d3                	mov    %edx,%ebx
c0024261:	83 c1 ff             	add    $0xffffffff,%ecx
c0024264:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024267:	be 00 00 00 00       	mov    $0x0,%esi
c002426c:	39 c6                	cmp    %eax,%esi
c002426e:	19 d6                	sbb    %edx,%esi
c0024270:	7d 0f                	jge    c0024281 <busy_wait+0x26>
c0024272:	83 c1 ff             	add    $0xffffffff,%ecx
c0024275:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024278:	89 d8                	mov    %ebx,%eax
c002427a:	21 c8                	and    %ecx,%eax
c002427c:	83 f8 ff             	cmp    $0xffffffff,%eax
c002427f:	75 f1                	jne    c0024272 <busy_wait+0x17>
            barrier ();
}
c0024281:	5b                   	pop    %ebx
c0024282:	5e                   	pop    %esi
c0024283:	c3                   	ret    

c0024284 <too_many_loops>:
too_many_loops(unsigned loops) {
c0024284:	55                   	push   %ebp
c0024285:	57                   	push   %edi
c0024286:	56                   	push   %esi
c0024287:	53                   	push   %ebx
c0024288:	83 ec 0c             	sub    $0xc,%esp
c002428b:	e8 b3 be 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024290:	81 c3 1c 9a 01 00    	add    $0x19a1c,%ebx
c0024296:	89 44 24 04          	mov    %eax,0x4(%esp)
    int64_t start = ticks;
c002429a:	8b ab d4 18 00 00    	mov    0x18d4(%ebx),%ebp
c00242a0:	8b 8b d8 18 00 00    	mov    0x18d8(%ebx),%ecx
    while (ticks == start)
c00242a6:	8b bb d4 18 00 00    	mov    0x18d4(%ebx),%edi
c00242ac:	8b b3 d8 18 00 00    	mov    0x18d8(%ebx),%esi
c00242b2:	89 f8                	mov    %edi,%eax
c00242b4:	31 e8                	xor    %ebp,%eax
c00242b6:	89 f2                	mov    %esi,%edx
c00242b8:	31 ca                	xor    %ecx,%edx
c00242ba:	09 c2                	or     %eax,%edx
c00242bc:	74 e8                	je     c00242a6 <too_many_loops+0x22>
    busy_wait(loops);
c00242be:	8b 44 24 04          	mov    0x4(%esp),%eax
c00242c2:	ba 00 00 00 00       	mov    $0x0,%edx
c00242c7:	e8 8f ff ff ff       	call   c002425b <busy_wait>
    return start != ticks;
c00242cc:	33 bb d4 18 00 00    	xor    0x18d4(%ebx),%edi
c00242d2:	33 b3 d8 18 00 00    	xor    0x18d8(%ebx),%esi
c00242d8:	09 f7                	or     %esi,%edi
c00242da:	0f 95 c0             	setne  %al
}
c00242dd:	83 c4 0c             	add    $0xc,%esp
c00242e0:	5b                   	pop    %ebx
c00242e1:	5e                   	pop    %esi
c00242e2:	5f                   	pop    %edi
c00242e3:	5d                   	pop    %ebp
c00242e4:	c3                   	ret    

c00242e5 <timer_interrupt>:
timer_interrupt(struct intr_frame *args UNUSED) {
c00242e5:	56                   	push   %esi
c00242e6:	53                   	push   %ebx
c00242e7:	83 ec 04             	sub    $0x4,%esp
c00242ea:	e8 54 be 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00242ef:	81 c3 bd 99 01 00    	add    $0x199bd,%ebx
    ticks++;
c00242f5:	83 83 d4 18 00 00 01 	addl   $0x1,0x18d4(%ebx)
c00242fc:	83 93 d8 18 00 00 00 	adcl   $0x0,0x18d8(%ebx)
    if (thread_mlfqs) {
c0024303:	c7 c0 cc fc 03 c0    	mov    $0xc003fccc,%eax
c0024309:	80 38 00             	cmpb   $0x0,(%eax)
c002430c:	75 2b                	jne    c0024339 <timer_interrupt+0x54>
    enum intr_level old_level = intr_disable();
c002430e:	e8 4f da ff ff       	call   c0021d62 <intr_disable>
c0024313:	89 c6                	mov    %eax,%esi
    thread_foreach(thread_blocked_check, NULL);
c0024315:	83 ec 08             	sub    $0x8,%esp
c0024318:	6a 00                	push   $0x0
c002431a:	8d 83 89 67 fe ff    	lea    -0x19877(%ebx),%eax
c0024320:	50                   	push   %eax
c0024321:	e8 b4 cd ff ff       	call   c00210da <thread_foreach>
    intr_set_level(old_level);
c0024326:	89 34 24             	mov    %esi,(%esp)
c0024329:	e8 3b da ff ff       	call   c0021d69 <intr_set_level>
    thread_tick();
c002432e:	e8 17 cd ff ff       	call   c002104a <thread_tick>
}
c0024333:	83 c4 14             	add    $0x14,%esp
c0024336:	5b                   	pop    %ebx
c0024337:	5e                   	pop    %esi
c0024338:	c3                   	ret    
        update_cur_thread_cpu();
c0024339:	e8 b8 ce ff ff       	call   c00211f6 <update_cur_thread_cpu>
        if (ticks % TIMER_FREQ == 0) {
c002433e:	6a 00                	push   $0x0
c0024340:	6a 64                	push   $0x64
c0024342:	ff b3 d8 18 00 00    	pushl  0x18d8(%ebx)
c0024348:	ff b3 d4 18 00 00    	pushl  0x18d4(%ebx)
c002434e:	e8 c0 47 00 00       	call   c0028b13 <__moddi3>
c0024353:	83 c4 10             	add    $0x10,%esp
c0024356:	09 c2                	or     %eax,%edx
c0024358:	74 10                	je     c002436a <timer_interrupt+0x85>
        if (ticks % 4) {
c002435a:	f6 83 d4 18 00 00 03 	testb  $0x3,0x18d4(%ebx)
c0024361:	74 ab                	je     c002430e <timer_interrupt+0x29>
            update_all_priority();
c0024363:	e8 50 ce ff ff       	call   c00211b8 <update_all_priority>
c0024368:	eb a4                	jmp    c002430e <timer_interrupt+0x29>
            update_load_avg();
c002436a:	e8 a9 ce ff ff       	call   c0021218 <update_load_avg>
            update_all_recent_cpu();
c002436f:	e8 63 ce ff ff       	call   c00211d7 <update_all_recent_cpu>
c0024374:	eb e4                	jmp    c002435a <timer_interrupt+0x75>

c0024376 <real_time_delay>:
    }
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay(int64_t num, int32_t denom) {
c0024376:	55                   	push   %ebp
c0024377:	57                   	push   %edi
c0024378:	56                   	push   %esi
c0024379:	53                   	push   %ebx
c002437a:	83 ec 0c             	sub    $0xc,%esp
c002437d:	e8 cd bd 00 00       	call   c003014f <__x86.get_pc_thunk.di>
c0024382:	81 c7 2a 99 01 00    	add    $0x1992a,%edi
c0024388:	89 c5                	mov    %eax,%ebp
c002438a:	89 d3                	mov    %edx,%ebx
    /* Scale the numerator and denominator down by 1000 to avoid
       the possibility of overflow. */
    ASSERT (denom % 1000 == 0);
c002438c:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0024391:	89 c8                	mov    %ecx,%eax
c0024393:	f7 ea                	imul   %edx
c0024395:	c1 fa 06             	sar    $0x6,%edx
c0024398:	89 c8                	mov    %ecx,%eax
c002439a:	c1 f8 1f             	sar    $0x1f,%eax
c002439d:	29 c2                	sub    %eax,%edx
c002439f:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
c00243a5:	39 d1                	cmp    %edx,%ecx
c00243a7:	75 61                	jne    c002440a <real_time_delay+0x94>
c00243a9:	89 ce                	mov    %ecx,%esi
    busy_wait(loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000));
c00243ab:	8b 87 cc 18 00 00    	mov    0x18cc(%edi),%eax
c00243b1:	0f af d8             	imul   %eax,%ebx
c00243b4:	f7 e5                	mul    %ebp
c00243b6:	01 da                	add    %ebx,%edx
c00243b8:	6a 00                	push   $0x0
c00243ba:	68 e8 03 00 00       	push   $0x3e8
c00243bf:	52                   	push   %edx
c00243c0:	50                   	push   %eax
c00243c1:	89 fb                	mov    %edi,%ebx
c00243c3:	e8 2f 47 00 00       	call   c0028af7 <__divdi3>
c00243c8:	83 c4 10             	add    $0x10,%esp
c00243cb:	6b ea 64             	imul   $0x64,%edx,%ebp
c00243ce:	b9 64 00 00 00       	mov    $0x64,%ecx
c00243d3:	f7 e1                	mul    %ecx
c00243d5:	89 c1                	mov    %eax,%ecx
c00243d7:	89 d3                	mov    %edx,%ebx
c00243d9:	01 eb                	add    %ebp,%ebx
c00243db:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00243e0:	89 f0                	mov    %esi,%eax
c00243e2:	f7 ea                	imul   %edx
c00243e4:	c1 fa 06             	sar    $0x6,%edx
c00243e7:	c1 fe 1f             	sar    $0x1f,%esi
c00243ea:	29 f2                	sub    %esi,%edx
c00243ec:	89 d0                	mov    %edx,%eax
c00243ee:	99                   	cltd   
c00243ef:	52                   	push   %edx
c00243f0:	50                   	push   %eax
c00243f1:	53                   	push   %ebx
c00243f2:	51                   	push   %ecx
c00243f3:	89 fb                	mov    %edi,%ebx
c00243f5:	e8 fd 46 00 00       	call   c0028af7 <__divdi3>
c00243fa:	83 c4 10             	add    $0x10,%esp
c00243fd:	e8 59 fe ff ff       	call   c002425b <busy_wait>
}
c0024402:	83 c4 0c             	add    $0xc,%esp
c0024405:	5b                   	pop    %ebx
c0024406:	5e                   	pop    %esi
c0024407:	5f                   	pop    %edi
c0024408:	5d                   	pop    %ebp
c0024409:	c3                   	ret    
    ASSERT (denom % 1000 == 0);
c002440a:	83 ec 0c             	sub    $0xc,%esp
c002440d:	8d 87 63 45 ff ff    	lea    -0xba9d(%edi),%eax
c0024413:	50                   	push   %eax
c0024414:	8d 87 de 36 ff ff    	lea    -0xc922(%edi),%eax
c002441a:	50                   	push   %eax
c002441b:	8d 87 e4 27 ff ff    	lea    -0xd81c(%edi),%eax
c0024421:	50                   	push   %eax
c0024422:	68 08 01 00 00       	push   $0x108
c0024427:	8d 87 75 45 ff ff    	lea    -0xba8b(%edi),%eax
c002442d:	50                   	push   %eax
c002442e:	89 fb                	mov    %edi,%ebx
c0024430:	e8 f8 4c 00 00       	call   c002912d <debug_panic>

c0024435 <thread_blocked_check>:
void thread_blocked_check(struct thread *t, void *aux UNUSED) {
c0024435:	56                   	push   %esi
c0024436:	53                   	push   %ebx
c0024437:	83 ec 04             	sub    $0x4,%esp
c002443a:	e8 14 bd 00 00       	call   c0030153 <__x86.get_pc_thunk.dx>
c002443f:	81 c2 6d 98 01 00    	add    $0x1986d,%edx
c0024445:	8b 44 24 10          	mov    0x10(%esp),%eax
    if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c0024449:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
c002444d:	74 06                	je     c0024455 <thread_blocked_check+0x20>
}
c002444f:	83 c4 04             	add    $0x4,%esp
c0024452:	5b                   	pop    %ebx
c0024453:	5e                   	pop    %esi
c0024454:	c3                   	ret    
    if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c0024455:	8b 88 e4 00 00 00    	mov    0xe4(%eax),%ecx
c002445b:	8b 98 e8 00 00 00    	mov    0xe8(%eax),%ebx
c0024461:	be 00 00 00 00       	mov    $0x0,%esi
c0024466:	39 ce                	cmp    %ecx,%esi
c0024468:	19 de                	sbb    %ebx,%esi
c002446a:	7d e3                	jge    c002444f <thread_blocked_check+0x1a>
        t->ticks_blocked--;
c002446c:	83 c1 ff             	add    $0xffffffff,%ecx
c002446f:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024472:	89 de                	mov    %ebx,%esi
c0024474:	89 88 e4 00 00 00    	mov    %ecx,0xe4(%eax)
c002447a:	89 b0 e8 00 00 00    	mov    %esi,0xe8(%eax)
        if (t->ticks_blocked == 0) {
c0024480:	89 f3                	mov    %esi,%ebx
c0024482:	09 cb                	or     %ecx,%ebx
c0024484:	75 c9                	jne    c002444f <thread_blocked_check+0x1a>
            thread_unblock(t);
c0024486:	83 ec 0c             	sub    $0xc,%esp
c0024489:	50                   	push   %eax
c002448a:	89 d3                	mov    %edx,%ebx
c002448c:	e8 85 ca ff ff       	call   c0020f16 <thread_unblock>
c0024491:	83 c4 10             	add    $0x10,%esp
}
c0024494:	eb b9                	jmp    c002444f <thread_blocked_check+0x1a>

c0024496 <timer_init>:
timer_init(void) {
c0024496:	53                   	push   %ebx
c0024497:	83 ec 0c             	sub    $0xc,%esp
c002449a:	e8 a4 bc 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002449f:	81 c3 0d 98 01 00    	add    $0x1980d,%ebx
    pit_configure_channel(0, 2, TIMER_FREQ);
c00244a5:	6a 64                	push   $0x64
c00244a7:	6a 02                	push   $0x2
c00244a9:	6a 00                	push   $0x0
c00244ab:	e8 d0 fc ff ff       	call   c0024180 <pit_configure_channel>
    intr_register_ext(0x20, timer_interrupt, "8254 Timer");
c00244b0:	83 c4 0c             	add    $0xc,%esp
c00244b3:	8d 83 8b 45 ff ff    	lea    -0xba75(%ebx),%eax
c00244b9:	50                   	push   %eax
c00244ba:	8d 83 39 66 fe ff    	lea    -0x199c7(%ebx),%eax
c00244c0:	50                   	push   %eax
c00244c1:	6a 20                	push   $0x20
c00244c3:	e8 76 da ff ff       	call   c0021f3e <intr_register_ext>
}
c00244c8:	83 c4 18             	add    $0x18,%esp
c00244cb:	5b                   	pop    %ebx
c00244cc:	c3                   	ret    

c00244cd <timer_calibrate>:
timer_calibrate(void) {
c00244cd:	55                   	push   %ebp
c00244ce:	57                   	push   %edi
c00244cf:	56                   	push   %esi
c00244d0:	53                   	push   %ebx
c00244d1:	83 ec 0c             	sub    $0xc,%esp
c00244d4:	e8 6a bc 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00244d9:	81 c3 d3 97 01 00    	add    $0x197d3,%ebx
    ASSERT (intr_get_level() == INTR_ON);
c00244df:	e8 2c d8 ff ff       	call   c0021d10 <intr_get_level>
c00244e4:	83 f8 01             	cmp    $0x1,%eax
c00244e7:	75 60                	jne    c0024549 <timer_calibrate+0x7c>
    printf("Calibrating timer...  ");
c00244e9:	83 ec 0c             	sub    $0xc,%esp
c00244ec:	8d 83 b2 45 ff ff    	lea    -0xba4e(%ebx),%eax
c00244f2:	50                   	push   %eax
c00244f3:	e8 d9 2f 00 00       	call   c00274d1 <printf>
    loops_per_tick = 1u << 10;
c00244f8:	c7 83 cc 18 00 00 00 	movl   $0x400,0x18cc(%ebx)
c00244ff:	04 00 00 
    while (!too_many_loops(loops_per_tick << 1)) {
c0024502:	83 c4 10             	add    $0x10,%esp
c0024505:	8b bb cc 18 00 00    	mov    0x18cc(%ebx),%edi
c002450b:	8d 34 3f             	lea    (%edi,%edi,1),%esi
c002450e:	89 f0                	mov    %esi,%eax
c0024510:	e8 6f fd ff ff       	call   c0024284 <too_many_loops>
c0024515:	84 c0                	test   %al,%al
c0024517:	75 56                	jne    c002456f <timer_calibrate+0xa2>
        loops_per_tick <<= 1;
c0024519:	89 b3 cc 18 00 00    	mov    %esi,0x18cc(%ebx)
        ASSERT (loops_per_tick != 0);
c002451f:	85 f6                	test   %esi,%esi
c0024521:	75 e2                	jne    c0024505 <timer_calibrate+0x38>
c0024523:	83 ec 0c             	sub    $0xc,%esp
c0024526:	8d 83 c9 45 ff ff    	lea    -0xba37(%ebx),%eax
c002452c:	50                   	push   %eax
c002452d:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0024533:	50                   	push   %eax
c0024534:	8d 83 10 28 ff ff    	lea    -0xd7f0(%ebx),%eax
c002453a:	50                   	push   %eax
c002453b:	6a 3c                	push   $0x3c
c002453d:	8d 83 75 45 ff ff    	lea    -0xba8b(%ebx),%eax
c0024543:	50                   	push   %eax
c0024544:	e8 e4 4b 00 00       	call   c002912d <debug_panic>
    ASSERT (intr_get_level() == INTR_ON);
c0024549:	83 ec 0c             	sub    $0xc,%esp
c002454c:	8d 83 96 45 ff ff    	lea    -0xba6a(%ebx),%eax
c0024552:	50                   	push   %eax
c0024553:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0024559:	50                   	push   %eax
c002455a:	8d 83 10 28 ff ff    	lea    -0xd7f0(%ebx),%eax
c0024560:	50                   	push   %eax
c0024561:	6a 34                	push   $0x34
c0024563:	8d 83 75 45 ff ff    	lea    -0xba8b(%ebx),%eax
c0024569:	50                   	push   %eax
c002456a:	e8 be 4b 00 00       	call   c002912d <debug_panic>
    for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c002456f:	89 fe                	mov    %edi,%esi
c0024571:	d1 ee                	shr    %esi
c0024573:	89 fd                	mov    %edi,%ebp
c0024575:	c1 ed 0a             	shr    $0xa,%ebp
c0024578:	39 f5                	cmp    %esi,%ebp
c002457a:	75 2a                	jne    c00245a6 <timer_calibrate+0xd9>
    printf("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c002457c:	83 ec 04             	sub    $0x4,%esp
c002457f:	b8 64 00 00 00       	mov    $0x64,%eax
c0024584:	f7 a3 cc 18 00 00    	mull   0x18cc(%ebx)
c002458a:	52                   	push   %edx
c002458b:	50                   	push   %eax
c002458c:	8d 83 dd 45 ff ff    	lea    -0xba23(%ebx),%eax
c0024592:	50                   	push   %eax
c0024593:	e8 39 2f 00 00       	call   c00274d1 <printf>
}
c0024598:	83 c4 1c             	add    $0x1c,%esp
c002459b:	5b                   	pop    %ebx
c002459c:	5e                   	pop    %esi
c002459d:	5f                   	pop    %edi
c002459e:	5d                   	pop    %ebp
c002459f:	c3                   	ret    
    for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00245a0:	d1 ee                	shr    %esi
c00245a2:	39 f5                	cmp    %esi,%ebp
c00245a4:	74 d6                	je     c002457c <timer_calibrate+0xaf>
        if (!too_many_loops(high_bit | test_bit))
c00245a6:	89 f8                	mov    %edi,%eax
c00245a8:	09 f0                	or     %esi,%eax
c00245aa:	e8 d5 fc ff ff       	call   c0024284 <too_many_loops>
c00245af:	84 c0                	test   %al,%al
c00245b1:	75 ed                	jne    c00245a0 <timer_calibrate+0xd3>
            loops_per_tick |= test_bit;
c00245b3:	09 b3 cc 18 00 00    	or     %esi,0x18cc(%ebx)
c00245b9:	eb e5                	jmp    c00245a0 <timer_calibrate+0xd3>

c00245bb <timer_ticks>:
timer_ticks(void) {
c00245bb:	57                   	push   %edi
c00245bc:	56                   	push   %esi
c00245bd:	53                   	push   %ebx
c00245be:	e8 80 bb 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00245c3:	81 c3 e9 96 01 00    	add    $0x196e9,%ebx
    enum intr_level old_level = intr_disable(); // ensure this process is not interrupted
c00245c9:	e8 94 d7 ff ff       	call   c0021d62 <intr_disable>
    int64_t t = ticks;
c00245ce:	8b b3 d4 18 00 00    	mov    0x18d4(%ebx),%esi
c00245d4:	8b bb d8 18 00 00    	mov    0x18d8(%ebx),%edi
    intr_set_level(old_level);
c00245da:	83 ec 0c             	sub    $0xc,%esp
c00245dd:	50                   	push   %eax
c00245de:	e8 86 d7 ff ff       	call   c0021d69 <intr_set_level>
    return t;
c00245e3:	83 c4 10             	add    $0x10,%esp
}
c00245e6:	89 f0                	mov    %esi,%eax
c00245e8:	89 fa                	mov    %edi,%edx
c00245ea:	5b                   	pop    %ebx
c00245eb:	5e                   	pop    %esi
c00245ec:	5f                   	pop    %edi
c00245ed:	c3                   	ret    

c00245ee <timer_elapsed>:
timer_elapsed(int64_t then) {
c00245ee:	57                   	push   %edi
c00245ef:	56                   	push   %esi
c00245f0:	83 ec 04             	sub    $0x4,%esp
c00245f3:	8b 74 24 10          	mov    0x10(%esp),%esi
c00245f7:	8b 7c 24 14          	mov    0x14(%esp),%edi
    return timer_ticks() - then;
c00245fb:	e8 bb ff ff ff       	call   c00245bb <timer_ticks>
c0024600:	29 f0                	sub    %esi,%eax
c0024602:	19 fa                	sbb    %edi,%edx
}
c0024604:	83 c4 04             	add    $0x4,%esp
c0024607:	5e                   	pop    %esi
c0024608:	5f                   	pop    %edi
c0024609:	c3                   	ret    

c002460a <timer_sleep>:
timer_sleep(int64_t ticks) {
c002460a:	55                   	push   %ebp
c002460b:	57                   	push   %edi
c002460c:	56                   	push   %esi
c002460d:	53                   	push   %ebx
c002460e:	83 ec 0c             	sub    $0xc,%esp
c0024611:	e8 2d bb 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024616:	81 c3 96 96 01 00    	add    $0x19696,%ebx
c002461c:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0024620:	8b 74 24 24          	mov    0x24(%esp),%esi
    if (ticks <= 0) {
c0024624:	b8 00 00 00 00       	mov    $0x0,%eax
c0024629:	39 f8                	cmp    %edi,%eax
c002462b:	19 f0                	sbb    %esi,%eax
c002462d:	7d 38                	jge    c0024667 <timer_sleep+0x5d>
    int64_t start = timer_ticks();
c002462f:	e8 87 ff ff ff       	call   c00245bb <timer_ticks>
    ASSERT (intr_get_level() == INTR_ON);
c0024634:	e8 d7 d6 ff ff       	call   c0021d10 <intr_get_level>
c0024639:	83 f8 01             	cmp    $0x1,%eax
c002463c:	75 31                	jne    c002466f <timer_sleep+0x65>
    enum intr_level old_level = intr_disable();
c002463e:	e8 1f d7 ff ff       	call   c0021d62 <intr_disable>
c0024643:	89 c5                	mov    %eax,%ebp
    struct thread *cur = thread_current();
c0024645:	e8 7f c9 ff ff       	call   c0020fc9 <thread_current>
    cur->ticks_blocked = ticks;
c002464a:	89 b8 e4 00 00 00    	mov    %edi,0xe4(%eax)
c0024650:	89 b0 e8 00 00 00    	mov    %esi,0xe8(%eax)
    thread_block();
c0024656:	e8 0d cf ff ff       	call   c0021568 <thread_block>
    intr_set_level(old_level);
c002465b:	83 ec 0c             	sub    $0xc,%esp
c002465e:	55                   	push   %ebp
c002465f:	e8 05 d7 ff ff       	call   c0021d69 <intr_set_level>
c0024664:	83 c4 10             	add    $0x10,%esp
}
c0024667:	83 c4 0c             	add    $0xc,%esp
c002466a:	5b                   	pop    %ebx
c002466b:	5e                   	pop    %esi
c002466c:	5f                   	pop    %edi
c002466d:	5d                   	pop    %ebp
c002466e:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c002466f:	83 ec 0c             	sub    $0xc,%esp
c0024672:	8d 83 96 45 ff ff    	lea    -0xba6a(%ebx),%eax
c0024678:	50                   	push   %eax
c0024679:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002467f:	50                   	push   %eax
c0024680:	8d 83 04 28 ff ff    	lea    -0xd7fc(%ebx),%eax
c0024686:	50                   	push   %eax
c0024687:	6a 62                	push   $0x62
c0024689:	8d 83 75 45 ff ff    	lea    -0xba8b(%ebx),%eax
c002468f:	50                   	push   %eax
c0024690:	e8 98 4a 00 00       	call   c002912d <debug_panic>

c0024695 <real_time_sleep>:
real_time_sleep(int64_t num, int32_t denom) {
c0024695:	55                   	push   %ebp
c0024696:	57                   	push   %edi
c0024697:	56                   	push   %esi
c0024698:	53                   	push   %ebx
c0024699:	83 ec 1c             	sub    $0x1c,%esp
c002469c:	e8 a2 ba 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00246a1:	81 c3 0b 96 01 00    	add    $0x1960b,%ebx
c00246a7:	89 c6                	mov    %eax,%esi
c00246a9:	89 44 24 08          	mov    %eax,0x8(%esp)
c00246ad:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00246b1:	89 cd                	mov    %ecx,%ebp
    int64_t ticks = num * TIMER_FREQ / denom;
c00246b3:	6b ca 64             	imul   $0x64,%edx,%ecx
c00246b6:	b8 64 00 00 00       	mov    $0x64,%eax
c00246bb:	f7 e6                	mul    %esi
c00246bd:	01 ca                	add    %ecx,%edx
c00246bf:	89 ef                	mov    %ebp,%edi
c00246c1:	c1 ff 1f             	sar    $0x1f,%edi
c00246c4:	57                   	push   %edi
c00246c5:	55                   	push   %ebp
c00246c6:	52                   	push   %edx
c00246c7:	50                   	push   %eax
c00246c8:	e8 2a 44 00 00       	call   c0028af7 <__divdi3>
c00246cd:	83 c4 10             	add    $0x10,%esp
c00246d0:	89 c6                	mov    %eax,%esi
c00246d2:	89 d7                	mov    %edx,%edi
    ASSERT (intr_get_level() == INTR_ON);
c00246d4:	e8 37 d6 ff ff       	call   c0021d10 <intr_get_level>
c00246d9:	83 f8 01             	cmp    $0x1,%eax
c00246dc:	75 20                	jne    c00246fe <real_time_sleep+0x69>
    if (ticks > 0) {
c00246de:	b8 00 00 00 00       	mov    $0x0,%eax
c00246e3:	39 f0                	cmp    %esi,%eax
c00246e5:	19 f8                	sbb    %edi,%eax
c00246e7:	7d 3e                	jge    c0024727 <real_time_sleep+0x92>
        timer_sleep(ticks);
c00246e9:	83 ec 08             	sub    $0x8,%esp
c00246ec:	57                   	push   %edi
c00246ed:	56                   	push   %esi
c00246ee:	e8 17 ff ff ff       	call   c002460a <timer_sleep>
c00246f3:	83 c4 10             	add    $0x10,%esp
}
c00246f6:	83 c4 1c             	add    $0x1c,%esp
c00246f9:	5b                   	pop    %ebx
c00246fa:	5e                   	pop    %esi
c00246fb:	5f                   	pop    %edi
c00246fc:	5d                   	pop    %ebp
c00246fd:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c00246fe:	83 ec 0c             	sub    $0xc,%esp
c0024701:	8d 83 96 45 ff ff    	lea    -0xba6a(%ebx),%eax
c0024707:	50                   	push   %eax
c0024708:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002470e:	50                   	push   %eax
c002470f:	8d 83 f4 27 ff ff    	lea    -0xd80c(%ebx),%eax
c0024715:	50                   	push   %eax
c0024716:	68 f6 00 00 00       	push   $0xf6
c002471b:	8d 83 75 45 ff ff    	lea    -0xba8b(%ebx),%eax
c0024721:	50                   	push   %eax
c0024722:	e8 06 4a 00 00       	call   c002912d <debug_panic>
        real_time_delay(num, denom);
c0024727:	89 e9                	mov    %ebp,%ecx
c0024729:	8b 44 24 08          	mov    0x8(%esp),%eax
c002472d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0024731:	e8 40 fc ff ff       	call   c0024376 <real_time_delay>
}
c0024736:	eb be                	jmp    c00246f6 <real_time_sleep+0x61>

c0024738 <timer_msleep>:
timer_msleep(int64_t ms) {
c0024738:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(ms, 1000);
c002473b:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024740:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024744:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024748:	e8 48 ff ff ff       	call   c0024695 <real_time_sleep>
}
c002474d:	83 c4 0c             	add    $0xc,%esp
c0024750:	c3                   	ret    

c0024751 <timer_usleep>:
timer_usleep(int64_t us) {
c0024751:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(us, 1000 * 1000);
c0024754:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024759:	8b 44 24 10          	mov    0x10(%esp),%eax
c002475d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024761:	e8 2f ff ff ff       	call   c0024695 <real_time_sleep>
}
c0024766:	83 c4 0c             	add    $0xc,%esp
c0024769:	c3                   	ret    

c002476a <timer_nsleep>:
timer_nsleep(int64_t ns) {
c002476a:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(ns, 1000 * 1000 * 1000);
c002476d:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024772:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024776:	8b 54 24 14          	mov    0x14(%esp),%edx
c002477a:	e8 16 ff ff ff       	call   c0024695 <real_time_sleep>
}
c002477f:	83 c4 0c             	add    $0xc,%esp
c0024782:	c3                   	ret    

c0024783 <timer_mdelay>:
timer_mdelay(int64_t ms) {
c0024783:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(ms, 1000);
c0024786:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002478b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002478f:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024793:	e8 de fb ff ff       	call   c0024376 <real_time_delay>
}
c0024798:	83 c4 0c             	add    $0xc,%esp
c002479b:	c3                   	ret    

c002479c <timer_udelay>:
timer_udelay(int64_t us) {
c002479c:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(us, 1000 * 1000);
c002479f:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c00247a4:	8b 44 24 10          	mov    0x10(%esp),%eax
c00247a8:	8b 54 24 14          	mov    0x14(%esp),%edx
c00247ac:	e8 c5 fb ff ff       	call   c0024376 <real_time_delay>
}
c00247b1:	83 c4 0c             	add    $0xc,%esp
c00247b4:	c3                   	ret    

c00247b5 <timer_ndelay>:
timer_ndelay(int64_t ns) {
c00247b5:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(ns, 1000 * 1000 * 1000);
c00247b8:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c00247bd:	8b 44 24 10          	mov    0x10(%esp),%eax
c00247c1:	8b 54 24 14          	mov    0x14(%esp),%edx
c00247c5:	e8 ac fb ff ff       	call   c0024376 <real_time_delay>
}
c00247ca:	83 c4 0c             	add    $0xc,%esp
c00247cd:	c3                   	ret    

c00247ce <timer_print_stats>:
timer_print_stats(void) {
c00247ce:	53                   	push   %ebx
c00247cf:	83 ec 08             	sub    $0x8,%esp
c00247d2:	e8 6c b9 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00247d7:	81 c3 d5 94 01 00    	add    $0x194d5,%ebx
    printf("Timer: %"PRId64" ticks\n", timer_ticks());
c00247dd:	e8 d9 fd ff ff       	call   c00245bb <timer_ticks>
c00247e2:	83 ec 04             	sub    $0x4,%esp
c00247e5:	52                   	push   %edx
c00247e6:	50                   	push   %eax
c00247e7:	8d 83 ed 45 ff ff    	lea    -0xba13(%ebx),%eax
c00247ed:	50                   	push   %eax
c00247ee:	e8 de 2c 00 00       	call   c00274d1 <printf>
}
c00247f3:	83 c4 18             	add    $0x18,%esp
c00247f6:	5b                   	pop    %ebx
c00247f7:	c3                   	ret    

c00247f8 <map_key>:
/* Scans the array of keymaps K for SCANCODE.
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key(const struct keymap k[], unsigned scancode, uint8_t *c) {
c00247f8:	55                   	push   %ebp
c00247f9:	57                   	push   %edi
c00247fa:	56                   	push   %esi
c00247fb:	53                   	push   %ebx
c00247fc:	83 ec 04             	sub    $0x4,%esp
c00247ff:	89 0c 24             	mov    %ecx,(%esp)
    for (; k->first_scancode != 0; k++)
c0024802:	0f b6 18             	movzbl (%eax),%ebx
c0024805:	84 db                	test   %bl,%bl
c0024807:	74 50                	je     c0024859 <map_key+0x61>
c0024809:	89 c6                	mov    %eax,%esi
        if (scancode >= k->first_scancode
            && scancode < k->first_scancode + strlen(k->chars)) {
c002480b:	b8 00 00 00 00       	mov    $0x0,%eax
c0024810:	eb 0a                	jmp    c002481c <map_key+0x24>
    for (; k->first_scancode != 0; k++)
c0024812:	83 c6 08             	add    $0x8,%esi
c0024815:	0f b6 1e             	movzbl (%esi),%ebx
c0024818:	84 db                	test   %bl,%bl
c002481a:	74 30                	je     c002484c <map_key+0x54>
        if (scancode >= k->first_scancode
c002481c:	0f b6 db             	movzbl %bl,%ebx
c002481f:	39 d3                	cmp    %edx,%ebx
c0024821:	77 ef                	ja     c0024812 <map_key+0x1a>
            && scancode < k->first_scancode + strlen(k->chars)) {
c0024823:	8b 6e 04             	mov    0x4(%esi),%ebp
c0024826:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002482b:	89 ef                	mov    %ebp,%edi
c002482d:	f2 ae                	repnz scas %es:(%edi),%al
c002482f:	f7 d1                	not    %ecx
c0024831:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c0024835:	39 d1                	cmp    %edx,%ecx
c0024837:	76 d9                	jbe    c0024812 <map_key+0x1a>
            *c = k->chars[scancode - k->first_scancode];
c0024839:	29 da                	sub    %ebx,%edx
c002483b:	0f b6 44 15 00       	movzbl 0x0(%ebp,%edx,1),%eax
c0024840:	8b 3c 24             	mov    (%esp),%edi
c0024843:	88 07                	mov    %al,(%edi)
            return true;
c0024845:	b8 01 00 00 00       	mov    $0x1,%eax
c002484a:	eb 05                	jmp    c0024851 <map_key+0x59>
        }

    return false;
c002484c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024851:	83 c4 04             	add    $0x4,%esp
c0024854:	5b                   	pop    %ebx
c0024855:	5e                   	pop    %esi
c0024856:	5f                   	pop    %edi
c0024857:	5d                   	pop    %ebp
c0024858:	c3                   	ret    
    return false;
c0024859:	b8 00 00 00 00       	mov    $0x0,%eax
c002485e:	eb f1                	jmp    c0024851 <map_key+0x59>

c0024860 <keyboard_interrupt>:
keyboard_interrupt(struct intr_frame *args UNUSED) {
c0024860:	55                   	push   %ebp
c0024861:	57                   	push   %edi
c0024862:	56                   	push   %esi
c0024863:	53                   	push   %ebx
c0024864:	83 ec 2c             	sub    $0x2c,%esp
c0024867:	e8 d7 b8 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002486c:	81 c3 40 94 01 00    	add    $0x19440,%ebx
    bool shift = left_shift || right_shift;
c0024872:	ba 01 00 00 00       	mov    $0x1,%edx
c0024877:	80 bb ea 18 00 00 00 	cmpb   $0x0,0x18ea(%ebx)
c002487e:	75 07                	jne    c0024887 <keyboard_interrupt+0x27>
c0024880:	0f b6 93 e9 18 00 00 	movzbl 0x18e9(%ebx),%edx
    bool alt = left_alt || right_alt;
c0024887:	bd 01 00 00 00       	mov    $0x1,%ebp
c002488c:	80 bb e8 18 00 00 00 	cmpb   $0x0,0x18e8(%ebx)
c0024893:	75 07                	jne    c002489c <keyboard_interrupt+0x3c>
c0024895:	0f b6 ab e7 18 00 00 	movzbl 0x18e7(%ebx),%ebp
    bool ctrl = left_ctrl || right_ctrl;
c002489c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c00248a3:	00 
c00248a4:	80 bb e6 18 00 00 00 	cmpb   $0x0,0x18e6(%ebx)
c00248ab:	75 0b                	jne    c00248b8 <keyboard_interrupt+0x58>
c00248ad:	0f b6 83 e5 18 00 00 	movzbl 0x18e5(%ebx),%eax
c00248b4:	89 44 24 08          	mov    %eax,0x8(%esp)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00248b8:	e4 60                	in     $0x60,%al
    code = inb(DATA_REG);
c00248ba:	0f b6 f0             	movzbl %al,%esi
    if (code == 0xe0)
c00248bd:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
c00248c3:	74 24                	je     c00248e9 <keyboard_interrupt+0x89>
    release = (code & 0x80) != 0;
c00248c5:	83 e0 80             	and    $0xffffff80,%eax
c00248c8:	0f b6 f8             	movzbl %al,%edi
    code &= ~0x80u;
c00248cb:	81 e6 7f ff ff ff    	and    $0xffffff7f,%esi
    if (code == 0x3a) {
c00248d1:	83 fe 3a             	cmp    $0x3a,%esi
c00248d4:	75 25                	jne    c00248fb <keyboard_interrupt+0x9b>
        if (!release)
c00248d6:	85 ff                	test   %edi,%edi
c00248d8:	75 07                	jne    c00248e1 <keyboard_interrupt+0x81>
            caps_lock = !caps_lock;
c00248da:	80 b3 e4 18 00 00 01 	xorb   $0x1,0x18e4(%ebx)
}
c00248e1:	83 c4 2c             	add    $0x2c,%esp
c00248e4:	5b                   	pop    %ebx
c00248e5:	5e                   	pop    %esi
c00248e6:	5f                   	pop    %edi
c00248e7:	5d                   	pop    %ebp
c00248e8:	c3                   	ret    
c00248e9:	e4 60                	in     $0x60,%al
    release = (code & 0x80) != 0;
c00248eb:	89 c1                	mov    %eax,%ecx
c00248ed:	83 e1 80             	and    $0xffffff80,%ecx
c00248f0:	0f b6 f9             	movzbl %cl,%edi
    code &= ~0x80u;
c00248f3:	83 e0 7f             	and    $0x7f,%eax
c00248f6:	80 cc e0             	or     $0xe0,%ah
c00248f9:	89 c6                	mov    %eax,%esi
    bool shift = left_shift || right_shift;
c00248fb:	89 d0                	mov    %edx,%eax
c00248fd:	83 e0 01             	and    $0x1,%eax
c0024900:	88 44 24 0f          	mov    %al,0xf(%esp)
    } else if (map_key(invariant_keymap, code, &c)
c0024904:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024908:	89 f2                	mov    %esi,%edx
c002490a:	8d 83 14 60 ff ff    	lea    -0x9fec(%ebx),%eax
c0024910:	e8 e3 fe ff ff       	call   c00247f8 <map_key>
c0024915:	84 c0                	test   %al,%al
c0024917:	75 57                	jne    c0024970 <keyboard_interrupt+0x110>
               || (!shift && map_key(unshifted_keymap, code, &c))
c0024919:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c002491e:	74 3b                	je     c002495b <keyboard_interrupt+0xfb>
               || (shift && map_key(shifted_keymap, code, &c))) {
c0024920:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024924:	89 f2                	mov    %esi,%edx
c0024926:	8d 83 94 5f ff ff    	lea    -0xa06c(%ebx),%eax
c002492c:	e8 c7 fe ff ff       	call   c00247f8 <map_key>
c0024931:	84 c0                	test   %al,%al
c0024933:	75 3b                	jne    c0024970 <keyboard_interrupt+0x110>
            if (key->scancode == code) {
c0024935:	83 fe 2a             	cmp    $0x2a,%esi
c0024938:	0f 84 da 00 00 00    	je     c0024a18 <keyboard_interrupt+0x1b8>
        for (key = shift_keys; key->scancode != 0; key++)
c002493e:	8d 83 54 5f ff ff    	lea    -0xa0ac(%ebx),%eax
c0024944:	83 c0 08             	add    $0x8,%eax
c0024947:	8b 10                	mov    (%eax),%edx
c0024949:	85 d2                	test   %edx,%edx
c002494b:	74 94                	je     c00248e1 <keyboard_interrupt+0x81>
            if (key->scancode == code) {
c002494d:	39 f2                	cmp    %esi,%edx
c002494f:	75 f3                	jne    c0024944 <keyboard_interrupt+0xe4>
                *key->state_var = !release;
c0024951:	8b 40 04             	mov    0x4(%eax),%eax
c0024954:	85 ff                	test   %edi,%edi
c0024956:	0f 94 00             	sete   (%eax)
                break;
c0024959:	eb 86                	jmp    c00248e1 <keyboard_interrupt+0x81>
               || (!shift && map_key(unshifted_keymap, code, &c))
c002495b:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c002495f:	89 f2                	mov    %esi,%edx
c0024961:	8d 83 d4 5f ff ff    	lea    -0xa02c(%ebx),%eax
c0024967:	e8 8c fe ff ff       	call   c00247f8 <map_key>
c002496c:	84 c0                	test   %al,%al
c002496e:	74 c5                	je     c0024935 <keyboard_interrupt+0xd5>
        if (!release) {
c0024970:	85 ff                	test   %edi,%edi
c0024972:	0f 85 69 ff ff ff    	jne    c00248e1 <keyboard_interrupt+0x81>
            if (c == 0177 && ctrl && alt)
c0024978:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
c002497d:	3c 7f                	cmp    $0x7f,%al
c002497f:	74 5a                	je     c00249db <keyboard_interrupt+0x17b>
            if (ctrl && c >= 0x40 && c < 0x60) {
c0024981:	8d 50 c0             	lea    -0x40(%eax),%edx
c0024984:	80 fa 1f             	cmp    $0x1f,%dl
c0024987:	77 07                	ja     c0024990 <keyboard_interrupt+0x130>
c0024989:	f6 44 24 08 01       	testb  $0x1,0x8(%esp)
c002498e:	75 6d                	jne    c00249fd <keyboard_interrupt+0x19d>
            } else if (shift == caps_lock)
c0024990:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024995:	38 8b e4 18 00 00    	cmp    %cl,0x18e4(%ebx)
c002499b:	74 66                	je     c0024a03 <keyboard_interrupt+0x1a3>
            if (alt)
c002499d:	f7 c5 01 00 00 00    	test   $0x1,%ebp
c00249a3:	74 05                	je     c00249aa <keyboard_interrupt+0x14a>
                c += 0x80;
c00249a5:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
            if (!input_full()) {
c00249aa:	e8 9a 1c 00 00       	call   c0026649 <input_full>
c00249af:	84 c0                	test   %al,%al
c00249b1:	0f 85 2a ff ff ff    	jne    c00248e1 <keyboard_interrupt+0x81>
                key_cnt++;
c00249b7:	83 83 dc 18 00 00 01 	addl   $0x1,0x18dc(%ebx)
c00249be:	83 93 e0 18 00 00 00 	adcl   $0x0,0x18e0(%ebx)
                input_putc(c);
c00249c5:	83 ec 0c             	sub    $0xc,%esp
c00249c8:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c00249cd:	50                   	push   %eax
c00249ce:	e8 9b 1b 00 00       	call   c002656e <input_putc>
c00249d3:	83 c4 10             	add    $0x10,%esp
c00249d6:	e9 06 ff ff ff       	jmp    c00248e1 <keyboard_interrupt+0x81>
            if (c == 0177 && ctrl && alt)
c00249db:	8b 54 24 08          	mov    0x8(%esp),%edx
c00249df:	21 ea                	and    %ebp,%edx
c00249e1:	f6 c2 01             	test   $0x1,%dl
c00249e4:	75 12                	jne    c00249f8 <keyboard_interrupt+0x198>
            } else if (shift == caps_lock)
c00249e6:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c00249eb:	3a 8b e4 18 00 00    	cmp    0x18e4(%ebx),%cl
c00249f1:	75 aa                	jne    c002499d <keyboard_interrupt+0x13d>
                c = tolower(c);
c00249f3:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c00249f6:	eb 1a                	jmp    c0024a12 <keyboard_interrupt+0x1b2>
                shutdown_reboot();
c00249f8:	e8 3f 22 00 00       	call   c0026c3c <shutdown_reboot>
                c -= 0x40;
c00249fd:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c0024a01:	eb 9a                	jmp    c002499d <keyboard_interrupt+0x13d>
                c = tolower(c);
c0024a03:	0f b6 c0             	movzbl %al,%eax
c0024a06:	8d 48 bf             	lea    -0x41(%eax),%ecx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0024a09:	8d 50 20             	lea    0x20(%eax),%edx
c0024a0c:	83 f9 1a             	cmp    $0x1a,%ecx
c0024a0f:	0f 42 c2             	cmovb  %edx,%eax
c0024a12:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0024a16:	eb 85                	jmp    c002499d <keyboard_interrupt+0x13d>
        for (key = shift_keys; key->scancode != 0; key++)
c0024a18:	8d 83 54 5f ff ff    	lea    -0xa0ac(%ebx),%eax
c0024a1e:	e9 2e ff ff ff       	jmp    c0024951 <keyboard_interrupt+0xf1>

c0024a23 <kbd_init>:
kbd_init(void) {
c0024a23:	53                   	push   %ebx
c0024a24:	83 ec 0c             	sub    $0xc,%esp
c0024a27:	e8 17 b7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024a2c:	81 c3 80 92 01 00    	add    $0x19280,%ebx
    intr_register_ext(0x21, keyboard_interrupt, "8042 Keyboard");
c0024a32:	8d 83 00 46 ff ff    	lea    -0xba00(%ebx),%eax
c0024a38:	50                   	push   %eax
c0024a39:	8d 83 b4 6b fe ff    	lea    -0x1944c(%ebx),%eax
c0024a3f:	50                   	push   %eax
c0024a40:	6a 21                	push   $0x21
c0024a42:	e8 f7 d4 ff ff       	call   c0021f3e <intr_register_ext>
}
c0024a47:	83 c4 18             	add    $0x18,%esp
c0024a4a:	5b                   	pop    %ebx
c0024a4b:	c3                   	ret    

c0024a4c <kbd_print_stats>:
kbd_print_stats(void) {
c0024a4c:	53                   	push   %ebx
c0024a4d:	83 ec 0c             	sub    $0xc,%esp
c0024a50:	e8 ee b6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024a55:	81 c3 57 92 01 00    	add    $0x19257,%ebx
    printf("Keyboard: %lld keys pressed\n", key_cnt);
c0024a5b:	ff b3 e0 18 00 00    	pushl  0x18e0(%ebx)
c0024a61:	ff b3 dc 18 00 00    	pushl  0x18dc(%ebx)
c0024a67:	8d 83 0e 46 ff ff    	lea    -0xb9f2(%ebx),%eax
c0024a6d:	50                   	push   %eax
c0024a6e:	e8 5e 2a 00 00       	call   c00274d1 <printf>
}
c0024a73:	83 c4 18             	add    $0x18,%esp
c0024a76:	5b                   	pop    %ebx
c0024a77:	c3                   	ret    

c0024a78 <move_cursor>:
    }
}

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor(void) {
c0024a78:	e8 ca b6 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c0024a7d:	05 2f 92 01 00       	add    $0x1922f,%eax
    /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
    uint16_t cp = cx + COL_CNT * cy;
c0024a82:	8b 88 f4 18 00 00    	mov    0x18f4(%eax),%ecx
c0024a88:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0024a8b:	c1 e1 04             	shl    $0x4,%ecx
c0024a8e:	66 03 88 f8 18 00 00 	add    0x18f8(%eax),%cx
    outw(0x3d4, 0x0e | (cp & 0xff00));
c0024a95:	89 c8                	mov    %ecx,%eax
c0024a97:	b0 00                	mov    $0x0,%al
c0024a99:	83 c8 0e             	or     $0xe,%eax

/* Writes the 16-bit DATA to PORT. */
static inline void
outw(uint16_t port, uint16_t data) {
    /* See [IA32-v2b] "OUT". */
    asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024a9c:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024aa1:	66 ef                	out    %ax,(%dx)
    outw(0x3d4, 0x0f | (cp << 8));
c0024aa3:	89 c8                	mov    %ecx,%eax
c0024aa5:	c1 e0 08             	shl    $0x8,%eax
c0024aa8:	83 c8 0f             	or     $0xf,%eax
c0024aab:	66 ef                	out    %ax,(%dx)
}
c0024aad:	c3                   	ret    

c0024aae <newline>:
newline(void) {
c0024aae:	56                   	push   %esi
c0024aaf:	53                   	push   %ebx
c0024ab0:	83 ec 04             	sub    $0x4,%esp
c0024ab3:	e8 8b b6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024ab8:	81 c3 f4 91 01 00    	add    $0x191f4,%ebx
    cx = 0;
c0024abe:	c7 83 f8 18 00 00 00 	movl   $0x0,0x18f8(%ebx)
c0024ac5:	00 00 00 
    cy++;
c0024ac8:	8b 83 f4 18 00 00    	mov    0x18f4(%ebx),%eax
c0024ace:	83 c0 01             	add    $0x1,%eax
    if (cy >= ROW_CNT) {
c0024ad1:	83 f8 18             	cmp    $0x18,%eax
c0024ad4:	77 0c                	ja     c0024ae2 <newline+0x34>
    cy++;
c0024ad6:	89 83 f4 18 00 00    	mov    %eax,0x18f4(%ebx)
}
c0024adc:	83 c4 04             	add    $0x4,%esp
c0024adf:	5b                   	pop    %ebx
c0024ae0:	5e                   	pop    %esi
c0024ae1:	c3                   	ret    
        cy = ROW_CNT - 1;
c0024ae2:	c7 83 f4 18 00 00 18 	movl   $0x18,0x18f4(%ebx)
c0024ae9:	00 00 00 
        memmove(&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024aec:	8b b3 f0 18 00 00    	mov    0x18f0(%ebx),%esi
c0024af2:	83 ec 04             	sub    $0x4,%esp
c0024af5:	68 00 0f 00 00       	push   $0xf00
c0024afa:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0024b00:	50                   	push   %eax
c0024b01:	56                   	push   %esi
c0024b02:	e8 41 38 00 00       	call   c0028348 <memmove>
    for (x = 0; x < COL_CNT; x++) {
c0024b07:	8d 86 00 0f 00 00    	lea    0xf00(%esi),%eax
c0024b0d:	81 c6 a0 0f 00 00    	add    $0xfa0,%esi
c0024b13:	83 c4 10             	add    $0x10,%esp
        fb[y][x][0] = ' ';
c0024b16:	c6 00 20             	movb   $0x20,(%eax)
        fb[y][x][1] = GRAY_ON_BLACK;
c0024b19:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024b1d:	83 c0 02             	add    $0x2,%eax
    for (x = 0; x < COL_CNT; x++) {
c0024b20:	39 f0                	cmp    %esi,%eax
c0024b22:	75 f2                	jne    c0024b16 <newline+0x68>
c0024b24:	eb b6                	jmp    c0024adc <newline+0x2e>

c0024b26 <vga_putc>:
vga_putc(int c) {
c0024b26:	55                   	push   %ebp
c0024b27:	57                   	push   %edi
c0024b28:	56                   	push   %esi
c0024b29:	53                   	push   %ebx
c0024b2a:	83 ec 0c             	sub    $0xc,%esp
c0024b2d:	e8 11 b6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024b32:	81 c3 7a 91 01 00    	add    $0x1917a,%ebx
    enum intr_level old_level = intr_disable();
c0024b38:	e8 25 d2 ff ff       	call   c0021d62 <intr_disable>
c0024b3d:	89 c6                	mov    %eax,%esi
    if (!inited) {
c0024b3f:	80 bb ec 18 00 00 00 	cmpb   $0x0,0x18ec(%ebx)
c0024b46:	74 1b                	je     c0024b63 <vga_putc+0x3d>
    switch (c) {
c0024b48:	8b 44 24 20          	mov    0x20(%esp),%eax
c0024b4c:	83 e8 07             	sub    $0x7,%eax
c0024b4f:	83 f8 06             	cmp    $0x6,%eax
c0024b52:	0f 87 23 01 00 00    	ja     c0024c7b <.L11>
c0024b58:	89 df                	mov    %ebx,%edi
c0024b5a:	03 bc 83 20 28 ff ff 	add    -0xd7e0(%ebx,%eax,4),%edi
c0024b61:	ff e7                	jmp    *%edi
        fb = ptov(0xb8000);
c0024b63:	c7 83 f0 18 00 00 00 	movl   $0xc00b8000,0x18f0(%ebx)
c0024b6a:	80 0b c0 
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024b6d:	bd d4 03 00 00       	mov    $0x3d4,%ebp
c0024b72:	b8 0e 00 00 00       	mov    $0xe,%eax
c0024b77:	89 ea                	mov    %ebp,%edx
c0024b79:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024b7a:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0024b7f:	89 ca                	mov    %ecx,%edx
c0024b81:	ec                   	in     (%dx),%al
find_cursor(size_t *x, size_t *y) {
    /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
    uint16_t cp;

    outb(0x3d4, 0x0e);
    cp = inb(0x3d5) << 8;
c0024b82:	89 c7                	mov    %eax,%edi
c0024b84:	c1 e7 08             	shl    $0x8,%edi
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024b87:	b8 0f 00 00 00       	mov    $0xf,%eax
c0024b8c:	89 ea                	mov    %ebp,%edx
c0024b8e:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024b8f:	89 ca                	mov    %ecx,%edx
c0024b91:	ec                   	in     (%dx),%al

    outb(0x3d4, 0x0f);
    cp |= inb(0x3d5);
c0024b92:	0f b6 c0             	movzbl %al,%eax
c0024b95:	09 c7                	or     %eax,%edi

    *x = cp % COL_CNT;
c0024b97:	0f b7 c7             	movzwl %di,%eax
c0024b9a:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c0024ba0:	c1 e8 16             	shr    $0x16,%eax
c0024ba3:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0024ba6:	c1 e2 04             	shl    $0x4,%edx
c0024ba9:	29 d7                	sub    %edx,%edi
c0024bab:	0f b7 ff             	movzwl %di,%edi
c0024bae:	89 bb f8 18 00 00    	mov    %edi,0x18f8(%ebx)
    *y = cp / COL_CNT;
c0024bb4:	0f b7 c0             	movzwl %ax,%eax
c0024bb7:	89 83 f4 18 00 00    	mov    %eax,0x18f4(%ebx)
        inited = true;
c0024bbd:	c6 83 ec 18 00 00 01 	movb   $0x1,0x18ec(%ebx)
c0024bc4:	eb 82                	jmp    c0024b48 <vga_putc+0x22>

c0024bc6 <.L14>:
c0024bc6:	8b 8b f0 18 00 00    	mov    0x18f0(%ebx),%ecx
c0024bcc:	8d b9 a0 0f 00 00    	lea    0xfa0(%ecx),%edi
vga_putc(int c) {
c0024bd2:	89 c8                	mov    %ecx,%eax
c0024bd4:	8d 91 a0 00 00 00    	lea    0xa0(%ecx),%edx
        fb[y][x][0] = ' ';
c0024bda:	c6 00 20             	movb   $0x20,(%eax)
        fb[y][x][1] = GRAY_ON_BLACK;
c0024bdd:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024be1:	83 c0 02             	add    $0x2,%eax
    for (x = 0; x < COL_CNT; x++) {
c0024be4:	39 d0                	cmp    %edx,%eax
c0024be6:	75 f2                	jne    c0024bda <.L14+0x14>
c0024be8:	89 d1                	mov    %edx,%ecx
    for (y = 0; y < ROW_CNT; y++)
c0024bea:	39 d7                	cmp    %edx,%edi
c0024bec:	75 e4                	jne    c0024bd2 <.L14+0xc>
    cx = cy = 0;
c0024bee:	c7 83 f4 18 00 00 00 	movl   $0x0,0x18f4(%ebx)
c0024bf5:	00 00 00 
c0024bf8:	c7 83 f8 18 00 00 00 	movl   $0x0,0x18f8(%ebx)
c0024bff:	00 00 00 
    move_cursor();
c0024c02:	e8 71 fe ff ff       	call   c0024a78 <move_cursor>
c0024c07:	eb 05                	jmp    c0024c0e <.L15+0x5>

c0024c09 <.L15>:
            newline();
c0024c09:	e8 a0 fe ff ff       	call   c0024aae <newline>
    move_cursor();
c0024c0e:	e8 65 fe ff ff       	call   c0024a78 <move_cursor>
    intr_set_level(old_level);
c0024c13:	83 ec 0c             	sub    $0xc,%esp
c0024c16:	56                   	push   %esi
c0024c17:	e8 4d d1 ff ff       	call   c0021d69 <intr_set_level>
}
c0024c1c:	83 c4 1c             	add    $0x1c,%esp
c0024c1f:	5b                   	pop    %ebx
c0024c20:	5e                   	pop    %esi
c0024c21:	5f                   	pop    %edi
c0024c22:	5d                   	pop    %ebp
c0024c23:	c3                   	ret    

c0024c24 <.L17>:
            if (cx > 0)
c0024c24:	8b 83 f8 18 00 00    	mov    0x18f8(%ebx),%eax
c0024c2a:	85 c0                	test   %eax,%eax
c0024c2c:	74 e0                	je     c0024c0e <.L15+0x5>
                cx--;
c0024c2e:	83 e8 01             	sub    $0x1,%eax
c0024c31:	89 83 f8 18 00 00    	mov    %eax,0x18f8(%ebx)
c0024c37:	eb d5                	jmp    c0024c0e <.L15+0x5>

c0024c39 <.L12>:
            cx = 0;
c0024c39:	c7 83 f8 18 00 00 00 	movl   $0x0,0x18f8(%ebx)
c0024c40:	00 00 00 
            break;
c0024c43:	eb c9                	jmp    c0024c0e <.L15+0x5>

c0024c45 <.L16>:
            cx = ROUND_UP (cx + 1, 8);
c0024c45:	8b 83 f8 18 00 00    	mov    0x18f8(%ebx),%eax
c0024c4b:	83 c0 08             	add    $0x8,%eax
c0024c4e:	83 e0 f8             	and    $0xfffffff8,%eax
c0024c51:	89 83 f8 18 00 00    	mov    %eax,0x18f8(%ebx)
            if (cx >= COL_CNT)
c0024c57:	83 f8 4f             	cmp    $0x4f,%eax
c0024c5a:	76 b2                	jbe    c0024c0e <.L15+0x5>
                newline();
c0024c5c:	e8 4d fe ff ff       	call   c0024aae <newline>
c0024c61:	eb ab                	jmp    c0024c0e <.L15+0x5>

c0024c63 <.L18>:
            intr_set_level(old_level);
c0024c63:	83 ec 0c             	sub    $0xc,%esp
c0024c66:	56                   	push   %esi
c0024c67:	e8 fd d0 ff ff       	call   c0021d69 <intr_set_level>
            speaker_beep();
c0024c6c:	e8 92 21 00 00       	call   c0026e03 <speaker_beep>
            intr_disable();
c0024c71:	e8 ec d0 ff ff       	call   c0021d62 <intr_disable>
            break;
c0024c76:	83 c4 10             	add    $0x10,%esp
c0024c79:	eb 93                	jmp    c0024c0e <.L15+0x5>

c0024c7b <.L11>:
            fb[cy][cx][0] = c;
c0024c7b:	8b bb f0 18 00 00    	mov    0x18f0(%ebx),%edi
c0024c81:	8b 83 f4 18 00 00    	mov    0x18f4(%ebx),%eax
c0024c87:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024c8a:	c1 e0 05             	shl    $0x5,%eax
c0024c8d:	01 f8                	add    %edi,%eax
c0024c8f:	8b 8b f8 18 00 00    	mov    0x18f8(%ebx),%ecx
c0024c95:	0f b6 54 24 20       	movzbl 0x20(%esp),%edx
c0024c9a:	88 14 48             	mov    %dl,(%eax,%ecx,2)
            fb[cy][cx][1] = GRAY_ON_BLACK;
c0024c9d:	8b 83 f4 18 00 00    	mov    0x18f4(%ebx),%eax
c0024ca3:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024ca6:	c1 e0 05             	shl    $0x5,%eax
c0024ca9:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0024cac:	8b 83 f8 18 00 00    	mov    0x18f8(%ebx),%eax
c0024cb2:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
            if (++cx >= COL_CNT)
c0024cb7:	8b 83 f8 18 00 00    	mov    0x18f8(%ebx),%eax
c0024cbd:	83 c0 01             	add    $0x1,%eax
c0024cc0:	89 83 f8 18 00 00    	mov    %eax,0x18f8(%ebx)
c0024cc6:	83 f8 4f             	cmp    $0x4f,%eax
c0024cc9:	0f 86 3f ff ff ff    	jbe    c0024c0e <.L15+0x5>
                newline();
c0024ccf:	e8 da fd ff ff       	call   c0024aae <newline>
c0024cd4:	e9 35 ff ff ff       	jmp    c0024c0e <.L15+0x5>

c0024cd9 <init_poll>:
/* Initializes the serial port device for polling mode.
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll(void) {
c0024cd9:	57                   	push   %edi
c0024cda:	56                   	push   %esi
c0024cdb:	53                   	push   %ebx
c0024cdc:	e8 62 b4 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024ce1:	81 c3 cb 8f 01 00    	add    $0x18fcb,%ebx
    ASSERT (mode == UNINIT);
c0024ce7:	83 bb 88 19 00 00 00 	cmpl   $0x0,0x1988(%ebx)
c0024cee:	75 65                	jne    c0024d55 <init_poll+0x7c>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024cf0:	b9 00 00 00 00       	mov    $0x0,%ecx
c0024cf5:	bf f9 03 00 00       	mov    $0x3f9,%edi
c0024cfa:	89 c8                	mov    %ecx,%eax
c0024cfc:	89 fa                	mov    %edi,%edx
c0024cfe:	ee                   	out    %al,(%dx)
c0024cff:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024d04:	ee                   	out    %al,(%dx)
c0024d05:	be fb 03 00 00       	mov    $0x3fb,%esi
c0024d0a:	b8 83 ff ff ff       	mov    $0xffffff83,%eax
c0024d0f:	89 f2                	mov    %esi,%edx
c0024d11:	ee                   	out    %al,(%dx)
c0024d12:	b8 0c 00 00 00       	mov    $0xc,%eax
c0024d17:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024d1c:	ee                   	out    %al,(%dx)
c0024d1d:	89 c8                	mov    %ecx,%eax
c0024d1f:	89 fa                	mov    %edi,%edx
c0024d21:	ee                   	out    %al,(%dx)
c0024d22:	b8 03 00 00 00       	mov    $0x3,%eax
c0024d27:	89 f2                	mov    %esi,%edx
c0024d29:	ee                   	out    %al,(%dx)
c0024d2a:	b8 08 00 00 00       	mov    $0x8,%eax
c0024d2f:	ba fc 03 00 00       	mov    $0x3fc,%edx
c0024d34:	ee                   	out    %al,(%dx)
    outb(IER_REG, 0);                    /* Turn off all interrupts. */
    outb(FCR_REG, 0);                    /* Disable FIFO. */
    set_serial(9600);                    /* 9.6 kbps, N-8-1. */
    outb(MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
    intq_init(&txq);
c0024d35:	83 ec 0c             	sub    $0xc,%esp
c0024d38:	8d 83 14 19 00 00    	lea    0x1914(%ebx),%eax
c0024d3e:	50                   	push   %eax
c0024d3f:	e8 57 19 00 00       	call   c002669b <intq_init>
    mode = POLL;
c0024d44:	c7 83 88 19 00 00 01 	movl   $0x1,0x1988(%ebx)
c0024d4b:	00 00 00 
}
c0024d4e:	83 c4 10             	add    $0x10,%esp
c0024d51:	5b                   	pop    %ebx
c0024d52:	5e                   	pop    %esi
c0024d53:	5f                   	pop    %edi
c0024d54:	c3                   	ret    
    ASSERT (mode == UNINIT);
c0024d55:	83 ec 0c             	sub    $0xc,%esp
c0024d58:	8d 83 87 46 ff ff    	lea    -0xb979(%ebx),%eax
c0024d5e:	50                   	push   %eax
c0024d5f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0024d65:	50                   	push   %eax
c0024d66:	8d 83 64 28 ff ff    	lea    -0xd79c(%ebx),%eax
c0024d6c:	50                   	push   %eax
c0024d6d:	6a 49                	push   $0x49
c0024d6f:	8d 83 96 46 ff ff    	lea    -0xb96a(%ebx),%eax
c0024d75:	50                   	push   %eax
c0024d76:	e8 b2 43 00 00       	call   c002912d <debug_panic>

c0024d7b <write_ier>:
    outb(LCR_REG, LCR_N81);
}

/* Update interrupt enable register. */
static void
write_ier(void) {
c0024d7b:	56                   	push   %esi
c0024d7c:	53                   	push   %ebx
c0024d7d:	83 ec 04             	sub    $0x4,%esp
c0024d80:	e8 be b3 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024d85:	81 c3 27 8f 01 00    	add    $0x18f27,%ebx
    uint8_t ier = 0;

    ASSERT (intr_get_level() == INTR_OFF);
c0024d8b:	e8 80 cf ff ff       	call   c0021d10 <intr_get_level>
c0024d90:	85 c0                	test   %eax,%eax
c0024d92:	75 37                	jne    c0024dcb <write_ier+0x50>

    /* Enable transmit interrupt if we have any characters to
       transmit. */
    if (!intq_empty(&txq))
c0024d94:	83 ec 0c             	sub    $0xc,%esp
c0024d97:	8d 83 14 19 00 00    	lea    0x1914(%ebx),%eax
c0024d9d:	50                   	push   %eax
c0024d9e:	e8 34 19 00 00       	call   c00266d7 <intq_empty>
c0024da3:	83 c4 10             	add    $0x10,%esp
        ier |= IER_XMIT;
c0024da6:	84 c0                	test   %al,%al
c0024da8:	0f 94 c0             	sete   %al
c0024dab:	8d 34 00             	lea    (%eax,%eax,1),%esi

    /* Enable receive interrupt if we have room to store any
       characters we receive. */
    if (!input_full())
c0024dae:	e8 96 18 00 00       	call   c0026649 <input_full>
        ier |= IER_RECV;
c0024db3:	89 f2                	mov    %esi,%edx
c0024db5:	83 ca 01             	or     $0x1,%edx
c0024db8:	84 c0                	test   %al,%al
c0024dba:	0f 44 f2             	cmove  %edx,%esi
c0024dbd:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0024dc2:	89 f0                	mov    %esi,%eax
c0024dc4:	ee                   	out    %al,(%dx)

    outb(IER_REG, ier);
}
c0024dc5:	83 c4 04             	add    $0x4,%esp
c0024dc8:	5b                   	pop    %ebx
c0024dc9:	5e                   	pop    %esi
c0024dca:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0024dcb:	83 ec 0c             	sub    $0xc,%esp
c0024dce:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c0024dd4:	50                   	push   %eax
c0024dd5:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0024ddb:	50                   	push   %eax
c0024ddc:	8d 83 58 28 ff ff    	lea    -0xd7a8(%ebx),%eax
c0024de2:	50                   	push   %eax
c0024de3:	68 af 00 00 00       	push   $0xaf
c0024de8:	8d 83 96 46 ff ff    	lea    -0xb96a(%ebx),%eax
c0024dee:	50                   	push   %eax
c0024def:	e8 39 43 00 00       	call   c002912d <debug_panic>

c0024df4 <serial_interrupt>:
    outb(THR_REG, byte);
}

/* Serial interrupt handler. */
static void
serial_interrupt(struct intr_frame *f UNUSED) {
c0024df4:	57                   	push   %edi
c0024df5:	56                   	push   %esi
c0024df6:	53                   	push   %ebx
c0024df7:	e8 47 b3 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024dfc:	81 c3 b0 8e 01 00    	add    $0x18eb0,%ebx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024e02:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024e07:	ec                   	in     (%dx),%al
c0024e08:	be fd 03 00 00       	mov    $0x3fd,%esi
c0024e0d:	bf f8 03 00 00       	mov    $0x3f8,%edi
       occasionally miss an interrupt running under QEMU. */
    inb(IIR_REG);

    /* As long as we have room to receive a byte, and the hardware
       has a byte for us, receive a byte.  */
    while (!input_full() && (inb(LSR_REG) & LSR_DR) != 0)
c0024e12:	e8 32 18 00 00       	call   c0026649 <input_full>
c0024e17:	84 c0                	test   %al,%al
c0024e19:	75 4d                	jne    c0024e68 <serial_interrupt+0x74>
c0024e1b:	89 f2                	mov    %esi,%edx
c0024e1d:	ec                   	in     (%dx),%al
c0024e1e:	a8 01                	test   $0x1,%al
c0024e20:	74 46                	je     c0024e68 <serial_interrupt+0x74>
c0024e22:	89 fa                	mov    %edi,%edx
c0024e24:	ec                   	in     (%dx),%al
        input_putc(inb(RBR_REG));
c0024e25:	83 ec 0c             	sub    $0xc,%esp
c0024e28:	0f b6 c0             	movzbl %al,%eax
c0024e2b:	50                   	push   %eax
c0024e2c:	e8 3d 17 00 00       	call   c002656e <input_putc>
c0024e31:	83 c4 10             	add    $0x10,%esp
c0024e34:	eb dc                	jmp    c0024e12 <serial_interrupt+0x1e>

    /* As long as we have a byte to transmit, and the hardware is
       ready to accept a byte for transmission, transmit a byte. */
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
        outb(THR_REG, intq_getc(&txq));
c0024e36:	83 ec 0c             	sub    $0xc,%esp
c0024e39:	56                   	push   %esi
c0024e3a:	e8 da 1a 00 00       	call   c0026919 <intq_getc>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024e3f:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024e44:	ee                   	out    %al,(%dx)
c0024e45:	83 c4 10             	add    $0x10,%esp
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c0024e48:	83 ec 0c             	sub    $0xc,%esp
c0024e4b:	56                   	push   %esi
c0024e4c:	e8 86 18 00 00       	call   c00266d7 <intq_empty>
c0024e51:	83 c4 10             	add    $0x10,%esp
c0024e54:	84 c0                	test   %al,%al
c0024e56:	75 07                	jne    c0024e5f <serial_interrupt+0x6b>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024e58:	89 fa                	mov    %edi,%edx
c0024e5a:	ec                   	in     (%dx),%al
c0024e5b:	a8 20                	test   $0x20,%al
c0024e5d:	75 d7                	jne    c0024e36 <serial_interrupt+0x42>

    /* Update interrupt enable register based on queue status. */
    write_ier();
c0024e5f:	e8 17 ff ff ff       	call   c0024d7b <write_ier>
}
c0024e64:	5b                   	pop    %ebx
c0024e65:	5e                   	pop    %esi
c0024e66:	5f                   	pop    %edi
c0024e67:	c3                   	ret    
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c0024e68:	8d b3 14 19 00 00    	lea    0x1914(%ebx),%esi
c0024e6e:	bf fd 03 00 00       	mov    $0x3fd,%edi
c0024e73:	eb d3                	jmp    c0024e48 <serial_interrupt+0x54>

c0024e75 <putc_poll>:
putc_poll(uint8_t byte) {
c0024e75:	56                   	push   %esi
c0024e76:	53                   	push   %ebx
c0024e77:	83 ec 04             	sub    $0x4,%esp
c0024e7a:	e8 c4 b2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024e7f:	81 c3 2d 8e 01 00    	add    $0x18e2d,%ebx
c0024e85:	89 c6                	mov    %eax,%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0024e87:	e8 84 ce ff ff       	call   c0021d10 <intr_get_level>
c0024e8c:	85 c0                	test   %eax,%eax
c0024e8e:	75 18                	jne    c0024ea8 <putc_poll+0x33>
c0024e90:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024e95:	ec                   	in     (%dx),%al
    while ((inb(LSR_REG) & LSR_THRE) == 0)
c0024e96:	a8 20                	test   $0x20,%al
c0024e98:	74 fb                	je     c0024e95 <putc_poll+0x20>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024e9a:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024e9f:	89 f0                	mov    %esi,%eax
c0024ea1:	ee                   	out    %al,(%dx)
}
c0024ea2:	83 c4 04             	add    $0x4,%esp
c0024ea5:	5b                   	pop    %ebx
c0024ea6:	5e                   	pop    %esi
c0024ea7:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0024ea8:	83 ec 0c             	sub    $0xc,%esp
c0024eab:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c0024eb1:	50                   	push   %eax
c0024eb2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0024eb8:	50                   	push   %eax
c0024eb9:	8d 83 4c 28 ff ff    	lea    -0xd7b4(%ebx),%eax
c0024ebf:	50                   	push   %eax
c0024ec0:	68 c2 00 00 00       	push   $0xc2
c0024ec5:	8d 83 96 46 ff ff    	lea    -0xb96a(%ebx),%eax
c0024ecb:	50                   	push   %eax
c0024ecc:	e8 5c 42 00 00       	call   c002912d <debug_panic>

c0024ed1 <serial_init_queue>:
serial_init_queue(void) {
c0024ed1:	56                   	push   %esi
c0024ed2:	53                   	push   %ebx
c0024ed3:	83 ec 04             	sub    $0x4,%esp
c0024ed6:	e8 68 b2 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024edb:	81 c3 d1 8d 01 00    	add    $0x18dd1,%ebx
    if (mode == UNINIT)
c0024ee1:	83 bb 88 19 00 00 00 	cmpl   $0x0,0x1988(%ebx)
c0024ee8:	74 45                	je     c0024f2f <serial_init_queue+0x5e>
    ASSERT (mode == POLL);
c0024eea:	83 bb 88 19 00 00 01 	cmpl   $0x1,0x1988(%ebx)
c0024ef1:	75 43                	jne    c0024f36 <serial_init_queue+0x65>
    intr_register_ext(0x20 + 4, serial_interrupt, "serial");
c0024ef3:	83 ec 04             	sub    $0x4,%esp
c0024ef6:	8d 83 ba 46 ff ff    	lea    -0xb946(%ebx),%eax
c0024efc:	50                   	push   %eax
c0024efd:	8d 83 48 71 fe ff    	lea    -0x18eb8(%ebx),%eax
c0024f03:	50                   	push   %eax
c0024f04:	6a 24                	push   $0x24
c0024f06:	e8 33 d0 ff ff       	call   c0021f3e <intr_register_ext>
    mode = QUEUE;
c0024f0b:	c7 83 88 19 00 00 02 	movl   $0x2,0x1988(%ebx)
c0024f12:	00 00 00 
    old_level = intr_disable();
c0024f15:	e8 48 ce ff ff       	call   c0021d62 <intr_disable>
c0024f1a:	89 c6                	mov    %eax,%esi
    write_ier();
c0024f1c:	e8 5a fe ff ff       	call   c0024d7b <write_ier>
    intr_set_level(old_level);
c0024f21:	89 34 24             	mov    %esi,(%esp)
c0024f24:	e8 40 ce ff ff       	call   c0021d69 <intr_set_level>
}
c0024f29:	83 c4 14             	add    $0x14,%esp
c0024f2c:	5b                   	pop    %ebx
c0024f2d:	5e                   	pop    %esi
c0024f2e:	c3                   	ret    
        init_poll();
c0024f2f:	e8 a5 fd ff ff       	call   c0024cd9 <init_poll>
c0024f34:	eb b4                	jmp    c0024eea <serial_init_queue+0x19>
    ASSERT (mode == POLL);
c0024f36:	83 ec 0c             	sub    $0xc,%esp
c0024f39:	8d 83 ad 46 ff ff    	lea    -0xb953(%ebx),%eax
c0024f3f:	50                   	push   %eax
c0024f40:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0024f46:	50                   	push   %eax
c0024f47:	8d 83 70 28 ff ff    	lea    -0xd790(%ebx),%eax
c0024f4d:	50                   	push   %eax
c0024f4e:	6a 5b                	push   $0x5b
c0024f50:	8d 83 96 46 ff ff    	lea    -0xb96a(%ebx),%eax
c0024f56:	50                   	push   %eax
c0024f57:	e8 d1 41 00 00       	call   c002912d <debug_panic>

c0024f5c <serial_putc>:
serial_putc(uint8_t byte) {
c0024f5c:	57                   	push   %edi
c0024f5d:	56                   	push   %esi
c0024f5e:	53                   	push   %ebx
c0024f5f:	e8 df b1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0024f64:	81 c3 48 8d 01 00    	add    $0x18d48,%ebx
c0024f6a:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0024f6e:	e8 ef cd ff ff       	call   c0021d62 <intr_disable>
c0024f73:	89 c7                	mov    %eax,%edi
    if (mode != QUEUE) {
c0024f75:	8b 83 88 19 00 00    	mov    0x1988(%ebx),%eax
c0024f7b:	83 f8 02             	cmp    $0x2,%eax
c0024f7e:	74 25                	je     c0024fa5 <serial_putc+0x49>
        if (mode == UNINIT)
c0024f80:	85 c0                	test   %eax,%eax
c0024f82:	74 1a                	je     c0024f9e <serial_putc+0x42>
        putc_poll(byte);
c0024f84:	89 f0                	mov    %esi,%eax
c0024f86:	0f b6 c0             	movzbl %al,%eax
c0024f89:	e8 e7 fe ff ff       	call   c0024e75 <putc_poll>
    intr_set_level(old_level);
c0024f8e:	83 ec 0c             	sub    $0xc,%esp
c0024f91:	57                   	push   %edi
c0024f92:	e8 d2 cd ff ff       	call   c0021d69 <intr_set_level>
}
c0024f97:	83 c4 10             	add    $0x10,%esp
c0024f9a:	5b                   	pop    %ebx
c0024f9b:	5e                   	pop    %esi
c0024f9c:	5f                   	pop    %edi
c0024f9d:	c3                   	ret    
            init_poll();
c0024f9e:	e8 36 fd ff ff       	call   c0024cd9 <init_poll>
c0024fa3:	eb df                	jmp    c0024f84 <serial_putc+0x28>
        if (old_level == INTR_OFF && intq_full(&txq)) {
c0024fa5:	85 ff                	test   %edi,%edi
c0024fa7:	74 1f                	je     c0024fc8 <serial_putc+0x6c>
        intq_putc(&txq, byte);
c0024fa9:	83 ec 08             	sub    $0x8,%esp
c0024fac:	89 f0                	mov    %esi,%eax
c0024fae:	0f b6 f0             	movzbl %al,%esi
c0024fb1:	56                   	push   %esi
c0024fb2:	8d 83 14 19 00 00    	lea    0x1914(%ebx),%eax
c0024fb8:	50                   	push   %eax
c0024fb9:	e8 26 1a 00 00       	call   c00269e4 <intq_putc>
        write_ier();
c0024fbe:	e8 b8 fd ff ff       	call   c0024d7b <write_ier>
c0024fc3:	83 c4 10             	add    $0x10,%esp
c0024fc6:	eb c6                	jmp    c0024f8e <serial_putc+0x32>
        if (old_level == INTR_OFF && intq_full(&txq)) {
c0024fc8:	83 ec 0c             	sub    $0xc,%esp
c0024fcb:	8d 83 14 19 00 00    	lea    0x1914(%ebx),%eax
c0024fd1:	50                   	push   %eax
c0024fd2:	e8 52 17 00 00       	call   c0026729 <intq_full>
c0024fd7:	83 c4 10             	add    $0x10,%esp
c0024fda:	84 c0                	test   %al,%al
c0024fdc:	74 cb                	je     c0024fa9 <serial_putc+0x4d>
            putc_poll(intq_getc(&txq));
c0024fde:	83 ec 0c             	sub    $0xc,%esp
c0024fe1:	8d 83 14 19 00 00    	lea    0x1914(%ebx),%eax
c0024fe7:	50                   	push   %eax
c0024fe8:	e8 2c 19 00 00       	call   c0026919 <intq_getc>
c0024fed:	0f b6 c0             	movzbl %al,%eax
c0024ff0:	e8 80 fe ff ff       	call   c0024e75 <putc_poll>
c0024ff5:	83 c4 10             	add    $0x10,%esp
c0024ff8:	eb af                	jmp    c0024fa9 <serial_putc+0x4d>

c0024ffa <serial_flush>:
serial_flush(void) {
c0024ffa:	57                   	push   %edi
c0024ffb:	56                   	push   %esi
c0024ffc:	53                   	push   %ebx
c0024ffd:	e8 41 b1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025002:	81 c3 aa 8c 01 00    	add    $0x18caa,%ebx
    enum intr_level old_level = intr_disable();
c0025008:	e8 55 cd ff ff       	call   c0021d62 <intr_disable>
c002500d:	89 c7                	mov    %eax,%edi
    while (!intq_empty(&txq))
c002500f:	8d b3 14 19 00 00    	lea    0x1914(%ebx),%esi
c0025015:	83 ec 0c             	sub    $0xc,%esp
c0025018:	56                   	push   %esi
c0025019:	e8 b9 16 00 00       	call   c00266d7 <intq_empty>
c002501e:	83 c4 10             	add    $0x10,%esp
c0025021:	84 c0                	test   %al,%al
c0025023:	75 16                	jne    c002503b <serial_flush+0x41>
        putc_poll(intq_getc(&txq));
c0025025:	83 ec 0c             	sub    $0xc,%esp
c0025028:	56                   	push   %esi
c0025029:	e8 eb 18 00 00       	call   c0026919 <intq_getc>
c002502e:	0f b6 c0             	movzbl %al,%eax
c0025031:	e8 3f fe ff ff       	call   c0024e75 <putc_poll>
c0025036:	83 c4 10             	add    $0x10,%esp
c0025039:	eb da                	jmp    c0025015 <serial_flush+0x1b>
    intr_set_level(old_level);
c002503b:	83 ec 0c             	sub    $0xc,%esp
c002503e:	57                   	push   %edi
c002503f:	e8 25 cd ff ff       	call   c0021d69 <intr_set_level>
}
c0025044:	83 c4 10             	add    $0x10,%esp
c0025047:	5b                   	pop    %ebx
c0025048:	5e                   	pop    %esi
c0025049:	5f                   	pop    %edi
c002504a:	c3                   	ret    

c002504b <serial_notify>:
serial_notify(void) {
c002504b:	53                   	push   %ebx
c002504c:	83 ec 08             	sub    $0x8,%esp
c002504f:	e8 ef b0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025054:	81 c3 58 8c 01 00    	add    $0x18c58,%ebx
    ASSERT (intr_get_level() == INTR_OFF);
c002505a:	e8 b1 cc ff ff       	call   c0021d10 <intr_get_level>
c002505f:	85 c0                	test   %eax,%eax
c0025061:	75 0e                	jne    c0025071 <serial_notify+0x26>
    if (mode == QUEUE)
c0025063:	83 bb 88 19 00 00 02 	cmpl   $0x2,0x1988(%ebx)
c002506a:	74 2e                	je     c002509a <serial_notify+0x4f>
}
c002506c:	83 c4 08             	add    $0x8,%esp
c002506f:	5b                   	pop    %ebx
c0025070:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0025071:	83 ec 0c             	sub    $0xc,%esp
c0025074:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c002507a:	50                   	push   %eax
c002507b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0025081:	50                   	push   %eax
c0025082:	8d 83 3c 28 ff ff    	lea    -0xd7c4(%ebx),%eax
c0025088:	50                   	push   %eax
c0025089:	68 92 00 00 00       	push   $0x92
c002508e:	8d 83 96 46 ff ff    	lea    -0xb96a(%ebx),%eax
c0025094:	50                   	push   %eax
c0025095:	e8 93 40 00 00       	call   c002912d <debug_panic>
        write_ier();
c002509a:	e8 dc fc ff ff       	call   c0024d7b <write_ier>
}
c002509f:	eb cb                	jmp    c002506c <serial_notify+0x21>

c00250a1 <check_sector>:
}

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector(struct block *block, block_sector_t sector) {
c00250a1:	53                   	push   %ebx
c00250a2:	83 ec 08             	sub    $0x8,%esp
c00250a5:	e8 ad b0 00 00       	call   c0030157 <__x86.get_pc_thunk.cx>
c00250aa:	81 c1 02 8c 01 00    	add    $0x18c02,%ecx
    if (sector >= block->size) {
c00250b0:	8b 58 1c             	mov    0x1c(%eax),%ebx
c00250b3:	39 d3                	cmp    %edx,%ebx
c00250b5:	76 05                	jbe    c00250bc <check_sector+0x1b>
                       ", "
                       "size=%"
                       PRDSNu
                       ")\n", block_name(block), sector, block->size);
    }
}
c00250b7:	83 c4 08             	add    $0x8,%esp
c00250ba:	5b                   	pop    %ebx
c00250bb:	c3                   	ret    
        PANIC ("Access past end of device %s (sector=%"
c00250bc:	83 ec 04             	sub    $0x4,%esp
c00250bf:	53                   	push   %ebx
c00250c0:	52                   	push   %edx
}

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name(struct block *block) {
    return block->name;
c00250c1:	83 c0 08             	add    $0x8,%eax
        PANIC ("Access past end of device %s (sector=%"
c00250c4:	50                   	push   %eax
c00250c5:	8d 81 c4 46 ff ff    	lea    -0xb93c(%ecx),%eax
c00250cb:	50                   	push   %eax
c00250cc:	8d 81 a0 28 ff ff    	lea    -0xd760(%ecx),%eax
c00250d2:	50                   	push   %eax
c00250d3:	6a 6a                	push   $0x6a
c00250d5:	8d 81 52 47 ff ff    	lea    -0xb8ae(%ecx),%eax
c00250db:	50                   	push   %eax
c00250dc:	89 cb                	mov    %ecx,%ebx
c00250de:	e8 4a 40 00 00       	call   c002912d <debug_panic>

c00250e3 <block_type_name>:
block_type_name(enum block_type type) {
c00250e3:	53                   	push   %ebx
c00250e4:	83 ec 08             	sub    $0x8,%esp
c00250e7:	e8 57 b0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00250ec:	81 c3 c0 8b 01 00    	add    $0x18bc0,%ebx
c00250f2:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (type < BLOCK_CNT);
c00250f6:	83 f8 05             	cmp    $0x5,%eax
c00250f9:	77 0c                	ja     c0025107 <block_type_name+0x24>
    return block_type_names[type];
c00250fb:	8b 84 83 64 60 ff ff 	mov    -0x9f9c(%ebx,%eax,4),%eax
}
c0025102:	83 c4 08             	add    $0x8,%esp
c0025105:	5b                   	pop    %ebx
c0025106:	c3                   	ret    
    ASSERT (type < BLOCK_CNT);
c0025107:	83 ec 0c             	sub    $0xc,%esp
c002510a:	8d 83 68 47 ff ff    	lea    -0xb898(%ebx),%eax
c0025110:	50                   	push   %eax
c0025111:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0025117:	50                   	push   %eax
c0025118:	8d 83 d0 28 ff ff    	lea    -0xd730(%ebx),%eax
c002511e:	50                   	push   %eax
c002511f:	6a 2d                	push   $0x2d
c0025121:	8d 83 52 47 ff ff    	lea    -0xb8ae(%ebx),%eax
c0025127:	50                   	push   %eax
c0025128:	e8 00 40 00 00       	call   c002912d <debug_panic>

c002512d <block_get_role>:
block_get_role(enum block_type role) {
c002512d:	53                   	push   %ebx
c002512e:	83 ec 08             	sub    $0x8,%esp
c0025131:	e8 0d b0 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025136:	81 c3 76 8b 01 00    	add    $0x18b76,%ebx
c002513c:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (role < BLOCK_ROLE_CNT);
c0025140:	83 f8 03             	cmp    $0x3,%eax
c0025143:	77 0c                	ja     c0025151 <block_get_role+0x24>
    return block_by_role[role];
c0025145:	8b 84 83 8c 19 00 00 	mov    0x198c(%ebx,%eax,4),%eax
}
c002514c:	83 c4 08             	add    $0x8,%esp
c002514f:	5b                   	pop    %ebx
c0025150:	c3                   	ret    
    ASSERT (role < BLOCK_ROLE_CNT);
c0025151:	83 ec 0c             	sub    $0xc,%esp
c0025154:	8d 83 79 47 ff ff    	lea    -0xb887(%ebx),%eax
c002515a:	50                   	push   %eax
c002515b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0025161:	50                   	push   %eax
c0025162:	8d 83 c0 28 ff ff    	lea    -0xd740(%ebx),%eax
c0025168:	50                   	push   %eax
c0025169:	6a 35                	push   $0x35
c002516b:	8d 83 52 47 ff ff    	lea    -0xb8ae(%ebx),%eax
c0025171:	50                   	push   %eax
c0025172:	e8 b6 3f 00 00       	call   c002912d <debug_panic>

c0025177 <block_set_role>:
block_set_role(enum block_type role, struct block *block) {
c0025177:	53                   	push   %ebx
c0025178:	83 ec 08             	sub    $0x8,%esp
c002517b:	e8 c3 af 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025180:	81 c3 2c 8b 01 00    	add    $0x18b2c,%ebx
c0025186:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (role < BLOCK_ROLE_CNT);
c002518a:	83 f8 03             	cmp    $0x3,%eax
c002518d:	77 10                	ja     c002519f <block_set_role+0x28>
    block_by_role[role] = block;
c002518f:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0025193:	89 8c 83 8c 19 00 00 	mov    %ecx,0x198c(%ebx,%eax,4)
}
c002519a:	83 c4 08             	add    $0x8,%esp
c002519d:	5b                   	pop    %ebx
c002519e:	c3                   	ret    
    ASSERT (role < BLOCK_ROLE_CNT);
c002519f:	83 ec 0c             	sub    $0xc,%esp
c00251a2:	8d 83 79 47 ff ff    	lea    -0xb887(%ebx),%eax
c00251a8:	50                   	push   %eax
c00251a9:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00251af:	50                   	push   %eax
c00251b0:	8d 83 b0 28 ff ff    	lea    -0xd750(%ebx),%eax
c00251b6:	50                   	push   %eax
c00251b7:	6a 3c                	push   $0x3c
c00251b9:	8d 83 52 47 ff ff    	lea    -0xb8ae(%ebx),%eax
c00251bf:	50                   	push   %eax
c00251c0:	e8 68 3f 00 00       	call   c002912d <debug_panic>

c00251c5 <block_first>:
block_first(void) {
c00251c5:	57                   	push   %edi
c00251c6:	56                   	push   %esi
c00251c7:	53                   	push   %ebx
c00251c8:	e8 76 af 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00251cd:	81 c3 df 8a 01 00    	add    $0x18adf,%ebx
    return list_elem_to_block(list_begin(&all_blocks));
c00251d3:	83 ec 0c             	sub    $0xc,%esp
c00251d6:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c00251dc:	57                   	push   %edi
c00251dd:	e8 70 40 00 00       	call   c0029252 <list_begin>
c00251e2:	89 c6                	mov    %eax,%esi

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block(struct list_elem *list_elem) {
    return (list_elem != list_end(&all_blocks)
c00251e4:	89 3c 24             	mov    %edi,(%esp)
c00251e7:	e8 08 41 00 00       	call   c00292f4 <list_end>
            ? list_entry (list_elem, struct block, list_elem)
            : NULL);
c00251ec:	83 c4 10             	add    $0x10,%esp
c00251ef:	39 c6                	cmp    %eax,%esi
c00251f1:	b8 00 00 00 00       	mov    $0x0,%eax
c00251f6:	0f 44 f0             	cmove  %eax,%esi
}
c00251f9:	89 f0                	mov    %esi,%eax
c00251fb:	5b                   	pop    %ebx
c00251fc:	5e                   	pop    %esi
c00251fd:	5f                   	pop    %edi
c00251fe:	c3                   	ret    

c00251ff <block_next>:
block_next(struct block *block) {
c00251ff:	56                   	push   %esi
c0025200:	53                   	push   %ebx
c0025201:	83 ec 10             	sub    $0x10,%esp
c0025204:	e8 3a af 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025209:	81 c3 a3 8a 01 00    	add    $0x18aa3,%ebx
    return list_elem_to_block(list_next(&block->list_elem));
c002520f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025213:	e8 7f 40 00 00       	call   c0029297 <list_next>
c0025218:	89 c6                	mov    %eax,%esi
    return (list_elem != list_end(&all_blocks)
c002521a:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c0025220:	89 04 24             	mov    %eax,(%esp)
c0025223:	e8 cc 40 00 00       	call   c00292f4 <list_end>
            : NULL);
c0025228:	39 c6                	cmp    %eax,%esi
c002522a:	b8 00 00 00 00       	mov    $0x0,%eax
c002522f:	0f 44 f0             	cmove  %eax,%esi
}
c0025232:	89 f0                	mov    %esi,%eax
c0025234:	83 c4 14             	add    $0x14,%esp
c0025237:	5b                   	pop    %ebx
c0025238:	5e                   	pop    %esi
c0025239:	c3                   	ret    

c002523a <block_get_by_name>:
block_get_by_name(const char *name) {
c002523a:	55                   	push   %ebp
c002523b:	57                   	push   %edi
c002523c:	56                   	push   %esi
c002523d:	53                   	push   %ebx
c002523e:	83 ec 18             	sub    $0x18,%esp
c0025241:	e8 fd ae 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025246:	81 c3 66 8a 01 00    	add    $0x18a66,%ebx
c002524c:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    for (e = list_begin(&all_blocks); e != list_end(&all_blocks);
c0025250:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c0025256:	50                   	push   %eax
c0025257:	e8 f6 3f 00 00       	call   c0029252 <list_begin>
c002525c:	89 c6                	mov    %eax,%esi
c002525e:	83 c4 10             	add    $0x10,%esp
c0025261:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c0025267:	83 ec 0c             	sub    $0xc,%esp
c002526a:	57                   	push   %edi
c002526b:	e8 84 40 00 00       	call   c00292f4 <list_end>
c0025270:	83 c4 10             	add    $0x10,%esp
c0025273:	39 f0                	cmp    %esi,%eax
c0025275:	74 24                	je     c002529b <block_get_by_name+0x61>
        if (!strcmp(name, block->name))
c0025277:	8d 46 08             	lea    0x8(%esi),%eax
c002527a:	83 ec 08             	sub    $0x8,%esp
c002527d:	50                   	push   %eax
c002527e:	55                   	push   %ebp
c002527f:	e8 5f 31 00 00       	call   c00283e3 <strcmp>
c0025284:	83 c4 10             	add    $0x10,%esp
c0025287:	85 c0                	test   %eax,%eax
c0025289:	74 15                	je     c00252a0 <block_get_by_name+0x66>
         e = list_next(e)) {
c002528b:	83 ec 0c             	sub    $0xc,%esp
c002528e:	56                   	push   %esi
c002528f:	e8 03 40 00 00       	call   c0029297 <list_next>
c0025294:	89 c6                	mov    %eax,%esi
c0025296:	83 c4 10             	add    $0x10,%esp
c0025299:	eb cc                	jmp    c0025267 <block_get_by_name+0x2d>
    return NULL;
c002529b:	be 00 00 00 00       	mov    $0x0,%esi
}
c00252a0:	89 f0                	mov    %esi,%eax
c00252a2:	83 c4 0c             	add    $0xc,%esp
c00252a5:	5b                   	pop    %ebx
c00252a6:	5e                   	pop    %esi
c00252a7:	5f                   	pop    %edi
c00252a8:	5d                   	pop    %ebp
c00252a9:	c3                   	ret    

c00252aa <block_read>:
block_read(struct block *block, block_sector_t sector, void *buffer) {
c00252aa:	56                   	push   %esi
c00252ab:	53                   	push   %ebx
c00252ac:	83 ec 04             	sub    $0x4,%esp
c00252af:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00252b3:	8b 74 24 14          	mov    0x14(%esp),%esi
    check_sector(block, sector);
c00252b7:	89 f2                	mov    %esi,%edx
c00252b9:	89 d8                	mov    %ebx,%eax
c00252bb:	e8 e1 fd ff ff       	call   c00250a1 <check_sector>
    block->ops->read(block->aux, sector, buffer);
c00252c0:	83 ec 04             	sub    $0x4,%esp
c00252c3:	8b 43 20             	mov    0x20(%ebx),%eax
c00252c6:	ff 74 24 1c          	pushl  0x1c(%esp)
c00252ca:	56                   	push   %esi
c00252cb:	ff 73 24             	pushl  0x24(%ebx)
c00252ce:	ff 10                	call   *(%eax)
    block->read_cnt++;
c00252d0:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c00252d4:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c00252d8:	83 c4 14             	add    $0x14,%esp
c00252db:	5b                   	pop    %ebx
c00252dc:	5e                   	pop    %esi
c00252dd:	c3                   	ret    

c00252de <block_write>:
block_write(struct block *block, block_sector_t sector, const void *buffer) {
c00252de:	57                   	push   %edi
c00252df:	56                   	push   %esi
c00252e0:	53                   	push   %ebx
c00252e1:	e8 5d ae 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00252e6:	81 c3 c6 89 01 00    	add    $0x189c6,%ebx
c00252ec:	8b 74 24 10          	mov    0x10(%esp),%esi
c00252f0:	8b 7c 24 14          	mov    0x14(%esp),%edi
    check_sector(block, sector);
c00252f4:	89 fa                	mov    %edi,%edx
c00252f6:	89 f0                	mov    %esi,%eax
c00252f8:	e8 a4 fd ff ff       	call   c00250a1 <check_sector>
    ASSERT (block->type != BLOCK_FOREIGN);
c00252fd:	83 7e 18 05          	cmpl   $0x5,0x18(%esi)
c0025301:	74 20                	je     c0025323 <block_write+0x45>
    block->ops->write(block->aux, sector, buffer);
c0025303:	83 ec 04             	sub    $0x4,%esp
c0025306:	8b 46 20             	mov    0x20(%esi),%eax
c0025309:	ff 74 24 1c          	pushl  0x1c(%esp)
c002530d:	57                   	push   %edi
c002530e:	ff 76 24             	pushl  0x24(%esi)
c0025311:	ff 50 04             	call   *0x4(%eax)
    block->write_cnt++;
c0025314:	83 46 30 01          	addl   $0x1,0x30(%esi)
c0025318:	83 56 34 00          	adcl   $0x0,0x34(%esi)
}
c002531c:	83 c4 10             	add    $0x10,%esp
c002531f:	5b                   	pop    %ebx
c0025320:	5e                   	pop    %esi
c0025321:	5f                   	pop    %edi
c0025322:	c3                   	ret    
    ASSERT (block->type != BLOCK_FOREIGN);
c0025323:	83 ec 0c             	sub    $0xc,%esp
c0025326:	8d 83 8f 47 ff ff    	lea    -0xb871(%ebx),%eax
c002532c:	50                   	push   %eax
c002532d:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0025333:	50                   	push   %eax
c0025334:	8d 83 94 28 ff ff    	lea    -0xd76c(%ebx),%eax
c002533a:	50                   	push   %eax
c002533b:	68 81 00 00 00       	push   $0x81
c0025340:	8d 83 52 47 ff ff    	lea    -0xb8ae(%ebx),%eax
c0025346:	50                   	push   %eax
c0025347:	e8 e1 3d 00 00       	call   c002912d <debug_panic>

c002534c <block_size>:
    return block->size;
c002534c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025350:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0025353:	c3                   	ret    

c0025354 <block_name>:
    return block->name;
c0025354:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025358:	83 c0 08             	add    $0x8,%eax
}
c002535b:	c3                   	ret    

c002535c <block_type>:
    return block->type;
c002535c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025360:	8b 40 18             	mov    0x18(%eax),%eax
}
c0025363:	c3                   	ret    

c0025364 <block_print_stats>:
block_print_stats(void) {
c0025364:	55                   	push   %ebp
c0025365:	57                   	push   %edi
c0025366:	56                   	push   %esi
c0025367:	53                   	push   %ebx
c0025368:	83 ec 1c             	sub    $0x1c,%esp
c002536b:	e8 d3 ad 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025370:	81 c3 3c 89 01 00    	add    $0x1893c,%ebx
    for (i = 0; i < BLOCK_ROLE_CNT; i++) {
c0025376:	8d bb 8c 19 00 00    	lea    0x198c(%ebx),%edi
c002537c:	8d 6f 10             	lea    0x10(%edi),%ebp
            printf("%s (%s): %llu reads, %llu writes\n",
c002537f:	8d 83 f8 46 ff ff    	lea    -0xb908(%ebx),%eax
c0025385:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0025389:	eb 32                	jmp    c00253bd <block_print_stats+0x59>
c002538b:	83 ec 0c             	sub    $0xc,%esp
c002538e:	ff 76 18             	pushl  0x18(%esi)
c0025391:	e8 4d fd ff ff       	call   c00250e3 <block_type_name>
c0025396:	83 c4 0c             	add    $0xc,%esp
c0025399:	ff 76 34             	pushl  0x34(%esi)
c002539c:	ff 76 30             	pushl  0x30(%esi)
c002539f:	ff 76 2c             	pushl  0x2c(%esi)
c00253a2:	ff 76 28             	pushl  0x28(%esi)
c00253a5:	50                   	push   %eax
c00253a6:	83 c6 08             	add    $0x8,%esi
c00253a9:	56                   	push   %esi
c00253aa:	ff 74 24 28          	pushl  0x28(%esp)
c00253ae:	e8 1e 21 00 00       	call   c00274d1 <printf>
c00253b3:	83 c4 20             	add    $0x20,%esp
c00253b6:	83 c7 04             	add    $0x4,%edi
    for (i = 0; i < BLOCK_ROLE_CNT; i++) {
c00253b9:	39 ef                	cmp    %ebp,%edi
c00253bb:	74 08                	je     c00253c5 <block_print_stats+0x61>
        struct block *block = block_by_role[i];
c00253bd:	8b 37                	mov    (%edi),%esi
        if (block != NULL) {
c00253bf:	85 f6                	test   %esi,%esi
c00253c1:	75 c8                	jne    c002538b <block_print_stats+0x27>
c00253c3:	eb f1                	jmp    c00253b6 <block_print_stats+0x52>
}
c00253c5:	83 c4 1c             	add    $0x1c,%esp
c00253c8:	5b                   	pop    %ebx
c00253c9:	5e                   	pop    %esi
c00253ca:	5f                   	pop    %edi
c00253cb:	5d                   	pop    %ebp
c00253cc:	c3                   	ret    

c00253cd <block_register>:
               const struct block_operations *ops, void *aux) {
c00253cd:	55                   	push   %ebp
c00253ce:	57                   	push   %edi
c00253cf:	56                   	push   %esi
c00253d0:	53                   	push   %ebx
c00253d1:	83 ec 18             	sub    $0x18,%esp
c00253d4:	e8 6a ad 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00253d9:	81 c3 d3 88 01 00    	add    $0x188d3,%ebx
c00253df:	8b 7c 24 38          	mov    0x38(%esp),%edi
    struct block *block = malloc(sizeof *block);
c00253e3:	6a 38                	push   $0x38
c00253e5:	e8 64 ea ff ff       	call   c0023e4e <malloc>
    if (block == NULL)
c00253ea:	83 c4 10             	add    $0x10,%esp
c00253ed:	85 c0                	test   %eax,%eax
c00253ef:	0f 84 c6 00 00 00    	je     c00254bb <block_register+0xee>
c00253f5:	89 c6                	mov    %eax,%esi
    list_push_back(&all_blocks, &block->list_elem);
c00253f7:	83 ec 08             	sub    $0x8,%esp
c00253fa:	50                   	push   %eax
c00253fb:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c0025401:	50                   	push   %eax
c0025402:	e8 d8 43 00 00       	call   c00297df <list_push_back>
    strlcpy(block->name, name, sizeof block->name);
c0025407:	8d 6e 08             	lea    0x8(%esi),%ebp
c002540a:	83 c4 0c             	add    $0xc,%esp
c002540d:	6a 10                	push   $0x10
c002540f:	ff 74 24 28          	pushl  0x28(%esp)
c0025413:	55                   	push   %ebp
c0025414:	e8 56 33 00 00       	call   c002876f <strlcpy>
    block->type = type;
c0025419:	8b 44 24 34          	mov    0x34(%esp),%eax
c002541d:	89 46 18             	mov    %eax,0x18(%esi)
    block->size = size;
c0025420:	89 7e 1c             	mov    %edi,0x1c(%esi)
    block->ops = ops;
c0025423:	8b 44 24 40          	mov    0x40(%esp),%eax
c0025427:	89 46 20             	mov    %eax,0x20(%esi)
    block->aux = aux;
c002542a:	8b 44 24 44          	mov    0x44(%esp),%eax
c002542e:	89 46 24             	mov    %eax,0x24(%esi)
    block->read_cnt = 0;
c0025431:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c0025438:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
    block->write_cnt = 0;
c002543f:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
c0025446:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
    printf("%s: %'"PRDSNu" sectors (", block->name, block->size);
c002544d:	83 c4 0c             	add    $0xc,%esp
c0025450:	57                   	push   %edi
c0025451:	55                   	push   %ebp
c0025452:	8d 83 ac 47 ff ff    	lea    -0xb854(%ebx),%eax
c0025458:	50                   	push   %eax
c0025459:	e8 73 20 00 00       	call   c00274d1 <printf>
    print_human_readable_size((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c002545e:	83 c4 08             	add    $0x8,%esp
c0025461:	8b 7e 1c             	mov    0x1c(%esi),%edi
c0025464:	bd 00 00 00 00       	mov    $0x0,%ebp
c0025469:	89 f8                	mov    %edi,%eax
c002546b:	89 ea                	mov    %ebp,%edx
c002546d:	0f a4 fa 09          	shld   $0x9,%edi,%edx
c0025471:	c1 e0 09             	shl    $0x9,%eax
c0025474:	52                   	push   %edx
c0025475:	50                   	push   %eax
c0025476:	e8 1c 2a 00 00       	call   c0027e97 <print_human_readable_size>
    printf(")");
c002547b:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0025482:	e8 ee 5c 00 00       	call   c002b175 <putchar>
    if (extra_info != NULL)
c0025487:	83 c4 10             	add    $0x10,%esp
c002548a:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c002548f:	74 16                	je     c00254a7 <block_register+0xda>
        printf(", %s", extra_info);
c0025491:	83 ec 08             	sub    $0x8,%esp
c0025494:	ff 74 24 30          	pushl  0x30(%esp)
c0025498:	8d 83 be 47 ff ff    	lea    -0xb842(%ebx),%eax
c002549e:	50                   	push   %eax
c002549f:	e8 2d 20 00 00       	call   c00274d1 <printf>
c00254a4:	83 c4 10             	add    $0x10,%esp
    printf("\n");
c00254a7:	83 ec 0c             	sub    $0xc,%esp
c00254aa:	6a 0a                	push   $0xa
c00254ac:	e8 c4 5c 00 00       	call   c002b175 <putchar>
}
c00254b1:	89 f0                	mov    %esi,%eax
c00254b3:	83 c4 1c             	add    $0x1c,%esp
c00254b6:	5b                   	pop    %ebx
c00254b7:	5e                   	pop    %esi
c00254b8:	5f                   	pop    %edi
c00254b9:	5d                   	pop    %ebp
c00254ba:	c3                   	ret    
        PANIC ("Failed to allocate memory for block device descriptor");
c00254bb:	8d 83 1c 47 ff ff    	lea    -0xb8e4(%ebx),%eax
c00254c1:	50                   	push   %eax
c00254c2:	8d 83 84 28 ff ff    	lea    -0xd77c(%ebx),%eax
c00254c8:	50                   	push   %eax
c00254c9:	68 b2 00 00 00       	push   $0xb2
c00254ce:	8d 83 52 47 ff ff    	lea    -0xb8ae(%ebx),%eax
c00254d4:	50                   	push   %eax
c00254d5:	e8 53 3c 00 00       	call   c002912d <debug_panic>

c00254da <partition_read>:
}

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read(void *p_, block_sector_t sector, void *buffer) {
c00254da:	53                   	push   %ebx
c00254db:	83 ec 0c             	sub    $0xc,%esp
c00254de:	e8 60 ac 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00254e3:	81 c3 c9 87 01 00    	add    $0x187c9,%ebx
c00254e9:	8b 54 24 14          	mov    0x14(%esp),%edx
    struct partition *p = p_;
    block_read(p->block, p->start + sector, buffer);
c00254ed:	ff 74 24 1c          	pushl  0x1c(%esp)
c00254f1:	8b 42 04             	mov    0x4(%edx),%eax
c00254f4:	03 44 24 1c          	add    0x1c(%esp),%eax
c00254f8:	50                   	push   %eax
c00254f9:	ff 32                	pushl  (%edx)
c00254fb:	e8 aa fd ff ff       	call   c00252aa <block_read>
}
c0025500:	83 c4 18             	add    $0x18,%esp
c0025503:	5b                   	pop    %ebx
c0025504:	c3                   	ret    

c0025505 <read_partition_table>:
                     int *part_nr) {
c0025505:	55                   	push   %ebp
c0025506:	57                   	push   %edi
c0025507:	56                   	push   %esi
c0025508:	53                   	push   %ebx
c0025509:	81 ec d8 00 00 00    	sub    $0xd8,%esp
c002550f:	e8 2f ac 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025514:	81 c3 98 87 01 00    	add    $0x18798,%ebx
c002551a:	89 c6                	mov    %eax,%esi
c002551c:	89 d7                	mov    %edx,%edi
c002551e:	89 54 24 10          	mov    %edx,0x10(%esp)
c0025522:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    if (sector >= block_size(block)) {
c0025526:	50                   	push   %eax
c0025527:	e8 20 fe ff ff       	call   c002534c <block_size>
c002552c:	83 c4 10             	add    $0x10,%esp
c002552f:	39 f8                	cmp    %edi,%eax
c0025531:	76 65                	jbe    c0025598 <read_partition_table+0x93>
    pt = malloc(sizeof *pt);
c0025533:	83 ec 0c             	sub    $0xc,%esp
c0025536:	68 00 02 00 00       	push   $0x200
c002553b:	e8 0e e9 ff ff       	call   c0023e4e <malloc>
c0025540:	89 c5                	mov    %eax,%ebp
    if (pt == NULL)
c0025542:	83 c4 10             	add    $0x10,%esp
c0025545:	85 c0                	test   %eax,%eax
c0025547:	74 7a                	je     c00255c3 <read_partition_table+0xbe>
    block_read(block, 0, pt);
c0025549:	83 ec 04             	sub    $0x4,%esp
c002554c:	50                   	push   %eax
c002554d:	6a 00                	push   $0x0
c002554f:	56                   	push   %esi
c0025550:	e8 55 fd ff ff       	call   c00252aa <block_read>
    if (pt->signature != 0xaa55) {
c0025555:	83 c4 10             	add    $0x10,%esp
c0025558:	66 81 bd fe 01 00 00 	cmpw   $0xaa55,0x1fe(%ebp)
c002555f:	55 aa 
c0025561:	0f 84 9a 00 00 00    	je     c0025601 <read_partition_table+0xfc>
        if (primary_extended_sector == 0)
c0025567:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c002556c:	75 71                	jne    c00255df <read_partition_table+0xda>
            printf("%s: Invalid partition table signature\n", block_name(block));
c002556e:	83 ec 0c             	sub    $0xc,%esp
c0025571:	56                   	push   %esi
c0025572:	e8 dd fd ff ff       	call   c0025354 <block_name>
c0025577:	83 c4 08             	add    $0x8,%esp
c002557a:	50                   	push   %eax
c002557b:	8d 83 d0 4c ff ff    	lea    -0xb330(%ebx),%eax
c0025581:	50                   	push   %eax
c0025582:	e8 4a 1f 00 00       	call   c00274d1 <printf>
c0025587:	83 c4 10             	add    $0x10,%esp
        free(pt);
c002558a:	83 ec 0c             	sub    $0xc,%esp
c002558d:	55                   	push   %ebp
c002558e:	e8 69 ea ff ff       	call   c0023ffc <free>
        return;
c0025593:	83 c4 10             	add    $0x10,%esp
c0025596:	eb 20                	jmp    c00255b8 <read_partition_table+0xb3>
        printf("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025598:	83 ec 0c             	sub    $0xc,%esp
c002559b:	56                   	push   %esi
c002559c:	e8 b3 fd ff ff       	call   c0025354 <block_name>
c00255a1:	83 c4 0c             	add    $0xc,%esp
c00255a4:	ff 74 24 08          	pushl  0x8(%esp)
c00255a8:	50                   	push   %eax
c00255a9:	8d 83 68 4c ff ff    	lea    -0xb398(%ebx),%eax
c00255af:	50                   	push   %eax
c00255b0:	e8 1c 1f 00 00       	call   c00274d1 <printf>
        return;
c00255b5:	83 c4 10             	add    $0x10,%esp
}
c00255b8:	81 c4 cc 00 00 00    	add    $0xcc,%esp
c00255be:	5b                   	pop    %ebx
c00255bf:	5e                   	pop    %esi
c00255c0:	5f                   	pop    %edi
c00255c1:	5d                   	pop    %ebp
c00255c2:	c3                   	ret    
        PANIC ("Failed to allocate memory for partition table.");
c00255c3:	8d 83 a0 4c ff ff    	lea    -0xb360(%ebx),%eax
c00255c9:	50                   	push   %eax
c00255ca:	8d 83 f0 28 ff ff    	lea    -0xd710(%ebx),%eax
c00255d0:	50                   	push   %eax
c00255d1:	6a 56                	push   $0x56
c00255d3:	8d 83 d7 47 ff ff    	lea    -0xb829(%ebx),%eax
c00255d9:	50                   	push   %eax
c00255da:	e8 4e 3b 00 00       	call   c002912d <debug_panic>
            printf("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c00255df:	83 ec 0c             	sub    $0xc,%esp
c00255e2:	56                   	push   %esi
c00255e3:	e8 6c fd ff ff       	call   c0025354 <block_name>
c00255e8:	83 c4 0c             	add    $0xc,%esp
c00255eb:	ff 74 24 08          	pushl  0x8(%esp)
c00255ef:	50                   	push   %eax
c00255f0:	8d 83 f8 4c ff ff    	lea    -0xb308(%ebx),%eax
c00255f6:	50                   	push   %eax
c00255f7:	e8 d5 1e 00 00       	call   c00274d1 <printf>
c00255fc:	83 c4 10             	add    $0x10,%esp
c00255ff:	eb 89                	jmp    c002558a <read_partition_table+0x85>
c0025601:	8d bd c2 01 00 00    	lea    0x1c2(%ebp),%edi
c0025607:	8d 85 02 02 00 00    	lea    0x202(%ebp),%eax
c002560d:	89 44 24 08          	mov    %eax,0x8(%esp)
            printf("%s: Extended partition in sector %"PRDSNu"\n",
c0025611:	8d 83 2c 4d ff ff    	lea    -0xb2d4(%ebx),%eax
c0025617:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        printf("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c002561b:	8d 83 8c 4d ff ff    	lea    -0xb274(%ebx),%eax
c0025621:	89 44 24 20          	mov    %eax,0x20(%esp)
c0025625:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c0025629:	89 74 24 14          	mov    %esi,0x14(%esp)
c002562d:	eb 30                	jmp    c002565f <read_partition_table+0x15a>
                read_partition_table(block, e->offset + primary_extended_sector,
c002562f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0025633:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0025637:	89 ca                	mov    %ecx,%edx
c0025639:	03 50 04             	add    0x4(%eax),%edx
c002563c:	83 ec 0c             	sub    $0xc,%esp
c002563f:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c0025646:	8b 44 24 24          	mov    0x24(%esp),%eax
c002564a:	e8 b6 fe ff ff       	call   c0025505 <read_partition_table>
c002564f:	83 c4 10             	add    $0x10,%esp
c0025652:	83 c7 10             	add    $0x10,%edi
    for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++) {
c0025655:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c0025659:	0f 84 f0 01 00 00    	je     c002584f <read_partition_table+0x34a>
        if (e->size == 0 || e->type == 0) {
c002565f:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0025663:	8b 77 08             	mov    0x8(%edi),%esi
c0025666:	85 f6                	test   %esi,%esi
c0025668:	74 e8                	je     c0025652 <read_partition_table+0x14d>
c002566a:	0f b6 2f             	movzbl (%edi),%ebp
c002566d:	89 e8                	mov    %ebp,%eax
c002566f:	84 c0                	test   %al,%al
c0025671:	74 df                	je     c0025652 <read_partition_table+0x14d>
                   || e->type == 0x0f    /* Windows 98 extended partition. */
c0025673:	3c 0f                	cmp    $0xf,%al
c0025675:	0f 94 c2             	sete   %dl
                   || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025678:	3c c5                	cmp    $0xc5,%al
c002567a:	0f 94 c0             	sete   %al
c002567d:	08 c2                	or     %al,%dl
c002567f:	75 09                	jne    c002568a <read_partition_table+0x185>
                   || e->type == 0x0f    /* Windows 98 extended partition. */
c0025681:	89 e8                	mov    %ebp,%eax
c0025683:	83 e0 7f             	and    $0x7f,%eax
                   || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025686:	3c 05                	cmp    $0x5,%al
c0025688:	75 4c                	jne    c00256d6 <read_partition_table+0x1d1>
            printf("%s: Extended partition in sector %"PRDSNu"\n",
c002568a:	83 ec 0c             	sub    $0xc,%esp
c002568d:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025691:	55                   	push   %ebp
c0025692:	e8 bd fc ff ff       	call   c0025354 <block_name>
c0025697:	83 c4 0c             	add    $0xc,%esp
c002569a:	8b 74 24 08          	mov    0x8(%esp),%esi
c002569e:	56                   	push   %esi
c002569f:	50                   	push   %eax
c00256a0:	ff 74 24 28          	pushl  0x28(%esp)
c00256a4:	e8 28 1e 00 00       	call   c00274d1 <printf>
            if (sector == 0)
c00256a9:	83 c4 10             	add    $0x10,%esp
c00256ac:	85 f6                	test   %esi,%esi
c00256ae:	0f 85 7b ff ff ff    	jne    c002562f <read_partition_table+0x12a>
                read_partition_table(block, e->offset, e->offset, part_nr);
c00256b4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00256b8:	8b 50 04             	mov    0x4(%eax),%edx
c00256bb:	83 ec 0c             	sub    $0xc,%esp
c00256be:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c00256c5:	89 d1                	mov    %edx,%ecx
c00256c7:	89 e8                	mov    %ebp,%eax
c00256c9:	e8 37 fe ff ff       	call   c0025505 <read_partition_table>
c00256ce:	83 c4 10             	add    $0x10,%esp
c00256d1:	e9 7c ff ff ff       	jmp    c0025652 <read_partition_table+0x14d>
            ++*part_nr;
c00256d6:	8b 84 24 e0 00 00 00 	mov    0xe0(%esp),%eax
c00256dd:	8b 00                	mov    (%eax),%eax
c00256df:	83 c0 01             	add    $0x1,%eax
c00256e2:	89 44 24 24          	mov    %eax,0x24(%esp)
c00256e6:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
c00256ed:	89 01                	mov    %eax,(%ecx)
            found_partition(block, e->type, e->offset + sector,
c00256ef:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c00256f3:	8b 44 24 04          	mov    0x4(%esp),%eax
c00256f7:	03 41 04             	add    0x4(%ecx),%eax
c00256fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (start >= block_size(block))
c00256fe:	83 ec 0c             	sub    $0xc,%esp
c0025701:	ff 74 24 20          	pushl  0x20(%esp)
c0025705:	e8 42 fc ff ff       	call   c002534c <block_size>
c002570a:	83 c4 10             	add    $0x10,%esp
c002570d:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c0025711:	73 55                	jae    c0025768 <read_partition_table+0x263>
    else if (start + size < start || start + size > block_size(block))
c0025713:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0025717:	01 f0                	add    %esi,%eax
c0025719:	89 44 24 28          	mov    %eax,0x28(%esp)
c002571d:	72 15                	jb     c0025734 <read_partition_table+0x22f>
c002571f:	83 ec 0c             	sub    $0xc,%esp
c0025722:	ff 74 24 20          	pushl  0x20(%esp)
c0025726:	e8 21 fc ff ff       	call   c002534c <block_size>
c002572b:	83 c4 10             	add    $0x10,%esp
c002572e:	39 44 24 28          	cmp    %eax,0x28(%esp)
c0025732:	76 5d                	jbe    c0025791 <read_partition_table+0x28c>
        printf("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025734:	83 ec 0c             	sub    $0xc,%esp
c0025737:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002573b:	55                   	push   %ebp
c002573c:	e8 0b fc ff ff       	call   c002534c <block_size>
c0025741:	89 c6                	mov    %eax,%esi
c0025743:	89 2c 24             	mov    %ebp,(%esp)
c0025746:	e8 09 fc ff ff       	call   c0025354 <block_name>
c002574b:	89 34 24             	mov    %esi,(%esp)
c002574e:	ff 74 24 38          	pushl  0x38(%esp)
c0025752:	ff 74 24 38          	pushl  0x38(%esp)
c0025756:	50                   	push   %eax
c0025757:	ff 74 24 3c          	pushl  0x3c(%esp)
c002575b:	e8 71 1d 00 00       	call   c00274d1 <printf>
c0025760:	83 c4 20             	add    $0x20,%esp
c0025763:	e9 ea fe ff ff       	jmp    c0025652 <read_partition_table+0x14d>
        printf("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025768:	83 ec 0c             	sub    $0xc,%esp
c002576b:	ff 74 24 20          	pushl  0x20(%esp)
c002576f:	e8 e0 fb ff ff       	call   c0025354 <block_name>
c0025774:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025778:	ff 74 24 38          	pushl  0x38(%esp)
c002577c:	50                   	push   %eax
c002577d:	8d 83 54 4d ff ff    	lea    -0xb2ac(%ebx),%eax
c0025783:	50                   	push   %eax
c0025784:	e8 48 1d 00 00       	call   c00274d1 <printf>
c0025789:	83 c4 20             	add    $0x20,%esp
c002578c:	e9 c1 fe ff ff       	jmp    c0025652 <read_partition_table+0x14d>
            found_partition(block, e->type, e->offset + sector,
c0025791:	89 e8                	mov    %ebp,%eax
c0025793:	0f b6 c0             	movzbl %al,%eax
c0025796:	89 44 24 28          	mov    %eax,0x28(%esp)
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c002579a:	89 e8                	mov    %ebp,%eax
c002579c:	3c 20                	cmp    $0x20,%al
c002579e:	0f 84 c0 00 00 00    	je     c0025864 <read_partition_table+0x35f>
c00257a4:	3c 21                	cmp    $0x21,%al
c00257a6:	0f 84 5b 01 00 00    	je     c0025907 <read_partition_table+0x402>
c00257ac:	3c 22                	cmp    $0x22,%al
c00257ae:	0f 84 60 01 00 00    	je     c0025914 <read_partition_table+0x40f>
c00257b4:	3c 23                	cmp    $0x23,%al
c00257b6:	0f 84 65 01 00 00    	je     c0025921 <read_partition_table+0x41c>
        p = malloc(sizeof *p);
c00257bc:	83 ec 0c             	sub    $0xc,%esp
c00257bf:	6a 08                	push   $0x8
c00257c1:	e8 88 e6 ff ff       	call   c0023e4e <malloc>
c00257c6:	89 c5                	mov    %eax,%ebp
        if (p == NULL)
c00257c8:	83 c4 10             	add    $0x10,%esp
c00257cb:	85 c0                	test   %eax,%eax
c00257cd:	74 57                	je     c0025826 <read_partition_table+0x321>
        p->block = block;
c00257cf:	8b 44 24 14          	mov    0x14(%esp),%eax
c00257d3:	89 45 00             	mov    %eax,0x0(%ebp)
        p->start = start;
c00257d6:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00257da:	89 55 04             	mov    %edx,0x4(%ebp)
        snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c00257dd:	83 ec 0c             	sub    $0xc,%esp
c00257e0:	50                   	push   %eax
c00257e1:	e8 6e fb ff ff       	call   c0025354 <block_name>
c00257e6:	83 c4 04             	add    $0x4,%esp
c00257e9:	ff 74 24 30          	pushl  0x30(%esp)
c00257ed:	50                   	push   %eax
c00257ee:	8d 83 f1 47 ff ff    	lea    -0xb80f(%ebx),%eax
c00257f4:	50                   	push   %eax
c00257f5:	6a 10                	push   $0x10
c00257f7:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c00257fb:	50                   	push   %eax
c00257fc:	e8 61 24 00 00       	call   c0027c62 <snprintf>
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025801:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025805:	8b 84 83 94 60 ff ff 	mov    -0x9f6c(%ebx,%eax,4),%eax
c002580c:	83 c4 20             	add    $0x20,%esp
c002580f:	85 c0                	test   %eax,%eax
c0025811:	75 32                	jne    c0025845 <read_partition_table+0x340>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c0025813:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c002581a:	00 
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c002581b:	8d 83 cf 47 ff ff    	lea    -0xb831(%ebx),%eax
c0025821:	e9 99 00 00 00       	jmp    c00258bf <read_partition_table+0x3ba>
            PANIC ("Failed to allocate memory for partition descriptor");
c0025826:	8d 83 c0 4d ff ff    	lea    -0xb240(%ebx),%eax
c002582c:	50                   	push   %eax
c002582d:	8d 83 e0 28 ff ff    	lea    -0xd720(%ebx),%eax
c0025833:	50                   	push   %eax
c0025834:	68 a6 00 00 00       	push   $0xa6
c0025839:	8d 83 d7 47 ff ff    	lea    -0xb829(%ebx),%eax
c002583f:	50                   	push   %eax
c0025840:	e8 e8 38 00 00       	call   c002912d <debug_panic>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c0025845:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c002584c:	00 
c002584d:	eb 70                	jmp    c00258bf <read_partition_table+0x3ba>
c002584f:	8b 6c 24 18          	mov    0x18(%esp),%ebp
    free(pt);
c0025853:	83 ec 0c             	sub    $0xc,%esp
c0025856:	55                   	push   %ebp
c0025857:	e8 a0 e7 ff ff       	call   c0023ffc <free>
c002585c:	83 c4 10             	add    $0x10,%esp
c002585f:	e9 54 fd ff ff       	jmp    c00255b8 <read_partition_table+0xb3>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c0025864:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
c002586b:	00 
        p = malloc(sizeof *p);
c002586c:	83 ec 0c             	sub    $0xc,%esp
c002586f:	6a 08                	push   $0x8
c0025871:	e8 d8 e5 ff ff       	call   c0023e4e <malloc>
c0025876:	89 c5                	mov    %eax,%ebp
        if (p == NULL)
c0025878:	83 c4 10             	add    $0x10,%esp
c002587b:	85 c0                	test   %eax,%eax
c002587d:	74 a7                	je     c0025826 <read_partition_table+0x321>
        p->block = block;
c002587f:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025883:	89 45 00             	mov    %eax,0x0(%ebp)
        p->start = start;
c0025886:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c002588a:	89 4d 04             	mov    %ecx,0x4(%ebp)
        snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c002588d:	83 ec 0c             	sub    $0xc,%esp
c0025890:	50                   	push   %eax
c0025891:	e8 be fa ff ff       	call   c0025354 <block_name>
c0025896:	83 c4 04             	add    $0x4,%esp
c0025899:	ff 74 24 30          	pushl  0x30(%esp)
c002589d:	50                   	push   %eax
c002589e:	8d 83 f1 47 ff ff    	lea    -0xb80f(%ebx),%eax
c00258a4:	50                   	push   %eax
c00258a5:	6a 10                	push   $0x10
c00258a7:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c00258ab:	50                   	push   %eax
c00258ac:	e8 b1 23 00 00       	call   c0027c62 <snprintf>
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c00258b1:	8b 44 24 48          	mov    0x48(%esp),%eax
c00258b5:	8b 84 83 94 60 ff ff 	mov    -0x9f6c(%ebx,%eax,4),%eax
c00258bc:	83 c4 20             	add    $0x20,%esp
        snprintf(extra_info, sizeof extra_info, "%s (%02x)",
c00258bf:	83 ec 0c             	sub    $0xc,%esp
c00258c2:	ff 74 24 34          	pushl  0x34(%esp)
c00258c6:	50                   	push   %eax
c00258c7:	8d 83 f6 47 ff ff    	lea    -0xb80a(%ebx),%eax
c00258cd:	50                   	push   %eax
c00258ce:	68 80 00 00 00       	push   $0x80
c00258d3:	8d 44 24 5c          	lea    0x5c(%esp),%eax
c00258d7:	89 44 24 28          	mov    %eax,0x28(%esp)
c00258db:	50                   	push   %eax
c00258dc:	e8 81 23 00 00       	call   c0027c62 <snprintf>
        block_register(name, type, extra_info, size, &partition_operations, p);
c00258e1:	83 c4 18             	add    $0x18,%esp
c00258e4:	55                   	push   %ebp
c00258e5:	8d 83 d4 ff ff ff    	lea    -0x2c(%ebx),%eax
c00258eb:	50                   	push   %eax
c00258ec:	56                   	push   %esi
c00258ed:	ff 74 24 20          	pushl  0x20(%esp)
c00258f1:	ff 74 24 44          	pushl  0x44(%esp)
c00258f5:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c00258f9:	50                   	push   %eax
c00258fa:	e8 ce fa ff ff       	call   c00253cd <block_register>
c00258ff:	83 c4 20             	add    $0x20,%esp
c0025902:	e9 4b fd ff ff       	jmp    c0025652 <read_partition_table+0x14d>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c0025907:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c002590e:	00 
c002590f:	e9 58 ff ff ff       	jmp    c002586c <read_partition_table+0x367>
c0025914:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c002591b:	00 
c002591c:	e9 4b ff ff ff       	jmp    c002586c <read_partition_table+0x367>
c0025921:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c0025928:	00 
c0025929:	e9 3e ff ff ff       	jmp    c002586c <read_partition_table+0x367>

c002592e <partition_write>:

/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write(void *p_, block_sector_t sector, const void *buffer) {
c002592e:	53                   	push   %ebx
c002592f:	83 ec 0c             	sub    $0xc,%esp
c0025932:	e8 0c a8 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025937:	81 c3 75 83 01 00    	add    $0x18375,%ebx
c002593d:	8b 54 24 14          	mov    0x14(%esp),%edx
    struct partition *p = p_;
    block_write(p->block, p->start + sector, buffer);
c0025941:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025945:	8b 42 04             	mov    0x4(%edx),%eax
c0025948:	03 44 24 1c          	add    0x1c(%esp),%eax
c002594c:	50                   	push   %eax
c002594d:	ff 32                	pushl  (%edx)
c002594f:	e8 8a f9 ff ff       	call   c00252de <block_write>
}
c0025954:	83 c4 18             	add    $0x18,%esp
c0025957:	5b                   	pop    %ebx
c0025958:	c3                   	ret    

c0025959 <partition_scan>:
partition_scan(struct block *block) {
c0025959:	56                   	push   %esi
c002595a:	53                   	push   %ebx
c002595b:	83 ec 20             	sub    $0x20,%esp
c002595e:	e8 e0 a7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025963:	81 c3 49 83 01 00    	add    $0x18349,%ebx
c0025969:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    int part_nr = 0;
c002596d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0025974:	00 
    read_partition_table(block, 0, 0, &part_nr);
c0025975:	8d 44 24 18          	lea    0x18(%esp),%eax
c0025979:	50                   	push   %eax
c002597a:	b9 00 00 00 00       	mov    $0x0,%ecx
c002597f:	ba 00 00 00 00       	mov    $0x0,%edx
c0025984:	89 f0                	mov    %esi,%eax
c0025986:	e8 7a fb ff ff       	call   c0025505 <read_partition_table>
    if (part_nr == 0)
c002598b:	83 c4 10             	add    $0x10,%esp
c002598e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0025993:	74 06                	je     c002599b <partition_scan+0x42>
}
c0025995:	83 c4 14             	add    $0x14,%esp
c0025998:	5b                   	pop    %ebx
c0025999:	5e                   	pop    %esi
c002599a:	c3                   	ret    
        printf("%s: Device contains no partitions\n", block_name(block));
c002599b:	83 ec 0c             	sub    $0xc,%esp
c002599e:	56                   	push   %esi
c002599f:	e8 b0 f9 ff ff       	call   c0025354 <block_name>
c00259a4:	83 c4 08             	add    $0x8,%esp
c00259a7:	50                   	push   %eax
c00259a8:	8d 83 f4 4d ff ff    	lea    -0xb20c(%ebx),%eax
c00259ae:	50                   	push   %eax
c00259af:	e8 1d 1b 00 00       	call   c00274d1 <printf>
c00259b4:	83 c4 10             	add    $0x10,%esp
}
c00259b7:	eb dc                	jmp    c0025995 <partition_scan+0x3c>

c00259b9 <descramble_ata_string>:

/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string(char *string, int size) {
c00259b9:	57                   	push   %edi
c00259ba:	56                   	push   %esi
c00259bb:	53                   	push   %ebx
c00259bc:	89 d7                	mov    %edx,%edi
    int i;

    /* Swap all pairs of bytes. */
    for (i = 0; i + 1 < size; i += 2) {
c00259be:	83 fa 01             	cmp    $0x1,%edx
c00259c1:	7e 24                	jle    c00259e7 <descramble_ata_string+0x2e>
c00259c3:	89 c1                	mov    %eax,%ecx
c00259c5:	8d 5a fe             	lea    -0x2(%edx),%ebx
c00259c8:	83 e3 fe             	and    $0xfffffffe,%ebx
c00259cb:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
        char tmp = string[i];
c00259cf:	0f b6 19             	movzbl (%ecx),%ebx
        string[i] = string[i + 1];
c00259d2:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
c00259d6:	88 11                	mov    %dl,(%ecx)
        string[i + 1] = tmp;
c00259d8:	88 59 01             	mov    %bl,0x1(%ecx)
c00259db:	83 c1 02             	add    $0x2,%ecx
    for (i = 0; i + 1 < size; i += 2) {
c00259de:	39 f1                	cmp    %esi,%ecx
c00259e0:	75 ed                	jne    c00259cf <descramble_ata_string+0x16>
    }

    /* Find the last non-white, non-null character. */
    for (size--; size > 0; size--) {
c00259e2:	8d 57 ff             	lea    -0x1(%edi),%edx
c00259e5:	eb 0c                	jmp    c00259f3 <descramble_ata_string+0x3a>
c00259e7:	8d 52 ff             	lea    -0x1(%edx),%edx
c00259ea:	eb 19                	jmp    c0025a05 <descramble_ata_string+0x4c>
c00259ec:	83 ea 01             	sub    $0x1,%edx
c00259ef:	85 d2                	test   %edx,%edx
c00259f1:	7e 12                	jle    c0025a05 <descramble_ata_string+0x4c>
        int c = string[size - 1];
c00259f3:	0f b6 4c 10 ff       	movzbl -0x1(%eax,%edx,1),%ecx
        if (c != '\0' && !isspace(c))
c00259f8:	f6 c1 df             	test   $0xdf,%cl
c00259fb:	74 ef                	je     c00259ec <descramble_ata_string+0x33>
          || c == '\r' || c == '\t' || c == '\v');
c00259fd:	83 e9 09             	sub    $0x9,%ecx
c0025a00:	80 f9 04             	cmp    $0x4,%cl
c0025a03:	76 e7                	jbe    c00259ec <descramble_ata_string+0x33>
            break;
    }
    string[size] = '\0';
c0025a05:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

    return string;
}
c0025a09:	5b                   	pop    %ebx
c0025a0a:	5e                   	pop    %esi
c0025a0b:	5f                   	pop    %edi
c0025a0c:	c3                   	ret    

c0025a0d <interrupt_handler>:
    wait_until_idle(d);
}

/* ATA interrupt handler. */
static void
interrupt_handler(struct intr_frame *f) {
c0025a0d:	53                   	push   %ebx
c0025a0e:	83 ec 08             	sub    $0x8,%esp
c0025a11:	e8 2d a7 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025a16:	81 c3 96 82 01 00    	add    $0x18296,%ebx
    struct channel *c;

    for (c = channels; c < channels + CHANNEL_CNT; c++)
        if (f->vec_no == c->irq) {
c0025a1c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025a20:	8b 40 30             	mov    0x30(%eax),%eax
c0025a23:	0f b6 93 be 19 00 00 	movzbl 0x19be(%ebx),%edx
c0025a2a:	39 d0                	cmp    %edx,%eax
c0025a2c:	74 30                	je     c0025a5e <interrupt_handler+0x51>
c0025a2e:	0f b6 93 2e 1a 00 00 	movzbl 0x1a2e(%ebx),%edx
c0025a35:	8d 8b 24 1a 00 00    	lea    0x1a24(%ebx),%ecx
c0025a3b:	39 c2                	cmp    %eax,%edx
c0025a3d:	74 25                	je     c0025a64 <interrupt_handler+0x57>
            } else
                printf("%s: unexpected interrupt\n", c->name);
            return;
        }

    NOT_REACHED ();
c0025a3f:	8d 83 54 3d ff ff    	lea    -0xc2ac(%ebx),%eax
c0025a45:	50                   	push   %eax
c0025a46:	8d 83 58 29 ff ff    	lea    -0xd6a8(%ebx),%eax
c0025a4c:	50                   	push   %eax
c0025a4d:	68 f0 01 00 00       	push   $0x1f0
c0025a52:	8d 83 31 4e ff ff    	lea    -0xb1cf(%ebx),%eax
c0025a58:	50                   	push   %eax
c0025a59:	e8 cf 36 00 00       	call   c002912d <debug_panic>
    for (c = channels; c < channels + CHANNEL_CNT; c++)
c0025a5e:	8d 8b b4 19 00 00    	lea    0x19b4(%ebx),%ecx
            if (c->expecting_interrupt) {
c0025a64:	80 79 30 00          	cmpb   $0x0,0x30(%ecx)
c0025a68:	74 1c                	je     c0025a86 <interrupt_handler+0x79>
                inb(reg_status (c));               /* Acknowledge interrupt. */
c0025a6a:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
c0025a6e:	8d 50 07             	lea    0x7(%eax),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025a71:	ec                   	in     (%dx),%al
                sema_up(&c->completion_wait);      /* Wake up waiter. */
c0025a72:	83 ec 0c             	sub    $0xc,%esp
c0025a75:	83 c1 34             	add    $0x34,%ecx
c0025a78:	51                   	push   %ecx
c0025a79:	e8 e0 d5 ff ff       	call   c002305e <sema_up>
c0025a7e:	83 c4 10             	add    $0x10,%esp
}
c0025a81:	83 c4 08             	add    $0x8,%esp
c0025a84:	5b                   	pop    %ebx
c0025a85:	c3                   	ret    
                printf("%s: unexpected interrupt\n", c->name);
c0025a86:	83 ec 08             	sub    $0x8,%esp
c0025a89:	51                   	push   %ecx
c0025a8a:	8d 83 17 4e ff ff    	lea    -0xb1e9(%ebx),%eax
c0025a90:	50                   	push   %eax
c0025a91:	e8 3b 1a 00 00       	call   c00274d1 <printf>
c0025a96:	83 c4 10             	add    $0x10,%esp
            return;
c0025a99:	eb e6                	jmp    c0025a81 <interrupt_handler+0x74>

c0025a9b <wait_until_idle>:
wait_until_idle(const struct ata_disk *d) {
c0025a9b:	57                   	push   %edi
c0025a9c:	56                   	push   %esi
c0025a9d:	53                   	push   %ebx
c0025a9e:	e8 a0 a6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025aa3:	81 c3 09 82 01 00    	add    $0x18209,%ebx
c0025aa9:	89 c7                	mov    %eax,%edi
        if ((inb(reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025aab:	8b 40 08             	mov    0x8(%eax),%eax
c0025aae:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025ab2:	8d 50 07             	lea    0x7(%eax),%edx
c0025ab5:	ec                   	in     (%dx),%al
c0025ab6:	a8 88                	test   $0x88,%al
c0025ab8:	74 4a                	je     c0025b04 <wait_until_idle+0x69>
        timer_usleep(10);
c0025aba:	83 ec 08             	sub    $0x8,%esp
c0025abd:	6a 00                	push   $0x0
c0025abf:	6a 0a                	push   $0xa
c0025ac1:	e8 8b ec ff ff       	call   c0024751 <timer_usleep>
c0025ac6:	83 c4 10             	add    $0x10,%esp
c0025ac9:	be e7 03 00 00       	mov    $0x3e7,%esi
        if ((inb(reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025ace:	8b 47 08             	mov    0x8(%edi),%eax
c0025ad1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025ad5:	8d 50 07             	lea    0x7(%eax),%edx
c0025ad8:	ec                   	in     (%dx),%al
c0025ad9:	a8 88                	test   $0x88,%al
c0025adb:	74 27                	je     c0025b04 <wait_until_idle+0x69>
        timer_usleep(10);
c0025add:	83 ec 08             	sub    $0x8,%esp
c0025ae0:	6a 00                	push   $0x0
c0025ae2:	6a 0a                	push   $0xa
c0025ae4:	e8 68 ec ff ff       	call   c0024751 <timer_usleep>
    for (i = 0; i < 1000; i++) {
c0025ae9:	83 c4 10             	add    $0x10,%esp
c0025aec:	83 ee 01             	sub    $0x1,%esi
c0025aef:	75 dd                	jne    c0025ace <wait_until_idle+0x33>
    printf("%s: idle timeout\n", d->name);
c0025af1:	83 ec 08             	sub    $0x8,%esp
c0025af4:	57                   	push   %edi
c0025af5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0025afb:	50                   	push   %eax
c0025afc:	e8 d0 19 00 00       	call   c00274d1 <printf>
c0025b01:	83 c4 10             	add    $0x10,%esp
}
c0025b04:	5b                   	pop    %ebx
c0025b05:	5e                   	pop    %esi
c0025b06:	5f                   	pop    %edi
c0025b07:	c3                   	ret    

c0025b08 <select_device>:
select_device(const struct ata_disk *d) {
c0025b08:	53                   	push   %ebx
c0025b09:	83 ec 10             	sub    $0x10,%esp
c0025b0c:	e8 32 a6 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025b11:	81 c3 9b 81 01 00    	add    $0x1819b,%ebx
    struct channel *c = d->channel;
c0025b17:	8b 50 08             	mov    0x8(%eax),%edx
    if (d->dev_no == 1)
c0025b1a:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
        dev |= DEV_DEV;
c0025b1e:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
c0025b23:	b9 b0 ff ff ff       	mov    $0xffffffb0,%ecx
c0025b28:	0f 44 c1             	cmove  %ecx,%eax
    outb(reg_device (c), dev);
c0025b2b:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
c0025b2f:	8d 51 06             	lea    0x6(%ecx),%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025b32:	ee                   	out    %al,(%dx)
    inb(reg_alt_status (c));
c0025b33:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025b39:	ec                   	in     (%dx),%al
    timer_nsleep(400);
c0025b3a:	6a 00                	push   $0x0
c0025b3c:	68 90 01 00 00       	push   $0x190
c0025b41:	e8 24 ec ff ff       	call   c002476a <timer_nsleep>
}
c0025b46:	83 c4 18             	add    $0x18,%esp
c0025b49:	5b                   	pop    %ebx
c0025b4a:	c3                   	ret    

c0025b4b <check_device_type>:
check_device_type(struct ata_disk *d) {
c0025b4b:	55                   	push   %ebp
c0025b4c:	57                   	push   %edi
c0025b4d:	56                   	push   %esi
c0025b4e:	53                   	push   %ebx
c0025b4f:	83 ec 0c             	sub    $0xc,%esp
c0025b52:	89 c6                	mov    %eax,%esi
    struct channel *c = d->channel;
c0025b54:	8b 58 08             	mov    0x8(%eax),%ebx
    select_device(d);
c0025b57:	e8 ac ff ff ff       	call   c0025b08 <select_device>
    error = inb(reg_error (c));
c0025b5c:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c0025b60:	8d 51 01             	lea    0x1(%ecx),%edx
c0025b63:	ec                   	in     (%dx),%al
c0025b64:	89 c3                	mov    %eax,%ebx
    lbam = inb(reg_lbam (c));
c0025b66:	8d 51 04             	lea    0x4(%ecx),%edx
c0025b69:	ec                   	in     (%dx),%al
c0025b6a:	89 c5                	mov    %eax,%ebp
    lbah = inb(reg_lbah (c));
c0025b6c:	8d 51 05             	lea    0x5(%ecx),%edx
c0025b6f:	ec                   	in     (%dx),%al
c0025b70:	89 c7                	mov    %eax,%edi
    status = inb(reg_status (c));
c0025b72:	8d 51 07             	lea    0x7(%ecx),%edx
c0025b75:	ec                   	in     (%dx),%al
    if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025b76:	80 fb 01             	cmp    $0x1,%bl
c0025b79:	74 0b                	je     c0025b86 <check_device_type+0x3b>
c0025b7b:	80 fb 81             	cmp    $0x81,%bl
c0025b7e:	75 3b                	jne    c0025bbb <check_device_type+0x70>
c0025b80:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0025b84:	74 35                	je     c0025bbb <check_device_type+0x70>
        || (status & STA_DRDY) == 0
c0025b86:	a8 40                	test   $0x40,%al
c0025b88:	74 31                	je     c0025bbb <check_device_type+0x70>
        || (status & STA_BSY) != 0) {
c0025b8a:	84 c0                	test   %al,%al
c0025b8c:	78 2d                	js     c0025bbb <check_device_type+0x70>
        d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025b8e:	b8 01 00 00 00       	mov    $0x1,%eax
c0025b93:	89 f9                	mov    %edi,%ecx
c0025b95:	89 eb                	mov    %ebp,%ebx
c0025b97:	08 d9                	or     %bl,%cl
c0025b99:	74 12                	je     c0025bad <check_device_type+0x62>
c0025b9b:	80 fb 3c             	cmp    $0x3c,%bl
c0025b9e:	0f 94 c2             	sete   %dl
c0025ba1:	89 f8                	mov    %edi,%eax
c0025ba3:	3c c3                	cmp    $0xc3,%al
c0025ba5:	0f 94 c0             	sete   %al
c0025ba8:	0f b6 c0             	movzbl %al,%eax
c0025bab:	21 d0                	and    %edx,%eax
c0025bad:	88 46 10             	mov    %al,0x10(%esi)
c0025bb0:	80 66 10 01          	andb   $0x1,0x10(%esi)
        return true;
c0025bb4:	b8 01 00 00 00       	mov    $0x1,%eax
c0025bb9:	eb 0a                	jmp    c0025bc5 <check_device_type+0x7a>
        d->is_ata = false;
c0025bbb:	c6 46 10 00          	movb   $0x0,0x10(%esi)
        return error != 0x81;
c0025bbf:	80 fb 81             	cmp    $0x81,%bl
c0025bc2:	0f 95 c0             	setne  %al
}
c0025bc5:	83 c4 0c             	add    $0xc,%esp
c0025bc8:	5b                   	pop    %ebx
c0025bc9:	5e                   	pop    %esi
c0025bca:	5f                   	pop    %edi
c0025bcb:	5d                   	pop    %ebp
c0025bcc:	c3                   	ret    

c0025bcd <select_sector>:
select_sector(struct ata_disk *d, block_sector_t sec_no) {
c0025bcd:	55                   	push   %ebp
c0025bce:	57                   	push   %edi
c0025bcf:	56                   	push   %esi
c0025bd0:	53                   	push   %ebx
c0025bd1:	83 ec 0c             	sub    $0xc,%esp
c0025bd4:	e8 6a a5 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025bd9:	81 c3 d3 80 01 00    	add    $0x180d3,%ebx
    struct channel *c = d->channel;
c0025bdf:	8b 68 08             	mov    0x8(%eax),%ebp
    ASSERT (sec_no < (1UL << 28));
c0025be2:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0025be8:	77 5e                	ja     c0025c48 <select_sector+0x7b>
c0025bea:	89 c7                	mov    %eax,%edi
c0025bec:	89 d6                	mov    %edx,%esi
    wait_until_idle(d);
c0025bee:	e8 a8 fe ff ff       	call   c0025a9b <wait_until_idle>
    select_device(d);
c0025bf3:	89 f8                	mov    %edi,%eax
c0025bf5:	e8 0e ff ff ff       	call   c0025b08 <select_device>
    wait_until_idle(d);
c0025bfa:	89 f8                	mov    %edi,%eax
c0025bfc:	e8 9a fe ff ff       	call   c0025a9b <wait_until_idle>
    outb(reg_nsect (c), 1);
c0025c01:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
c0025c05:	8d 51 02             	lea    0x2(%ecx),%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025c08:	b8 01 00 00 00       	mov    $0x1,%eax
c0025c0d:	ee                   	out    %al,(%dx)
    outb(reg_lbal (c), sec_no);
c0025c0e:	8d 51 03             	lea    0x3(%ecx),%edx
c0025c11:	89 f0                	mov    %esi,%eax
c0025c13:	ee                   	out    %al,(%dx)
    outb(reg_lbam (c), sec_no >> 8);
c0025c14:	89 f0                	mov    %esi,%eax
c0025c16:	c1 e8 08             	shr    $0x8,%eax
c0025c19:	8d 51 04             	lea    0x4(%ecx),%edx
c0025c1c:	ee                   	out    %al,(%dx)
    outb(reg_lbah (c), (sec_no >> 16));
c0025c1d:	89 f0                	mov    %esi,%eax
c0025c1f:	c1 e8 10             	shr    $0x10,%eax
c0025c22:	8d 51 05             	lea    0x5(%ecx),%edx
c0025c25:	ee                   	out    %al,(%dx)
         DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0025c26:	83 7f 0c 01          	cmpl   $0x1,0xc(%edi)
c0025c2a:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
c0025c2f:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c0025c34:	0f 45 c2             	cmovne %edx,%eax
c0025c37:	c1 ee 18             	shr    $0x18,%esi
c0025c3a:	09 f0                	or     %esi,%eax
    outb(reg_device (c),
c0025c3c:	8d 51 06             	lea    0x6(%ecx),%edx
c0025c3f:	ee                   	out    %al,(%dx)
}
c0025c40:	83 c4 0c             	add    $0xc,%esp
c0025c43:	5b                   	pop    %ebx
c0025c44:	5e                   	pop    %esi
c0025c45:	5f                   	pop    %edi
c0025c46:	5d                   	pop    %ebp
c0025c47:	c3                   	ret    
    ASSERT (sec_no < (1UL << 28));
c0025c48:	83 ec 0c             	sub    $0xc,%esp
c0025c4b:	8d 83 57 4e ff ff    	lea    -0xb1a9(%ebx),%eax
c0025c51:	50                   	push   %eax
c0025c52:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0025c58:	50                   	push   %eax
c0025c59:	8d 83 28 29 ff ff    	lea    -0xd6d8(%ebx),%eax
c0025c5f:	50                   	push   %eax
c0025c60:	68 7b 01 00 00       	push   $0x17b
c0025c65:	8d 83 31 4e ff ff    	lea    -0xb1cf(%ebx),%eax
c0025c6b:	50                   	push   %eax
c0025c6c:	e8 bc 34 00 00       	call   c002912d <debug_panic>

c0025c71 <wait_while_busy>:
wait_while_busy(const struct ata_disk *d) {
c0025c71:	55                   	push   %ebp
c0025c72:	57                   	push   %edi
c0025c73:	56                   	push   %esi
c0025c74:	53                   	push   %ebx
c0025c75:	83 ec 1c             	sub    $0x1c,%esp
c0025c78:	e8 c6 a4 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025c7d:	81 c3 2f 80 01 00    	add    $0x1802f,%ebx
c0025c83:	89 c5                	mov    %eax,%ebp
    struct channel *c = d->channel;
c0025c85:	8b 78 08             	mov    0x8(%eax),%edi
    for (i = 0; i < 3000; i++) {
c0025c88:	be 00 00 00 00       	mov    $0x0,%esi
            printf("%s: busy, waiting...", d->name);
c0025c8d:	8d 83 6c 4e ff ff    	lea    -0xb194(%ebx),%eax
c0025c93:	89 44 24 0c          	mov    %eax,0xc(%esp)
        if (!(inb(reg_alt_status (c)) & STA_BSY)) {
c0025c97:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025c9b:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025ca1:	ec                   	in     (%dx),%al
c0025ca2:	84 c0                	test   %al,%al
c0025ca4:	79 34                	jns    c0025cda <wait_while_busy+0x69>
        timer_msleep(10);
c0025ca6:	83 ec 08             	sub    $0x8,%esp
c0025ca9:	6a 00                	push   $0x0
c0025cab:	6a 0a                	push   $0xa
c0025cad:	e8 86 ea ff ff       	call   c0024738 <timer_msleep>
    for (i = 0; i < 3000; i++) {
c0025cb2:	83 c6 01             	add    $0x1,%esi
c0025cb5:	83 c4 10             	add    $0x10,%esp
c0025cb8:	81 fe b8 0b 00 00    	cmp    $0xbb8,%esi
c0025cbe:	74 4f                	je     c0025d0f <wait_while_busy+0x9e>
        if (i == 700)
c0025cc0:	81 fe bc 02 00 00    	cmp    $0x2bc,%esi
c0025cc6:	75 cf                	jne    c0025c97 <wait_while_busy+0x26>
            printf("%s: busy, waiting...", d->name);
c0025cc8:	83 ec 08             	sub    $0x8,%esp
c0025ccb:	55                   	push   %ebp
c0025ccc:	ff 74 24 18          	pushl  0x18(%esp)
c0025cd0:	e8 fc 17 00 00       	call   c00274d1 <printf>
c0025cd5:	83 c4 10             	add    $0x10,%esp
c0025cd8:	eb bd                	jmp    c0025c97 <wait_while_busy+0x26>
            if (i >= 700)
c0025cda:	81 fe bb 02 00 00    	cmp    $0x2bb,%esi
c0025ce0:	7f 19                	jg     c0025cfb <wait_while_busy+0x8a>
            return (inb(reg_alt_status (c)) & STA_DRQ) != 0;
c0025ce2:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025ce6:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025cec:	ec                   	in     (%dx),%al
c0025ced:	c0 e8 03             	shr    $0x3,%al
c0025cf0:	83 e0 01             	and    $0x1,%eax
}
c0025cf3:	83 c4 1c             	add    $0x1c,%esp
c0025cf6:	5b                   	pop    %ebx
c0025cf7:	5e                   	pop    %esi
c0025cf8:	5f                   	pop    %edi
c0025cf9:	5d                   	pop    %ebp
c0025cfa:	c3                   	ret    
                printf("ok\n");
c0025cfb:	83 ec 0c             	sub    $0xc,%esp
c0025cfe:	8d 83 81 4e ff ff    	lea    -0xb17f(%ebx),%eax
c0025d04:	50                   	push   %eax
c0025d05:	e8 f9 53 00 00       	call   c002b103 <puts>
c0025d0a:	83 c4 10             	add    $0x10,%esp
c0025d0d:	eb d3                	jmp    c0025ce2 <wait_while_busy+0x71>
    printf("failed\n");
c0025d0f:	83 ec 0c             	sub    $0xc,%esp
c0025d12:	8d 83 6c 5c ff ff    	lea    -0xa394(%ebx),%eax
c0025d18:	50                   	push   %eax
c0025d19:	e8 e5 53 00 00       	call   c002b103 <puts>
    return false;
c0025d1e:	83 c4 10             	add    $0x10,%esp
c0025d21:	b8 00 00 00 00       	mov    $0x0,%eax
c0025d26:	eb cb                	jmp    c0025cf3 <wait_while_busy+0x82>

c0025d28 <issue_pio_command>:
issue_pio_command(struct channel *c, uint8_t command) {
c0025d28:	57                   	push   %edi
c0025d29:	56                   	push   %esi
c0025d2a:	53                   	push   %ebx
c0025d2b:	e8 13 a4 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025d30:	81 c3 7c 7f 01 00    	add    $0x17f7c,%ebx
c0025d36:	89 c7                	mov    %eax,%edi
c0025d38:	89 d6                	mov    %edx,%esi
    ASSERT (intr_get_level() == INTR_ON);
c0025d3a:	e8 d1 bf ff ff       	call   c0021d10 <intr_get_level>
c0025d3f:	83 f8 01             	cmp    $0x1,%eax
c0025d42:	75 12                	jne    c0025d56 <issue_pio_command+0x2e>
    c->expecting_interrupt = true;
c0025d44:	c6 47 30 01          	movb   $0x1,0x30(%edi)
    outb(reg_command (c), command);
c0025d48:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025d4c:	83 c2 07             	add    $0x7,%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025d4f:	89 f0                	mov    %esi,%eax
c0025d51:	ee                   	out    %al,(%dx)
}
c0025d52:	5b                   	pop    %ebx
c0025d53:	5e                   	pop    %esi
c0025d54:	5f                   	pop    %edi
c0025d55:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c0025d56:	83 ec 0c             	sub    $0xc,%esp
c0025d59:	8d 83 96 45 ff ff    	lea    -0xba6a(%ebx),%eax
c0025d5f:	50                   	push   %eax
c0025d60:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0025d66:	50                   	push   %eax
c0025d67:	8d 83 08 29 ff ff    	lea    -0xd6f8(%ebx),%eax
c0025d6d:	50                   	push   %eax
c0025d6e:	68 8c 01 00 00       	push   $0x18c
c0025d73:	8d 83 31 4e ff ff    	lea    -0xb1cf(%ebx),%eax
c0025d79:	50                   	push   %eax
c0025d7a:	e8 ae 33 00 00       	call   c002912d <debug_panic>

c0025d7f <ide_write>:
ide_write(void *d_, block_sector_t sec_no, const void *buffer) {
c0025d7f:	55                   	push   %ebp
c0025d80:	57                   	push   %edi
c0025d81:	56                   	push   %esi
c0025d82:	53                   	push   %ebx
c0025d83:	83 ec 18             	sub    $0x18,%esp
c0025d86:	e8 b8 a3 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025d8b:	81 c3 21 7f 01 00    	add    $0x17f21,%ebx
c0025d91:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    struct channel *c = d->channel;
c0025d95:	8b 7e 08             	mov    0x8(%esi),%edi
    lock_acquire(&c->lock);
c0025d98:	8d 6f 0c             	lea    0xc(%edi),%ebp
c0025d9b:	55                   	push   %ebp
c0025d9c:	e8 bb d4 ff ff       	call   c002325c <lock_acquire>
    select_sector(d, sec_no);
c0025da1:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025da5:	89 f0                	mov    %esi,%eax
c0025da7:	e8 21 fe ff ff       	call   c0025bcd <select_sector>
    issue_pio_command(c, CMD_WRITE_SECTOR_RETRY);
c0025dac:	ba 30 00 00 00       	mov    $0x30,%edx
c0025db1:	89 f8                	mov    %edi,%eax
c0025db3:	e8 70 ff ff ff       	call   c0025d28 <issue_pio_command>
    if (!wait_while_busy(d))
c0025db8:	89 f0                	mov    %esi,%eax
c0025dba:	e8 b2 fe ff ff       	call   c0025c71 <wait_while_busy>
c0025dbf:	83 c4 10             	add    $0x10,%esp
c0025dc2:	84 c0                	test   %al,%al
c0025dc4:	74 2c                	je     c0025df2 <ide_write+0x73>
/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw(uint16_t port, const void *addr, size_t cnt) {
    /* See [IA32-v2b] "OUTS". */
    asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025dc6:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025dca:	8b 74 24 28          	mov    0x28(%esp),%esi
c0025dce:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025dd3:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
    sema_down(&c->completion_wait);
c0025dd6:	83 ec 0c             	sub    $0xc,%esp
c0025dd9:	83 c7 34             	add    $0x34,%edi
c0025ddc:	57                   	push   %edi
c0025ddd:	e8 51 d1 ff ff       	call   c0022f33 <sema_down>
    lock_release(&c->lock);
c0025de2:	89 2c 24             	mov    %ebp,(%esp)
c0025de5:	e8 73 d6 ff ff       	call   c002345d <lock_release>
}
c0025dea:	83 c4 1c             	add    $0x1c,%esp
c0025ded:	5b                   	pop    %ebx
c0025dee:	5e                   	pop    %esi
c0025def:	5f                   	pop    %edi
c0025df0:	5d                   	pop    %ebp
c0025df1:	c3                   	ret    
        PANIC ("%s: disk write failed, sector=%"
c0025df2:	83 ec 08             	sub    $0x8,%esp
c0025df5:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025df9:	56                   	push   %esi
c0025dfa:	8d 83 d0 4e ff ff    	lea    -0xb130(%ebx),%eax
c0025e00:	50                   	push   %eax
c0025e01:	8d 83 38 29 ff ff    	lea    -0xd6c8(%ebx),%eax
c0025e07:	50                   	push   %eax
c0025e08:	68 68 01 00 00       	push   $0x168
c0025e0d:	8d 83 31 4e ff ff    	lea    -0xb1cf(%ebx),%eax
c0025e13:	50                   	push   %eax
c0025e14:	e8 14 33 00 00       	call   c002912d <debug_panic>

c0025e19 <identify_ata_device>:
identify_ata_device(struct ata_disk *d) {
c0025e19:	55                   	push   %ebp
c0025e1a:	57                   	push   %edi
c0025e1b:	56                   	push   %esi
c0025e1c:	53                   	push   %ebx
c0025e1d:	81 ec 8c 02 00 00    	sub    $0x28c,%esp
c0025e23:	e8 1b a3 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025e28:	81 c3 84 7e 01 00    	add    $0x17e84,%ebx
    struct channel *c = d->channel;
c0025e2e:	8b 78 08             	mov    0x8(%eax),%edi
    ASSERT (d->is_ata);
c0025e31:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c0025e35:	74 4a                	je     c0025e81 <identify_ata_device+0x68>
c0025e37:	89 c6                	mov    %eax,%esi
    wait_until_idle(d);
c0025e39:	e8 5d fc ff ff       	call   c0025a9b <wait_until_idle>
    select_device(d);
c0025e3e:	89 f0                	mov    %esi,%eax
c0025e40:	e8 c3 fc ff ff       	call   c0025b08 <select_device>
    wait_until_idle(d);
c0025e45:	89 f0                	mov    %esi,%eax
c0025e47:	e8 4f fc ff ff       	call   c0025a9b <wait_until_idle>
    issue_pio_command(c, CMD_IDENTIFY_DEVICE);
c0025e4c:	ba ec 00 00 00       	mov    $0xec,%edx
c0025e51:	89 f8                	mov    %edi,%eax
c0025e53:	e8 d0 fe ff ff       	call   c0025d28 <issue_pio_command>
    sema_down(&c->completion_wait);
c0025e58:	83 ec 0c             	sub    $0xc,%esp
c0025e5b:	8d 47 34             	lea    0x34(%edi),%eax
c0025e5e:	50                   	push   %eax
c0025e5f:	e8 cf d0 ff ff       	call   c0022f33 <sema_down>
    if (!wait_while_busy(d)) {
c0025e64:	89 f0                	mov    %esi,%eax
c0025e66:	e8 06 fe ff ff       	call   c0025c71 <wait_while_busy>
c0025e6b:	83 c4 10             	add    $0x10,%esp
c0025e6e:	84 c0                	test   %al,%al
c0025e70:	75 38                	jne    c0025eaa <identify_ata_device+0x91>
        d->is_ata = false;
c0025e72:	c6 46 10 00          	movb   $0x0,0x10(%esi)
}
c0025e76:	81 c4 8c 02 00 00    	add    $0x28c,%esp
c0025e7c:	5b                   	pop    %ebx
c0025e7d:	5e                   	pop    %esi
c0025e7e:	5f                   	pop    %edi
c0025e7f:	5d                   	pop    %ebp
c0025e80:	c3                   	ret    
    ASSERT (d->is_ata);
c0025e81:	83 ec 0c             	sub    $0xc,%esp
c0025e84:	8d 83 84 4e ff ff    	lea    -0xb17c(%ebx),%eax
c0025e8a:	50                   	push   %eax
c0025e8b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0025e91:	50                   	push   %eax
c0025e92:	8d 83 44 29 ff ff    	lea    -0xd6bc(%ebx),%eax
c0025e98:	50                   	push   %eax
c0025e99:	68 05 01 00 00       	push   $0x105
c0025e9e:	8d 83 31 4e ff ff    	lea    -0xb1cf(%ebx),%eax
c0025ea4:	50                   	push   %eax
c0025ea5:	e8 83 32 00 00       	call   c002912d <debug_panic>
    asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025eaa:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025eae:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025eb5:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025eba:	66 f3 6d             	rep insw (%dx),%es:(%edi)
    capacity = *(uint32_t *) &id[60 * 2];
c0025ebd:	8b bc 24 f8 00 00 00 	mov    0xf8(%esp),%edi
    model = descramble_ata_string(&id[10 * 2], 20);
c0025ec4:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0025ecb:	ba 14 00 00 00       	mov    $0x14,%edx
c0025ed0:	e8 e4 fa ff ff       	call   c00259b9 <descramble_ata_string>
c0025ed5:	89 c5                	mov    %eax,%ebp
    serial = descramble_ata_string(&id[27 * 2], 40);
c0025ed7:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0025ede:	ba 28 00 00 00       	mov    $0x28,%edx
c0025ee3:	e8 d1 fa ff ff       	call   c00259b9 <descramble_ata_string>
    snprintf(extra_info, sizeof extra_info,
c0025ee8:	83 ec 0c             	sub    $0xc,%esp
c0025eeb:	50                   	push   %eax
c0025eec:	55                   	push   %ebp
c0025eed:	8d 83 8e 4e ff ff    	lea    -0xb172(%ebx),%eax
c0025ef3:	50                   	push   %eax
c0025ef4:	68 80 00 00 00       	push   $0x80
c0025ef9:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0025efd:	50                   	push   %eax
c0025efe:	e8 5f 1d 00 00       	call   c0027c62 <snprintf>
    if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE) {
c0025f03:	83 c4 20             	add    $0x20,%esp
c0025f06:	81 ff ff ff 1f 00    	cmp    $0x1fffff,%edi
c0025f0c:	77 2a                	ja     c0025f38 <identify_ata_device+0x11f>
    block = block_register(d->name, BLOCK_RAW, extra_info, capacity,
c0025f0e:	83 ec 08             	sub    $0x8,%esp
c0025f11:	56                   	push   %esi
c0025f12:	8d 83 dc ff ff ff    	lea    -0x24(%ebx),%eax
c0025f18:	50                   	push   %eax
c0025f19:	57                   	push   %edi
c0025f1a:	8d 44 24 14          	lea    0x14(%esp),%eax
c0025f1e:	50                   	push   %eax
c0025f1f:	6a 04                	push   $0x4
c0025f21:	56                   	push   %esi
c0025f22:	e8 a6 f4 ff ff       	call   c00253cd <block_register>
    partition_scan(block);
c0025f27:	83 c4 14             	add    $0x14,%esp
c0025f2a:	50                   	push   %eax
c0025f2b:	e8 29 fa ff ff       	call   c0025959 <partition_scan>
c0025f30:	83 c4 10             	add    $0x10,%esp
c0025f33:	e9 3e ff ff ff       	jmp    c0025e76 <identify_ata_device+0x5d>
        printf("%s: ignoring ", d->name);
c0025f38:	83 ec 08             	sub    $0x8,%esp
c0025f3b:	56                   	push   %esi
c0025f3c:	8d 83 a6 4e ff ff    	lea    -0xb15a(%ebx),%eax
c0025f42:	50                   	push   %eax
c0025f43:	e8 89 15 00 00       	call   c00274d1 <printf>
        print_human_readable_size(capacity * 512);
c0025f48:	83 c4 08             	add    $0x8,%esp
c0025f4b:	c1 e7 09             	shl    $0x9,%edi
c0025f4e:	ba 00 00 00 00       	mov    $0x0,%edx
c0025f53:	52                   	push   %edx
c0025f54:	57                   	push   %edi
c0025f55:	e8 3d 1f 00 00       	call   c0027e97 <print_human_readable_size>
        printf("disk for safety\n");
c0025f5a:	8d 83 b4 4e ff ff    	lea    -0xb14c(%ebx),%eax
c0025f60:	89 04 24             	mov    %eax,(%esp)
c0025f63:	e8 9b 51 00 00       	call   c002b103 <puts>
        d->is_ata = false;
c0025f68:	c6 46 10 00          	movb   $0x0,0x10(%esi)
        return;
c0025f6c:	83 c4 10             	add    $0x10,%esp
c0025f6f:	e9 02 ff ff ff       	jmp    c0025e76 <identify_ata_device+0x5d>

c0025f74 <ide_read>:
ide_read(void *d_, block_sector_t sec_no, void *buffer) {
c0025f74:	55                   	push   %ebp
c0025f75:	57                   	push   %edi
c0025f76:	56                   	push   %esi
c0025f77:	53                   	push   %ebx
c0025f78:	83 ec 18             	sub    $0x18,%esp
c0025f7b:	e8 c3 a1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0025f80:	81 c3 2c 7d 01 00    	add    $0x17d2c,%ebx
c0025f86:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    struct channel *c = d->channel;
c0025f8a:	8b 77 08             	mov    0x8(%edi),%esi
    lock_acquire(&c->lock);
c0025f8d:	8d 6e 0c             	lea    0xc(%esi),%ebp
c0025f90:	55                   	push   %ebp
c0025f91:	e8 c6 d2 ff ff       	call   c002325c <lock_acquire>
    select_sector(d, sec_no);
c0025f96:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025f9a:	89 f8                	mov    %edi,%eax
c0025f9c:	e8 2c fc ff ff       	call   c0025bcd <select_sector>
    issue_pio_command(c, CMD_READ_SECTOR_RETRY);
c0025fa1:	ba 20 00 00 00       	mov    $0x20,%edx
c0025fa6:	89 f0                	mov    %esi,%eax
c0025fa8:	e8 7b fd ff ff       	call   c0025d28 <issue_pio_command>
    sema_down(&c->completion_wait);
c0025fad:	8d 46 34             	lea    0x34(%esi),%eax
c0025fb0:	89 04 24             	mov    %eax,(%esp)
c0025fb3:	e8 7b cf ff ff       	call   c0022f33 <sema_down>
    if (!wait_while_busy(d))
c0025fb8:	89 f8                	mov    %edi,%eax
c0025fba:	e8 b2 fc ff ff       	call   c0025c71 <wait_while_busy>
c0025fbf:	83 c4 10             	add    $0x10,%esp
c0025fc2:	84 c0                	test   %al,%al
c0025fc4:	74 21                	je     c0025fe7 <ide_read+0x73>
c0025fc6:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0025fca:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0025fce:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025fd3:	66 f3 6d             	rep insw (%dx),%es:(%edi)
    lock_release(&c->lock);
c0025fd6:	83 ec 0c             	sub    $0xc,%esp
c0025fd9:	55                   	push   %ebp
c0025fda:	e8 7e d4 ff ff       	call   c002345d <lock_release>
}
c0025fdf:	83 c4 1c             	add    $0x1c,%esp
c0025fe2:	5b                   	pop    %ebx
c0025fe3:	5e                   	pop    %esi
c0025fe4:	5f                   	pop    %edi
c0025fe5:	5d                   	pop    %ebp
c0025fe6:	c3                   	ret    
        PANIC ("%s: disk read failed, sector=%"
c0025fe7:	83 ec 08             	sub    $0x8,%esp
c0025fea:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025fee:	57                   	push   %edi
c0025fef:	8d 83 f4 4e ff ff    	lea    -0xb10c(%ebx),%eax
c0025ff5:	50                   	push   %eax
c0025ff6:	8d 83 1c 29 ff ff    	lea    -0xd6e4(%ebx),%eax
c0025ffc:	50                   	push   %eax
c0025ffd:	68 55 01 00 00       	push   $0x155
c0026002:	8d 83 31 4e ff ff    	lea    -0xb1cf(%ebx),%eax
c0026008:	50                   	push   %eax
c0026009:	e8 1f 31 00 00       	call   c002912d <debug_panic>

c002600e <ide_init>:
ide_init(void) {
c002600e:	55                   	push   %ebp
c002600f:	57                   	push   %edi
c0026010:	56                   	push   %esi
c0026011:	53                   	push   %ebx
c0026012:	83 ec 2c             	sub    $0x2c,%esp
c0026015:	e8 29 a1 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002601a:	81 c3 92 7c 01 00    	add    $0x17c92,%ebx
        snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c0026020:	6a 00                	push   $0x0
c0026022:	8d 83 c4 4e ff ff    	lea    -0xb13c(%ebx),%eax
c0026028:	50                   	push   %eax
c0026029:	6a 08                	push   $0x8
c002602b:	8d b3 b4 19 00 00    	lea    0x19b4(%ebx),%esi
c0026031:	56                   	push   %esi
c0026032:	e8 2b 1c 00 00       	call   c0027c62 <snprintf>
                c->reg_base = 0x1f0;
c0026037:	66 c7 83 bc 19 00 00 	movw   $0x1f0,0x19bc(%ebx)
c002603e:	f0 01 
                c->irq = 14 + 0x20;
c0026040:	c6 83 be 19 00 00 2e 	movb   $0x2e,0x19be(%ebx)
        lock_init(&c->lock);
c0026047:	8d 83 c0 19 00 00    	lea    0x19c0(%ebx),%eax
c002604d:	89 04 24             	mov    %eax,(%esp)
c0026050:	e8 5b d1 ff ff       	call   c00231b0 <lock_init>
        c->expecting_interrupt = false;
c0026055:	c6 83 e4 19 00 00 00 	movb   $0x0,0x19e4(%ebx)
        sema_init(&c->completion_wait, 0);
c002605c:	83 c4 08             	add    $0x8,%esp
c002605f:	6a 00                	push   $0x0
c0026061:	8d 83 e8 19 00 00    	lea    0x19e8(%ebx),%eax
c0026067:	50                   	push   %eax
c0026068:	e8 72 ce ff ff       	call   c0022edf <sema_init>
            snprintf(d->name, sizeof d->name,
c002606d:	6a 61                	push   $0x61
c002606f:	8d bb cb 4e ff ff    	lea    -0xb135(%ebx),%edi
c0026075:	57                   	push   %edi
c0026076:	6a 08                	push   $0x8
c0026078:	8d ab fc 19 00 00    	lea    0x19fc(%ebx),%ebp
c002607e:	55                   	push   %ebp
c002607f:	e8 de 1b 00 00       	call   c0027c62 <snprintf>
            d->channel = c;
c0026084:	89 b3 04 1a 00 00    	mov    %esi,0x1a04(%ebx)
            d->dev_no = dev_no;
c002608a:	c7 83 08 1a 00 00 00 	movl   $0x0,0x1a08(%ebx)
c0026091:	00 00 00 
            d->is_ata = false;
c0026094:	c6 83 0c 1a 00 00 00 	movb   $0x0,0x1a0c(%ebx)
            snprintf(d->name, sizeof d->name,
c002609b:	83 c4 20             	add    $0x20,%esp
c002609e:	6a 62                	push   $0x62
c00260a0:	57                   	push   %edi
c00260a1:	6a 08                	push   $0x8
c00260a3:	8d 83 10 1a 00 00    	lea    0x1a10(%ebx),%eax
c00260a9:	50                   	push   %eax
c00260aa:	e8 b3 1b 00 00       	call   c0027c62 <snprintf>
            d->channel = c;
c00260af:	89 b3 18 1a 00 00    	mov    %esi,0x1a18(%ebx)
            d->dev_no = dev_no;
c00260b5:	c7 83 1c 1a 00 00 01 	movl   $0x1,0x1a1c(%ebx)
c00260bc:	00 00 00 
            d->is_ata = false;
c00260bf:	c6 83 20 1a 00 00 00 	movb   $0x0,0x1a20(%ebx)
        intr_register_ext(c->irq, interrupt_handler, c->name);
c00260c6:	83 c4 0c             	add    $0xc,%esp
c00260c9:	56                   	push   %esi
c00260ca:	8d 83 61 7d fe ff    	lea    -0x1829f(%ebx),%eax
c00260d0:	50                   	push   %eax
c00260d1:	0f b6 83 be 19 00 00 	movzbl 0x19be(%ebx),%eax
c00260d8:	50                   	push   %eax
c00260d9:	e8 60 be ff ff       	call   c0021f3e <intr_register_ext>
        select_device(d);
c00260de:	89 e8                	mov    %ebp,%eax
c00260e0:	e8 23 fa ff ff       	call   c0025b08 <select_device>
        outb(reg_nsect (c), 0x55);
c00260e5:	0f b7 8b bc 19 00 00 	movzwl 0x19bc(%ebx),%ecx
c00260ec:	8d 69 02             	lea    0x2(%ecx),%ebp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00260ef:	bf 55 00 00 00       	mov    $0x55,%edi
c00260f4:	89 f8                	mov    %edi,%eax
c00260f6:	89 ea                	mov    %ebp,%edx
c00260f8:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c00260f9:	83 c1 03             	add    $0x3,%ecx
c00260fc:	be aa ff ff ff       	mov    $0xffffffaa,%esi
c0026101:	89 f0                	mov    %esi,%eax
c0026103:	89 ca                	mov    %ecx,%edx
c0026105:	ee                   	out    %al,(%dx)
c0026106:	89 ea                	mov    %ebp,%edx
c0026108:	ee                   	out    %al,(%dx)
c0026109:	89 f8                	mov    %edi,%eax
c002610b:	89 ca                	mov    %ecx,%edx
c002610d:	ee                   	out    %al,(%dx)
c002610e:	89 ea                	mov    %ebp,%edx
c0026110:	ee                   	out    %al,(%dx)
c0026111:	89 f0                	mov    %esi,%eax
c0026113:	89 ca                	mov    %ecx,%edx
c0026115:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026116:	89 ea                	mov    %ebp,%edx
c0026118:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c0026119:	83 c4 10             	add    $0x10,%esp
c002611c:	ba 00 00 00 00       	mov    $0x0,%edx
c0026121:	3c 55                	cmp    $0x55,%al
c0026123:	0f 84 d6 01 00 00    	je     c00262ff <ide_init+0x2f1>
c0026129:	89 d0                	mov    %edx,%eax
c002612b:	83 e0 01             	and    $0x1,%eax
c002612e:	88 44 24 08          	mov    %al,0x8(%esp)
        present[dev_no] = (inb(reg_nsect (c)) == 0x55
c0026132:	88 44 24 1e          	mov    %al,0x1e(%esp)
        select_device(d);
c0026136:	8d 83 10 1a 00 00    	lea    0x1a10(%ebx),%eax
c002613c:	e8 c7 f9 ff ff       	call   c0025b08 <select_device>
        outb(reg_nsect (c), 0x55);
c0026141:	0f b7 ab bc 19 00 00 	movzwl 0x19bc(%ebx),%ebp
c0026148:	8d 4d 02             	lea    0x2(%ebp),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002614b:	b8 55 00 00 00       	mov    $0x55,%eax
c0026150:	89 ca                	mov    %ecx,%edx
c0026152:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c0026153:	8d 75 03             	lea    0x3(%ebp),%esi
c0026156:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c002615b:	89 f8                	mov    %edi,%eax
c002615d:	89 f2                	mov    %esi,%edx
c002615f:	ee                   	out    %al,(%dx)
c0026160:	89 ca                	mov    %ecx,%edx
c0026162:	ee                   	out    %al,(%dx)
c0026163:	b8 55 00 00 00       	mov    $0x55,%eax
c0026168:	89 f2                	mov    %esi,%edx
c002616a:	ee                   	out    %al,(%dx)
c002616b:	89 ca                	mov    %ecx,%edx
c002616d:	ee                   	out    %al,(%dx)
c002616e:	89 f8                	mov    %edi,%eax
c0026170:	89 f2                	mov    %esi,%edx
c0026172:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026173:	89 ca                	mov    %ecx,%edx
c0026175:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c0026176:	ba 00 00 00 00       	mov    $0x0,%edx
c002617b:	3c 55                	cmp    $0x55,%al
c002617d:	0f 84 8c 01 00 00    	je     c002630f <ide_init+0x301>
c0026183:	89 d6                	mov    %edx,%esi
c0026185:	83 e6 01             	and    $0x1,%esi
        present[dev_no] = (inb(reg_nsect (c)) == 0x55
c0026188:	89 f0                	mov    %esi,%eax
c002618a:	88 44 24 1f          	mov    %al,0x1f(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002618e:	bf 00 00 00 00       	mov    $0x0,%edi
    outb(reg_ctl (c), 0);
c0026193:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c0026199:	89 f8                	mov    %edi,%eax
c002619b:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c002619c:	83 ec 08             	sub    $0x8,%esp
c002619f:	6a 00                	push   $0x0
c00261a1:	6a 0a                	push   $0xa
c00261a3:	e8 a9 e5 ff ff       	call   c0024751 <timer_usleep>
    outb(reg_ctl (c), CTL_SRST);
c00261a8:	0f b7 93 bc 19 00 00 	movzwl 0x19bc(%ebx),%edx
c00261af:	66 81 c2 06 02       	add    $0x206,%dx
c00261b4:	b8 04 00 00 00       	mov    $0x4,%eax
c00261b9:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c00261ba:	83 c4 08             	add    $0x8,%esp
c00261bd:	6a 00                	push   $0x0
c00261bf:	6a 0a                	push   $0xa
c00261c1:	e8 8b e5 ff ff       	call   c0024751 <timer_usleep>
    outb(reg_ctl (c), 0);
c00261c6:	0f b7 93 bc 19 00 00 	movzwl 0x19bc(%ebx),%edx
c00261cd:	66 81 c2 06 02       	add    $0x206,%dx
c00261d2:	89 f8                	mov    %edi,%eax
c00261d4:	ee                   	out    %al,(%dx)
    timer_msleep(150);
c00261d5:	83 c4 08             	add    $0x8,%esp
c00261d8:	6a 00                	push   $0x0
c00261da:	68 96 00 00 00       	push   $0x96
c00261df:	e8 54 e5 ff ff       	call   c0024738 <timer_msleep>
    if (present[0]) {
c00261e4:	83 c4 10             	add    $0x10,%esp
c00261e7:	80 7c 24 08 00       	cmpb   $0x0,0x8(%esp)
c00261ec:	0f 85 2d 01 00 00    	jne    c002631f <ide_init+0x311>
    if (present[1]) {
c00261f2:	89 f0                	mov    %esi,%eax
c00261f4:	84 c0                	test   %al,%al
c00261f6:	0f 85 3e 01 00 00    	jne    c002633a <ide_init+0x32c>
        if (check_device_type(&c->devices[0]))
c00261fc:	8d 83 fc 19 00 00    	lea    0x19fc(%ebx),%eax
c0026202:	e8 44 f9 ff ff       	call   c0025b4b <check_device_type>
c0026207:	84 c0                	test   %al,%al
c0026209:	0f 85 78 01 00 00    	jne    c0026387 <ide_init+0x379>
            if (c->devices[dev_no].is_ata)
c002620f:	80 bb 0c 1a 00 00 00 	cmpb   $0x0,0x1a0c(%ebx)
c0026216:	0f 85 7b 01 00 00    	jne    c0026397 <ide_init+0x389>
c002621c:	80 bb 20 1a 00 00 00 	cmpb   $0x0,0x1a20(%ebx)
c0026223:	0f 85 7e 01 00 00    	jne    c00263a7 <ide_init+0x399>
        snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c0026229:	6a 01                	push   $0x1
c002622b:	8d 83 c4 4e ff ff    	lea    -0xb13c(%ebx),%eax
c0026231:	50                   	push   %eax
c0026232:	6a 08                	push   $0x8
c0026234:	8d b3 24 1a 00 00    	lea    0x1a24(%ebx),%esi
c002623a:	56                   	push   %esi
c002623b:	e8 22 1a 00 00       	call   c0027c62 <snprintf>
                c->reg_base = 0x170;
c0026240:	66 c7 83 2c 1a 00 00 	movw   $0x170,0x1a2c(%ebx)
c0026247:	70 01 
                c->irq = 15 + 0x20;
c0026249:	c6 83 2e 1a 00 00 2f 	movb   $0x2f,0x1a2e(%ebx)
        lock_init(&c->lock);
c0026250:	8d 83 30 1a 00 00    	lea    0x1a30(%ebx),%eax
c0026256:	89 04 24             	mov    %eax,(%esp)
c0026259:	e8 52 cf ff ff       	call   c00231b0 <lock_init>
        c->expecting_interrupt = false;
c002625e:	c6 83 54 1a 00 00 00 	movb   $0x0,0x1a54(%ebx)
        sema_init(&c->completion_wait, 0);
c0026265:	83 c4 08             	add    $0x8,%esp
c0026268:	6a 00                	push   $0x0
c002626a:	8d 83 58 1a 00 00    	lea    0x1a58(%ebx),%eax
c0026270:	50                   	push   %eax
c0026271:	e8 69 cc ff ff       	call   c0022edf <sema_init>
            snprintf(d->name, sizeof d->name,
c0026276:	6a 63                	push   $0x63
c0026278:	8d bb cb 4e ff ff    	lea    -0xb135(%ebx),%edi
c002627e:	57                   	push   %edi
c002627f:	6a 08                	push   $0x8
c0026281:	8d ab 6c 1a 00 00    	lea    0x1a6c(%ebx),%ebp
c0026287:	55                   	push   %ebp
c0026288:	e8 d5 19 00 00       	call   c0027c62 <snprintf>
            d->channel = c;
c002628d:	89 b3 74 1a 00 00    	mov    %esi,0x1a74(%ebx)
            d->dev_no = dev_no;
c0026293:	c7 83 78 1a 00 00 00 	movl   $0x0,0x1a78(%ebx)
c002629a:	00 00 00 
            d->is_ata = false;
c002629d:	c6 83 7c 1a 00 00 00 	movb   $0x0,0x1a7c(%ebx)
            snprintf(d->name, sizeof d->name,
c00262a4:	83 c4 20             	add    $0x20,%esp
c00262a7:	6a 64                	push   $0x64
c00262a9:	57                   	push   %edi
c00262aa:	6a 08                	push   $0x8
c00262ac:	8d 83 80 1a 00 00    	lea    0x1a80(%ebx),%eax
c00262b2:	50                   	push   %eax
c00262b3:	e8 aa 19 00 00       	call   c0027c62 <snprintf>
            d->channel = c;
c00262b8:	89 b3 88 1a 00 00    	mov    %esi,0x1a88(%ebx)
            d->dev_no = dev_no;
c00262be:	c7 83 8c 1a 00 00 01 	movl   $0x1,0x1a8c(%ebx)
c00262c5:	00 00 00 
            d->is_ata = false;
c00262c8:	c6 83 90 1a 00 00 00 	movb   $0x0,0x1a90(%ebx)
        intr_register_ext(c->irq, interrupt_handler, c->name);
c00262cf:	83 c4 0c             	add    $0xc,%esp
c00262d2:	56                   	push   %esi
c00262d3:	8d 83 61 7d fe ff    	lea    -0x1829f(%ebx),%eax
c00262d9:	50                   	push   %eax
c00262da:	0f b6 83 2e 1a 00 00 	movzbl 0x1a2e(%ebx),%eax
c00262e1:	50                   	push   %eax
c00262e2:	e8 57 bc ff ff       	call   c0021f3e <intr_register_ext>
    for (dev_no = 0; dev_no < 2; dev_no++) {
c00262e7:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c00262eb:	8d 6c 24 2e          	lea    0x2e(%esp),%ebp
c00262ef:	8d 44 24 30          	lea    0x30(%esp),%eax
c00262f3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00262f7:	83 c4 10             	add    $0x10,%esp
c00262fa:	e9 cd 00 00 00       	jmp    c00263cc <ide_init+0x3be>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00262ff:	89 ca                	mov    %ecx,%edx
c0026301:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c0026302:	3c aa                	cmp    $0xaa,%al
c0026304:	0f 94 c2             	sete   %dl
c0026307:	0f b6 d2             	movzbl %dl,%edx
c002630a:	e9 1a fe ff ff       	jmp    c0026129 <ide_init+0x11b>
c002630f:	89 f2                	mov    %esi,%edx
c0026311:	ec                   	in     (%dx),%al
c0026312:	3c aa                	cmp    $0xaa,%al
c0026314:	0f 94 c2             	sete   %dl
c0026317:	0f b6 d2             	movzbl %dl,%edx
c002631a:	e9 64 fe ff ff       	jmp    c0026183 <ide_init+0x175>
        select_device(&c->devices[0]);
c002631f:	8d 83 fc 19 00 00    	lea    0x19fc(%ebx),%eax
c0026325:	e8 de f7 ff ff       	call   c0025b08 <select_device>
        wait_while_busy(&c->devices[0]);
c002632a:	8d 83 fc 19 00 00    	lea    0x19fc(%ebx),%eax
c0026330:	e8 3c f9 ff ff       	call   c0025c71 <wait_while_busy>
c0026335:	e9 b8 fe ff ff       	jmp    c00261f2 <ide_init+0x1e4>
        select_device(&c->devices[1]);
c002633a:	8d 83 10 1a 00 00    	lea    0x1a10(%ebx),%eax
c0026340:	e8 c3 f7 ff ff       	call   c0025b08 <select_device>
c0026345:	be b8 0b 00 00       	mov    $0xbb8,%esi
c002634a:	eb 14                	jmp    c0026360 <ide_init+0x352>
            timer_msleep(10);
c002634c:	83 ec 08             	sub    $0x8,%esp
c002634f:	6a 00                	push   $0x0
c0026351:	6a 0a                	push   $0xa
c0026353:	e8 e0 e3 ff ff       	call   c0024738 <timer_msleep>
        for (i = 0; i < 3000; i++) {
c0026358:	83 c4 10             	add    $0x10,%esp
c002635b:	83 ee 01             	sub    $0x1,%esi
c002635e:	74 17                	je     c0026377 <ide_init+0x369>
            if (inb(reg_nsect (c)) == 1 && inb(reg_lbal (c)) == 1)
c0026360:	0f b7 8b bc 19 00 00 	movzwl 0x19bc(%ebx),%ecx
c0026367:	8d 51 02             	lea    0x2(%ecx),%edx
c002636a:	ec                   	in     (%dx),%al
c002636b:	3c 01                	cmp    $0x1,%al
c002636d:	75 dd                	jne    c002634c <ide_init+0x33e>
c002636f:	8d 51 03             	lea    0x3(%ecx),%edx
c0026372:	ec                   	in     (%dx),%al
c0026373:	3c 01                	cmp    $0x1,%al
c0026375:	75 d5                	jne    c002634c <ide_init+0x33e>
        wait_while_busy(&c->devices[1]);
c0026377:	8d 83 10 1a 00 00    	lea    0x1a10(%ebx),%eax
c002637d:	e8 ef f8 ff ff       	call   c0025c71 <wait_while_busy>
c0026382:	e9 75 fe ff ff       	jmp    c00261fc <ide_init+0x1ee>
            check_device_type(&c->devices[1]);
c0026387:	8d 83 10 1a 00 00    	lea    0x1a10(%ebx),%eax
c002638d:	e8 b9 f7 ff ff       	call   c0025b4b <check_device_type>
c0026392:	e9 78 fe ff ff       	jmp    c002620f <ide_init+0x201>
                identify_ata_device(&c->devices[dev_no]);
c0026397:	8d 83 fc 19 00 00    	lea    0x19fc(%ebx),%eax
c002639d:	e8 77 fa ff ff       	call   c0025e19 <identify_ata_device>
c00263a2:	e9 75 fe ff ff       	jmp    c002621c <ide_init+0x20e>
c00263a7:	8d 83 10 1a 00 00    	lea    0x1a10(%ebx),%eax
c00263ad:	e8 67 fa ff ff       	call   c0025e19 <identify_ata_device>
c00263b2:	e9 72 fe ff ff       	jmp    c0026229 <ide_init+0x21b>
                           && inb(reg_lbal (c)) == 0xaa);
c00263b7:	88 55 00             	mov    %dl,0x0(%ebp)
c00263ba:	80 65 00 01          	andb   $0x1,0x0(%ebp)
c00263be:	83 44 24 08 14       	addl   $0x14,0x8(%esp)
c00263c3:	83 c5 01             	add    $0x1,%ebp
    for (dev_no = 0; dev_no < 2; dev_no++) {
c00263c6:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c00263ca:	74 55                	je     c0026421 <ide_init+0x413>
        select_device(d);
c00263cc:	8b 44 24 08          	mov    0x8(%esp),%eax
c00263d0:	e8 33 f7 ff ff       	call   c0025b08 <select_device>
        outb(reg_nsect (c), 0x55);
c00263d5:	0f b7 bb 2c 1a 00 00 	movzwl 0x1a2c(%ebx),%edi
c00263dc:	8d 4f 02             	lea    0x2(%edi),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00263df:	b8 55 00 00 00       	mov    $0x55,%eax
c00263e4:	89 ca                	mov    %ecx,%edx
c00263e6:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c00263e7:	8d 77 03             	lea    0x3(%edi),%esi
c00263ea:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c00263ef:	89 f2                	mov    %esi,%edx
c00263f1:	ee                   	out    %al,(%dx)
c00263f2:	89 ca                	mov    %ecx,%edx
c00263f4:	ee                   	out    %al,(%dx)
c00263f5:	b8 55 00 00 00       	mov    $0x55,%eax
c00263fa:	89 f2                	mov    %esi,%edx
c00263fc:	ee                   	out    %al,(%dx)
c00263fd:	89 ca                	mov    %ecx,%edx
c00263ff:	ee                   	out    %al,(%dx)
c0026400:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c0026405:	89 f2                	mov    %esi,%edx
c0026407:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026408:	89 ca                	mov    %ecx,%edx
c002640a:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c002640b:	ba 00 00 00 00       	mov    $0x0,%edx
c0026410:	3c 55                	cmp    $0x55,%al
c0026412:	75 a3                	jne    c00263b7 <ide_init+0x3a9>
c0026414:	89 f2                	mov    %esi,%edx
c0026416:	ec                   	in     (%dx),%al
c0026417:	3c aa                	cmp    $0xaa,%al
c0026419:	0f 94 c2             	sete   %dl
c002641c:	0f b6 d2             	movzbl %dl,%edx
c002641f:	eb 96                	jmp    c00263b7 <ide_init+0x3a9>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026421:	be 00 00 00 00       	mov    $0x0,%esi
    outb(reg_ctl (c), 0);
c0026426:	8d 97 06 02 00 00    	lea    0x206(%edi),%edx
c002642c:	89 f0                	mov    %esi,%eax
c002642e:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c002642f:	83 ec 08             	sub    $0x8,%esp
c0026432:	6a 00                	push   $0x0
c0026434:	6a 0a                	push   $0xa
c0026436:	e8 16 e3 ff ff       	call   c0024751 <timer_usleep>
    outb(reg_ctl (c), CTL_SRST);
c002643b:	0f b7 93 2c 1a 00 00 	movzwl 0x1a2c(%ebx),%edx
c0026442:	66 81 c2 06 02       	add    $0x206,%dx
c0026447:	b8 04 00 00 00       	mov    $0x4,%eax
c002644c:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c002644d:	83 c4 08             	add    $0x8,%esp
c0026450:	6a 00                	push   $0x0
c0026452:	6a 0a                	push   $0xa
c0026454:	e8 f8 e2 ff ff       	call   c0024751 <timer_usleep>
    outb(reg_ctl (c), 0);
c0026459:	0f b7 93 2c 1a 00 00 	movzwl 0x1a2c(%ebx),%edx
c0026460:	66 81 c2 06 02       	add    $0x206,%dx
c0026465:	89 f0                	mov    %esi,%eax
c0026467:	ee                   	out    %al,(%dx)
    timer_msleep(150);
c0026468:	83 c4 08             	add    $0x8,%esp
c002646b:	6a 00                	push   $0x0
c002646d:	68 96 00 00 00       	push   $0x96
c0026472:	e8 c1 e2 ff ff       	call   c0024738 <timer_msleep>
    if (present[0]) {
c0026477:	83 c4 10             	add    $0x10,%esp
c002647a:	80 7c 24 1e 00       	cmpb   $0x0,0x1e(%esp)
c002647f:	75 38                	jne    c00264b9 <ide_init+0x4ab>
    if (present[1]) {
c0026481:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0026486:	75 49                	jne    c00264d1 <ide_init+0x4c3>
        if (check_device_type(&c->devices[0]))
c0026488:	8d 83 6c 1a 00 00    	lea    0x1a6c(%ebx),%eax
c002648e:	e8 b8 f6 ff ff       	call   c0025b4b <check_device_type>
c0026493:	84 c0                	test   %al,%al
c0026495:	0f 85 83 00 00 00    	jne    c002651e <ide_init+0x510>
            if (c->devices[dev_no].is_ata)
c002649b:	80 bb 7c 1a 00 00 00 	cmpb   $0x0,0x1a7c(%ebx)
c00264a2:	0f 85 96 00 00 00    	jne    c002653e <ide_init+0x530>
c00264a8:	80 bb 90 1a 00 00 00 	cmpb   $0x0,0x1a90(%ebx)
c00264af:	75 7d                	jne    c002652e <ide_init+0x520>
}
c00264b1:	83 c4 2c             	add    $0x2c,%esp
c00264b4:	5b                   	pop    %ebx
c00264b5:	5e                   	pop    %esi
c00264b6:	5f                   	pop    %edi
c00264b7:	5d                   	pop    %ebp
c00264b8:	c3                   	ret    
        select_device(&c->devices[0]);
c00264b9:	8d 83 6c 1a 00 00    	lea    0x1a6c(%ebx),%eax
c00264bf:	e8 44 f6 ff ff       	call   c0025b08 <select_device>
        wait_while_busy(&c->devices[0]);
c00264c4:	8d 83 6c 1a 00 00    	lea    0x1a6c(%ebx),%eax
c00264ca:	e8 a2 f7 ff ff       	call   c0025c71 <wait_while_busy>
c00264cf:	eb b0                	jmp    c0026481 <ide_init+0x473>
        select_device(&c->devices[1]);
c00264d1:	8d 83 80 1a 00 00    	lea    0x1a80(%ebx),%eax
c00264d7:	e8 2c f6 ff ff       	call   c0025b08 <select_device>
c00264dc:	be b8 0b 00 00       	mov    $0xbb8,%esi
c00264e1:	eb 14                	jmp    c00264f7 <ide_init+0x4e9>
            timer_msleep(10);
c00264e3:	83 ec 08             	sub    $0x8,%esp
c00264e6:	6a 00                	push   $0x0
c00264e8:	6a 0a                	push   $0xa
c00264ea:	e8 49 e2 ff ff       	call   c0024738 <timer_msleep>
        for (i = 0; i < 3000; i++) {
c00264ef:	83 c4 10             	add    $0x10,%esp
c00264f2:	83 ee 01             	sub    $0x1,%esi
c00264f5:	74 17                	je     c002650e <ide_init+0x500>
            if (inb(reg_nsect (c)) == 1 && inb(reg_lbal (c)) == 1)
c00264f7:	0f b7 8b 2c 1a 00 00 	movzwl 0x1a2c(%ebx),%ecx
c00264fe:	8d 51 02             	lea    0x2(%ecx),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026501:	ec                   	in     (%dx),%al
c0026502:	3c 01                	cmp    $0x1,%al
c0026504:	75 dd                	jne    c00264e3 <ide_init+0x4d5>
c0026506:	8d 51 03             	lea    0x3(%ecx),%edx
c0026509:	ec                   	in     (%dx),%al
c002650a:	3c 01                	cmp    $0x1,%al
c002650c:	75 d5                	jne    c00264e3 <ide_init+0x4d5>
        wait_while_busy(&c->devices[1]);
c002650e:	8d 83 80 1a 00 00    	lea    0x1a80(%ebx),%eax
c0026514:	e8 58 f7 ff ff       	call   c0025c71 <wait_while_busy>
c0026519:	e9 6a ff ff ff       	jmp    c0026488 <ide_init+0x47a>
            check_device_type(&c->devices[1]);
c002651e:	8d 83 80 1a 00 00    	lea    0x1a80(%ebx),%eax
c0026524:	e8 22 f6 ff ff       	call   c0025b4b <check_device_type>
c0026529:	e9 6d ff ff ff       	jmp    c002649b <ide_init+0x48d>
                identify_ata_device(&c->devices[dev_no]);
c002652e:	8d 83 80 1a 00 00    	lea    0x1a80(%ebx),%eax
c0026534:	e8 e0 f8 ff ff       	call   c0025e19 <identify_ata_device>
}
c0026539:	e9 73 ff ff ff       	jmp    c00264b1 <ide_init+0x4a3>
                identify_ata_device(&c->devices[dev_no]);
c002653e:	8d 83 6c 1a 00 00    	lea    0x1a6c(%ebx),%eax
c0026544:	e8 d0 f8 ff ff       	call   c0025e19 <identify_ata_device>
c0026549:	e9 5a ff ff ff       	jmp    c00264a8 <ide_init+0x49a>

c002654e <input_init>:
/* Stores keys from the keyboard and serial port. */
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init(void) {
c002654e:	53                   	push   %ebx
c002654f:	83 ec 14             	sub    $0x14,%esp
c0026552:	e8 ec 9b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026557:	81 c3 55 77 01 00    	add    $0x17755,%ebx
    intq_init(&buffer);
c002655d:	8d 83 94 1a 00 00    	lea    0x1a94(%ebx),%eax
c0026563:	50                   	push   %eax
c0026564:	e8 32 01 00 00       	call   c002669b <intq_init>
}
c0026569:	83 c4 18             	add    $0x18,%esp
c002656c:	5b                   	pop    %ebx
c002656d:	c3                   	ret    

c002656e <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc(uint8_t key) {
c002656e:	56                   	push   %esi
c002656f:	53                   	push   %ebx
c0026570:	83 ec 04             	sub    $0x4,%esp
c0026573:	e8 cb 9b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026578:	81 c3 34 77 01 00    	add    $0x17734,%ebx
c002657e:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0026582:	e8 89 b7 ff ff       	call   c0021d10 <intr_get_level>
c0026587:	85 c0                	test   %eax,%eax
c0026589:	75 36                	jne    c00265c1 <input_putc+0x53>
    ASSERT (!intq_full(&buffer));
c002658b:	83 ec 0c             	sub    $0xc,%esp
c002658e:	8d 83 94 1a 00 00    	lea    0x1a94(%ebx),%eax
c0026594:	50                   	push   %eax
c0026595:	e8 8f 01 00 00       	call   c0026729 <intq_full>
c002659a:	83 c4 10             	add    $0x10,%esp
c002659d:	84 c0                	test   %al,%al
c002659f:	75 46                	jne    c00265e7 <input_putc+0x79>

    intq_putc(&buffer, key);
c00265a1:	83 ec 08             	sub    $0x8,%esp
c00265a4:	89 f0                	mov    %esi,%eax
c00265a6:	0f b6 f0             	movzbl %al,%esi
c00265a9:	56                   	push   %esi
c00265aa:	8d 83 94 1a 00 00    	lea    0x1a94(%ebx),%eax
c00265b0:	50                   	push   %eax
c00265b1:	e8 2e 04 00 00       	call   c00269e4 <intq_putc>
    serial_notify();
c00265b6:	e8 90 ea ff ff       	call   c002504b <serial_notify>
}
c00265bb:	83 c4 14             	add    $0x14,%esp
c00265be:	5b                   	pop    %ebx
c00265bf:	5e                   	pop    %esi
c00265c0:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c00265c1:	83 ec 0c             	sub    $0xc,%esp
c00265c4:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c00265ca:	50                   	push   %eax
c00265cb:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00265d1:	50                   	push   %eax
c00265d2:	8d 83 78 29 ff ff    	lea    -0xd688(%ebx),%eax
c00265d8:	50                   	push   %eax
c00265d9:	6a 13                	push   $0x13
c00265db:	8d 83 14 4f ff ff    	lea    -0xb0ec(%ebx),%eax
c00265e1:	50                   	push   %eax
c00265e2:	e8 46 2b 00 00       	call   c002912d <debug_panic>
    ASSERT (!intq_full(&buffer));
c00265e7:	83 ec 0c             	sub    $0xc,%esp
c00265ea:	8d 83 2a 4f ff ff    	lea    -0xb0d6(%ebx),%eax
c00265f0:	50                   	push   %eax
c00265f1:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00265f7:	50                   	push   %eax
c00265f8:	8d 83 78 29 ff ff    	lea    -0xd688(%ebx),%eax
c00265fe:	50                   	push   %eax
c00265ff:	6a 14                	push   $0x14
c0026601:	8d 83 14 4f ff ff    	lea    -0xb0ec(%ebx),%eax
c0026607:	50                   	push   %eax
c0026608:	e8 20 2b 00 00       	call   c002912d <debug_panic>

c002660d <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc(void) {
c002660d:	57                   	push   %edi
c002660e:	56                   	push   %esi
c002660f:	53                   	push   %ebx
c0026610:	e8 2e 9b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026615:	81 c3 97 76 01 00    	add    $0x17697,%ebx
    enum intr_level old_level;
    uint8_t key;

    old_level = intr_disable();
c002661b:	e8 42 b7 ff ff       	call   c0021d62 <intr_disable>
c0026620:	89 c7                	mov    %eax,%edi
    key = intq_getc(&buffer);
c0026622:	83 ec 0c             	sub    $0xc,%esp
c0026625:	8d 83 94 1a 00 00    	lea    0x1a94(%ebx),%eax
c002662b:	50                   	push   %eax
c002662c:	e8 e8 02 00 00       	call   c0026919 <intq_getc>
c0026631:	89 c6                	mov    %eax,%esi
    serial_notify();
c0026633:	e8 13 ea ff ff       	call   c002504b <serial_notify>
    intr_set_level(old_level);
c0026638:	89 3c 24             	mov    %edi,(%esp)
c002663b:	e8 29 b7 ff ff       	call   c0021d69 <intr_set_level>

    return key;
c0026640:	83 c4 10             	add    $0x10,%esp
}
c0026643:	89 f0                	mov    %esi,%eax
c0026645:	5b                   	pop    %ebx
c0026646:	5e                   	pop    %esi
c0026647:	5f                   	pop    %edi
c0026648:	c3                   	ret    

c0026649 <input_full>:

/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full(void) {
c0026649:	53                   	push   %ebx
c002664a:	83 ec 08             	sub    $0x8,%esp
c002664d:	e8 f1 9a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026652:	81 c3 5a 76 01 00    	add    $0x1765a,%ebx
    ASSERT (intr_get_level() == INTR_OFF);
c0026658:	e8 b3 b6 ff ff       	call   c0021d10 <intr_get_level>
c002665d:	85 c0                	test   %eax,%eax
c002665f:	75 14                	jne    c0026675 <input_full+0x2c>
    return intq_full(&buffer);
c0026661:	83 ec 0c             	sub    $0xc,%esp
c0026664:	8d 83 94 1a 00 00    	lea    0x1a94(%ebx),%eax
c002666a:	50                   	push   %eax
c002666b:	e8 b9 00 00 00       	call   c0026729 <intq_full>
}
c0026670:	83 c4 18             	add    $0x18,%esp
c0026673:	5b                   	pop    %ebx
c0026674:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026675:	83 ec 0c             	sub    $0xc,%esp
c0026678:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c002667e:	50                   	push   %eax
c002667f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026685:	50                   	push   %eax
c0026686:	8d 83 6c 29 ff ff    	lea    -0xd694(%ebx),%eax
c002668c:	50                   	push   %eax
c002668d:	6a 2e                	push   $0x2e
c002668f:	8d 83 14 4f ff ff    	lea    -0xb0ec(%ebx),%eax
c0026695:	50                   	push   %eax
c0026696:	e8 92 2a 00 00       	call   c002912d <debug_panic>

c002669b <intq_init>:

static void signal(struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init(struct intq *q) {
c002669b:	56                   	push   %esi
c002669c:	53                   	push   %ebx
c002669d:	83 ec 10             	sub    $0x10,%esp
c00266a0:	e8 9e 9a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00266a5:	81 c3 07 76 01 00    	add    $0x17607,%ebx
c00266ab:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    lock_init(&q->lock);
c00266af:	56                   	push   %esi
c00266b0:	e8 fb ca ff ff       	call   c00231b0 <lock_init>
    q->not_full = q->not_empty = NULL;
c00266b5:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c00266bc:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
    q->head = q->tail = 0;
c00266c3:	c7 46 70 00 00 00 00 	movl   $0x0,0x70(%esi)
c00266ca:	c7 46 6c 00 00 00 00 	movl   $0x0,0x6c(%esi)
}
c00266d1:	83 c4 14             	add    $0x14,%esp
c00266d4:	5b                   	pop    %ebx
c00266d5:	5e                   	pop    %esi
c00266d6:	c3                   	ret    

c00266d7 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty(const struct intq *q) {
c00266d7:	56                   	push   %esi
c00266d8:	53                   	push   %ebx
c00266d9:	83 ec 04             	sub    $0x4,%esp
c00266dc:	e8 62 9a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00266e1:	81 c3 cb 75 01 00    	add    $0x175cb,%ebx
c00266e7:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c00266eb:	e8 20 b6 ff ff       	call   c0021d10 <intr_get_level>
c00266f0:	85 c0                	test   %eax,%eax
c00266f2:	75 0f                	jne    c0026703 <intq_empty+0x2c>
    return q->head == q->tail;
c00266f4:	8b 46 70             	mov    0x70(%esi),%eax
c00266f7:	39 46 6c             	cmp    %eax,0x6c(%esi)
c00266fa:	0f 94 c0             	sete   %al
}
c00266fd:	83 c4 04             	add    $0x4,%esp
c0026700:	5b                   	pop    %ebx
c0026701:	5e                   	pop    %esi
c0026702:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026703:	83 ec 0c             	sub    $0xc,%esp
c0026706:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c002670c:	50                   	push   %eax
c002670d:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026713:	50                   	push   %eax
c0026714:	8d 83 b8 29 ff ff    	lea    -0xd648(%ebx),%eax
c002671a:	50                   	push   %eax
c002671b:	6a 16                	push   $0x16
c002671d:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c0026723:	50                   	push   %eax
c0026724:	e8 04 2a 00 00       	call   c002912d <debug_panic>

c0026729 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full(const struct intq *q) {
c0026729:	56                   	push   %esi
c002672a:	53                   	push   %ebx
c002672b:	83 ec 04             	sub    $0x4,%esp
c002672e:	e8 10 9a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026733:	81 c3 79 75 01 00    	add    $0x17579,%ebx
c0026739:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c002673d:	e8 ce b5 ff ff       	call   c0021d10 <intr_get_level>
c0026742:	85 c0                	test   %eax,%eax
c0026744:	75 1d                	jne    c0026763 <intq_full+0x3a>
}

/* Returns the position after POS within an intq. */
static int
next(int pos) {
    return (pos + 1) % INTQ_BUFSIZE;
c0026746:	8b 46 6c             	mov    0x6c(%esi),%eax
c0026749:	83 c0 01             	add    $0x1,%eax
c002674c:	99                   	cltd   
c002674d:	c1 ea 1a             	shr    $0x1a,%edx
c0026750:	01 d0                	add    %edx,%eax
c0026752:	83 e0 3f             	and    $0x3f,%eax
c0026755:	29 d0                	sub    %edx,%eax
    return next(q->head) == q->tail;
c0026757:	3b 46 70             	cmp    0x70(%esi),%eax
c002675a:	0f 94 c0             	sete   %al
}
c002675d:	83 c4 04             	add    $0x4,%esp
c0026760:	5b                   	pop    %ebx
c0026761:	5e                   	pop    %esi
c0026762:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026763:	83 ec 0c             	sub    $0xc,%esp
c0026766:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c002676c:	50                   	push   %eax
c002676d:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026773:	50                   	push   %eax
c0026774:	8d 83 ac 29 ff ff    	lea    -0xd654(%ebx),%eax
c002677a:	50                   	push   %eax
c002677b:	6a 1d                	push   $0x1d
c002677d:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c0026783:	50                   	push   %eax
c0026784:	e8 a4 29 00 00       	call   c002912d <debug_panic>

c0026789 <wait>:
}

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait(struct intq *q UNUSED, struct thread **waiter) {
c0026789:	57                   	push   %edi
c002678a:	56                   	push   %esi
c002678b:	53                   	push   %ebx
c002678c:	e8 b2 99 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026791:	81 c3 1b 75 01 00    	add    $0x1751b,%ebx
c0026797:	89 c6                	mov    %eax,%esi
c0026799:	89 d7                	mov    %edx,%edi
    ASSERT (!intr_context());
c002679b:	e8 68 b8 ff ff       	call   c0022008 <intr_context>
c00267a0:	84 c0                	test   %al,%al
c00267a2:	75 3b                	jne    c00267df <wait+0x56>
    ASSERT (intr_get_level() == INTR_OFF);
c00267a4:	e8 67 b5 ff ff       	call   c0021d10 <intr_get_level>
c00267a9:	85 c0                	test   %eax,%eax
c00267ab:	75 58                	jne    c0026805 <wait+0x7c>
    ASSERT ((waiter == &q->not_empty && intq_empty(q))
c00267ad:	8d 46 28             	lea    0x28(%esi),%eax
c00267b0:	39 c7                	cmp    %eax,%edi
c00267b2:	74 77                	je     c002682b <wait+0xa2>
c00267b4:	8d 46 24             	lea    0x24(%esi),%eax
c00267b7:	39 c7                	cmp    %eax,%edi
c00267b9:	0f 85 81 00 00 00    	jne    c0026840 <wait+0xb7>
c00267bf:	83 ec 0c             	sub    $0xc,%esp
c00267c2:	56                   	push   %esi
c00267c3:	e8 61 ff ff ff       	call   c0026729 <intq_full>
c00267c8:	83 c4 10             	add    $0x10,%esp
c00267cb:	84 c0                	test   %al,%al
c00267cd:	74 71                	je     c0026840 <wait+0xb7>
            || (waiter == &q->not_full && intq_full(q)));

    *waiter = thread_current();
c00267cf:	e8 f5 a7 ff ff       	call   c0020fc9 <thread_current>
c00267d4:	89 07                	mov    %eax,(%edi)
    thread_block();
c00267d6:	e8 8d ad ff ff       	call   c0021568 <thread_block>
}
c00267db:	5b                   	pop    %ebx
c00267dc:	5e                   	pop    %esi
c00267dd:	5f                   	pop    %edi
c00267de:	c3                   	ret    
    ASSERT (!intr_context());
c00267df:	83 ec 0c             	sub    $0xc,%esp
c00267e2:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c00267e8:	50                   	push   %eax
c00267e9:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00267ef:	50                   	push   %eax
c00267f0:	8d 83 98 29 ff ff    	lea    -0xd668(%ebx),%eax
c00267f6:	50                   	push   %eax
c00267f7:	6a 52                	push   $0x52
c00267f9:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c00267ff:	50                   	push   %eax
c0026800:	e8 28 29 00 00       	call   c002912d <debug_panic>
    ASSERT (intr_get_level() == INTR_OFF);
c0026805:	83 ec 0c             	sub    $0xc,%esp
c0026808:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c002680e:	50                   	push   %eax
c002680f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026815:	50                   	push   %eax
c0026816:	8d 83 98 29 ff ff    	lea    -0xd668(%ebx),%eax
c002681c:	50                   	push   %eax
c002681d:	6a 53                	push   $0x53
c002681f:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c0026825:	50                   	push   %eax
c0026826:	e8 02 29 00 00       	call   c002912d <debug_panic>
    ASSERT ((waiter == &q->not_empty && intq_empty(q))
c002682b:	83 ec 0c             	sub    $0xc,%esp
c002682e:	56                   	push   %esi
c002682f:	e8 a3 fe ff ff       	call   c00266d7 <intq_empty>
c0026834:	83 c4 10             	add    $0x10,%esp
c0026837:	84 c0                	test   %al,%al
c0026839:	75 94                	jne    c00267cf <wait+0x46>
c002683b:	e9 74 ff ff ff       	jmp    c00267b4 <wait+0x2b>
c0026840:	83 ec 0c             	sub    $0xc,%esp
c0026843:	8d 83 54 4f ff ff    	lea    -0xb0ac(%ebx),%eax
c0026849:	50                   	push   %eax
c002684a:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026850:	50                   	push   %eax
c0026851:	8d 83 98 29 ff ff    	lea    -0xd668(%ebx),%eax
c0026857:	50                   	push   %eax
c0026858:	6a 55                	push   $0x55
c002685a:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c0026860:	50                   	push   %eax
c0026861:	e8 c7 28 00 00       	call   c002912d <debug_panic>

c0026866 <signal>:
/* WAITER must be the address of Q's not_empty or not_full
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal(struct intq *q UNUSED, struct thread **waiter) {
c0026866:	57                   	push   %edi
c0026867:	56                   	push   %esi
c0026868:	53                   	push   %ebx
c0026869:	e8 d5 98 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002686e:	81 c3 3e 74 01 00    	add    $0x1743e,%ebx
c0026874:	89 c7                	mov    %eax,%edi
c0026876:	89 d6                	mov    %edx,%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0026878:	e8 93 b4 ff ff       	call   c0021d10 <intr_get_level>
c002687d:	85 c0                	test   %eax,%eax
c002687f:	75 3a                	jne    c00268bb <signal+0x55>
    ASSERT ((waiter == &q->not_empty && !intq_empty(q))
c0026881:	8d 47 28             	lea    0x28(%edi),%eax
c0026884:	39 c6                	cmp    %eax,%esi
c0026886:	74 59                	je     c00268e1 <signal+0x7b>
c0026888:	8d 47 24             	lea    0x24(%edi),%eax
c002688b:	39 c6                	cmp    %eax,%esi
c002688d:	75 64                	jne    c00268f3 <signal+0x8d>
c002688f:	83 ec 0c             	sub    $0xc,%esp
c0026892:	57                   	push   %edi
c0026893:	e8 91 fe ff ff       	call   c0026729 <intq_full>
c0026898:	83 c4 10             	add    $0x10,%esp
c002689b:	84 c0                	test   %al,%al
c002689d:	75 54                	jne    c00268f3 <signal+0x8d>
            || (waiter == &q->not_full && !intq_full(q)));

    if (*waiter != NULL) {
c002689f:	8b 06                	mov    (%esi),%eax
c00268a1:	85 c0                	test   %eax,%eax
c00268a3:	74 12                	je     c00268b7 <signal+0x51>
        thread_unblock(*waiter);
c00268a5:	83 ec 0c             	sub    $0xc,%esp
c00268a8:	50                   	push   %eax
c00268a9:	e8 68 a6 ff ff       	call   c0020f16 <thread_unblock>
        *waiter = NULL;
c00268ae:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c00268b4:	83 c4 10             	add    $0x10,%esp
    }
}
c00268b7:	5b                   	pop    %ebx
c00268b8:	5e                   	pop    %esi
c00268b9:	5f                   	pop    %edi
c00268ba:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c00268bb:	83 ec 0c             	sub    $0xc,%esp
c00268be:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c00268c4:	50                   	push   %eax
c00268c5:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00268cb:	50                   	push   %eax
c00268cc:	8d 83 90 29 ff ff    	lea    -0xd670(%ebx),%eax
c00268d2:	50                   	push   %eax
c00268d3:	6a 61                	push   $0x61
c00268d5:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c00268db:	50                   	push   %eax
c00268dc:	e8 4c 28 00 00       	call   c002912d <debug_panic>
    ASSERT ((waiter == &q->not_empty && !intq_empty(q))
c00268e1:	83 ec 0c             	sub    $0xc,%esp
c00268e4:	57                   	push   %edi
c00268e5:	e8 ed fd ff ff       	call   c00266d7 <intq_empty>
c00268ea:	83 c4 10             	add    $0x10,%esp
c00268ed:	84 c0                	test   %al,%al
c00268ef:	74 ae                	je     c002689f <signal+0x39>
c00268f1:	eb 95                	jmp    c0026888 <signal+0x22>
c00268f3:	83 ec 0c             	sub    $0xc,%esp
c00268f6:	8d 83 ac 4f ff ff    	lea    -0xb054(%ebx),%eax
c00268fc:	50                   	push   %eax
c00268fd:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026903:	50                   	push   %eax
c0026904:	8d 83 90 29 ff ff    	lea    -0xd670(%ebx),%eax
c002690a:	50                   	push   %eax
c002690b:	6a 63                	push   $0x63
c002690d:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c0026913:	50                   	push   %eax
c0026914:	e8 14 28 00 00       	call   c002912d <debug_panic>

c0026919 <intq_getc>:
intq_getc(struct intq *q) {
c0026919:	57                   	push   %edi
c002691a:	56                   	push   %esi
c002691b:	53                   	push   %ebx
c002691c:	e8 22 98 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026921:	81 c3 8b 73 01 00    	add    $0x1738b,%ebx
c0026927:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c002692b:	e8 e0 b3 ff ff       	call   c0021d10 <intr_get_level>
c0026930:	85 c0                	test   %eax,%eax
c0026932:	75 3b                	jne    c002696f <intq_getc+0x56>
        wait(q, &q->not_empty);
c0026934:	8d 7e 28             	lea    0x28(%esi),%edi
    while (intq_empty(q)) {
c0026937:	83 ec 0c             	sub    $0xc,%esp
c002693a:	56                   	push   %esi
c002693b:	e8 97 fd ff ff       	call   c00266d7 <intq_empty>
c0026940:	83 c4 10             	add    $0x10,%esp
c0026943:	84 c0                	test   %al,%al
c0026945:	74 74                	je     c00269bb <intq_getc+0xa2>
        ASSERT (!intr_context());
c0026947:	e8 bc b6 ff ff       	call   c0022008 <intr_context>
c002694c:	84 c0                	test   %al,%al
c002694e:	75 45                	jne    c0026995 <intq_getc+0x7c>
        lock_acquire(&q->lock);
c0026950:	83 ec 0c             	sub    $0xc,%esp
c0026953:	56                   	push   %esi
c0026954:	e8 03 c9 ff ff       	call   c002325c <lock_acquire>
        wait(q, &q->not_empty);
c0026959:	89 fa                	mov    %edi,%edx
c002695b:	89 f0                	mov    %esi,%eax
c002695d:	e8 27 fe ff ff       	call   c0026789 <wait>
        lock_release(&q->lock);
c0026962:	89 34 24             	mov    %esi,(%esp)
c0026965:	e8 f3 ca ff ff       	call   c002345d <lock_release>
c002696a:	83 c4 10             	add    $0x10,%esp
c002696d:	eb c8                	jmp    c0026937 <intq_getc+0x1e>
    ASSERT (intr_get_level() == INTR_OFF);
c002696f:	83 ec 0c             	sub    $0xc,%esp
c0026972:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c0026978:	50                   	push   %eax
c0026979:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002697f:	50                   	push   %eax
c0026980:	8d 83 a0 29 ff ff    	lea    -0xd660(%ebx),%eax
c0026986:	50                   	push   %eax
c0026987:	6a 28                	push   $0x28
c0026989:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c002698f:	50                   	push   %eax
c0026990:	e8 98 27 00 00       	call   c002912d <debug_panic>
        ASSERT (!intr_context());
c0026995:	83 ec 0c             	sub    $0xc,%esp
c0026998:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c002699e:	50                   	push   %eax
c002699f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00269a5:	50                   	push   %eax
c00269a6:	8d 83 a0 29 ff ff    	lea    -0xd660(%ebx),%eax
c00269ac:	50                   	push   %eax
c00269ad:	6a 2a                	push   $0x2a
c00269af:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c00269b5:	50                   	push   %eax
c00269b6:	e8 72 27 00 00       	call   c002912d <debug_panic>
    byte = q->buf[q->tail];
c00269bb:	8b 46 70             	mov    0x70(%esi),%eax
c00269be:	0f b6 5c 06 2c       	movzbl 0x2c(%esi,%eax,1),%ebx
    return (pos + 1) % INTQ_BUFSIZE;
c00269c3:	83 c0 01             	add    $0x1,%eax
c00269c6:	99                   	cltd   
c00269c7:	c1 ea 1a             	shr    $0x1a,%edx
c00269ca:	01 d0                	add    %edx,%eax
c00269cc:	83 e0 3f             	and    $0x3f,%eax
c00269cf:	29 d0                	sub    %edx,%eax
    q->tail = next(q->tail);
c00269d1:	89 46 70             	mov    %eax,0x70(%esi)
    signal(q, &q->not_full);
c00269d4:	8d 56 24             	lea    0x24(%esi),%edx
c00269d7:	89 f0                	mov    %esi,%eax
c00269d9:	e8 88 fe ff ff       	call   c0026866 <signal>
}
c00269de:	89 d8                	mov    %ebx,%eax
c00269e0:	5b                   	pop    %ebx
c00269e1:	5e                   	pop    %esi
c00269e2:	5f                   	pop    %edi
c00269e3:	c3                   	ret    

c00269e4 <intq_putc>:
intq_putc(struct intq *q, uint8_t byte) {
c00269e4:	55                   	push   %ebp
c00269e5:	57                   	push   %edi
c00269e6:	56                   	push   %esi
c00269e7:	53                   	push   %ebx
c00269e8:	83 ec 0c             	sub    $0xc,%esp
c00269eb:	e8 53 97 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00269f0:	81 c3 bc 72 01 00    	add    $0x172bc,%ebx
c00269f6:	8b 74 24 20          	mov    0x20(%esp),%esi
c00269fa:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    ASSERT (intr_get_level() == INTR_OFF);
c00269fe:	e8 0d b3 ff ff       	call   c0021d10 <intr_get_level>
c0026a03:	85 c0                	test   %eax,%eax
c0026a05:	75 3b                	jne    c0026a42 <intq_putc+0x5e>
        wait(q, &q->not_full);
c0026a07:	8d 7e 24             	lea    0x24(%esi),%edi
    while (intq_full(q)) {
c0026a0a:	83 ec 0c             	sub    $0xc,%esp
c0026a0d:	56                   	push   %esi
c0026a0e:	e8 16 fd ff ff       	call   c0026729 <intq_full>
c0026a13:	83 c4 10             	add    $0x10,%esp
c0026a16:	84 c0                	test   %al,%al
c0026a18:	74 74                	je     c0026a8e <intq_putc+0xaa>
        ASSERT (!intr_context());
c0026a1a:	e8 e9 b5 ff ff       	call   c0022008 <intr_context>
c0026a1f:	84 c0                	test   %al,%al
c0026a21:	75 45                	jne    c0026a68 <intq_putc+0x84>
        lock_acquire(&q->lock);
c0026a23:	83 ec 0c             	sub    $0xc,%esp
c0026a26:	56                   	push   %esi
c0026a27:	e8 30 c8 ff ff       	call   c002325c <lock_acquire>
        wait(q, &q->not_full);
c0026a2c:	89 fa                	mov    %edi,%edx
c0026a2e:	89 f0                	mov    %esi,%eax
c0026a30:	e8 54 fd ff ff       	call   c0026789 <wait>
        lock_release(&q->lock);
c0026a35:	89 34 24             	mov    %esi,(%esp)
c0026a38:	e8 20 ca ff ff       	call   c002345d <lock_release>
c0026a3d:	83 c4 10             	add    $0x10,%esp
c0026a40:	eb c8                	jmp    c0026a0a <intq_putc+0x26>
    ASSERT (intr_get_level() == INTR_OFF);
c0026a42:	83 ec 0c             	sub    $0xc,%esp
c0026a45:	8d 83 15 3e ff ff    	lea    -0xc1eb(%ebx),%eax
c0026a4b:	50                   	push   %eax
c0026a4c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026a52:	50                   	push   %eax
c0026a53:	8d 83 84 29 ff ff    	lea    -0xd67c(%ebx),%eax
c0026a59:	50                   	push   %eax
c0026a5a:	6a 3b                	push   $0x3b
c0026a5c:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c0026a62:	50                   	push   %eax
c0026a63:	e8 c5 26 00 00       	call   c002912d <debug_panic>
        ASSERT (!intr_context());
c0026a68:	83 ec 0c             	sub    $0xc,%esp
c0026a6b:	8d 83 a9 3e ff ff    	lea    -0xc157(%ebx),%eax
c0026a71:	50                   	push   %eax
c0026a72:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0026a78:	50                   	push   %eax
c0026a79:	8d 83 84 29 ff ff    	lea    -0xd67c(%ebx),%eax
c0026a7f:	50                   	push   %eax
c0026a80:	6a 3d                	push   $0x3d
c0026a82:	8d 83 3e 4f ff ff    	lea    -0xb0c2(%ebx),%eax
c0026a88:	50                   	push   %eax
c0026a89:	e8 9f 26 00 00       	call   c002912d <debug_panic>
    q->buf[q->head] = byte;
c0026a8e:	8b 46 6c             	mov    0x6c(%esi),%eax
c0026a91:	89 e9                	mov    %ebp,%ecx
c0026a93:	88 4c 06 2c          	mov    %cl,0x2c(%esi,%eax,1)
    return (pos + 1) % INTQ_BUFSIZE;
c0026a97:	83 c0 01             	add    $0x1,%eax
c0026a9a:	99                   	cltd   
c0026a9b:	c1 ea 1a             	shr    $0x1a,%edx
c0026a9e:	01 d0                	add    %edx,%eax
c0026aa0:	83 e0 3f             	and    $0x3f,%eax
c0026aa3:	29 d0                	sub    %edx,%eax
    q->head = next(q->head);
c0026aa5:	89 46 6c             	mov    %eax,0x6c(%esi)
    signal(q, &q->not_empty);
c0026aa8:	8d 56 28             	lea    0x28(%esi),%edx
c0026aab:	89 f0                	mov    %esi,%eax
c0026aad:	e8 b4 fd ff ff       	call   c0026866 <signal>
}
c0026ab2:	83 c4 0c             	add    $0xc,%esp
c0026ab5:	5b                   	pop    %ebx
c0026ab6:	5e                   	pop    %esi
c0026ab7:	5f                   	pop    %edi
c0026ab8:	5d                   	pop    %ebp
c0026ab9:	c3                   	ret    

c0026aba <rtc_get_time>:
static uint8_t cmos_read(uint8_t index);

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time(void) {
c0026aba:	55                   	push   %ebp
c0026abb:	57                   	push   %edi
c0026abc:	56                   	push   %esi
c0026abd:	53                   	push   %ebx
c0026abe:	83 ec 10             	sub    $0x10,%esp
c0026ac1:	e8 81 96 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c0026ac6:	05 e6 71 01 00       	add    $0x171e6,%eax
c0026acb:	89 44 24 0c          	mov    %eax,0xc(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026acf:	be 00 00 00 00       	mov    $0x0,%esi
c0026ad4:	bf 02 00 00 00       	mov    $0x2,%edi
c0026ad9:	89 f0                	mov    %esi,%eax
c0026adb:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026add:	e4 71                	in     $0x71,%al
}

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin(uint8_t x) {
    return (x & 0x0f) + ((x >> 4) * 10);
c0026adf:	89 c2                	mov    %eax,%edx
c0026ae1:	c0 ea 04             	shr    $0x4,%dl
c0026ae4:	0f b6 d2             	movzbl %dl,%edx
c0026ae7:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026aea:	83 e0 0f             	and    $0xf,%eax
c0026aed:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026af0:	89 f8                	mov    %edi,%eax
c0026af2:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026af4:	e4 71                	in     $0x71,%al
c0026af6:	88 44 24 08          	mov    %al,0x8(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026afa:	b8 04 00 00 00       	mov    $0x4,%eax
c0026aff:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b01:	e4 71                	in     $0x71,%al
c0026b03:	88 44 24 04          	mov    %al,0x4(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b07:	b8 07 00 00 00       	mov    $0x7,%eax
c0026b0c:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b0e:	e4 71                	in     $0x71,%al
c0026b10:	88 04 24             	mov    %al,(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b13:	b8 08 00 00 00       	mov    $0x8,%eax
c0026b18:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b1a:	e4 71                	in     $0x71,%al
c0026b1c:	89 c5                	mov    %eax,%ebp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b1e:	b8 09 00 00 00       	mov    $0x9,%eax
c0026b23:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b25:	e4 71                	in     $0x71,%al
c0026b27:	89 c1                	mov    %eax,%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b29:	89 f0                	mov    %esi,%eax
c0026b2b:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b2d:	e4 71                	in     $0x71,%al
c0026b2f:	89 c2                	mov    %eax,%edx
c0026b31:	c0 ea 04             	shr    $0x4,%dl
c0026b34:	0f b6 d2             	movzbl %dl,%edx
c0026b37:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026b3a:	83 e0 0f             	and    $0xf,%eax
c0026b3d:	8d 04 50             	lea    (%eax,%edx,2),%eax
    } while (sec != bcd_to_bin(cmos_read(RTC_REG_SEC)));
c0026b40:	39 d8                	cmp    %ebx,%eax
c0026b42:	75 95                	jne    c0026ad9 <rtc_get_time+0x1f>
    return (x & 0x0f) + ((x >> 4) * 10);
c0026b44:	89 c8                	mov    %ecx,%eax
c0026b46:	c0 e8 04             	shr    $0x4,%al
c0026b49:	0f b6 c0             	movzbl %al,%eax
c0026b4c:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0026b4f:	83 e1 0f             	and    $0xf,%ecx
c0026b52:	8d 04 41             	lea    (%ecx,%eax,2),%eax
        year += 100;
c0026b55:	8d 48 64             	lea    0x64(%eax),%ecx
c0026b58:	83 f8 46             	cmp    $0x46,%eax
c0026b5b:	0f 4c c1             	cmovl  %ecx,%eax
    return (x & 0x0f) + ((x >> 4) * 10);
c0026b5e:	89 ea                	mov    %ebp,%edx
c0026b60:	89 e9                	mov    %ebp,%ecx
c0026b62:	c0 e9 04             	shr    $0x4,%cl
c0026b65:	0f b6 c9             	movzbl %cl,%ecx
c0026b68:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026b6b:	83 e2 0f             	and    $0xf,%edx
c0026b6e:	8d 2c 4a             	lea    (%edx,%ecx,2),%ebp
    year -= 70;
c0026b71:	8d 78 ba             	lea    -0x46(%eax),%edi
    time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026b74:	8d 50 bc             	lea    -0x44(%eax),%edx
c0026b77:	83 e8 47             	sub    $0x47,%eax
c0026b7a:	0f 48 c2             	cmovs  %edx,%eax
c0026b7d:	c1 f8 02             	sar    $0x2,%eax
c0026b80:	69 d7 6d 01 00 00    	imul   $0x16d,%edi,%edx
c0026b86:	01 d0                	add    %edx,%eax
c0026b88:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    for (i = 1; i <= mon; i++)
c0026b8e:	85 ed                	test   %ebp,%ebp
c0026b90:	7e 1c                	jle    c0026bae <rtc_get_time+0xf4>
c0026b92:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0026b96:	8d 96 d4 29 ff ff    	lea    -0xd62c(%esi),%edx
c0026b9c:	8d 34 aa             	lea    (%edx,%ebp,4),%esi
        time += days_per_month[i - 1] * 24 * 60 * 60;
c0026b9f:	69 0a 80 51 01 00    	imul   $0x15180,(%edx),%ecx
c0026ba5:	01 c8                	add    %ecx,%eax
c0026ba7:	83 c2 04             	add    $0x4,%edx
    for (i = 1; i <= mon; i++)
c0026baa:	39 f2                	cmp    %esi,%edx
c0026bac:	75 f1                	jne    c0026b9f <rtc_get_time+0xe5>
    if (mon > 2 && year % 4 == 0)
c0026bae:	83 fd 02             	cmp    $0x2,%ebp
c0026bb1:	7e 0e                	jle    c0026bc1 <rtc_get_time+0x107>
c0026bb3:	83 e7 03             	and    $0x3,%edi
        time += 24 * 60 * 60;
c0026bb6:	8d 90 80 51 01 00    	lea    0x15180(%eax),%edx
c0026bbc:	85 ff                	test   %edi,%edi
c0026bbe:	0f 44 c2             	cmove  %edx,%eax
    return (x & 0x0f) + ((x >> 4) * 10);
c0026bc1:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c0026bc6:	c0 ea 04             	shr    $0x4,%dl
c0026bc9:	0f b6 d2             	movzbl %dl,%edx
c0026bcc:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026bcf:	8b 54 24 04          	mov    0x4(%esp),%edx
c0026bd3:	83 e2 0f             	and    $0xf,%edx
c0026bd6:	8d 0c 4a             	lea    (%edx,%ecx,2),%ecx
    time += hour * 60 * 60;
c0026bd9:	69 c9 10 0e 00 00    	imul   $0xe10,%ecx,%ecx
    return (x & 0x0f) + ((x >> 4) * 10);
c0026bdf:	0f b6 54 24 08       	movzbl 0x8(%esp),%edx
c0026be4:	c0 ea 04             	shr    $0x4,%dl
c0026be7:	0f b6 d2             	movzbl %dl,%edx
c0026bea:	8d 34 92             	lea    (%edx,%edx,4),%esi
c0026bed:	8b 54 24 08          	mov    0x8(%esp),%edx
c0026bf1:	83 e2 0f             	and    $0xf,%edx
c0026bf4:	8d 14 72             	lea    (%edx,%esi,2),%edx
    time += min * 60;
c0026bf7:	6b d2 3c             	imul   $0x3c,%edx,%edx
    time += sec;
c0026bfa:	01 d1                	add    %edx,%ecx
c0026bfc:	01 cb                	add    %ecx,%ebx
    return (x & 0x0f) + ((x >> 4) * 10);
c0026bfe:	0f b6 14 24          	movzbl (%esp),%edx
c0026c02:	c0 ea 04             	shr    $0x4,%dl
c0026c05:	0f b6 d2             	movzbl %dl,%edx
c0026c08:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026c0b:	8b 14 24             	mov    (%esp),%edx
c0026c0e:	83 e2 0f             	and    $0xf,%edx
    time += (mday - 1) * 24 * 60 * 60;
c0026c11:	8d 54 4a ff          	lea    -0x1(%edx,%ecx,2),%edx
c0026c15:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
    time += sec;
c0026c1b:	01 d3                	add    %edx,%ebx
c0026c1d:	01 d8                	add    %ebx,%eax
}
c0026c1f:	83 c4 10             	add    $0x10,%esp
c0026c22:	5b                   	pop    %ebx
c0026c23:	5e                   	pop    %esi
c0026c24:	5f                   	pop    %edi
c0026c25:	5d                   	pop    %ebp
c0026c26:	c3                   	ret    

c0026c27 <shutdown_configure>:
}

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure(enum shutdown_type type) {
c0026c27:	e8 1b 95 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c0026c2c:	05 80 70 01 00       	add    $0x17080,%eax
    how = type;
c0026c31:	8b 54 24 04          	mov    0x4(%esp),%edx
c0026c35:	89 90 08 1b 00 00    	mov    %edx,0x1b08(%eax)
}
c0026c3b:	c3                   	ret    

c0026c3c <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot(void) {
c0026c3c:	57                   	push   %edi
c0026c3d:	56                   	push   %esi
c0026c3e:	53                   	push   %ebx
c0026c3f:	e8 ff 94 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026c44:	81 c3 68 70 01 00    	add    $0x17068,%ebx
    printf("Rebooting...\n");
c0026c4a:	83 ec 0c             	sub    $0xc,%esp
c0026c4d:	8d 83 05 50 ff ff    	lea    -0xaffb(%ebx),%eax
c0026c53:	50                   	push   %eax
c0026c54:	e8 aa 44 00 00       	call   c002b103 <puts>
c0026c59:	83 c4 10             	add    $0x10,%esp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026c5c:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
c0026c61:	eb 1f                	jmp    c0026c82 <shutdown_reboot+0x46>
            if ((inb(CONTROL_REG) & 0x02) == 0)
                break;
            timer_udelay(2);
        }

        timer_udelay(50);
c0026c63:	83 ec 08             	sub    $0x8,%esp
c0026c66:	6a 00                	push   $0x0
c0026c68:	6a 32                	push   $0x32
c0026c6a:	e8 2d db ff ff       	call   c002479c <timer_udelay>
c0026c6f:	89 f8                	mov    %edi,%eax
c0026c71:	e6 64                	out    %al,$0x64

        /* Pulse bit 0 of the output port P2 of the keyboard controller.
         * This will reset the CPU. */
        outb(CONTROL_REG, 0xfe);
        timer_udelay(50);
c0026c73:	83 c4 08             	add    $0x8,%esp
c0026c76:	6a 00                	push   $0x0
c0026c78:	6a 32                	push   $0x32
c0026c7a:	e8 1d db ff ff       	call   c002479c <timer_udelay>
    for (;;) {
c0026c7f:	83 c4 10             	add    $0x10,%esp
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026c82:	e4 64                	in     $0x64,%al
            if ((inb(CONTROL_REG) & 0x02) == 0)
c0026c84:	a8 02                	test   $0x2,%al
c0026c86:	74 db                	je     c0026c63 <shutdown_reboot+0x27>
            timer_udelay(2);
c0026c88:	83 ec 08             	sub    $0x8,%esp
c0026c8b:	6a 00                	push   $0x0
c0026c8d:	6a 02                	push   $0x2
c0026c8f:	e8 08 db ff ff       	call   c002479c <timer_udelay>
c0026c94:	83 c4 10             	add    $0x10,%esp
c0026c97:	be ff ff 00 00       	mov    $0xffff,%esi
c0026c9c:	e4 64                	in     $0x64,%al
            if ((inb(CONTROL_REG) & 0x02) == 0)
c0026c9e:	a8 02                	test   $0x2,%al
c0026ca0:	74 c1                	je     c0026c63 <shutdown_reboot+0x27>
            timer_udelay(2);
c0026ca2:	83 ec 08             	sub    $0x8,%esp
c0026ca5:	6a 00                	push   $0x0
c0026ca7:	6a 02                	push   $0x2
c0026ca9:	e8 ee da ff ff       	call   c002479c <timer_udelay>
        for (i = 0; i < 0x10000; i++) {
c0026cae:	83 c4 10             	add    $0x10,%esp
c0026cb1:	83 ee 01             	sub    $0x1,%esi
c0026cb4:	75 e6                	jne    c0026c9c <shutdown_reboot+0x60>
c0026cb6:	eb ab                	jmp    c0026c63 <shutdown_reboot+0x27>

c0026cb8 <shutdown_power_off>:
}

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off(void) {
c0026cb8:	53                   	push   %ebx
c0026cb9:	83 ec 18             	sub    $0x18,%esp
c0026cbc:	e8 82 94 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026cc1:	81 c3 eb 6f 01 00    	add    $0x16feb,%ebx
    const char s[] = "Shutdown";
c0026cc7:	c7 44 24 07 53 68 75 	movl   $0x74756853,0x7(%esp)
c0026cce:	74 
c0026ccf:	c7 44 24 0b 64 6f 77 	movl   $0x6e776f64,0xb(%esp)
c0026cd6:	6e 
c0026cd7:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
    const char *p;

#ifdef FILESYS
    filesys_done ();
c0026cdc:	e8 80 6c 00 00       	call   c002d961 <filesys_done>
}

/* Print statistics about Pintos execution. */
static void
print_stats(void) {
    timer_print_stats();
c0026ce1:	e8 e8 da ff ff       	call   c00247ce <timer_print_stats>
    thread_print_stats();
c0026ce6:	e8 d6 a1 ff ff       	call   c0020ec1 <thread_print_stats>
#ifdef FILESYS
    block_print_stats ();
c0026ceb:	e8 74 e6 ff ff       	call   c0025364 <block_print_stats>
#endif
    console_print_stats();
c0026cf0:	e8 9f 43 00 00       	call   c002b094 <console_print_stats>
    kbd_print_stats();
c0026cf5:	e8 52 dd ff ff       	call   c0024a4c <kbd_print_stats>
#ifdef USERPROG
    exception_print_stats ();
c0026cfa:	e8 b8 5a 00 00       	call   c002c7b7 <exception_print_stats>
    printf("Powering off...\n");
c0026cff:	83 ec 0c             	sub    $0xc,%esp
c0026d02:	8d 83 12 50 ff ff    	lea    -0xafee(%ebx),%eax
c0026d08:	50                   	push   %eax
c0026d09:	e8 f5 43 00 00       	call   c002b103 <puts>
    serial_flush();
c0026d0e:	e8 e7 e2 ff ff       	call   c0024ffa <serial_flush>
    asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026d13:	b8 00 20 00 00       	mov    $0x2000,%eax
c0026d18:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c0026d1d:	66 ef                	out    %ax,(%dx)
    for (p = s; *p != '\0'; p++)
c0026d1f:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
c0026d24:	83 c4 10             	add    $0x10,%esp
c0026d27:	84 c0                	test   %al,%al
c0026d29:	74 14                	je     c0026d3f <shutdown_power_off+0x87>
c0026d2b:	8d 4c 24 07          	lea    0x7(%esp),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026d2f:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c0026d34:	ee                   	out    %al,(%dx)
c0026d35:	83 c1 01             	add    $0x1,%ecx
c0026d38:	0f b6 01             	movzbl (%ecx),%eax
c0026d3b:	84 c0                	test   %al,%al
c0026d3d:	75 f5                	jne    c0026d34 <shutdown_power_off+0x7c>
c0026d3f:	b8 31 00 00 00       	mov    $0x31,%eax
c0026d44:	ba 01 05 00 00       	mov    $0x501,%edx
c0026d49:	ee                   	out    %al,(%dx)
    asm volatile ("cli; hlt" : : : "memory");
c0026d4a:	fa                   	cli    
c0026d4b:	f4                   	hlt    
    printf("still running...\n");
c0026d4c:	83 ec 0c             	sub    $0xc,%esp
c0026d4f:	8d 83 22 50 ff ff    	lea    -0xafde(%ebx),%eax
c0026d55:	50                   	push   %eax
c0026d56:	e8 a8 43 00 00       	call   c002b103 <puts>
c0026d5b:	83 c4 10             	add    $0x10,%esp
    for (;;);
c0026d5e:	eb fe                	jmp    c0026d5e <shutdown_power_off+0xa6>

c0026d60 <shutdown>:
shutdown(void) {
c0026d60:	83 ec 0c             	sub    $0xc,%esp
c0026d63:	e8 df 93 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c0026d68:	05 44 6f 01 00       	add    $0x16f44,%eax
    switch (how) {
c0026d6d:	8b 80 08 1b 00 00    	mov    0x1b08(%eax),%eax
c0026d73:	83 f8 01             	cmp    $0x1,%eax
c0026d76:	74 09                	je     c0026d81 <shutdown+0x21>
c0026d78:	83 f8 02             	cmp    $0x2,%eax
c0026d7b:	74 09                	je     c0026d86 <shutdown+0x26>
}
c0026d7d:	83 c4 0c             	add    $0xc,%esp
c0026d80:	c3                   	ret    
            shutdown_power_off();
c0026d81:	e8 32 ff ff ff       	call   c0026cb8 <shutdown_power_off>
            shutdown_reboot();
c0026d86:	e8 b1 fe ff ff       	call   c0026c3c <shutdown_reboot>

c0026d8b <speaker_off>:
}

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off(void) {
c0026d8b:	53                   	push   %ebx
c0026d8c:	83 ec 08             	sub    $0x8,%esp
c0026d8f:	e8 af 93 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026d94:	81 c3 18 6f 01 00    	add    $0x16f18,%ebx
    enum intr_level old_level = intr_disable();
c0026d9a:	e8 c3 af ff ff       	call   c0021d62 <intr_disable>
c0026d9f:	89 c2                	mov    %eax,%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026da1:	e4 61                	in     $0x61,%al
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026da3:	83 e0 fc             	and    $0xfffffffc,%eax
c0026da6:	e6 61                	out    %al,$0x61
    outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
    intr_set_level(old_level);
c0026da8:	83 ec 0c             	sub    $0xc,%esp
c0026dab:	52                   	push   %edx
c0026dac:	e8 b8 af ff ff       	call   c0021d69 <intr_set_level>
}
c0026db1:	83 c4 18             	add    $0x18,%esp
c0026db4:	5b                   	pop    %ebx
c0026db5:	c3                   	ret    

c0026db6 <speaker_on>:
speaker_on(int frequency) {
c0026db6:	57                   	push   %edi
c0026db7:	56                   	push   %esi
c0026db8:	53                   	push   %ebx
c0026db9:	e8 85 93 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026dbe:	81 c3 ee 6e 01 00    	add    $0x16eee,%ebx
c0026dc4:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (frequency >= 20 && frequency <= 20000) {
c0026dc8:	8d 46 ec             	lea    -0x14(%esi),%eax
c0026dcb:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c0026dd0:	77 2a                	ja     c0026dfc <speaker_on+0x46>
        enum intr_level old_level = intr_disable();
c0026dd2:	e8 8b af ff ff       	call   c0021d62 <intr_disable>
c0026dd7:	89 c7                	mov    %eax,%edi
        pit_configure_channel(2, 3, frequency);
c0026dd9:	83 ec 04             	sub    $0x4,%esp
c0026ddc:	56                   	push   %esi
c0026ddd:	6a 03                	push   $0x3
c0026ddf:	6a 02                	push   $0x2
c0026de1:	e8 9a d3 ff ff       	call   c0024180 <pit_configure_channel>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026de6:	e4 61                	in     $0x61,%al
        outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026de8:	83 c8 03             	or     $0x3,%eax
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026deb:	e6 61                	out    %al,$0x61
        intr_set_level(old_level);
c0026ded:	89 3c 24             	mov    %edi,(%esp)
c0026df0:	e8 74 af ff ff       	call   c0021d69 <intr_set_level>
c0026df5:	83 c4 10             	add    $0x10,%esp
}
c0026df8:	5b                   	pop    %ebx
c0026df9:	5e                   	pop    %esi
c0026dfa:	5f                   	pop    %edi
c0026dfb:	c3                   	ret    
        speaker_off();
c0026dfc:	e8 8a ff ff ff       	call   c0026d8b <speaker_off>
}
c0026e01:	eb f5                	jmp    c0026df8 <speaker_on+0x42>

c0026e03 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep(void) {
c0026e03:	53                   	push   %ebx
c0026e04:	83 ec 08             	sub    $0x8,%esp
c0026e07:	e8 37 93 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026e0c:	81 c3 a0 6e 01 00    	add    $0x16ea0,%ebx

       We can't just enable interrupts while we sleep.  For one
       thing, we get called (indirectly) from printf, which should
       always work, even during boot before we're ready to enable
       interrupts. */
    if (intr_get_level() == INTR_ON) {
c0026e12:	e8 f9 ae ff ff       	call   c0021d10 <intr_get_level>
c0026e17:	83 f8 01             	cmp    $0x1,%eax
c0026e1a:	74 05                	je     c0026e21 <speaker_beep+0x1e>
        speaker_on(440);
        timer_msleep(250);
        speaker_off();
    }
}
c0026e1c:	83 c4 08             	add    $0x8,%esp
c0026e1f:	5b                   	pop    %ebx
c0026e20:	c3                   	ret    
        speaker_on(440);
c0026e21:	83 ec 0c             	sub    $0xc,%esp
c0026e24:	68 b8 01 00 00       	push   $0x1b8
c0026e29:	e8 88 ff ff ff       	call   c0026db6 <speaker_on>
        timer_msleep(250);
c0026e2e:	83 c4 08             	add    $0x8,%esp
c0026e31:	6a 00                	push   $0x0
c0026e33:	68 fa 00 00 00       	push   $0xfa
c0026e38:	e8 fb d8 ff ff       	call   c0024738 <timer_msleep>
        speaker_off();
c0026e3d:	e8 49 ff ff ff       	call   c0026d8b <speaker_off>
c0026e42:	83 c4 10             	add    $0x10,%esp
}
c0026e45:	eb d5                	jmp    c0026e1c <speaker_beep+0x19>

c0026e47 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026e47:	55                   	push   %ebp
c0026e48:	89 e5                	mov    %esp,%ebp
c0026e4a:	57                   	push   %edi
c0026e4b:	56                   	push   %esi
c0026e4c:	53                   	push   %ebx
c0026e4d:	83 ec 14             	sub    $0x14,%esp
c0026e50:	e8 ee 92 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0026e55:	81 c3 57 6e 01 00    	add    $0x16e57,%ebx
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026e5b:	ff 75 04             	pushl  0x4(%ebp)
c0026e5e:	8d 83 33 50 ff ff    	lea    -0xafcd(%ebx),%eax
c0026e64:	50                   	push   %eax
c0026e65:	e8 67 06 00 00       	call   c00274d1 <printf>
  for (frame = __builtin_frame_address (1);
c0026e6a:	8b 75 00             	mov    0x0(%ebp),%esi
c0026e6d:	83 c4 10             	add    $0x10,%esp
c0026e70:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026e76:	76 29                	jbe    c0026ea1 <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026e78:	83 3e 00             	cmpl   $0x0,(%esi)
c0026e7b:	74 24                	je     c0026ea1 <debug_backtrace+0x5a>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026e7d:	8d bb 3e 50 ff ff    	lea    -0xafc2(%ebx),%edi
c0026e83:	83 ec 08             	sub    $0x8,%esp
c0026e86:	ff 76 04             	pushl  0x4(%esi)
c0026e89:	57                   	push   %edi
c0026e8a:	e8 42 06 00 00       	call   c00274d1 <printf>
       frame = frame[0]) 
c0026e8f:	8b 36                	mov    (%esi),%esi
  for (frame = __builtin_frame_address (1);
c0026e91:	83 c4 10             	add    $0x10,%esp
c0026e94:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026e9a:	76 05                	jbe    c0026ea1 <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026e9c:	83 3e 00             	cmpl   $0x0,(%esi)
c0026e9f:	75 e2                	jne    c0026e83 <debug_backtrace+0x3c>
  printf (".\n");
c0026ea1:	83 ec 0c             	sub    $0xc,%esp
c0026ea4:	8d 83 db 4b ff ff    	lea    -0xb425(%ebx),%eax
c0026eaa:	50                   	push   %eax
c0026eab:	e8 53 42 00 00       	call   c002b103 <puts>

  if (!explained) 
c0026eb0:	83 c4 10             	add    $0x10,%esp
c0026eb3:	80 bb 0c 1b 00 00 00 	cmpb   $0x0,0x1b0c(%ebx)
c0026eba:	74 08                	je     c0026ec4 <debug_backtrace+0x7d>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026ebc:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0026ebf:	5b                   	pop    %ebx
c0026ec0:	5e                   	pop    %esi
c0026ec1:	5f                   	pop    %edi
c0026ec2:	5d                   	pop    %ebp
c0026ec3:	c3                   	ret    
      explained = true;
c0026ec4:	c6 83 0c 1b 00 00 01 	movb   $0x1,0x1b0c(%ebx)
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026ecb:	83 ec 0c             	sub    $0xc,%esp
c0026ece:	8d 83 44 50 ff ff    	lea    -0xafbc(%ebx),%eax
c0026ed4:	50                   	push   %eax
c0026ed5:	e8 29 42 00 00       	call   c002b103 <puts>
c0026eda:	83 c4 10             	add    $0x10,%esp
}
c0026edd:	eb dd                	jmp    c0026ebc <debug_backtrace+0x75>

c0026edf <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026edf:	55                   	push   %ebp
c0026ee0:	57                   	push   %edi
c0026ee1:	56                   	push   %esi
c0026ee2:	53                   	push   %ebx
c0026ee3:	83 ec 04             	sub    $0x4,%esp
c0026ee6:	e8 64 92 00 00       	call   c003014f <__x86.get_pc_thunk.di>
c0026eeb:	81 c7 c1 6d 01 00    	add    $0x16dc1,%edi
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026ef1:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c0026ef6:	88 84 38 34 1b 00 00 	mov    %al,0x1b34(%eax,%edi,1)
  for (i = 0; i < 256; i++) 
c0026efd:	83 c0 01             	add    $0x1,%eax
c0026f00:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026f05:	75 ef                	jne    c0026ef6 <random_init+0x17>
c0026f07:	8d 8f 34 1b 00 00    	lea    0x1b34(%edi),%ecx
  for (i = j = 0; i < 256; i++) 
c0026f0d:	bb 00 00 00 00       	mov    $0x0,%ebx
c0026f12:	ba 00 00 00 00       	mov    $0x0,%edx
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
c0026f17:	89 cd                	mov    %ecx,%ebp
c0026f19:	88 5c 24 03          	mov    %bl,0x3(%esp)
      j += s[i] + seedp[i % sizeof seed];
c0026f1d:	89 d0                	mov    %edx,%eax
c0026f1f:	83 e0 03             	and    $0x3,%eax
c0026f22:	0f b6 31             	movzbl (%ecx),%esi
c0026f25:	89 f3                	mov    %esi,%ebx
c0026f27:	02 5c 04 18          	add    0x18(%esp,%eax,1),%bl
c0026f2b:	00 5c 24 03          	add    %bl,0x3(%esp)
c0026f2f:	0f b6 44 24 03       	movzbl 0x3(%esp),%eax
      swap_byte (s + i, s + j);
c0026f34:	0f b6 c0             	movzbl %al,%eax
c0026f37:	01 e8                	add    %ebp,%eax
  *a = *b;
c0026f39:	0f b6 18             	movzbl (%eax),%ebx
c0026f3c:	88 19                	mov    %bl,(%ecx)
  *b = t;
c0026f3e:	89 f3                	mov    %esi,%ebx
c0026f40:	88 18                	mov    %bl,(%eax)
  for (i = j = 0; i < 256; i++) 
c0026f42:	83 c2 01             	add    $0x1,%edx
c0026f45:	83 c1 01             	add    $0x1,%ecx
c0026f48:	81 fa 00 01 00 00    	cmp    $0x100,%edx
c0026f4e:	75 cd                	jne    c0026f1d <random_init+0x3e>
    }

  s_i = s_j = 0;
c0026f50:	c6 87 15 1b 00 00 00 	movb   $0x0,0x1b15(%edi)
c0026f57:	c6 87 16 1b 00 00 00 	movb   $0x0,0x1b16(%edi)
  inited = true;
c0026f5e:	c6 87 14 1b 00 00 01 	movb   $0x1,0x1b14(%edi)
}
c0026f65:	83 c4 04             	add    $0x4,%esp
c0026f68:	5b                   	pop    %ebx
c0026f69:	5e                   	pop    %esi
c0026f6a:	5f                   	pop    %edi
c0026f6b:	5d                   	pop    %ebp
c0026f6c:	c3                   	ret    

c0026f6d <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026f6d:	55                   	push   %ebp
c0026f6e:	57                   	push   %edi
c0026f6f:	56                   	push   %esi
c0026f70:	53                   	push   %ebx
c0026f71:	83 ec 14             	sub    $0x14,%esp
c0026f74:	e8 ce 91 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c0026f79:	05 33 6d 01 00       	add    $0x16d33,%eax
c0026f7e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0026f82:	8b 74 24 28          	mov    0x28(%esp),%esi
c0026f86:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  uint8_t *buf;

  if (!inited)
c0026f8a:	80 b8 14 1b 00 00 00 	cmpb   $0x0,0x1b14(%eax)
c0026f91:	0f 84 ac 00 00 00    	je     c0027043 <random_bytes+0xd6>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c0026f97:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0026f9a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0026f9e:	85 db                	test   %ebx,%ebx
c0026fa0:	0f 84 95 00 00 00    	je     c002703b <random_bytes+0xce>
c0026fa6:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0026faa:	0f b6 87 15 1b 00 00 	movzbl 0x1b15(%edi),%eax
c0026fb1:	88 44 24 11          	mov    %al,0x11(%esp)
c0026fb5:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c0026fb8:	89 44 24 04          	mov    %eax,0x4(%esp)
c0026fbc:	89 f3                	mov    %esi,%ebx
c0026fbe:	0f b6 87 16 1b 00 00 	movzbl 0x1b16(%edi),%eax
c0026fc5:	83 c0 01             	add    $0x1,%eax
c0026fc8:	88 44 24 13          	mov    %al,0x13(%esp)
c0026fcc:	89 f2                	mov    %esi,%edx
c0026fce:	29 d0                	sub    %edx,%eax
c0026fd0:	88 44 24 12          	mov    %al,0x12(%esp)
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c0026fd4:	8d 87 34 1b 00 00    	lea    0x1b34(%edi),%eax
      s_i++;
c0026fda:	0f b6 7c 24 12       	movzbl 0x12(%esp),%edi
c0026fdf:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
      s_j += s[s_i];
c0026fe2:	0f b6 d2             	movzbl %dl,%edx
c0026fe5:	0f b6 4c 24 11       	movzbl 0x11(%esp),%ecx
c0026fea:	02 0c 10             	add    (%eax,%edx,1),%cl
c0026fed:	88 4c 24 11          	mov    %cl,0x11(%esp)
      swap_byte (s + s_i, s + s_j);
c0026ff1:	0f b6 f1             	movzbl %cl,%esi
c0026ff4:	89 34 24             	mov    %esi,(%esp)
c0026ff7:	01 c6                	add    %eax,%esi
c0026ff9:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  uint8_t t = *a;
c0026ffc:	0f b6 2f             	movzbl (%edi),%ebp
  *a = *b;
c0026fff:	0f b6 0e             	movzbl (%esi),%ecx
c0027002:	88 0f                	mov    %cl,(%edi)
  *b = t;
c0027004:	89 e9                	mov    %ebp,%ecx
c0027006:	88 0e                	mov    %cl,(%esi)

      s_k = s[s_i] + s[s_j];
c0027008:	02 0c 10             	add    (%eax,%edx,1),%cl
      *buf = s[s_k];
c002700b:	0f b6 d1             	movzbl %cl,%edx
c002700e:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
c0027012:	88 13                	mov    %dl,(%ebx)
  for (buf = buf_; size-- > 0; buf++)
c0027014:	83 c3 01             	add    $0x1,%ebx
c0027017:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
c002701b:	75 bd                	jne    c0026fda <random_bytes+0x6d>
c002701d:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
c0027022:	02 44 24 0c          	add    0xc(%esp),%al
c0027026:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c002702a:	88 83 16 1b 00 00    	mov    %al,0x1b16(%ebx)
c0027030:	0f b6 44 24 11       	movzbl 0x11(%esp),%eax
c0027035:	88 83 15 1b 00 00    	mov    %al,0x1b15(%ebx)
    }
}
c002703b:	83 c4 14             	add    $0x14,%esp
c002703e:	5b                   	pop    %ebx
c002703f:	5e                   	pop    %esi
c0027040:	5f                   	pop    %edi
c0027041:	5d                   	pop    %ebp
c0027042:	c3                   	ret    
    random_init (0);
c0027043:	6a 00                	push   $0x0
c0027045:	e8 95 fe ff ff       	call   c0026edf <random_init>
c002704a:	83 c4 04             	add    $0x4,%esp
c002704d:	e9 45 ff ff ff       	jmp    c0026f97 <random_bytes+0x2a>

c0027052 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0027052:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0027055:	6a 04                	push   $0x4
c0027057:	8d 44 24 10          	lea    0x10(%esp),%eax
c002705b:	50                   	push   %eax
c002705c:	e8 0c ff ff ff       	call   c0026f6d <random_bytes>
  return ul;
}
c0027061:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027065:	83 c4 18             	add    $0x18,%esp
c0027068:	c3                   	ret    

c0027069 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027069:	53                   	push   %ebx
c002706a:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c002706e:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c0027072:	8b 50 04             	mov    0x4(%eax),%edx
c0027075:	8d 4a 01             	lea    0x1(%edx),%ecx
c0027078:	89 48 04             	mov    %ecx,0x4(%eax)
c002707b:	3b 50 08             	cmp    0x8(%eax),%edx
c002707e:	7d 09                	jge    c0027089 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c0027080:	8b 10                	mov    (%eax),%edx
c0027082:	8d 4a 01             	lea    0x1(%edx),%ecx
c0027085:	89 08                	mov    %ecx,(%eax)
c0027087:	88 1a                	mov    %bl,(%edx)
}
c0027089:	5b                   	pop    %ebx
c002708a:	c3                   	ret    

c002708b <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c002708b:	55                   	push   %ebp
c002708c:	57                   	push   %edi
c002708d:	56                   	push   %esi
c002708e:	53                   	push   %ebx
c002708f:	83 ec 0c             	sub    $0xc,%esp
c0027092:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c0027096:	85 d2                	test   %edx,%edx
c0027098:	74 1a                	je     c00270b4 <output_dup+0x29>
c002709a:	8d 5a ff             	lea    -0x1(%edx),%ebx
c002709d:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c002709f:	0f be f0             	movsbl %al,%esi
c00270a2:	83 ec 08             	sub    $0x8,%esp
c00270a5:	57                   	push   %edi
c00270a6:	56                   	push   %esi
c00270a7:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c00270a9:	83 eb 01             	sub    $0x1,%ebx
c00270ac:	83 c4 10             	add    $0x10,%esp
c00270af:	83 fb ff             	cmp    $0xffffffff,%ebx
c00270b2:	75 ee                	jne    c00270a2 <output_dup+0x17>
}
c00270b4:	83 c4 0c             	add    $0xc,%esp
c00270b7:	5b                   	pop    %ebx
c00270b8:	5e                   	pop    %esi
c00270b9:	5f                   	pop    %edi
c00270ba:	5d                   	pop    %ebp
c00270bb:	c3                   	ret    

c00270bc <format_integer>:
{
c00270bc:	55                   	push   %ebp
c00270bd:	57                   	push   %edi
c00270be:	56                   	push   %esi
c00270bf:	53                   	push   %ebx
c00270c0:	83 ec 7c             	sub    $0x7c,%esp
c00270c3:	e8 7b 90 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00270c8:	81 c3 e4 6b 01 00    	add    $0x16be4,%ebx
c00270ce:	89 c6                	mov    %eax,%esi
c00270d0:	89 d7                	mov    %edx,%edi
c00270d2:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  sign = 0;
c00270d9:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c00270e0:	00 
  if (is_signed) 
c00270e1:	84 c9                	test   %cl,%cl
c00270e3:	74 20                	je     c0027105 <format_integer+0x49>
      if (c->flags & PLUS)
c00270e5:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c00270ec:	8b 11                	mov    (%ecx),%edx
c00270ee:	f6 c2 02             	test   $0x2,%dl
c00270f1:	0f 84 88 00 00 00    	je     c002717f <format_integer+0xc3>
        sign = negative ? '-' : '+';
c00270f7:	3c 01                	cmp    $0x1,%al
c00270f9:	19 c0                	sbb    %eax,%eax
c00270fb:	83 e0 fe             	and    $0xfffffffe,%eax
c00270fe:	83 c0 2d             	add    $0x2d,%eax
c0027101:	89 44 24 20          	mov    %eax,0x20(%esp)
  x = (c->flags & POUND) && value ? b->x : 0;
c0027105:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002710c:	8b 00                	mov    (%eax),%eax
c002710e:	89 44 24 28          	mov    %eax,0x28(%esp)
c0027112:	83 e0 08             	and    $0x8,%eax
c0027115:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0027119:	89 f1                	mov    %esi,%ecx
c002711b:	09 f9                	or     %edi,%ecx
c002711d:	74 08                	je     c0027127 <format_integer+0x6b>
c002711f:	85 c0                	test   %eax,%eax
c0027121:	0f 85 82 00 00 00    	jne    c00271a9 <format_integer+0xed>
  while (value > 0) 
c0027127:	89 fa                	mov    %edi,%edx
c0027129:	09 f2                	or     %esi,%edx
c002712b:	0f 84 e2 02 00 00    	je     c0027413 <format_integer+0x357>
  x = (c->flags & POUND) && value ? b->x : 0;
c0027131:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0027138:	00 
      *cp++ = b->digits[value % b->base];
c0027139:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0027140:	8b 40 04             	mov    0x4(%eax),%eax
c0027143:	89 44 24 18          	mov    %eax,0x18(%esp)
c0027147:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c002714e:	8b 00                	mov    (%eax),%eax
c0027150:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027154:	89 c1                	mov    %eax,%ecx
c0027156:	c1 f9 1f             	sar    $0x1f,%ecx
c0027159:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c002715d:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027162:	8d 6c 24 30          	lea    0x30(%esp),%ebp
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027166:	8b 44 24 28          	mov    0x28(%esp),%eax
c002716a:	c1 e8 05             	shr    $0x5,%eax
c002716d:	83 e0 01             	and    $0x1,%eax
c0027170:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0027174:	89 6c 24 14          	mov    %ebp,0x14(%esp)
c0027178:	89 cd                	mov    %ecx,%ebp
c002717a:	e9 90 00 00 00       	jmp    c002720f <format_integer+0x153>
      else if (c->flags & SPACE)
c002717f:	f6 c2 04             	test   $0x4,%dl
c0027182:	74 13                	je     c0027197 <format_integer+0xdb>
        sign = negative ? '-' : ' ';
c0027184:	3c 01                	cmp    $0x1,%al
c0027186:	19 c0                	sbb    %eax,%eax
c0027188:	83 e0 f3             	and    $0xfffffff3,%eax
c002718b:	83 c0 2d             	add    $0x2d,%eax
c002718e:	89 44 24 20          	mov    %eax,0x20(%esp)
c0027192:	e9 6e ff ff ff       	jmp    c0027105 <format_integer+0x49>
        sign = '-';
c0027197:	3c 01                	cmp    $0x1,%al
c0027199:	19 c0                	sbb    %eax,%eax
c002719b:	f7 d0                	not    %eax
c002719d:	83 e0 2d             	and    $0x2d,%eax
c00271a0:	89 44 24 20          	mov    %eax,0x20(%esp)
c00271a4:	e9 5c ff ff ff       	jmp    c0027105 <format_integer+0x49>
  x = (c->flags & POUND) && value ? b->x : 0;
c00271a9:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c00271b0:	8b 40 08             	mov    0x8(%eax),%eax
c00271b3:	89 44 24 24          	mov    %eax,0x24(%esp)
  while (value > 0) 
c00271b7:	eb 80                	jmp    c0027139 <format_integer+0x7d>
c00271b9:	8b 44 24 14          	mov    0x14(%esp),%eax
c00271bd:	89 44 24 10          	mov    %eax,0x10(%esp)
      *cp++ = b->digits[value % b->base];
c00271c1:	8b 44 24 10          	mov    0x10(%esp),%eax
c00271c5:	8d 50 01             	lea    0x1(%eax),%edx
c00271c8:	89 54 24 14          	mov    %edx,0x14(%esp)
c00271cc:	ff 74 24 0c          	pushl  0xc(%esp)
c00271d0:	ff 74 24 0c          	pushl  0xc(%esp)
c00271d4:	57                   	push   %edi
c00271d5:	56                   	push   %esi
c00271d6:	e8 7f 19 00 00       	call   c0028b5a <__umoddi3>
c00271db:	83 c4 10             	add    $0x10,%esp
c00271de:	8b 54 24 18          	mov    0x18(%esp),%edx
c00271e2:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
c00271e6:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00271ea:	88 01                	mov    %al,(%ecx)
      value /= b->base;
c00271ec:	ff 74 24 0c          	pushl  0xc(%esp)
c00271f0:	ff 74 24 0c          	pushl  0xc(%esp)
c00271f4:	57                   	push   %edi
c00271f5:	56                   	push   %esi
c00271f6:	e8 43 19 00 00       	call   c0028b3e <__udivdi3>
c00271fb:	83 c4 10             	add    $0x10,%esp
      digit_cnt++;
c00271fe:	83 c5 01             	add    $0x1,%ebp
  while (value > 0) 
c0027201:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027205:	1b 7c 24 0c          	sbb    0xc(%esp),%edi
c0027209:	72 34                	jb     c002723f <format_integer+0x183>
      value /= b->base;
c002720b:	89 c6                	mov    %eax,%esi
c002720d:	89 d7                	mov    %edx,%edi
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c002720f:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0027214:	74 a3                	je     c00271b9 <format_integer+0xfd>
c0027216:	85 ed                	test   %ebp,%ebp
c0027218:	7e 9f                	jle    c00271b9 <format_integer+0xfd>
c002721a:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c0027221:	89 e8                	mov    %ebp,%eax
c0027223:	99                   	cltd   
c0027224:	f7 79 0c             	idivl  0xc(%ecx)
c0027227:	8b 44 24 14          	mov    0x14(%esp),%eax
c002722b:	89 44 24 10          	mov    %eax,0x10(%esp)
c002722f:	85 d2                	test   %edx,%edx
c0027231:	75 8e                	jne    c00271c1 <format_integer+0x105>
        *cp++ = ',';
c0027233:	8d 48 01             	lea    0x1(%eax),%ecx
c0027236:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c002723a:	c6 00 2c             	movb   $0x2c,(%eax)
c002723d:	eb 82                	jmp    c00271c1 <format_integer+0x105>
c002723f:	8b 6c 24 14          	mov    0x14(%esp),%ebp
  precision = c->precision < 0 ? 1 : c->precision;
c0027243:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002724a:	8b 50 08             	mov    0x8(%eax),%edx
c002724d:	85 d2                	test   %edx,%edx
c002724f:	b8 01 00 00 00       	mov    $0x1,%eax
c0027254:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027257:	8d 44 24 30          	lea    0x30(%esp),%eax
c002725b:	89 ef                	mov    %ebp,%edi
c002725d:	29 c7                	sub    %eax,%edi
c002725f:	39 fa                	cmp    %edi,%edx
c0027261:	7e 21                	jle    c0027284 <format_integer+0x1c8>
c0027263:	8d 44 24 6f          	lea    0x6f(%esp),%eax
c0027267:	39 c5                	cmp    %eax,%ebp
c0027269:	73 19                	jae    c0027284 <format_integer+0x1c8>
c002726b:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c002726f:	89 c3                	mov    %eax,%ebx
    *cp++ = '0';
c0027271:	83 c5 01             	add    $0x1,%ebp
c0027274:	c6 45 ff 30          	movb   $0x30,-0x1(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027278:	89 e8                	mov    %ebp,%eax
c002727a:	29 c8                	sub    %ecx,%eax
c002727c:	39 d0                	cmp    %edx,%eax
c002727e:	7d 04                	jge    c0027284 <format_integer+0x1c8>
c0027280:	39 dd                	cmp    %ebx,%ebp
c0027282:	72 ed                	jb     c0027271 <format_integer+0x1b5>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027284:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0027289:	74 10                	je     c002729b <format_integer+0x1df>
c002728b:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0027292:	83 38 08             	cmpl   $0x8,(%eax)
c0027295:	0f 84 eb 00 00 00    	je     c0027386 <format_integer+0x2ca>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c002729b:	8d 74 24 30          	lea    0x30(%esp),%esi
c002729f:	29 ee                	sub    %ebp,%esi
c00272a1:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00272a8:	03 70 04             	add    0x4(%eax),%esi
c00272ab:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00272af:	85 ff                	test   %edi,%edi
c00272b1:	b8 02 00 00 00       	mov    $0x2,%eax
c00272b6:	0f 44 c7             	cmove  %edi,%eax
c00272b9:	29 c6                	sub    %eax,%esi
c00272bb:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c00272c0:	0f 95 c0             	setne  %al
c00272c3:	0f b6 c0             	movzbl %al,%eax
  if (pad_cnt < 0)
c00272c6:	29 c6                	sub    %eax,%esi
c00272c8:	b8 00 00 00 00       	mov    $0x0,%eax
c00272cd:	0f 48 f0             	cmovs  %eax,%esi
  if ((c->flags & (MINUS | ZERO)) == 0)
c00272d0:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c00272d5:	0f 84 c9 00 00 00    	je     c00273a4 <format_integer+0x2e8>
  if (sign)
c00272db:	8b 44 24 20          	mov    0x20(%esp),%eax
c00272df:	85 c0                	test   %eax,%eax
c00272e1:	74 15                	je     c00272f8 <format_integer+0x23c>
    output (sign, aux);
c00272e3:	83 ec 08             	sub    $0x8,%esp
c00272e6:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c00272ed:	50                   	push   %eax
c00272ee:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c00272f5:	83 c4 10             	add    $0x10,%esp
  if (x) 
c00272f8:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00272fc:	85 ff                	test   %edi,%edi
c00272fe:	74 2d                	je     c002732d <format_integer+0x271>
      output ('0', aux);
c0027300:	83 ec 08             	sub    $0x8,%esp
c0027303:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002730a:	6a 30                	push   $0x30
c002730c:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c0027313:	83 c4 08             	add    $0x8,%esp
c0027316:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002731d:	89 f8                	mov    %edi,%eax
c002731f:	0f be c0             	movsbl %al,%eax
c0027322:	50                   	push   %eax
c0027323:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c002732a:	83 c4 10             	add    $0x10,%esp
  if (c->flags & ZERO)
c002732d:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027334:	f6 00 10             	testb  $0x10,(%eax)
c0027337:	0f 85 8c 00 00 00    	jne    c00273c9 <format_integer+0x30d>
  while (cp > buf)
c002733d:	8d 44 24 30          	lea    0x30(%esp),%eax
c0027341:	89 c7                	mov    %eax,%edi
c0027343:	39 c5                	cmp    %eax,%ebp
c0027345:	76 2b                	jbe    c0027372 <format_integer+0x2b6>
c0027347:	89 74 24 08          	mov    %esi,0x8(%esp)
c002734b:	8b 9c 24 9c 00 00 00 	mov    0x9c(%esp),%ebx
c0027352:	8b b4 24 a0 00 00 00 	mov    0xa0(%esp),%esi
    output (*--cp, aux);
c0027359:	83 ed 01             	sub    $0x1,%ebp
c002735c:	83 ec 08             	sub    $0x8,%esp
c002735f:	56                   	push   %esi
c0027360:	0f be 45 00          	movsbl 0x0(%ebp),%eax
c0027364:	50                   	push   %eax
c0027365:	ff d3                	call   *%ebx
  while (cp > buf)
c0027367:	83 c4 10             	add    $0x10,%esp
c002736a:	39 fd                	cmp    %edi,%ebp
c002736c:	75 eb                	jne    c0027359 <format_integer+0x29d>
c002736e:	8b 74 24 08          	mov    0x8(%esp),%esi
  if (c->flags & MINUS)
c0027372:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027379:	f6 00 01             	testb  $0x1,(%eax)
c002737c:	75 70                	jne    c00273ee <format_integer+0x332>
}
c002737e:	83 c4 7c             	add    $0x7c,%esp
c0027381:	5b                   	pop    %ebx
c0027382:	5e                   	pop    %esi
c0027383:	5f                   	pop    %edi
c0027384:	5d                   	pop    %ebp
c0027385:	c3                   	ret    
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027386:	8d 44 24 30          	lea    0x30(%esp),%eax
c002738a:	39 c5                	cmp    %eax,%ebp
c002738c:	74 0a                	je     c0027398 <format_integer+0x2dc>
c002738e:	80 7d ff 30          	cmpb   $0x30,-0x1(%ebp)
c0027392:	0f 84 03 ff ff ff    	je     c002729b <format_integer+0x1df>
    *cp++ = '0';
c0027398:	c6 45 00 30          	movb   $0x30,0x0(%ebp)
c002739c:	8d 6d 01             	lea    0x1(%ebp),%ebp
c002739f:	e9 f7 fe ff ff       	jmp    c002729b <format_integer+0x1df>
    output_dup (' ', pad_cnt, output, aux);
c00273a4:	83 ec 0c             	sub    $0xc,%esp
c00273a7:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c00273ae:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c00273b5:	89 f2                	mov    %esi,%edx
c00273b7:	b8 20 00 00 00       	mov    $0x20,%eax
c00273bc:	e8 ca fc ff ff       	call   c002708b <output_dup>
c00273c1:	83 c4 10             	add    $0x10,%esp
c00273c4:	e9 12 ff ff ff       	jmp    c00272db <format_integer+0x21f>
    output_dup ('0', pad_cnt, output, aux);
c00273c9:	83 ec 0c             	sub    $0xc,%esp
c00273cc:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c00273d3:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c00273da:	89 f2                	mov    %esi,%edx
c00273dc:	b8 30 00 00 00       	mov    $0x30,%eax
c00273e1:	e8 a5 fc ff ff       	call   c002708b <output_dup>
c00273e6:	83 c4 10             	add    $0x10,%esp
c00273e9:	e9 4f ff ff ff       	jmp    c002733d <format_integer+0x281>
    output_dup (' ', pad_cnt, output, aux);
c00273ee:	83 ec 0c             	sub    $0xc,%esp
c00273f1:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c00273f8:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c00273ff:	89 f2                	mov    %esi,%edx
c0027401:	b8 20 00 00 00       	mov    $0x20,%eax
c0027406:	e8 80 fc ff ff       	call   c002708b <output_dup>
c002740b:	83 c4 10             	add    $0x10,%esp
}
c002740e:	e9 6b ff ff ff       	jmp    c002737e <format_integer+0x2c2>
  precision = c->precision < 0 ? 1 : c->precision;
c0027413:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002741a:	8b 50 08             	mov    0x8(%eax),%edx
  cp = buf;
c002741d:	8d 6c 24 30          	lea    0x30(%esp),%ebp
  x = (c->flags & POUND) && value ? b->x : 0;
c0027421:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0027428:	00 
  precision = c->precision < 0 ? 1 : c->precision;
c0027429:	85 d2                	test   %edx,%edx
c002742b:	0f 89 26 fe ff ff    	jns    c0027257 <format_integer+0x19b>
    *cp++ = '0';
c0027431:	8d 6c 24 31          	lea    0x31(%esp),%ebp
c0027435:	c6 44 24 30 30       	movb   $0x30,0x30(%esp)
c002743a:	e9 45 fe ff ff       	jmp    c0027284 <format_integer+0x1c8>

c002743f <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c002743f:	55                   	push   %ebp
c0027440:	57                   	push   %edi
c0027441:	56                   	push   %esi
c0027442:	53                   	push   %ebx
c0027443:	83 ec 1c             	sub    $0x1c,%esp
c0027446:	89 c5                	mov    %eax,%ebp
c0027448:	89 d6                	mov    %edx,%esi
c002744a:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c002744e:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027452:	8b 51 04             	mov    0x4(%ecx),%edx
c0027455:	39 f2                	cmp    %esi,%edx
c0027457:	7e 3f                	jle    c0027498 <format_string+0x59>
c0027459:	f6 01 01             	testb  $0x1,(%ecx)
c002745c:	74 1d                	je     c002747b <format_string+0x3c>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c002745e:	85 f6                	test   %esi,%esi
c0027460:	7f 3a                	jg     c002749c <format_string+0x5d>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c0027462:	29 f2                	sub    %esi,%edx
c0027464:	83 ec 0c             	sub    $0xc,%esp
c0027467:	57                   	push   %edi
c0027468:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c002746c:	b8 20 00 00 00       	mov    $0x20,%eax
c0027471:	e8 15 fc ff ff       	call   c002708b <output_dup>
c0027476:	83 c4 10             	add    $0x10,%esp
}
c0027479:	eb 4e                	jmp    c00274c9 <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
c002747b:	29 f2                	sub    %esi,%edx
c002747d:	83 ec 0c             	sub    $0xc,%esp
c0027480:	57                   	push   %edi
c0027481:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0027485:	b8 20 00 00 00       	mov    $0x20,%eax
c002748a:	e8 fc fb ff ff       	call   c002708b <output_dup>
  for (i = 0; i < length; i++)
c002748f:	83 c4 10             	add    $0x10,%esp
c0027492:	85 f6                	test   %esi,%esi
c0027494:	7f 06                	jg     c002749c <format_string+0x5d>
c0027496:	eb 21                	jmp    c00274b9 <format_string+0x7a>
c0027498:	85 f6                	test   %esi,%esi
c002749a:	7e 2d                	jle    c00274c9 <format_string+0x8a>
{
c002749c:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c00274a1:	83 ec 08             	sub    $0x8,%esp
c00274a4:	57                   	push   %edi
c00274a5:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c00274aa:	50                   	push   %eax
c00274ab:	ff 54 24 40          	call   *0x40(%esp)
  for (i = 0; i < length; i++)
c00274af:	83 c3 01             	add    $0x1,%ebx
c00274b2:	83 c4 10             	add    $0x10,%esp
c00274b5:	39 de                	cmp    %ebx,%esi
c00274b7:	7f e8                	jg     c00274a1 <format_string+0x62>
  if (c->width > length && (c->flags & MINUS) != 0)
c00274b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00274bd:	8b 50 04             	mov    0x4(%eax),%edx
c00274c0:	39 f2                	cmp    %esi,%edx
c00274c2:	7e 05                	jle    c00274c9 <format_string+0x8a>
c00274c4:	f6 00 01             	testb  $0x1,(%eax)
c00274c7:	75 99                	jne    c0027462 <format_string+0x23>
}
c00274c9:	83 c4 1c             	add    $0x1c,%esp
c00274cc:	5b                   	pop    %ebx
c00274cd:	5e                   	pop    %esi
c00274ce:	5f                   	pop    %edi
c00274cf:	5d                   	pop    %ebp
c00274d0:	c3                   	ret    

c00274d1 <printf>:
{
c00274d1:	53                   	push   %ebx
c00274d2:	83 ec 08             	sub    $0x8,%esp
c00274d5:	e8 69 8c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00274da:	81 c3 d2 67 01 00    	add    $0x167d2,%ebx
  va_start (args, format);
c00274e0:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c00274e4:	83 ec 08             	sub    $0x8,%esp
c00274e7:	50                   	push   %eax
c00274e8:	ff 74 24 1c          	pushl  0x1c(%esp)
c00274ec:	e8 cf 3b 00 00       	call   c002b0c0 <vprintf>
}
c00274f1:	83 c4 18             	add    $0x18,%esp
c00274f4:	5b                   	pop    %ebx
c00274f5:	c3                   	ret    

c00274f6 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c00274f6:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c00274f9:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c00274fd:	ff 74 24 18          	pushl  0x18(%esp)
c0027501:	ff 74 24 18          	pushl  0x18(%esp)
c0027505:	50                   	push   %eax
c0027506:	ff 74 24 1c          	pushl  0x1c(%esp)
c002750a:	e8 04 00 00 00       	call   c0027513 <__vprintf>
  va_end (args);
}
c002750f:	83 c4 1c             	add    $0x1c,%esp
c0027512:	c3                   	ret    

c0027513 <__vprintf>:
{
c0027513:	55                   	push   %ebp
c0027514:	57                   	push   %edi
c0027515:	56                   	push   %esi
c0027516:	53                   	push   %ebx
c0027517:	83 ec 4c             	sub    $0x4c,%esp
c002751a:	e8 2c 8c 00 00       	call   c003014b <__x86.get_pc_thunk.bp>
c002751f:	81 c5 8d 67 01 00    	add    $0x1678d,%ebp
c0027525:	8b 74 24 60          	mov    0x60(%esp),%esi
c0027529:	8b 7c 24 64          	mov    0x64(%esp),%edi
  for (; *format != '\0'; format++)
c002752d:	0f b6 06             	movzbl (%esi),%eax
c0027530:	84 c0                	test   %al,%al
c0027532:	75 27                	jne    c002755b <__vprintf+0x48>
}
c0027534:	83 c4 4c             	add    $0x4c,%esp
c0027537:	5b                   	pop    %ebx
c0027538:	5e                   	pop    %esi
c0027539:	5f                   	pop    %edi
c002753a:	5d                   	pop    %ebp
c002753b:	c3                   	ret    
          output (*format, aux);
c002753c:	83 ec 08             	sub    $0x8,%esp
c002753f:	ff 74 24 74          	pushl  0x74(%esp)
c0027543:	0f be c0             	movsbl %al,%eax
c0027546:	50                   	push   %eax
c0027547:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c002754b:	83 c4 10             	add    $0x10,%esp
c002754e:	89 f3                	mov    %esi,%ebx
  for (; *format != '\0'; format++)
c0027550:	8d 73 01             	lea    0x1(%ebx),%esi
c0027553:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027557:	84 c0                	test   %al,%al
c0027559:	74 d9                	je     c0027534 <__vprintf+0x21>
      if (*format != '%') 
c002755b:	3c 25                	cmp    $0x25,%al
c002755d:	75 dd                	jne    c002753c <__vprintf+0x29>
      format++;
c002755f:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c0027562:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c0027566:	74 17                	je     c002757f <__vprintf+0x6c>
  c->flags = 0;
c0027568:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c002756f:	00 
c0027570:	c6 04 24 00          	movb   $0x0,(%esp)
c0027574:	ba 00 00 00 00       	mov    $0x0,%edx
c0027579:	89 7c 24 64          	mov    %edi,0x64(%esp)
c002757d:	eb 1b                	jmp    c002759a <.L80+0x9>
          output ('%', aux);
c002757f:	83 ec 08             	sub    $0x8,%esp
c0027582:	ff 74 24 74          	pushl  0x74(%esp)
c0027586:	6a 25                	push   $0x25
c0027588:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c002758c:	83 c4 10             	add    $0x10,%esp
c002758f:	eb bf                	jmp    c0027550 <__vprintf+0x3d>

c0027591 <.L80>:
          c->flags |= MINUS;
c0027591:	83 ca 01             	or     $0x1,%edx
          break;
c0027594:	c6 04 24 01          	movb   $0x1,(%esp)
      switch (*format++) 
c0027598:	89 f3                	mov    %esi,%ebx
c002759a:	8d 73 01             	lea    0x1(%ebx),%esi
c002759d:	0f b6 46 ff          	movzbl -0x1(%esi),%eax
c00275a1:	8d 48 e0             	lea    -0x20(%eax),%ecx
c00275a4:	80 f9 10             	cmp    $0x10,%cl
c00275a7:	77 27                	ja     c00275d0 <.L77>
c00275a9:	0f b6 c9             	movzbl %cl,%ecx
c00275ac:	89 ef                	mov    %ebp,%edi
c00275ae:	03 bc 8d 04 2a ff ff 	add    -0xd5fc(%ebp,%ecx,4),%edi
c00275b5:	ff e7                	jmp    *%edi

c00275b7 <.L81>:
          c->flags |= PLUS;
c00275b7:	83 ca 02             	or     $0x2,%edx
          break;
c00275ba:	eb d8                	jmp    c0027594 <.L80+0x3>

c00275bc <.L84>:
          c->flags |= SPACE;
c00275bc:	83 ca 04             	or     $0x4,%edx
          break;
c00275bf:	eb d3                	jmp    c0027594 <.L80+0x3>

c00275c1 <.L83>:
          c->flags |= POUND;
c00275c1:	83 ca 08             	or     $0x8,%edx
          break;
c00275c4:	eb ce                	jmp    c0027594 <.L80+0x3>

c00275c6 <.L78>:
          c->flags |= ZERO;
c00275c6:	83 ca 10             	or     $0x10,%edx
          break;
c00275c9:	eb c9                	jmp    c0027594 <.L80+0x3>

c00275cb <.L82>:
          c->flags |= GROUP;
c00275cb:	83 ca 20             	or     $0x20,%edx
          break;
c00275ce:	eb c4                	jmp    c0027594 <.L80+0x3>

c00275d0 <.L77>:
c00275d0:	8b 7c 24 64          	mov    0x64(%esp),%edi
c00275d4:	80 3c 24 00          	cmpb   $0x0,(%esp)
c00275d8:	74 0f                	je     c00275e9 <.L77+0x19>
    c->flags &= ~ZERO;
c00275da:	89 d1                	mov    %edx,%ecx
c00275dc:	83 e1 ef             	and    $0xffffffef,%ecx
c00275df:	f6 c2 01             	test   $0x1,%dl
c00275e2:	0f 45 d1             	cmovne %ecx,%edx
c00275e5:	89 54 24 30          	mov    %edx,0x30(%esp)
  if (c->flags & PLUS)
c00275e9:	8b 54 24 30          	mov    0x30(%esp),%edx
c00275ed:	f6 c2 02             	test   $0x2,%dl
c00275f0:	74 07                	je     c00275f9 <.L77+0x29>
    c->flags &= ~SPACE;
c00275f2:	83 e2 fb             	and    $0xfffffffb,%edx
c00275f5:	89 54 24 30          	mov    %edx,0x30(%esp)
  c->width = 0;
c00275f9:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
c0027600:	00 
  if (*format == '*')
c0027601:	3c 2a                	cmp    $0x2a,%al
c0027603:	74 47                	je     c002764c <.L77+0x7c>
      for (; isdigit (*format); format++)
c0027605:	0f be c0             	movsbl %al,%eax
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027608:	8d 48 d0             	lea    -0x30(%eax),%ecx
c002760b:	ba 00 00 00 00       	mov    $0x0,%edx
c0027610:	83 f9 09             	cmp    $0x9,%ecx
c0027613:	77 21                	ja     c0027636 <.L77+0x66>
        c->width = c->width * 10 + *format - '0';
c0027615:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0027618:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
      for (; isdigit (*format); format++)
c002761c:	83 c3 01             	add    $0x1,%ebx
c002761f:	0f be 03             	movsbl (%ebx),%eax
c0027622:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0027625:	83 f9 09             	cmp    $0x9,%ecx
c0027628:	76 eb                	jbe    c0027615 <.L77+0x45>
c002762a:	89 54 24 34          	mov    %edx,0x34(%esp)
  if (c->width < 0) 
c002762e:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027632:	85 c0                	test   %eax,%eax
c0027634:	78 23                	js     c0027659 <.L77+0x89>
  c->precision = -1;
c0027636:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c002763d:	ff 
  if (*format == '.') 
c002763e:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c0027641:	74 23                	je     c0027666 <.L77+0x96>
  if (c->precision >= 0)
c0027643:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027647:	89 04 24             	mov    %eax,(%esp)
c002764a:	eb 69                	jmp    c00276b5 <.L77+0xe5>
      c->width = va_arg (*args, int);
c002764c:	8b 07                	mov    (%edi),%eax
c002764e:	89 44 24 34          	mov    %eax,0x34(%esp)
c0027652:	8d 7f 04             	lea    0x4(%edi),%edi
      switch (*format++) 
c0027655:	89 f3                	mov    %esi,%ebx
c0027657:	eb d5                	jmp    c002762e <.L77+0x5e>
      c->width = -c->width;
c0027659:	f7 d8                	neg    %eax
c002765b:	89 44 24 34          	mov    %eax,0x34(%esp)
      c->flags |= MINUS;
c002765f:	83 4c 24 30 01       	orl    $0x1,0x30(%esp)
c0027664:	eb d0                	jmp    c0027636 <.L77+0x66>
      if (*format == '*') 
c0027666:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002766a:	3c 2a                	cmp    $0x2a,%al
c002766c:	74 6f                	je     c00276dd <.L77+0x10d>
      format++;
c002766e:	83 c3 01             	add    $0x1,%ebx
          c->precision = 0;
c0027671:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
c0027678:	00 
          for (; isdigit (*format); format++)
c0027679:	0f be c0             	movsbl %al,%eax
c002767c:	8d 50 d0             	lea    -0x30(%eax),%edx
c002767f:	83 fa 09             	cmp    $0x9,%edx
c0027682:	77 25                	ja     c00276a9 <.L77+0xd9>
c0027684:	ba 00 00 00 00       	mov    $0x0,%edx
            c->precision = c->precision * 10 + *format - '0';
c0027689:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002768c:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
          for (; isdigit (*format); format++)
c0027690:	83 c3 01             	add    $0x1,%ebx
c0027693:	0f be 03             	movsbl (%ebx),%eax
c0027696:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0027699:	83 f9 09             	cmp    $0x9,%ecx
c002769c:	76 eb                	jbe    c0027689 <.L77+0xb9>
c002769e:	89 54 24 38          	mov    %edx,0x38(%esp)
      if (c->precision < 0) 
c00276a2:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c00276a7:	78 42                	js     c00276eb <.L77+0x11b>
  if (c->precision >= 0)
c00276a9:	8b 44 24 38          	mov    0x38(%esp),%eax
c00276ad:	89 04 24             	mov    %eax,(%esp)
    c->flags &= ~ZERO;
c00276b0:	83 64 24 30 ef       	andl   $0xffffffef,0x30(%esp)
  c->type = INT;
c00276b5:	c7 44 24 3c 03 00 00 	movl   $0x3,0x3c(%esp)
c00276bc:	00 
  switch (*format++) 
c00276bd:	8d 73 01             	lea    0x1(%ebx),%esi
c00276c0:	0f b6 03             	movzbl (%ebx),%eax
c00276c3:	8d 50 98             	lea    -0x68(%eax),%edx
c00276c6:	80 fa 12             	cmp    $0x12,%dl
c00276c9:	0f 87 56 01 00 00    	ja     c0027825 <.L97>
c00276cf:	0f b6 d2             	movzbl %dl,%edx
c00276d2:	89 e9                	mov    %ebp,%ecx
c00276d4:	03 8c 95 48 2a ff ff 	add    -0xd5b8(%ebp,%edx,4),%ecx
c00276db:	ff e1                	jmp    *%ecx
          format++;
c00276dd:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c00276e0:	8b 07                	mov    (%edi),%eax
c00276e2:	89 44 24 38          	mov    %eax,0x38(%esp)
c00276e6:	8d 7f 04             	lea    0x4(%edi),%edi
c00276e9:	eb b7                	jmp    c00276a2 <.L77+0xd2>
        c->precision = -1;
c00276eb:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c00276f2:	ff 
c00276f3:	e9 4b ff ff ff       	jmp    c0027643 <.L77+0x73>

c00276f8 <.L103>:
      if (*format == 'h') 
c00276f8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00276fc:	3c 68                	cmp    $0x68,%al
c00276fe:	74 25                	je     c0027725 <.L103+0x2d>
        c->type = SHORT;
c0027700:	c7 44 24 3c 02 00 00 	movl   $0x2,0x3c(%esp)
c0027707:	00 
      switch (*format) 
c0027708:	0f be d0             	movsbl %al,%edx
c002770b:	8d 58 bb             	lea    -0x45(%eax),%ebx
c002770e:	80 fb 33             	cmp    $0x33,%bl
c0027711:	0f 87 ae 04 00 00    	ja     c0027bc5 <.L105>
c0027717:	0f b6 db             	movzbl %bl,%ebx
c002771a:	89 e9                	mov    %ebp,%ecx
c002771c:	03 8c 9d 94 2a ff ff 	add    -0xd56c(%ebp,%ebx,4),%ecx
c0027723:	ff e1                	jmp    *%ecx
          format++;
c0027725:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = CHAR;
c0027728:	c7 44 24 3c 01 00 00 	movl   $0x1,0x3c(%esp)
c002772f:	00 
      switch (*format) 
c0027730:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c0027734:	0f be d0             	movsbl %al,%edx
c0027737:	8d 58 bb             	lea    -0x45(%eax),%ebx
c002773a:	80 fb 33             	cmp    $0x33,%bl
c002773d:	0f 87 82 04 00 00    	ja     c0027bc5 <.L105>
c0027743:	0f b6 db             	movzbl %bl,%ebx
c0027746:	89 e9                	mov    %ebp,%ecx
c0027748:	03 8c 9d 64 2b ff ff 	add    -0xd49c(%ebp,%ebx,4),%ecx
c002774f:	ff e1                	jmp    *%ecx

c0027751 <.L102>:
      c->type = INTMAX;
c0027751:	c7 44 24 3c 04 00 00 	movl   $0x4,0x3c(%esp)
c0027758:	00 
      switch (*format) 
c0027759:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002775d:	0f be d0             	movsbl %al,%edx
c0027760:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0027763:	80 fb 33             	cmp    $0x33,%bl
c0027766:	0f 87 59 04 00 00    	ja     c0027bc5 <.L105>
c002776c:	0f b6 db             	movzbl %bl,%ebx
c002776f:	89 e9                	mov    %ebp,%ecx
c0027771:	03 8c 9d 34 2c ff ff 	add    -0xd3cc(%ebp,%ebx,4),%ecx
c0027778:	ff e1                	jmp    *%ecx

c002777a <.L101>:
      if (*format == 'l')
c002777a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002777e:	3c 6c                	cmp    $0x6c,%al
c0027780:	74 25                	je     c00277a7 <.L101+0x2d>
        c->type = LONG;
c0027782:	c7 44 24 3c 05 00 00 	movl   $0x5,0x3c(%esp)
c0027789:	00 
      switch (*format) 
c002778a:	0f be d0             	movsbl %al,%edx
c002778d:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0027790:	80 fb 33             	cmp    $0x33,%bl
c0027793:	0f 87 2c 04 00 00    	ja     c0027bc5 <.L105>
c0027799:	0f b6 db             	movzbl %bl,%ebx
c002779c:	89 e9                	mov    %ebp,%ecx
c002779e:	03 8c 9d 04 2d ff ff 	add    -0xd2fc(%ebp,%ebx,4),%ecx
c00277a5:	ff e1                	jmp    *%ecx
          format++;
c00277a7:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = LONGLONG;
c00277aa:	c7 44 24 3c 06 00 00 	movl   $0x6,0x3c(%esp)
c00277b1:	00 
      switch (*format) 
c00277b2:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c00277b6:	0f be d0             	movsbl %al,%edx
c00277b9:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00277bc:	80 fb 33             	cmp    $0x33,%bl
c00277bf:	0f 87 00 04 00 00    	ja     c0027bc5 <.L105>
c00277c5:	0f b6 db             	movzbl %bl,%ebx
c00277c8:	89 e9                	mov    %ebp,%ecx
c00277ca:	03 8c 9d d4 2d ff ff 	add    -0xd22c(%ebp,%ebx,4),%ecx
c00277d1:	ff e1                	jmp    *%ecx

c00277d3 <.L100>:
      c->type = PTRDIFFT;
c00277d3:	c7 44 24 3c 07 00 00 	movl   $0x7,0x3c(%esp)
c00277da:	00 
      switch (*format) 
c00277db:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00277df:	0f be d0             	movsbl %al,%edx
c00277e2:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00277e5:	80 fb 33             	cmp    $0x33,%bl
c00277e8:	0f 87 d7 03 00 00    	ja     c0027bc5 <.L105>
c00277ee:	0f b6 db             	movzbl %bl,%ebx
c00277f1:	89 e9                	mov    %ebp,%ecx
c00277f3:	03 8c 9d a4 2e ff ff 	add    -0xd15c(%ebp,%ebx,4),%ecx
c00277fa:	ff e1                	jmp    *%ecx

c00277fc <.L98>:
      c->type = SIZET;
c00277fc:	c7 44 24 3c 08 00 00 	movl   $0x8,0x3c(%esp)
c0027803:	00 
      switch (*format) 
c0027804:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027808:	0f be d0             	movsbl %al,%edx
c002780b:	8d 58 bb             	lea    -0x45(%eax),%ebx
c002780e:	80 fb 33             	cmp    $0x33,%bl
c0027811:	0f 87 ae 03 00 00    	ja     c0027bc5 <.L105>
c0027817:	0f b6 db             	movzbl %bl,%ebx
c002781a:	89 e9                	mov    %ebp,%ecx
c002781c:	03 8c 9d 74 2f ff ff 	add    -0xd08c(%ebp,%ebx,4),%ecx
c0027823:	ff e1                	jmp    *%ecx

c0027825 <.L97>:
c0027825:	0f be d0             	movsbl %al,%edx
c0027828:	8d 70 bb             	lea    -0x45(%eax),%esi
c002782b:	89 f1                	mov    %esi,%ecx
c002782d:	80 f9 33             	cmp    $0x33,%cl
c0027830:	0f 87 8d 03 00 00    	ja     c0027bc3 <.L149>
c0027836:	0f b6 f1             	movzbl %cl,%esi
c0027839:	89 e9                	mov    %ebp,%ecx
c002783b:	03 8c b5 44 30 ff ff 	add    -0xcfbc(%ebp,%esi,4),%ecx
c0027842:	ff e1                	jmp    *%ecx

c0027844 <.L152>:
c0027844:	89 de                	mov    %ebx,%esi

c0027846 <.L111>:
            switch (c.type) 
c0027846:	83 7c 24 3c 08       	cmpl   $0x8,0x3c(%esp)
c002784b:	0f 87 20 01 00 00    	ja     c0027971 <.L128>
c0027851:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0027855:	89 eb                	mov    %ebp,%ebx
c0027857:	03 9c 85 14 31 ff ff 	add    -0xceec(%ebp,%eax,4),%ebx
c002785e:	ff e3                	jmp    *%ebx

c0027860 <.L137>:
                value = (signed char) va_arg (args, int);
c0027860:	0f be 0f             	movsbl (%edi),%ecx
c0027863:	89 c8                	mov    %ecx,%eax
c0027865:	99                   	cltd   
c0027866:	89 0c 24             	mov    %ecx,(%esp)
c0027869:	89 54 24 04          	mov    %edx,0x4(%esp)
c002786d:	8d 7f 04             	lea    0x4(%edi),%edi
            format_integer (value < 0 ? -value : value,
c0027870:	8b 54 24 04          	mov    0x4(%esp),%edx
c0027874:	c1 fa 1f             	sar    $0x1f,%edx
c0027877:	89 d3                	mov    %edx,%ebx
c0027879:	33 1c 24             	xor    (%esp),%ebx
c002787c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0027880:	89 d3                	mov    %edx,%ebx
c0027882:	33 5c 24 04          	xor    0x4(%esp),%ebx
c0027886:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c002788a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002788e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027892:	29 d1                	sub    %edx,%ecx
c0027894:	19 d3                	sbb    %edx,%ebx
c0027896:	89 c8                	mov    %ecx,%eax
c0027898:	89 da                	mov    %ebx,%edx
c002789a:	83 ec 0c             	sub    $0xc,%esp
c002789d:	ff 74 24 78          	pushl  0x78(%esp)
c00278a1:	ff 74 24 78          	pushl  0x78(%esp)
c00278a5:	8d 4c 24 44          	lea    0x44(%esp),%ecx
c00278a9:	51                   	push   %ecx
c00278aa:	8d 8d c4 64 ff ff    	lea    -0x9b3c(%ebp),%ecx
c00278b0:	51                   	push   %ecx
c00278b1:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c00278b5:	c1 e9 1f             	shr    $0x1f,%ecx
c00278b8:	51                   	push   %ecx
c00278b9:	b9 01 00 00 00       	mov    $0x1,%ecx
c00278be:	e8 f9 f7 ff ff       	call   c00270bc <format_integer>
          break;
c00278c3:	83 c4 20             	add    $0x20,%esp
c00278c6:	89 f3                	mov    %esi,%ebx
c00278c8:	e9 83 fc ff ff       	jmp    c0027550 <__vprintf+0x3d>

c00278cd <.L136>:
                value = (short) va_arg (args, int);
c00278cd:	0f bf 0f             	movswl (%edi),%ecx
c00278d0:	89 c8                	mov    %ecx,%eax
c00278d2:	99                   	cltd   
c00278d3:	89 0c 24             	mov    %ecx,(%esp)
c00278d6:	89 54 24 04          	mov    %edx,0x4(%esp)
c00278da:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00278dd:	eb 91                	jmp    c0027870 <.L137+0x10>

c00278df <.L135>:
                value = va_arg (args, int);
c00278df:	8b 0f                	mov    (%edi),%ecx
c00278e1:	89 c8                	mov    %ecx,%eax
c00278e3:	99                   	cltd   
c00278e4:	89 0c 24             	mov    %ecx,(%esp)
c00278e7:	89 54 24 04          	mov    %edx,0x4(%esp)
c00278eb:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00278ee:	eb 80                	jmp    c0027870 <.L137+0x10>

c00278f0 <.L134>:
                value = va_arg (args, intmax_t);
c00278f0:	8b 07                	mov    (%edi),%eax
c00278f2:	8b 57 04             	mov    0x4(%edi),%edx
c00278f5:	89 04 24             	mov    %eax,(%esp)
c00278f8:	89 54 24 04          	mov    %edx,0x4(%esp)
c00278fc:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00278ff:	e9 6c ff ff ff       	jmp    c0027870 <.L137+0x10>

c0027904 <.L133>:
                value = va_arg (args, long);
c0027904:	8b 0f                	mov    (%edi),%ecx
c0027906:	89 c8                	mov    %ecx,%eax
c0027908:	99                   	cltd   
c0027909:	89 0c 24             	mov    %ecx,(%esp)
c002790c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027910:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027913:	e9 58 ff ff ff       	jmp    c0027870 <.L137+0x10>

c0027918 <.L132>:
                value = va_arg (args, long long);
c0027918:	8b 07                	mov    (%edi),%eax
c002791a:	8b 57 04             	mov    0x4(%edi),%edx
c002791d:	89 04 24             	mov    %eax,(%esp)
c0027920:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027924:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c0027927:	e9 44 ff ff ff       	jmp    c0027870 <.L137+0x10>

c002792c <.L131>:
                value = va_arg (args, ptrdiff_t);
c002792c:	8b 0f                	mov    (%edi),%ecx
c002792e:	89 c8                	mov    %ecx,%eax
c0027930:	99                   	cltd   
c0027931:	89 0c 24             	mov    %ecx,(%esp)
c0027934:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027938:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c002793b:	e9 30 ff ff ff       	jmp    c0027870 <.L137+0x10>

c0027940 <.L129>:
                value = va_arg (args, size_t);
c0027940:	8d 47 04             	lea    0x4(%edi),%eax
c0027943:	8b 0f                	mov    (%edi),%ecx
c0027945:	bb 00 00 00 00       	mov    $0x0,%ebx
c002794a:	89 0c 24             	mov    %ecx,(%esp)
c002794d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
                if (value > SIZE_MAX / 2)
c0027951:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
c0027956:	39 ca                	cmp    %ecx,%edx
c0027958:	ba 00 00 00 00       	mov    $0x0,%edx
c002795d:	19 da                	sbb    %ebx,%edx
                value = va_arg (args, size_t);
c002795f:	89 c7                	mov    %eax,%edi
                if (value > SIZE_MAX / 2)
c0027961:	0f 8d 09 ff ff ff    	jge    c0027870 <.L137+0x10>
                  value = value - SIZE_MAX - 1;
c0027967:	83 6c 24 04 01       	subl   $0x1,0x4(%esp)
c002796c:	e9 ff fe ff ff       	jmp    c0027870 <.L137+0x10>

c0027971 <.L128>:
                NOT_REACHED ();
c0027971:	8d 85 54 3d ff ff    	lea    -0xc2ac(%ebp),%eax
c0027977:	50                   	push   %eax
c0027978:	8d 85 38 31 ff ff    	lea    -0xcec8(%ebp),%eax
c002797e:	50                   	push   %eax
c002797f:	68 dc 00 00 00       	push   $0xdc
c0027984:	8d 85 e5 50 ff ff    	lea    -0xaf1b(%ebp),%eax
c002798a:	50                   	push   %eax
c002798b:	89 eb                	mov    %ebp,%ebx
c002798d:	e8 9b 17 00 00       	call   c002912d <debug_panic>

c0027992 <.L126>:
                value = va_arg (args, unsigned);
c0027992:	8b 17                	mov    (%edi),%edx
c0027994:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027999:	89 54 24 10          	mov    %edx,0x10(%esp)
c002799d:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c00279a1:	8d 7f 04             	lea    0x4(%edi),%edi
            switch (*format) 
c00279a4:	3c 6f                	cmp    $0x6f,%al
c00279a6:	0f 84 1c 01 00 00    	je     c0027ac8 <.L124+0x71>
c00279ac:	3c 6f                	cmp    $0x6f,%al
c00279ae:	0f 8e bc 00 00 00    	jle    c0027a70 <.L124+0x19>
c00279b4:	3c 75                	cmp    $0x75,%al
c00279b6:	0f 84 14 01 00 00    	je     c0027ad0 <.L124+0x79>
c00279bc:	3c 78                	cmp    $0x78,%al
c00279be:	0f 85 e3 00 00 00    	jne    c0027aa7 <.L124+0x50>
              case 'x': b = &base_x; break;
c00279c4:	8d 85 a4 64 ff ff    	lea    -0x9b5c(%ebp),%eax
c00279ca:	e9 ab 00 00 00       	jmp    c0027a7a <.L124+0x23>

c00279cf <.L106>:
                value = (unsigned char) va_arg (args, unsigned);
c00279cf:	0f b6 17             	movzbl (%edi),%edx
c00279d2:	89 54 24 10          	mov    %edx,0x10(%esp)
c00279d6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c00279dd:	00 
                break;
c00279de:	89 f3                	mov    %esi,%ebx
                value = (unsigned char) va_arg (args, unsigned);
c00279e0:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00279e3:	eb bf                	jmp    c00279a4 <.L126+0x12>

c00279e5 <.L113>:
                value = (unsigned short) va_arg (args, unsigned);
c00279e5:	0f b7 17             	movzwl (%edi),%edx
c00279e8:	89 54 24 10          	mov    %edx,0x10(%esp)
c00279ec:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c00279f3:	00 
                break;
c00279f4:	89 f3                	mov    %esi,%ebx
                value = (unsigned short) va_arg (args, unsigned);
c00279f6:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00279f9:	eb a9                	jmp    c00279a4 <.L126+0x12>

c00279fb <.L115>:
                value = va_arg (args, uintmax_t);
c00279fb:	8b 0f                	mov    (%edi),%ecx
c00279fd:	8b 5f 04             	mov    0x4(%edi),%ebx
c0027a00:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a04:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c0027a08:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, uintmax_t);
c0027a0a:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c0027a0d:	eb 95                	jmp    c00279a4 <.L126+0x12>

c0027a0f <.L120>:
                value = va_arg (args, unsigned long);
c0027a0f:	8b 0f                	mov    (%edi),%ecx
c0027a11:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027a16:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a1a:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c0027a1e:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, unsigned long);
c0027a20:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027a23:	e9 7c ff ff ff       	jmp    c00279a4 <.L126+0x12>

c0027a28 <.L118>:
                value = va_arg (args, unsigned long long);
c0027a28:	8b 0f                	mov    (%edi),%ecx
c0027a2a:	8b 5f 04             	mov    0x4(%edi),%ebx
c0027a2d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a31:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c0027a35:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, unsigned long long);
c0027a37:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c0027a3a:	e9 65 ff ff ff       	jmp    c00279a4 <.L126+0x12>

c0027a3f <.L122>:
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027a3f:	8b 1f                	mov    (%edi),%ebx
c0027a41:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c0027a45:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0027a4c:	00 
                break;
c0027a4d:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, ptrdiff_t);
c0027a4f:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027a52:	e9 4d ff ff ff       	jmp    c00279a4 <.L126+0x12>

c0027a57 <.L124>:
                value = va_arg (args, size_t);
c0027a57:	8b 0f                	mov    (%edi),%ecx
c0027a59:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027a5e:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a62:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c0027a66:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, size_t);
c0027a68:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027a6b:	e9 34 ff ff ff       	jmp    c00279a4 <.L126+0x12>
c0027a70:	3c 58                	cmp    $0x58,%al
c0027a72:	75 33                	jne    c0027aa7 <.L124+0x50>
              case 'X': b = &base_X; break;
c0027a74:	8d 85 94 64 ff ff    	lea    -0x9b6c(%ebp),%eax
            format_integer (value, false, false, b, &c, output, aux);
c0027a7a:	83 ec 0c             	sub    $0xc,%esp
c0027a7d:	ff 74 24 78          	pushl  0x78(%esp)
c0027a81:	ff 74 24 78          	pushl  0x78(%esp)
c0027a85:	8d 54 24 44          	lea    0x44(%esp),%edx
c0027a89:	52                   	push   %edx
c0027a8a:	50                   	push   %eax
c0027a8b:	6a 00                	push   $0x0
c0027a8d:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027a92:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027a96:	8b 54 24 34          	mov    0x34(%esp),%edx
c0027a9a:	e8 1d f6 ff ff       	call   c00270bc <format_integer>
          break;
c0027a9f:	83 c4 20             	add    $0x20,%esp
c0027aa2:	e9 a9 fa ff ff       	jmp    c0027550 <__vprintf+0x3d>
              default: NOT_REACHED ();
c0027aa7:	8d 85 54 3d ff ff    	lea    -0xc2ac(%ebp),%eax
c0027aad:	50                   	push   %eax
c0027aae:	8d 85 38 31 ff ff    	lea    -0xcec8(%ebp),%eax
c0027ab4:	50                   	push   %eax
c0027ab5:	68 14 01 00 00       	push   $0x114
c0027aba:	8d 85 e5 50 ff ff    	lea    -0xaf1b(%ebp),%eax
c0027ac0:	50                   	push   %eax
c0027ac1:	89 eb                	mov    %ebp,%ebx
c0027ac3:	e8 65 16 00 00       	call   c002912d <debug_panic>
              case 'o': b = &base_o; break;
c0027ac8:	8d 85 b4 64 ff ff    	lea    -0x9b4c(%ebp),%eax
c0027ace:	eb aa                	jmp    c0027a7a <.L124+0x23>
              case 'u': b = &base_d; break;
c0027ad0:	8d 85 c4 64 ff ff    	lea    -0x9b3c(%ebp),%eax
c0027ad6:	eb a2                	jmp    c0027a7a <.L124+0x23>

c0027ad8 <.L151>:
      switch (*format) 
c0027ad8:	89 de                	mov    %ebx,%esi

c0027ada <.L112>:
            char ch = va_arg (args, int);
c0027ada:	8d 47 04             	lea    0x4(%edi),%eax
c0027add:	89 04 24             	mov    %eax,(%esp)
c0027ae0:	8b 07                	mov    (%edi),%eax
c0027ae2:	88 44 24 2f          	mov    %al,0x2f(%esp)
            format_string (&ch, 1, &c, output, aux);
c0027ae6:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c0027aea:	8d 44 24 2f          	lea    0x2f(%esp),%eax
c0027aee:	83 ec 08             	sub    $0x8,%esp
c0027af1:	ff 74 24 74          	pushl  0x74(%esp)
c0027af5:	ff 74 24 74          	pushl  0x74(%esp)
c0027af9:	ba 01 00 00 00       	mov    $0x1,%edx
c0027afe:	e8 3c f9 ff ff       	call   c002743f <format_string>
          break;
c0027b03:	83 c4 10             	add    $0x10,%esp
c0027b06:	89 f3                	mov    %esi,%ebx
            char ch = va_arg (args, int);
c0027b08:	8b 3c 24             	mov    (%esp),%edi
          break;
c0027b0b:	e9 40 fa ff ff       	jmp    c0027550 <__vprintf+0x3d>

c0027b10 <.L154>:
      switch (*format) 
c0027b10:	89 de                	mov    %ebx,%esi

c0027b12 <.L108>:
            const char *s = va_arg (args, char *);
c0027b12:	8d 47 04             	lea    0x4(%edi),%eax
c0027b15:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0027b19:	8b 3f                	mov    (%edi),%edi
              s = "(null)";
c0027b1b:	85 ff                	test   %edi,%edi
c0027b1d:	8d 85 de 50 ff ff    	lea    -0xaf22(%ebp),%eax
c0027b23:	0f 44 f8             	cmove  %eax,%edi
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027b26:	83 ec 08             	sub    $0x8,%esp
c0027b29:	ff 74 24 08          	pushl  0x8(%esp)
c0027b2d:	57                   	push   %edi
c0027b2e:	89 eb                	mov    %ebp,%ebx
c0027b30:	e8 0e 0c 00 00       	call   c0028743 <strnlen>
c0027b35:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c0027b39:	83 c4 08             	add    $0x8,%esp
c0027b3c:	ff 74 24 74          	pushl  0x74(%esp)
c0027b40:	ff 74 24 74          	pushl  0x74(%esp)
c0027b44:	89 c2                	mov    %eax,%edx
c0027b46:	89 f8                	mov    %edi,%eax
c0027b48:	e8 f2 f8 ff ff       	call   c002743f <format_string>
          break;
c0027b4d:	83 c4 10             	add    $0x10,%esp
c0027b50:	89 f3                	mov    %esi,%ebx
            const char *s = va_arg (args, char *);
c0027b52:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
          break;
c0027b56:	e9 f5 f9 ff ff       	jmp    c0027550 <__vprintf+0x3d>

c0027b5b <.L153>:
      switch (*format) 
c0027b5b:	89 de                	mov    %ebx,%esi

c0027b5d <.L109>:
            void *p = va_arg (args, void *);
c0027b5d:	8d 47 04             	lea    0x4(%edi),%eax
c0027b60:	89 04 24             	mov    %eax,(%esp)
c0027b63:	8b 07                	mov    (%edi),%eax
            c.flags = POUND;
c0027b65:	c7 44 24 30 08 00 00 	movl   $0x8,0x30(%esp)
c0027b6c:	00 
            format_integer ((uintptr_t) p, false, false,
c0027b6d:	ba 00 00 00 00       	mov    $0x0,%edx
c0027b72:	83 ec 0c             	sub    $0xc,%esp
c0027b75:	ff 74 24 78          	pushl  0x78(%esp)
c0027b79:	ff 74 24 78          	pushl  0x78(%esp)
c0027b7d:	8d 4c 24 44          	lea    0x44(%esp),%ecx
c0027b81:	51                   	push   %ecx
c0027b82:	8d 8d a4 64 ff ff    	lea    -0x9b5c(%ebp),%ecx
c0027b88:	51                   	push   %ecx
c0027b89:	6a 00                	push   $0x0
c0027b8b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027b90:	e8 27 f5 ff ff       	call   c00270bc <format_integer>
          break;
c0027b95:	83 c4 20             	add    $0x20,%esp
c0027b98:	89 f3                	mov    %esi,%ebx
            void *p = va_arg (args, void *);
c0027b9a:	8b 3c 24             	mov    (%esp),%edi
          break;
c0027b9d:	e9 ae f9 ff ff       	jmp    c0027550 <__vprintf+0x3d>

c0027ba2 <.L150>:
      switch (*format) 
c0027ba2:	89 de                	mov    %ebx,%esi

c0027ba4 <.L110>:
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027ba4:	52                   	push   %edx
c0027ba5:	ff 74 24 70          	pushl  0x70(%esp)
c0027ba9:	ff 74 24 70          	pushl  0x70(%esp)
c0027bad:	8d 85 f7 50 ff ff    	lea    -0xaf09(%ebp),%eax
c0027bb3:	50                   	push   %eax
c0027bb4:	e8 3d f9 ff ff       	call   c00274f6 <__printf>
          break;
c0027bb9:	83 c4 10             	add    $0x10,%esp
c0027bbc:	89 f3                	mov    %esi,%ebx
c0027bbe:	e9 8d f9 ff ff       	jmp    c0027550 <__vprintf+0x3d>

c0027bc3 <.L149>:
      switch (*format) 
c0027bc3:	89 de                	mov    %ebx,%esi

c0027bc5 <.L105>:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027bc5:	52                   	push   %edx
c0027bc6:	ff 74 24 70          	pushl  0x70(%esp)
c0027bca:	ff 74 24 70          	pushl  0x70(%esp)
c0027bce:	8d 85 0d 51 ff ff    	lea    -0xaef3(%ebp),%eax
c0027bd4:	50                   	push   %eax
c0027bd5:	e8 1c f9 ff ff       	call   c00274f6 <__printf>
          break;
c0027bda:	83 c4 10             	add    $0x10,%esp
c0027bdd:	89 f3                	mov    %esi,%ebx
c0027bdf:	e9 6c f9 ff ff       	jmp    c0027550 <__vprintf+0x3d>

c0027be4 <vsnprintf>:
{
c0027be4:	56                   	push   %esi
c0027be5:	53                   	push   %ebx
c0027be6:	83 ec 14             	sub    $0x14,%esp
c0027be9:	e8 55 85 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0027bee:	81 c3 be 60 01 00    	add    $0x160be,%ebx
c0027bf4:	8b 44 24 24          	mov    0x24(%esp),%eax
c0027bf8:	8b 54 24 28          	mov    0x28(%esp),%edx
c0027bfc:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c0027c00:	8b 74 24 20          	mov    0x20(%esp),%esi
c0027c04:	89 74 24 04          	mov    %esi,0x4(%esp)
  aux.length = 0;
c0027c08:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0027c0f:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027c10:	85 c0                	test   %eax,%eax
c0027c12:	74 26                	je     c0027c3a <vsnprintf+0x56>
c0027c14:	83 e8 01             	sub    $0x1,%eax
c0027c17:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027c1b:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027c1f:	50                   	push   %eax
c0027c20:	8d 83 bd 93 fe ff    	lea    -0x16c43(%ebx),%eax
c0027c26:	50                   	push   %eax
c0027c27:	51                   	push   %ecx
c0027c28:	52                   	push   %edx
c0027c29:	e8 e5 f8 ff ff       	call   c0027513 <__vprintf>
    *aux.p = '\0';
c0027c2e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027c32:	c6 00 00             	movb   $0x0,(%eax)
c0027c35:	83 c4 10             	add    $0x10,%esp
c0027c38:	eb 1e                	jmp    c0027c58 <vsnprintf+0x74>
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027c3a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027c41:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027c42:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027c46:	50                   	push   %eax
c0027c47:	8d 83 bd 93 fe ff    	lea    -0x16c43(%ebx),%eax
c0027c4d:	50                   	push   %eax
c0027c4e:	51                   	push   %ecx
c0027c4f:	52                   	push   %edx
c0027c50:	e8 be f8 ff ff       	call   c0027513 <__vprintf>
c0027c55:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c0027c58:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c0027c5c:	83 c4 14             	add    $0x14,%esp
c0027c5f:	5b                   	pop    %ebx
c0027c60:	5e                   	pop    %esi
c0027c61:	c3                   	ret    

c0027c62 <snprintf>:
{
c0027c62:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0027c65:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0027c69:	50                   	push   %eax
c0027c6a:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027c6e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027c72:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027c76:	e8 69 ff ff ff       	call   c0027be4 <vsnprintf>
}
c0027c7b:	83 c4 1c             	add    $0x1c,%esp
c0027c7e:	c3                   	ret    

c0027c7f <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027c7f:	55                   	push   %ebp
c0027c80:	57                   	push   %edi
c0027c81:	56                   	push   %esi
c0027c82:	53                   	push   %ebx
c0027c83:	83 ec 2c             	sub    $0x2c,%esp
c0027c86:	e8 c4 84 00 00       	call   c003014f <__x86.get_pc_thunk.di>
c0027c8b:	81 c7 21 60 01 00    	add    $0x16021,%edi
c0027c91:	0f b6 44 24 4c       	movzbl 0x4c(%esp),%eax
c0027c96:	88 44 24 17          	mov    %al,0x17(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027c9a:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c0027c9f:	0f 84 ea 01 00 00    	je     c0027e8f <hex_dump+0x210>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027ca5:	8d 87 24 51 ff ff    	lea    -0xaedc(%edi),%eax
c0027cab:	89 44 24 18          	mov    %eax,0x18(%esp)
c0027caf:	eb 5a                	jmp    c0027d0b <hex_dump+0x8c>
      for (i = 0; i < start; i++)
c0027cb1:	89 eb                	mov    %ebp,%ebx
c0027cb3:	e9 c2 00 00 00       	jmp    c0027d7a <hex_dump+0xfb>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0027cb8:	89 ee                	mov    %ebp,%esi
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
            printf (" ");
c0027cba:	83 ec 0c             	sub    $0xc,%esp
c0027cbd:	6a 20                	push   $0x20
c0027cbf:	89 fb                	mov    %edi,%ebx
c0027cc1:	e8 af 34 00 00       	call   c002b175 <putchar>
          for (; i < per_line; i++)
c0027cc6:	83 c6 01             	add    $0x1,%esi
c0027cc9:	83 c4 10             	add    $0x10,%esp
c0027ccc:	83 fe 0f             	cmp    $0xf,%esi
c0027ccf:	76 e9                	jbe    c0027cba <hex_dump+0x3b>
          printf ("|");
c0027cd1:	83 ec 0c             	sub    $0xc,%esp
c0027cd4:	6a 7c                	push   $0x7c
c0027cd6:	89 fb                	mov    %edi,%ebx
c0027cd8:	e8 98 34 00 00       	call   c002b175 <putchar>
c0027cdd:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027ce0:	83 ec 0c             	sub    $0xc,%esp
c0027ce3:	6a 0a                	push   $0xa
c0027ce5:	89 fb                	mov    %edi,%ebx
c0027ce7:	e8 89 34 00 00       	call   c002b175 <putchar>

      ofs += n;
c0027cec:	8b 44 24 20          	mov    0x20(%esp),%eax
c0027cf0:	01 44 24 50          	add    %eax,0x50(%esp)
      buf += n;
c0027cf4:	01 44 24 54          	add    %eax,0x54(%esp)
      size -= n;
c0027cf8:	89 e8                	mov    %ebp,%eax
c0027cfa:	2b 44 24 1c          	sub    0x1c(%esp),%eax
  while (size > 0)
c0027cfe:	83 c4 10             	add    $0x10,%esp
c0027d01:	01 44 24 48          	add    %eax,0x48(%esp)
c0027d05:	0f 84 84 01 00 00    	je     c0027e8f <hex_dump+0x210>
      start = ofs % per_line;
c0027d0b:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c0027d0f:	83 e5 0f             	and    $0xf,%ebp
      if (end - start > size)
c0027d12:	ba 10 00 00 00       	mov    $0x10,%edx
c0027d17:	29 ea                	sub    %ebp,%edx
        end = start + size;
c0027d19:	89 e8                	mov    %ebp,%eax
c0027d1b:	03 44 24 48          	add    0x48(%esp),%eax
c0027d1f:	3b 54 24 48          	cmp    0x48(%esp),%edx
c0027d23:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027d28:	0f 46 c1             	cmovbe %ecx,%eax
c0027d2b:	89 44 24 0c          	mov    %eax,0xc(%esp)
      n = end - start;
c0027d2f:	29 e8                	sub    %ebp,%eax
c0027d31:	89 44 24 10          	mov    %eax,0x10(%esp)
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027d35:	83 ec 04             	sub    $0x4,%esp
c0027d38:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027d3c:	83 e0 f0             	and    $0xfffffff0,%eax
c0027d3f:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d44:	52                   	push   %edx
c0027d45:	50                   	push   %eax
c0027d46:	ff 74 24 24          	pushl  0x24(%esp)
c0027d4a:	e8 82 f7 ff ff       	call   c00274d1 <printf>
      for (i = 0; i < start; i++)
c0027d4f:	83 c4 10             	add    $0x10,%esp
c0027d52:	85 ed                	test   %ebp,%ebp
c0027d54:	0f 84 57 ff ff ff    	je     c0027cb1 <hex_dump+0x32>
c0027d5a:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c0027d5f:	8d b7 2c 51 ff ff    	lea    -0xaed4(%edi),%esi
c0027d65:	83 ec 0c             	sub    $0xc,%esp
c0027d68:	56                   	push   %esi
c0027d69:	e8 63 f7 ff ff       	call   c00274d1 <printf>
      for (i = 0; i < start; i++)
c0027d6e:	83 c3 01             	add    $0x1,%ebx
c0027d71:	83 c4 10             	add    $0x10,%esp
c0027d74:	39 dd                	cmp    %ebx,%ebp
c0027d76:	75 ed                	jne    c0027d65 <hex_dump+0xe6>
c0027d78:	89 eb                	mov    %ebp,%ebx
      for (; i < end; i++) 
c0027d7a:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0027d7e:	0f 86 fb 00 00 00    	jbe    c0027e7f <hex_dump+0x200>
        printf ("%02hhx%c",
c0027d84:	be 20 00 00 00       	mov    $0x20,%esi
c0027d89:	83 fb 07             	cmp    $0x7,%ebx
c0027d8c:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027d91:	0f 45 c6             	cmovne %esi,%eax
c0027d94:	83 ec 04             	sub    $0x4,%esp
c0027d97:	50                   	push   %eax
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027d98:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0027d9c:	29 e8                	sub    %ebp,%eax
        printf ("%02hhx%c",
c0027d9e:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
c0027da2:	50                   	push   %eax
c0027da3:	8d 87 30 51 ff ff    	lea    -0xaed0(%edi),%eax
c0027da9:	50                   	push   %eax
c0027daa:	e8 22 f7 ff ff       	call   c00274d1 <printf>
      for (; i < end; i++) 
c0027daf:	83 c3 01             	add    $0x1,%ebx
c0027db2:	83 c4 10             	add    $0x10,%esp
c0027db5:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0027db9:	75 ce                	jne    c0027d89 <hex_dump+0x10a>
      if (ascii) 
c0027dbb:	80 7c 24 17 00       	cmpb   $0x0,0x17(%esp)
c0027dc0:	0f 84 1a ff ff ff    	je     c0027ce0 <hex_dump+0x61>
          for (; i < per_line; i++)
c0027dc6:	83 fb 0f             	cmp    $0xf,%ebx
c0027dc9:	77 1a                	ja     c0027de5 <hex_dump+0x166>
            printf ("   ");
c0027dcb:	8d b7 2c 51 ff ff    	lea    -0xaed4(%edi),%esi
c0027dd1:	83 ec 0c             	sub    $0xc,%esp
c0027dd4:	56                   	push   %esi
c0027dd5:	e8 f7 f6 ff ff       	call   c00274d1 <printf>
          for (; i < per_line; i++)
c0027dda:	83 c3 01             	add    $0x1,%ebx
c0027ddd:	83 c4 10             	add    $0x10,%esp
c0027de0:	83 fb 10             	cmp    $0x10,%ebx
c0027de3:	75 ec                	jne    c0027dd1 <hex_dump+0x152>
          printf ("|");
c0027de5:	83 ec 0c             	sub    $0xc,%esp
c0027de8:	6a 7c                	push   $0x7c
c0027dea:	89 fb                	mov    %edi,%ebx
c0027dec:	e8 84 33 00 00       	call   c002b175 <putchar>
          for (i = 0; i < start; i++)
c0027df1:	83 c4 10             	add    $0x10,%esp
c0027df4:	85 ed                	test   %ebp,%ebp
c0027df6:	74 75                	je     c0027e6d <hex_dump+0x1ee>
c0027df8:	be 00 00 00 00       	mov    $0x0,%esi
            printf (" ");
c0027dfd:	83 ec 0c             	sub    $0xc,%esp
c0027e00:	6a 20                	push   $0x20
c0027e02:	89 fb                	mov    %edi,%ebx
c0027e04:	e8 6c 33 00 00       	call   c002b175 <putchar>
          for (i = 0; i < start; i++)
c0027e09:	83 c6 01             	add    $0x1,%esi
c0027e0c:	83 c4 10             	add    $0x10,%esp
c0027e0f:	39 f5                	cmp    %esi,%ebp
c0027e11:	75 ea                	jne    c0027dfd <hex_dump+0x17e>
          for (; i < end; i++)
c0027e13:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c0027e17:	0f 86 9b fe ff ff    	jbe    c0027cb8 <hex_dump+0x39>
          for (i = 0; i < start; i++)
c0027e1d:	89 ee                	mov    %ebp,%esi
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027e1f:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027e23:	29 e8                	sub    %ebp,%eax
c0027e25:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c0027e29:	89 c5                	mov    %eax,%ebp
c0027e2b:	0f b6 44 35 00       	movzbl 0x0(%ebp,%esi,1),%eax
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027e30:	0f b6 d0             	movzbl %al,%edx
c0027e33:	83 ea 20             	sub    $0x20,%edx
c0027e36:	83 fa 5f             	cmp    $0x5f,%edx
c0027e39:	b9 2e 00 00 00       	mov    $0x2e,%ecx
c0027e3e:	0f 43 c1             	cmovae %ecx,%eax
            printf ("%c",
c0027e41:	83 ec 0c             	sub    $0xc,%esp
c0027e44:	0f b6 c0             	movzbl %al,%eax
c0027e47:	50                   	push   %eax
c0027e48:	89 fb                	mov    %edi,%ebx
c0027e4a:	e8 26 33 00 00       	call   c002b175 <putchar>
          for (; i < end; i++)
c0027e4f:	83 c6 01             	add    $0x1,%esi
c0027e52:	83 c4 10             	add    $0x10,%esp
c0027e55:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c0027e59:	77 d0                	ja     c0027e2b <hex_dump+0x1ac>
c0027e5b:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
          for (; i < per_line; i++)
c0027e5f:	83 fe 0f             	cmp    $0xf,%esi
c0027e62:	0f 86 52 fe ff ff    	jbe    c0027cba <hex_dump+0x3b>
c0027e68:	e9 64 fe ff ff       	jmp    c0027cd1 <hex_dump+0x52>
          for (i = 0; i < start; i++)
c0027e6d:	89 ee                	mov    %ebp,%esi
          for (; i < end; i++)
c0027e6f:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0027e74:	75 a9                	jne    c0027e1f <hex_dump+0x1a0>
          for (i = 0; i < start; i++)
c0027e76:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027e7a:	e9 3b fe ff ff       	jmp    c0027cba <hex_dump+0x3b>
      if (ascii) 
c0027e7f:	80 7c 24 17 00       	cmpb   $0x0,0x17(%esp)
c0027e84:	0f 84 56 fe ff ff    	je     c0027ce0 <hex_dump+0x61>
c0027e8a:	e9 3c ff ff ff       	jmp    c0027dcb <hex_dump+0x14c>
    }
}
c0027e8f:	83 c4 2c             	add    $0x2c,%esp
c0027e92:	5b                   	pop    %ebx
c0027e93:	5e                   	pop    %esi
c0027e94:	5f                   	pop    %edi
c0027e95:	5d                   	pop    %ebp
c0027e96:	c3                   	ret    

c0027e97 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027e97:	55                   	push   %ebp
c0027e98:	57                   	push   %edi
c0027e99:	56                   	push   %esi
c0027e9a:	53                   	push   %ebx
c0027e9b:	83 ec 1c             	sub    $0x1c,%esp
c0027e9e:	e8 ac 82 00 00       	call   c003014f <__x86.get_pc_thunk.di>
c0027ea3:	81 c7 09 5e 01 00    	add    $0x15e09,%edi
c0027ea9:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0027ead:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027eb1:	8b 54 24 34          	mov    0x34(%esp),%edx
  if (size == 1)
c0027eb5:	89 c1                	mov    %eax,%ecx
c0027eb7:	83 f1 01             	xor    $0x1,%ecx
c0027eba:	89 d3                	mov    %edx,%ebx
c0027ebc:	09 cb                	or     %ecx,%ebx
c0027ebe:	74 6e                	je     c0027f2e <print_human_readable_size+0x97>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027ec0:	b9 ff 03 00 00       	mov    $0x3ff,%ecx
c0027ec5:	39 c1                	cmp    %eax,%ecx
c0027ec7:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027ecc:	19 d1                	sbb    %edx,%ecx
c0027ece:	73 76                	jae    c0027f46 <print_human_readable_size+0xaf>
c0027ed0:	8d 8f e4 ff ff ff    	lea    -0x1c(%edi),%ecx
c0027ed6:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027edb:	83 bf e8 ff ff ff 00 	cmpl   $0x0,-0x18(%edi)
c0027ee2:	74 44                	je     c0027f28 <print_human_readable_size+0x91>
        size /= 1024;
c0027ee4:	89 c6                	mov    %eax,%esi
c0027ee6:	89 d7                	mov    %edx,%edi
c0027ee8:	0f ac d6 0a          	shrd   $0xa,%edx,%esi
c0027eec:	c1 ef 0a             	shr    $0xa,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027eef:	83 c1 04             	add    $0x4,%ecx
c0027ef2:	bd ff ff 0f 00       	mov    $0xfffff,%ebp
c0027ef7:	39 c5                	cmp    %eax,%ebp
c0027ef9:	89 dd                	mov    %ebx,%ebp
c0027efb:	19 d5                	sbb    %edx,%ebp
c0027efd:	73 0a                	jae    c0027f09 <print_human_readable_size+0x72>
        size /= 1024;
c0027eff:	89 f0                	mov    %esi,%eax
c0027f01:	89 fa                	mov    %edi,%edx
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027f03:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
c0027f07:	75 db                	jne    c0027ee4 <print_human_readable_size+0x4d>
      printf ("%"PRIu64" %s", size, *fp);
c0027f09:	ff 31                	pushl  (%ecx)
c0027f0b:	57                   	push   %edi
c0027f0c:	56                   	push   %esi
c0027f0d:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027f11:	8d 80 40 51 ff ff    	lea    -0xaec0(%eax),%eax
c0027f17:	50                   	push   %eax
c0027f18:	e8 b4 f5 ff ff       	call   c00274d1 <printf>
c0027f1d:	83 c4 10             	add    $0x10,%esp
    }
}
c0027f20:	83 c4 1c             	add    $0x1c,%esp
c0027f23:	5b                   	pop    %ebx
c0027f24:	5e                   	pop    %esi
c0027f25:	5f                   	pop    %edi
c0027f26:	5d                   	pop    %ebp
c0027f27:	c3                   	ret    
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027f28:	89 c6                	mov    %eax,%esi
c0027f2a:	89 d7                	mov    %edx,%edi
c0027f2c:	eb db                	jmp    c0027f09 <print_human_readable_size+0x72>
    printf ("1 byte");
c0027f2e:	83 ec 0c             	sub    $0xc,%esp
c0027f31:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027f35:	8d 80 39 51 ff ff    	lea    -0xaec7(%eax),%eax
c0027f3b:	50                   	push   %eax
c0027f3c:	e8 90 f5 ff ff       	call   c00274d1 <printf>
c0027f41:	83 c4 10             	add    $0x10,%esp
c0027f44:	eb da                	jmp    c0027f20 <print_human_readable_size+0x89>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027f46:	89 c6                	mov    %eax,%esi
c0027f48:	89 d7                	mov    %edx,%edi
c0027f4a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027f4e:	8d 88 e4 ff ff ff    	lea    -0x1c(%eax),%ecx
c0027f54:	eb b3                	jmp    c0027f09 <print_human_readable_size+0x72>

c0027f56 <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0027f56:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c0027f59:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027f5d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027f61:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027f65:	ff 10                	call   *(%eax)
}
c0027f67:	83 c4 1c             	add    $0x1c,%esp
c0027f6a:	c3                   	ret    

c0027f6b <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0027f6b:	55                   	push   %ebp
c0027f6c:	57                   	push   %edi
c0027f6d:	56                   	push   %esi
c0027f6e:	53                   	push   %ebx
c0027f6f:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c0027f73:	8d 72 ff             	lea    -0x1(%edx),%esi
c0027f76:	0f af f7             	imul   %edi,%esi
  unsigned char *b = array + (b_idx - 1) * size;
c0027f79:	83 e9 01             	sub    $0x1,%ecx
c0027f7c:	0f af cf             	imul   %edi,%ecx
  size_t i;

  for (i = 0; i < size; i++)
c0027f7f:	85 ff                	test   %edi,%edi
c0027f81:	74 21                	je     c0027fa4 <do_swap+0x39>
c0027f83:	8d 14 30             	lea    (%eax,%esi,1),%edx
c0027f86:	01 f8                	add    %edi,%eax
c0027f88:	8d 3c 30             	lea    (%eax,%esi,1),%edi
    {
      unsigned char t = a[i];
c0027f8b:	0f b6 2a             	movzbl (%edx),%ebp
      a[i] = b[i];
c0027f8e:	89 d0                	mov    %edx,%eax
c0027f90:	29 f0                	sub    %esi,%eax
c0027f92:	0f b6 1c 08          	movzbl (%eax,%ecx,1),%ebx
c0027f96:	88 1a                	mov    %bl,(%edx)
      b[i] = t;
c0027f98:	89 eb                	mov    %ebp,%ebx
c0027f9a:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
c0027f9d:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < size; i++)
c0027fa0:	39 fa                	cmp    %edi,%edx
c0027fa2:	75 e7                	jne    c0027f8b <do_swap+0x20>
    }
}
c0027fa4:	5b                   	pop    %ebx
c0027fa5:	5e                   	pop    %esi
c0027fa6:	5f                   	pop    %edi
c0027fa7:	5d                   	pop    %ebp
c0027fa8:	c3                   	ret    

c0027fa9 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0027fa9:	55                   	push   %ebp
c0027faa:	57                   	push   %edi
c0027fab:	56                   	push   %esi
c0027fac:	53                   	push   %ebx
c0027fad:	83 ec 1c             	sub    $0x1c,%esp
c0027fb0:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027fb4:	89 d7                	mov    %edx,%edi
c0027fb6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027fba:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0027fbe:	eb 4a                	jmp    c002800a <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027fc0:	83 ec 04             	sub    $0x4,%esp
c0027fc3:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027fc7:	8d 47 ff             	lea    -0x1(%edi),%eax
c0027fca:	0f af c5             	imul   %ebp,%eax
c0027fcd:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027fd1:	01 d0                	add    %edx,%eax
c0027fd3:	50                   	push   %eax
c0027fd4:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027fd7:	0f af c5             	imul   %ebp,%eax
c0027fda:	01 d0                	add    %edx,%eax
c0027fdc:	50                   	push   %eax
c0027fdd:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027fe1:	83 c4 10             	add    $0x10,%esp
c0027fe4:	85 c0                	test   %eax,%eax
c0027fe6:	7e 2e                	jle    c0028016 <heapify+0x6d>
        max = left;
      if (right <= cnt
c0027fe8:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027fec:	76 5b                	jbe    c0028049 <heapify+0xa0>
        max = left;
c0027fee:	89 de                	mov    %ebx,%esi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0027ff0:	39 f7                	cmp    %esi,%edi
c0027ff2:	74 4d                	je     c0028041 <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0027ff4:	83 ec 0c             	sub    $0xc,%esp
c0027ff7:	55                   	push   %ebp
c0027ff8:	89 f1                	mov    %esi,%ecx
c0027ffa:	89 fa                	mov    %edi,%edx
c0027ffc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0028000:	e8 66 ff ff ff       	call   c0027f6b <do_swap>
      i = max;
c0028005:	89 f7                	mov    %esi,%edi
    {
c0028007:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c002800a:	8d 1c 3f             	lea    (%edi,%edi,1),%ebx
      size_t right = 2 * i + 1;
c002800d:	8d 73 01             	lea    0x1(%ebx),%esi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0028010:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0028014:	76 aa                	jbe    c0027fc0 <heapify+0x17>
      if (right <= cnt
c0028016:	3b 74 24 08          	cmp    0x8(%esp),%esi
c002801a:	77 25                	ja     c0028041 <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c002801c:	83 ec 04             	sub    $0x4,%esp
c002801f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028023:	8d 47 ff             	lea    -0x1(%edi),%eax
c0028026:	0f af c5             	imul   %ebp,%eax
c0028029:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002802d:	01 c8                	add    %ecx,%eax
c002802f:	50                   	push   %eax
c0028030:	0f af dd             	imul   %ebp,%ebx
c0028033:	01 cb                	add    %ecx,%ebx
c0028035:	53                   	push   %ebx
c0028036:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c002803a:	83 c4 10             	add    $0x10,%esp
c002803d:	85 c0                	test   %eax,%eax
c002803f:	7f af                	jg     c0027ff0 <heapify+0x47>
    }
}
c0028041:	83 c4 1c             	add    $0x1c,%esp
c0028044:	5b                   	pop    %ebx
c0028045:	5e                   	pop    %esi
c0028046:	5f                   	pop    %edi
c0028047:	5d                   	pop    %ebp
c0028048:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028049:	83 ec 04             	sub    $0x4,%esp
c002804c:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028050:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0028053:	0f af c5             	imul   %ebp,%eax
c0028056:	8b 54 24 14          	mov    0x14(%esp),%edx
c002805a:	01 d0                	add    %edx,%eax
c002805c:	50                   	push   %eax
c002805d:	89 d8                	mov    %ebx,%eax
c002805f:	0f af c5             	imul   %ebp,%eax
c0028062:	01 d0                	add    %edx,%eax
c0028064:	50                   	push   %eax
c0028065:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028069:	83 c4 10             	add    $0x10,%esp
c002806c:	85 c0                	test   %eax,%eax
        max = left;
c002806e:	0f 4e f3             	cmovle %ebx,%esi
c0028071:	e9 7a ff ff ff       	jmp    c0027ff0 <heapify+0x47>

c0028076 <atoi>:
{
c0028076:	56                   	push   %esi
c0028077:	53                   	push   %ebx
c0028078:	83 ec 04             	sub    $0x4,%esp
c002807b:	e8 c3 80 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0028080:	81 c3 2c 5c 01 00    	add    $0x15c2c,%ebx
c0028086:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c002808a:	85 d2                	test   %edx,%edx
c002808c:	75 29                	jne    c00280b7 <atoi+0x41>
c002808e:	83 ec 0c             	sub    $0xc,%esp
c0028091:	8d 83 df 51 ff ff    	lea    -0xae21(%ebx),%eax
c0028097:	50                   	push   %eax
c0028098:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002809e:	50                   	push   %eax
c002809f:	8d 83 4c 31 ff ff    	lea    -0xceb4(%ebx),%eax
c00280a5:	50                   	push   %eax
c00280a6:	6a 0f                	push   $0xf
c00280a8:	8d 83 90 51 ff ff    	lea    -0xae70(%ebx),%eax
c00280ae:	50                   	push   %eax
c00280af:	e8 79 10 00 00       	call   c002912d <debug_panic>
    s++;
c00280b4:	83 c2 01             	add    $0x1,%edx
  while (isspace ((unsigned char) *s))
c00280b7:	0f b6 02             	movzbl (%edx),%eax
          || c == '\r' || c == '\t' || c == '\v');
c00280ba:	3c 20                	cmp    $0x20,%al
c00280bc:	74 f6                	je     c00280b4 <atoi+0x3e>
c00280be:	8d 48 f7             	lea    -0x9(%eax),%ecx
c00280c1:	80 f9 04             	cmp    $0x4,%cl
c00280c4:	76 ee                	jbe    c00280b4 <atoi+0x3e>
  if (*s == '+')
c00280c6:	3c 2b                	cmp    $0x2b,%al
c00280c8:	74 40                	je     c002810a <atoi+0x94>
  negative = false;
c00280ca:	bb 00 00 00 00       	mov    $0x0,%ebx
  else if (*s == '-')
c00280cf:	3c 2d                	cmp    $0x2d,%al
c00280d1:	74 41                	je     c0028114 <atoi+0x9e>
  for (value = 0; isdigit (*s); s++)
c00280d3:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00280d6:	8d 41 d0             	lea    -0x30(%ecx),%eax
c00280d9:	83 f8 09             	cmp    $0x9,%eax
c00280dc:	77 40                	ja     c002811e <atoi+0xa8>
c00280de:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c00280e3:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00280e6:	01 c0                	add    %eax,%eax
c00280e8:	83 e9 30             	sub    $0x30,%ecx
c00280eb:	29 c8                	sub    %ecx,%eax
  for (value = 0; isdigit (*s); s++)
c00280ed:	83 c2 01             	add    $0x1,%edx
c00280f0:	0f be 0a             	movsbl (%edx),%ecx
c00280f3:	8d 71 d0             	lea    -0x30(%ecx),%esi
c00280f6:	83 fe 09             	cmp    $0x9,%esi
c00280f9:	76 e8                	jbe    c00280e3 <atoi+0x6d>
    value = -value;
c00280fb:	89 c2                	mov    %eax,%edx
c00280fd:	f7 da                	neg    %edx
c00280ff:	84 db                	test   %bl,%bl
c0028101:	0f 44 c2             	cmove  %edx,%eax
}
c0028104:	83 c4 04             	add    $0x4,%esp
c0028107:	5b                   	pop    %ebx
c0028108:	5e                   	pop    %esi
c0028109:	c3                   	ret    
    s++;
c002810a:	83 c2 01             	add    $0x1,%edx
  negative = false;
c002810d:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028112:	eb bf                	jmp    c00280d3 <atoi+0x5d>
      s++;
c0028114:	83 c2 01             	add    $0x1,%edx
      negative = true;
c0028117:	bb 01 00 00 00       	mov    $0x1,%ebx
c002811c:	eb b5                	jmp    c00280d3 <atoi+0x5d>
  for (value = 0; isdigit (*s); s++)
c002811e:	b8 00 00 00 00       	mov    $0x0,%eax
c0028123:	eb d6                	jmp    c00280fb <atoi+0x85>

c0028125 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0028125:	55                   	push   %ebp
c0028126:	57                   	push   %edi
c0028127:	56                   	push   %esi
c0028128:	53                   	push   %ebx
c0028129:	83 ec 0c             	sub    $0xc,%esp
c002812c:	e8 12 80 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0028131:	81 c3 7b 5b 01 00    	add    $0x15b7b,%ebx
c0028137:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002813b:	8b 74 24 24          	mov    0x24(%esp),%esi
c002813f:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0028143:	85 ff                	test   %edi,%edi
c0028145:	75 08                	jne    c002814f <sort+0x2a>
c0028147:	85 f6                	test   %esi,%esi
c0028149:	0f 85 89 00 00 00    	jne    c00281d8 <sort+0xb3>
  ASSERT (compare != NULL);
c002814f:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0028154:	0f 84 a7 00 00 00    	je     c0028201 <sort+0xdc>
  ASSERT (size > 0);
c002815a:	85 ed                	test   %ebp,%ebp
c002815c:	0f 84 c8 00 00 00    	je     c002822a <sort+0x105>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0028162:	89 f3                	mov    %esi,%ebx
c0028164:	d1 eb                	shr    %ebx
c0028166:	83 fe 01             	cmp    $0x1,%esi
c0028169:	76 65                	jbe    c00281d0 <sort+0xab>
c002816b:	89 74 24 24          	mov    %esi,0x24(%esp)
c002816f:	89 fe                	mov    %edi,%esi
c0028171:	8b 7c 24 24          	mov    0x24(%esp),%edi
    heapify (array, i, cnt, size, compare, aux);
c0028175:	83 ec 04             	sub    $0x4,%esp
c0028178:	ff 74 24 34          	pushl  0x34(%esp)
c002817c:	ff 74 24 34          	pushl  0x34(%esp)
c0028180:	55                   	push   %ebp
c0028181:	89 f9                	mov    %edi,%ecx
c0028183:	89 da                	mov    %ebx,%edx
c0028185:	89 f0                	mov    %esi,%eax
c0028187:	e8 1d fe ff ff       	call   c0027fa9 <heapify>
  for (i = cnt / 2; i > 0; i--)
c002818c:	83 c4 10             	add    $0x10,%esp
c002818f:	83 eb 01             	sub    $0x1,%ebx
c0028192:	75 e1                	jne    c0028175 <sort+0x50>
c0028194:	89 f3                	mov    %esi,%ebx
c0028196:	89 fe                	mov    %edi,%esi
c0028198:	8b 7c 24 30          	mov    0x30(%esp),%edi

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
    {
      do_swap (array, 1, i, size);
c002819c:	83 ec 0c             	sub    $0xc,%esp
c002819f:	55                   	push   %ebp
c00281a0:	89 f1                	mov    %esi,%ecx
c00281a2:	ba 01 00 00 00       	mov    $0x1,%edx
c00281a7:	89 d8                	mov    %ebx,%eax
c00281a9:	e8 bd fd ff ff       	call   c0027f6b <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c00281ae:	83 ee 01             	sub    $0x1,%esi
c00281b1:	83 c4 0c             	add    $0xc,%esp
c00281b4:	57                   	push   %edi
c00281b5:	ff 74 24 34          	pushl  0x34(%esp)
c00281b9:	55                   	push   %ebp
c00281ba:	89 f1                	mov    %esi,%ecx
c00281bc:	ba 01 00 00 00       	mov    $0x1,%edx
c00281c1:	89 d8                	mov    %ebx,%eax
c00281c3:	e8 e1 fd ff ff       	call   c0027fa9 <heapify>
  for (i = cnt; i > 1; i--) 
c00281c8:	83 c4 10             	add    $0x10,%esp
c00281cb:	83 fe 01             	cmp    $0x1,%esi
c00281ce:	75 cc                	jne    c002819c <sort+0x77>
    }
}
c00281d0:	83 c4 0c             	add    $0xc,%esp
c00281d3:	5b                   	pop    %ebx
c00281d4:	5e                   	pop    %esi
c00281d5:	5f                   	pop    %edi
c00281d6:	5d                   	pop    %ebp
c00281d7:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c00281d8:	83 ec 0c             	sub    $0xc,%esp
c00281db:	8d 83 a3 51 ff ff    	lea    -0xae5d(%ebx),%eax
c00281e1:	50                   	push   %eax
c00281e2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00281e8:	50                   	push   %eax
c00281e9:	8d 83 44 31 ff ff    	lea    -0xcebc(%ebx),%eax
c00281ef:	50                   	push   %eax
c00281f0:	68 8a 00 00 00       	push   $0x8a
c00281f5:	8d 83 90 51 ff ff    	lea    -0xae70(%ebx),%eax
c00281fb:	50                   	push   %eax
c00281fc:	e8 2c 0f 00 00       	call   c002912d <debug_panic>
  ASSERT (compare != NULL);
c0028201:	83 ec 0c             	sub    $0xc,%esp
c0028204:	8d 83 bd 51 ff ff    	lea    -0xae43(%ebx),%eax
c002820a:	50                   	push   %eax
c002820b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0028211:	50                   	push   %eax
c0028212:	8d 83 44 31 ff ff    	lea    -0xcebc(%ebx),%eax
c0028218:	50                   	push   %eax
c0028219:	68 8b 00 00 00       	push   $0x8b
c002821e:	8d 83 90 51 ff ff    	lea    -0xae70(%ebx),%eax
c0028224:	50                   	push   %eax
c0028225:	e8 03 0f 00 00       	call   c002912d <debug_panic>
  ASSERT (size > 0);
c002822a:	83 ec 0c             	sub    $0xc,%esp
c002822d:	8d 83 cd 51 ff ff    	lea    -0xae33(%ebx),%eax
c0028233:	50                   	push   %eax
c0028234:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002823a:	50                   	push   %eax
c002823b:	8d 83 44 31 ff ff    	lea    -0xcebc(%ebx),%eax
c0028241:	50                   	push   %eax
c0028242:	68 8c 00 00 00       	push   $0x8c
c0028247:	8d 83 90 51 ff ff    	lea    -0xae70(%ebx),%eax
c002824d:	50                   	push   %eax
c002824e:	e8 da 0e 00 00       	call   c002912d <debug_panic>

c0028253 <qsort>:
{
c0028253:	83 ec 18             	sub    $0x18,%esp
c0028256:	e8 ec 7e 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c002825b:	05 51 5a 01 00       	add    $0x15a51,%eax
  sort (array, cnt, size, compare_thunk, &compare);
c0028260:	8d 54 24 28          	lea    0x28(%esp),%edx
c0028264:	52                   	push   %edx
c0028265:	8d 80 aa a2 fe ff    	lea    -0x15d56(%eax),%eax
c002826b:	50                   	push   %eax
c002826c:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028270:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028274:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028278:	e8 a8 fe ff ff       	call   c0028125 <sort>
}
c002827d:	83 c4 2c             	add    $0x2c,%esp
c0028280:	c3                   	ret    

c0028281 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c0028281:	55                   	push   %ebp
c0028282:	57                   	push   %edi
c0028283:	56                   	push   %esi
c0028284:	53                   	push   %ebx
c0028285:	83 ec 0c             	sub    $0xc,%esp
c0028288:	8b 74 24 24          	mov    0x24(%esp),%esi
c002828c:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c0028290:	89 fd                	mov    %edi,%ebp
c0028292:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c0028297:	01 f5                	add    %esi,%ebp

  while (first < last) 
c0028299:	39 ee                	cmp    %ebp,%esi
c002829b:	72 0d                	jb     c00282aa <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c002829d:	bb 00 00 00 00       	mov    $0x0,%ebx
c00282a2:	eb 3c                	jmp    c00282e0 <binary_search+0x5f>
      const unsigned char *middle = first + (range / 2) * size;
c00282a4:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c00282a6:	39 ee                	cmp    %ebp,%esi
c00282a8:	73 31                	jae    c00282db <binary_search+0x5a>
      size_t range = (last - first) / size;
c00282aa:	89 e8                	mov    %ebp,%eax
c00282ac:	29 f0                	sub    %esi,%eax
c00282ae:	ba 00 00 00 00       	mov    $0x0,%edx
c00282b3:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c00282b5:	d1 e8                	shr    %eax
c00282b7:	0f af c7             	imul   %edi,%eax
c00282ba:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c00282bd:	83 ec 04             	sub    $0x4,%esp
c00282c0:	ff 74 24 38          	pushl  0x38(%esp)
c00282c4:	53                   	push   %ebx
c00282c5:	ff 74 24 2c          	pushl  0x2c(%esp)
c00282c9:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c00282cd:	83 c4 10             	add    $0x10,%esp
c00282d0:	85 c0                	test   %eax,%eax
c00282d2:	78 d0                	js     c00282a4 <binary_search+0x23>
      else if (cmp > 0) 
c00282d4:	7e 0a                	jle    c00282e0 <binary_search+0x5f>
        first = middle + size;
c00282d6:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c00282d9:	eb cb                	jmp    c00282a6 <binary_search+0x25>
  return NULL;
c00282db:	bb 00 00 00 00       	mov    $0x0,%ebx
}
c00282e0:	89 d8                	mov    %ebx,%eax
c00282e2:	83 c4 0c             	add    $0xc,%esp
c00282e5:	5b                   	pop    %ebx
c00282e6:	5e                   	pop    %esi
c00282e7:	5f                   	pop    %edi
c00282e8:	5d                   	pop    %ebp
c00282e9:	c3                   	ret    

c00282ea <bsearch>:
{
c00282ea:	83 ec 14             	sub    $0x14,%esp
c00282ed:	e8 55 7e 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c00282f2:	05 ba 59 01 00       	add    $0x159ba,%eax
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00282f7:	8d 54 24 28          	lea    0x28(%esp),%edx
c00282fb:	52                   	push   %edx
c00282fc:	8d 80 aa a2 fe ff    	lea    -0x15d56(%eax),%eax
c0028302:	50                   	push   %eax
c0028303:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028307:	ff 74 24 2c          	pushl  0x2c(%esp)
c002830b:	ff 74 24 2c          	pushl  0x2c(%esp)
c002830f:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028313:	e8 69 ff ff ff       	call   c0028281 <binary_search>
}
c0028318:	83 c4 2c             	add    $0x2c,%esp
c002831b:	c3                   	ret    

c002831c <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c002831c:	56                   	push   %esi
c002831d:	53                   	push   %ebx
c002831e:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0028322:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0028326:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c002832a:	85 db                	test   %ebx,%ebx
c002832c:	74 15                	je     c0028343 <memcpy+0x27>
c002832e:	01 f3                	add    %esi,%ebx
  unsigned char *dst = dst_;
c0028330:	89 f2                	mov    %esi,%edx
    *dst++ = *src++;
c0028332:	83 c1 01             	add    $0x1,%ecx
c0028335:	83 c2 01             	add    $0x1,%edx
c0028338:	0f b6 41 ff          	movzbl -0x1(%ecx),%eax
c002833c:	88 42 ff             	mov    %al,-0x1(%edx)
  while (size-- > 0)
c002833f:	39 d3                	cmp    %edx,%ebx
c0028341:	75 ef                	jne    c0028332 <memcpy+0x16>

  return dst_;
}
c0028343:	89 f0                	mov    %esi,%eax
c0028345:	5b                   	pop    %ebx
c0028346:	5e                   	pop    %esi
c0028347:	c3                   	ret    

c0028348 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0028348:	56                   	push   %esi
c0028349:	53                   	push   %ebx
c002834a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002834e:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0028352:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c0028356:	39 c8                	cmp    %ecx,%eax
c0028358:	73 1d                	jae    c0028377 <memmove+0x2f>
    {
      while (size-- > 0)
c002835a:	85 db                	test   %ebx,%ebx
c002835c:	74 16                	je     c0028374 <memmove+0x2c>
c002835e:	8d 14 18             	lea    (%eax,%ebx,1),%edx
        *dst++ = *src++;
c0028361:	83 c1 01             	add    $0x1,%ecx
c0028364:	83 c0 01             	add    $0x1,%eax
c0028367:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
c002836b:	88 58 ff             	mov    %bl,-0x1(%eax)
      while (size-- > 0)
c002836e:	39 d0                	cmp    %edx,%eax
c0028370:	75 ef                	jne    c0028361 <memmove+0x19>
        *dst++ = *src++;
c0028372:	89 d0                	mov    %edx,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c0028374:	5b                   	pop    %ebx
c0028375:	5e                   	pop    %esi
c0028376:	c3                   	ret    
      dst += size;
c0028377:	8d 34 18             	lea    (%eax,%ebx,1),%esi
      while (size-- > 0)
c002837a:	8d 53 ff             	lea    -0x1(%ebx),%edx
c002837d:	85 db                	test   %ebx,%ebx
c002837f:	74 11                	je     c0028392 <memmove+0x4a>
        *--dst = *--src;
c0028381:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c0028385:	88 1c 10             	mov    %bl,(%eax,%edx,1)
      while (size-- > 0)
c0028388:	83 ea 01             	sub    $0x1,%edx
c002838b:	83 fa ff             	cmp    $0xffffffff,%edx
c002838e:	75 f1                	jne    c0028381 <memmove+0x39>
c0028390:	eb e2                	jmp    c0028374 <memmove+0x2c>
      dst += size;
c0028392:	89 f0                	mov    %esi,%eax
c0028394:	eb de                	jmp    c0028374 <memmove+0x2c>

c0028396 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028396:	56                   	push   %esi
c0028397:	53                   	push   %ebx
c0028398:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002839c:	8b 54 24 10          	mov    0x10(%esp),%edx
c00283a0:	8b 74 24 14          	mov    0x14(%esp),%esi
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c00283a4:	85 f6                	test   %esi,%esi
c00283a6:	74 34                	je     c00283dc <memcmp+0x46>
    if (*a != *b)
c00283a8:	0f b6 08             	movzbl (%eax),%ecx
c00283ab:	0f b6 1a             	movzbl (%edx),%ebx
c00283ae:	01 c6                	add    %eax,%esi
c00283b0:	38 d9                	cmp    %bl,%cl
c00283b2:	75 14                	jne    c00283c8 <memcmp+0x32>
  for (; size-- > 0; a++, b++)
c00283b4:	83 c0 01             	add    $0x1,%eax
c00283b7:	83 c2 01             	add    $0x1,%edx
c00283ba:	39 c6                	cmp    %eax,%esi
c00283bc:	74 17                	je     c00283d5 <memcmp+0x3f>
    if (*a != *b)
c00283be:	0f b6 08             	movzbl (%eax),%ecx
c00283c1:	0f b6 1a             	movzbl (%edx),%ebx
c00283c4:	38 d9                	cmp    %bl,%cl
c00283c6:	74 ec                	je     c00283b4 <memcmp+0x1e>
      return *a > *b ? +1 : -1;
c00283c8:	38 cb                	cmp    %cl,%bl
c00283ca:	19 c0                	sbb    %eax,%eax
c00283cc:	83 e0 02             	and    $0x2,%eax
c00283cf:	83 e8 01             	sub    $0x1,%eax
  return 0;
}
c00283d2:	5b                   	pop    %ebx
c00283d3:	5e                   	pop    %esi
c00283d4:	c3                   	ret    
  return 0;
c00283d5:	b8 00 00 00 00       	mov    $0x0,%eax
c00283da:	eb f6                	jmp    c00283d2 <memcmp+0x3c>
c00283dc:	b8 00 00 00 00       	mov    $0x0,%eax
c00283e1:	eb ef                	jmp    c00283d2 <memcmp+0x3c>

c00283e3 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c00283e3:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00283e7:	8b 44 24 08          	mov    0x8(%esp),%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c00283eb:	0f b6 11             	movzbl (%ecx),%edx
c00283ee:	84 d2                	test   %dl,%dl
c00283f0:	74 15                	je     c0028407 <strcmp+0x24>
c00283f2:	3a 10                	cmp    (%eax),%dl
c00283f4:	75 11                	jne    c0028407 <strcmp+0x24>
    {
      a++;
c00283f6:	83 c1 01             	add    $0x1,%ecx
      b++;
c00283f9:	83 c0 01             	add    $0x1,%eax
  while (*a != '\0' && *a == *b) 
c00283fc:	0f b6 11             	movzbl (%ecx),%edx
c00283ff:	84 d2                	test   %dl,%dl
c0028401:	74 04                	je     c0028407 <strcmp+0x24>
c0028403:	3a 10                	cmp    (%eax),%dl
c0028405:	74 ef                	je     c00283f6 <strcmp+0x13>
    }

  return *a < *b ? -1 : *a > *b;
c0028407:	0f b6 08             	movzbl (%eax),%ecx
c002840a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002840f:	38 d1                	cmp    %dl,%cl
c0028411:	77 06                	ja     c0028419 <strcmp+0x36>
c0028413:	0f 92 c0             	setb   %al
c0028416:	0f b6 c0             	movzbl %al,%eax
}
c0028419:	c3                   	ret    

c002841a <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c002841a:	53                   	push   %ebx
c002841b:	8b 44 24 08          	mov    0x8(%esp),%eax
c002841f:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028423:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0028427:	85 d2                	test   %edx,%edx
c0028429:	74 1c                	je     c0028447 <memchr+0x2d>
c002842b:	89 d9                	mov    %ebx,%ecx
    if (*block == ch)
c002842d:	3a 18                	cmp    (%eax),%bl
c002842f:	74 14                	je     c0028445 <memchr+0x2b>
c0028431:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c0028433:	83 c0 01             	add    $0x1,%eax
c0028436:	39 c2                	cmp    %eax,%edx
c0028438:	74 06                	je     c0028440 <memchr+0x26>
    if (*block == ch)
c002843a:	38 08                	cmp    %cl,(%eax)
c002843c:	75 f5                	jne    c0028433 <memchr+0x19>
c002843e:	eb 05                	jmp    c0028445 <memchr+0x2b>
      return (void *) block;

  return NULL;
c0028440:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028445:	5b                   	pop    %ebx
c0028446:	c3                   	ret    
  return NULL;
c0028447:	b8 00 00 00 00       	mov    $0x0,%eax
c002844c:	eb f7                	jmp    c0028445 <memchr+0x2b>

c002844e <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c002844e:	53                   	push   %ebx
c002844f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028453:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c0028457:	0f b6 18             	movzbl (%eax),%ebx
c002845a:	38 da                	cmp    %bl,%dl
c002845c:	74 19                	je     c0028477 <strchr+0x29>
c002845e:	89 d1                	mov    %edx,%ecx
      return (char *) string;
    else if (*string == '\0')
c0028460:	84 db                	test   %bl,%bl
c0028462:	74 15                	je     c0028479 <strchr+0x2b>
      return NULL;
    else
      string++;
c0028464:	83 c0 01             	add    $0x1,%eax
    if (*string == c)
c0028467:	0f b6 10             	movzbl (%eax),%edx
c002846a:	38 ca                	cmp    %cl,%dl
c002846c:	74 09                	je     c0028477 <strchr+0x29>
    else if (*string == '\0')
c002846e:	84 d2                	test   %dl,%dl
c0028470:	75 f2                	jne    c0028464 <strchr+0x16>
      return NULL;
c0028472:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028477:	5b                   	pop    %ebx
c0028478:	c3                   	ret    
      return NULL;
c0028479:	b8 00 00 00 00       	mov    $0x0,%eax
c002847e:	eb f7                	jmp    c0028477 <strchr+0x29>

c0028480 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0028480:	57                   	push   %edi
c0028481:	56                   	push   %esi
c0028482:	53                   	push   %ebx
c0028483:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028487:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c002848b:	0f b6 06             	movzbl (%esi),%eax
c002848e:	84 c0                	test   %al,%al
c0028490:	74 27                	je     c00284b9 <strcspn+0x39>
c0028492:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c0028497:	0f be c0             	movsbl %al,%eax
c002849a:	50                   	push   %eax
c002849b:	57                   	push   %edi
c002849c:	e8 ad ff ff ff       	call   c002844e <strchr>
c00284a1:	83 c4 08             	add    $0x8,%esp
c00284a4:	85 c0                	test   %eax,%eax
c00284a6:	75 0b                	jne    c00284b3 <strcspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c00284a8:	83 c3 01             	add    $0x1,%ebx
c00284ab:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c00284af:	84 c0                	test   %al,%al
c00284b1:	75 e4                	jne    c0028497 <strcspn+0x17>
      break;
  return length;
}
c00284b3:	89 d8                	mov    %ebx,%eax
c00284b5:	5b                   	pop    %ebx
c00284b6:	5e                   	pop    %esi
c00284b7:	5f                   	pop    %edi
c00284b8:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c00284b9:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c00284be:	eb f3                	jmp    c00284b3 <strcspn+0x33>

c00284c0 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c00284c0:	56                   	push   %esi
c00284c1:	53                   	push   %ebx
c00284c2:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00284c6:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c00284ca:	0f b6 13             	movzbl (%ebx),%edx
c00284cd:	84 d2                	test   %dl,%dl
c00284cf:	74 1d                	je     c00284ee <strpbrk+0x2e>
    if (strchr (stop, *string) != NULL)
c00284d1:	0f be d2             	movsbl %dl,%edx
c00284d4:	52                   	push   %edx
c00284d5:	56                   	push   %esi
c00284d6:	e8 73 ff ff ff       	call   c002844e <strchr>
c00284db:	83 c4 08             	add    $0x8,%esp
c00284de:	85 c0                	test   %eax,%eax
c00284e0:	75 13                	jne    c00284f5 <strpbrk+0x35>
  for (; *string != '\0'; string++)
c00284e2:	83 c3 01             	add    $0x1,%ebx
c00284e5:	0f b6 13             	movzbl (%ebx),%edx
c00284e8:	84 d2                	test   %dl,%dl
c00284ea:	75 e5                	jne    c00284d1 <strpbrk+0x11>
c00284ec:	eb 09                	jmp    c00284f7 <strpbrk+0x37>
      return (char *) string;
  return NULL;
c00284ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00284f3:	eb 02                	jmp    c00284f7 <strpbrk+0x37>
c00284f5:	89 d8                	mov    %ebx,%eax
}
c00284f7:	5b                   	pop    %ebx
c00284f8:	5e                   	pop    %esi
c00284f9:	c3                   	ret    

c00284fa <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c00284fa:	53                   	push   %ebx
c00284fb:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c00284ff:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0028504:	0f b6 0a             	movzbl (%edx),%ecx
c0028507:	84 c9                	test   %cl,%cl
c0028509:	74 16                	je     c0028521 <strrchr+0x27>
  const char *p = NULL;
c002850b:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
c0028510:	38 cb                	cmp    %cl,%bl
c0028512:	0f 44 c2             	cmove  %edx,%eax
  for (; *string != '\0'; string++)
c0028515:	83 c2 01             	add    $0x1,%edx
c0028518:	0f b6 0a             	movzbl (%edx),%ecx
c002851b:	84 c9                	test   %cl,%cl
c002851d:	75 f1                	jne    c0028510 <strrchr+0x16>
      p = string;
  return (char *) p;
}
c002851f:	5b                   	pop    %ebx
c0028520:	c3                   	ret    
  const char *p = NULL;
c0028521:	b8 00 00 00 00       	mov    $0x0,%eax
  return (char *) p;
c0028526:	eb f7                	jmp    c002851f <strrchr+0x25>

c0028528 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0028528:	57                   	push   %edi
c0028529:	56                   	push   %esi
c002852a:	53                   	push   %ebx
c002852b:	8b 74 24 10          	mov    0x10(%esp),%esi
c002852f:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0028533:	0f b6 06             	movzbl (%esi),%eax
c0028536:	84 c0                	test   %al,%al
c0028538:	74 27                	je     c0028561 <strspn+0x39>
c002853a:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c002853f:	0f be c0             	movsbl %al,%eax
c0028542:	50                   	push   %eax
c0028543:	57                   	push   %edi
c0028544:	e8 05 ff ff ff       	call   c002844e <strchr>
c0028549:	83 c4 08             	add    $0x8,%esp
c002854c:	85 c0                	test   %eax,%eax
c002854e:	74 0b                	je     c002855b <strspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c0028550:	83 c3 01             	add    $0x1,%ebx
c0028553:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0028557:	84 c0                	test   %al,%al
c0028559:	75 e4                	jne    c002853f <strspn+0x17>
      break;
  return length;
}
c002855b:	89 d8                	mov    %ebx,%eax
c002855d:	5b                   	pop    %ebx
c002855e:	5e                   	pop    %esi
c002855f:	5f                   	pop    %edi
c0028560:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0028561:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0028566:	eb f3                	jmp    c002855b <strspn+0x33>

c0028568 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028568:	55                   	push   %ebp
c0028569:	57                   	push   %edi
c002856a:	56                   	push   %esi
c002856b:	53                   	push   %ebx
c002856c:	83 ec 1c             	sub    $0x1c,%esp
c002856f:	e8 cf 7b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0028574:	81 c3 38 57 01 00    	add    $0x15738,%ebx
c002857a:	8b 74 24 30          	mov    0x30(%esp),%esi
c002857e:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c0028582:	85 ff                	test   %edi,%edi
c0028584:	74 33                	je     c00285b9 <strtok_r+0x51>
  ASSERT (save_ptr != NULL);
c0028586:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002858b:	74 55                	je     c00285e2 <strtok_r+0x7a>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c002858d:	85 f6                	test   %esi,%esi
c002858f:	74 7a                	je     c002860b <strtok_r+0xa3>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0028591:	0f b6 1e             	movzbl (%esi),%ebx
c0028594:	83 ec 08             	sub    $0x8,%esp
c0028597:	0f be c3             	movsbl %bl,%eax
c002859a:	50                   	push   %eax
c002859b:	57                   	push   %edi
c002859c:	e8 ad fe ff ff       	call   c002844e <strchr>
c00285a1:	83 c4 10             	add    $0x10,%esp
c00285a4:	85 c0                	test   %eax,%eax
c00285a6:	0f 84 a9 00 00 00    	je     c0028655 <strtok_r+0xed>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c00285ac:	84 db                	test   %bl,%bl
c00285ae:	0f 84 8e 00 00 00    	je     c0028642 <strtok_r+0xda>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c00285b4:	83 c6 01             	add    $0x1,%esi
c00285b7:	eb d8                	jmp    c0028591 <strtok_r+0x29>
  ASSERT (delimiters != NULL);
c00285b9:	83 ec 0c             	sub    $0xc,%esp
c00285bc:	8d 83 d6 51 ff ff    	lea    -0xae2a(%ebx),%eax
c00285c2:	50                   	push   %eax
c00285c3:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00285c9:	50                   	push   %eax
c00285ca:	8d 83 64 31 ff ff    	lea    -0xce9c(%ebx),%eax
c00285d0:	50                   	push   %eax
c00285d1:	68 ef 00 00 00       	push   $0xef
c00285d6:	8d 83 e9 51 ff ff    	lea    -0xae17(%ebx),%eax
c00285dc:	50                   	push   %eax
c00285dd:	e8 4b 0b 00 00       	call   c002912d <debug_panic>
  ASSERT (save_ptr != NULL);
c00285e2:	83 ec 0c             	sub    $0xc,%esp
c00285e5:	8d 83 fc 51 ff ff    	lea    -0xae04(%ebx),%eax
c00285eb:	50                   	push   %eax
c00285ec:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00285f2:	50                   	push   %eax
c00285f3:	8d 83 64 31 ff ff    	lea    -0xce9c(%ebx),%eax
c00285f9:	50                   	push   %eax
c00285fa:	68 f0 00 00 00       	push   $0xf0
c00285ff:	8d 83 e9 51 ff ff    	lea    -0xae17(%ebx),%eax
c0028605:	50                   	push   %eax
c0028606:	e8 22 0b 00 00       	call   c002912d <debug_panic>
    s = *save_ptr;
c002860b:	8b 44 24 38          	mov    0x38(%esp),%eax
c002860f:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c0028611:	85 f6                	test   %esi,%esi
c0028613:	0f 85 78 ff ff ff    	jne    c0028591 <strtok_r+0x29>
c0028619:	83 ec 0c             	sub    $0xc,%esp
c002861c:	8d 83 df 51 ff ff    	lea    -0xae21(%ebx),%eax
c0028622:	50                   	push   %eax
c0028623:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0028629:	50                   	push   %eax
c002862a:	8d 83 64 31 ff ff    	lea    -0xce9c(%ebx),%eax
c0028630:	50                   	push   %eax
c0028631:	68 f6 00 00 00       	push   $0xf6
c0028636:	8d 83 e9 51 ff ff    	lea    -0xae17(%ebx),%eax
c002863c:	50                   	push   %eax
c002863d:	e8 eb 0a 00 00       	call   c002912d <debug_panic>
          *save_ptr = s;
c0028642:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028646:	89 30                	mov    %esi,(%eax)
          return NULL;
c0028648:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c002864d:	83 c4 1c             	add    $0x1c,%esp
c0028650:	5b                   	pop    %ebx
c0028651:	5e                   	pop    %esi
c0028652:	5f                   	pop    %edi
c0028653:	5d                   	pop    %ebp
c0028654:	c3                   	ret    
c0028655:	89 f3                	mov    %esi,%ebx
c0028657:	eb 02                	jmp    c002865b <strtok_r+0xf3>
    s++;
c0028659:	89 eb                	mov    %ebp,%ebx
c002865b:	8d 6b 01             	lea    0x1(%ebx),%ebp
  while (strchr (delimiters, *s) == NULL)
c002865e:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0028662:	88 44 24 0f          	mov    %al,0xf(%esp)
c0028666:	83 ec 08             	sub    $0x8,%esp
c0028669:	0f be c0             	movsbl %al,%eax
c002866c:	50                   	push   %eax
c002866d:	57                   	push   %edi
c002866e:	e8 db fd ff ff       	call   c002844e <strchr>
c0028673:	83 c4 10             	add    $0x10,%esp
c0028676:	85 c0                	test   %eax,%eax
c0028678:	74 df                	je     c0028659 <strtok_r+0xf1>
  if (*s != '\0') 
c002867a:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c002867f:	74 11                	je     c0028692 <strtok_r+0x12a>
      *s = '\0';
c0028681:	c6 45 00 00          	movb   $0x0,0x0(%ebp)
      *save_ptr = s + 1;
c0028685:	83 c3 02             	add    $0x2,%ebx
c0028688:	8b 44 24 38          	mov    0x38(%esp),%eax
c002868c:	89 18                	mov    %ebx,(%eax)
c002868e:	89 f0                	mov    %esi,%eax
c0028690:	eb bb                	jmp    c002864d <strtok_r+0xe5>
    *save_ptr = s;
c0028692:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028696:	89 28                	mov    %ebp,(%eax)
c0028698:	89 f0                	mov    %esi,%eax
c002869a:	eb b1                	jmp    c002864d <strtok_r+0xe5>

c002869c <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c002869c:	53                   	push   %ebx
c002869d:	8b 44 24 08          	mov    0x8(%esp),%eax
c00286a1:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00286a5:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c00286a9:	85 c9                	test   %ecx,%ecx
c00286ab:	74 0e                	je     c00286bb <memset+0x1f>
c00286ad:	01 c1                	add    %eax,%ecx
  unsigned char *dst = dst_;
c00286af:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c00286b1:	83 c2 01             	add    $0x1,%edx
c00286b4:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c00286b7:	39 d1                	cmp    %edx,%ecx
c00286b9:	75 f6                	jne    c00286b1 <memset+0x15>

  return dst_;
}
c00286bb:	5b                   	pop    %ebx
c00286bc:	c3                   	ret    

c00286bd <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c00286bd:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c00286c1:	89 d0                	mov    %edx,%eax
c00286c3:	80 3a 00             	cmpb   $0x0,(%edx)
c00286c6:	75 03                	jne    c00286cb <strlen+0xe>
    continue;
  return p - string;
c00286c8:	29 d0                	sub    %edx,%eax
}
c00286ca:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c00286cb:	83 c0 01             	add    $0x1,%eax
c00286ce:	80 38 00             	cmpb   $0x0,(%eax)
c00286d1:	74 f5                	je     c00286c8 <strlen+0xb>
c00286d3:	eb f6                	jmp    c00286cb <strlen+0xe>

c00286d5 <strstr>:
{
c00286d5:	55                   	push   %ebp
c00286d6:	57                   	push   %edi
c00286d7:	56                   	push   %esi
c00286d8:	53                   	push   %ebx
c00286d9:	83 ec 04             	sub    $0x4,%esp
c00286dc:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c00286e0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c00286e5:	b8 00 00 00 00       	mov    $0x0,%eax
c00286ea:	89 d9                	mov    %ebx,%ecx
c00286ec:	8b 7c 24 18          	mov    0x18(%esp),%edi
c00286f0:	f2 ae                	repnz scas %es:(%edi),%al
c00286f2:	f7 d1                	not    %ecx
c00286f4:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c00286f7:	89 d9                	mov    %ebx,%ecx
c00286f9:	89 ef                	mov    %ebp,%edi
c00286fb:	f2 ae                	repnz scas %es:(%edi),%al
c00286fd:	89 c8                	mov    %ecx,%eax
c00286ff:	f7 d0                	not    %eax
c0028701:	8d 70 ff             	lea    -0x1(%eax),%esi
  return NULL;
c0028704:	bf 00 00 00 00       	mov    $0x0,%edi
  if (haystack_len >= needle_len) 
c0028709:	39 f2                	cmp    %esi,%edx
c002870b:	72 2c                	jb     c0028739 <strstr+0x64>
      for (i = 0; i <= haystack_len - needle_len; i++)
c002870d:	29 f2                	sub    %esi,%edx
c002870f:	89 14 24             	mov    %edx,(%esp)
c0028712:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (!memcmp (haystack + i, needle, needle_len))
c0028717:	89 df                	mov    %ebx,%edi
c0028719:	03 7c 24 18          	add    0x18(%esp),%edi
c002871d:	56                   	push   %esi
c002871e:	55                   	push   %ebp
c002871f:	57                   	push   %edi
c0028720:	e8 71 fc ff ff       	call   c0028396 <memcmp>
c0028725:	83 c4 0c             	add    $0xc,%esp
c0028728:	85 c0                	test   %eax,%eax
c002872a:	74 0d                	je     c0028739 <strstr+0x64>
      for (i = 0; i <= haystack_len - needle_len; i++)
c002872c:	83 c3 01             	add    $0x1,%ebx
c002872f:	3b 1c 24             	cmp    (%esp),%ebx
c0028732:	76 e3                	jbe    c0028717 <strstr+0x42>
  return NULL;
c0028734:	bf 00 00 00 00       	mov    $0x0,%edi
}
c0028739:	89 f8                	mov    %edi,%eax
c002873b:	83 c4 04             	add    $0x4,%esp
c002873e:	5b                   	pop    %ebx
c002873f:	5e                   	pop    %esi
c0028740:	5f                   	pop    %edi
c0028741:	5d                   	pop    %ebp
c0028742:	c3                   	ret    

c0028743 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c0028743:	8b 54 24 04          	mov    0x4(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028747:	80 3a 00             	cmpb   $0x0,(%edx)
c002874a:	74 07                	je     c0028753 <strnlen+0x10>
c002874c:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028751:	75 06                	jne    c0028759 <strnlen+0x16>
c0028753:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
c0028758:	c3                   	ret    
  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028759:	b8 00 00 00 00       	mov    $0x0,%eax
c002875e:	83 c0 01             	add    $0x1,%eax
c0028761:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c0028765:	74 f1                	je     c0028758 <strnlen+0x15>
c0028767:	39 44 24 08          	cmp    %eax,0x8(%esp)
c002876b:	76 eb                	jbe    c0028758 <strnlen+0x15>
c002876d:	eb ef                	jmp    c002875e <strnlen+0x1b>

c002876f <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c002876f:	55                   	push   %ebp
c0028770:	57                   	push   %edi
c0028771:	56                   	push   %esi
c0028772:	53                   	push   %ebx
c0028773:	83 ec 0c             	sub    $0xc,%esp
c0028776:	e8 c8 79 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002877b:	81 c3 31 55 01 00    	add    $0x15531,%ebx
c0028781:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0028785:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c0028789:	85 ed                	test   %ebp,%ebp
c002878b:	74 49                	je     c00287d6 <strlcpy+0x67>
  ASSERT (src != NULL);
c002878d:	85 d2                	test   %edx,%edx
c002878f:	74 6e                	je     c00287ff <strlcpy+0x90>

  src_len = strlen (src);
c0028791:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028796:	b8 00 00 00 00       	mov    $0x0,%eax
c002879b:	89 d7                	mov    %edx,%edi
c002879d:	f2 ae                	repnz scas %es:(%edi),%al
c002879f:	89 ce                	mov    %ecx,%esi
c00287a1:	f7 d6                	not    %esi
c00287a3:	8d 76 ff             	lea    -0x1(%esi),%esi
  if (size > 0) 
c00287a6:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c00287ab:	74 1f                	je     c00287cc <strlcpy+0x5d>
    {
      size_t dst_len = size - 1;
c00287ad:	8b 44 24 28          	mov    0x28(%esp),%eax
c00287b1:	8d 78 ff             	lea    -0x1(%eax),%edi
      if (src_len < dst_len)
c00287b4:	39 fe                	cmp    %edi,%esi
c00287b6:	0f 46 fe             	cmovbe %esi,%edi
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c00287b9:	83 ec 04             	sub    $0x4,%esp
c00287bc:	57                   	push   %edi
c00287bd:	52                   	push   %edx
c00287be:	55                   	push   %ebp
c00287bf:	e8 58 fb ff ff       	call   c002831c <memcpy>
      dst[dst_len] = '\0';
c00287c4:	c6 44 3d 00 00       	movb   $0x0,0x0(%ebp,%edi,1)
c00287c9:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
c00287cc:	89 f0                	mov    %esi,%eax
c00287ce:	83 c4 0c             	add    $0xc,%esp
c00287d1:	5b                   	pop    %ebx
c00287d2:	5e                   	pop    %esi
c00287d3:	5f                   	pop    %edi
c00287d4:	5d                   	pop    %ebp
c00287d5:	c3                   	ret    
  ASSERT (dst != NULL);
c00287d6:	83 ec 0c             	sub    $0xc,%esp
c00287d9:	8d 83 0d 52 ff ff    	lea    -0xadf3(%ebx),%eax
c00287df:	50                   	push   %eax
c00287e0:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00287e6:	50                   	push   %eax
c00287e7:	8d 83 5c 31 ff ff    	lea    -0xcea4(%ebx),%eax
c00287ed:	50                   	push   %eax
c00287ee:	68 4a 01 00 00       	push   $0x14a
c00287f3:	8d 83 e9 51 ff ff    	lea    -0xae17(%ebx),%eax
c00287f9:	50                   	push   %eax
c00287fa:	e8 2e 09 00 00       	call   c002912d <debug_panic>
  ASSERT (src != NULL);
c00287ff:	83 ec 0c             	sub    $0xc,%esp
c0028802:	8d 83 19 52 ff ff    	lea    -0xade7(%ebx),%eax
c0028808:	50                   	push   %eax
c0028809:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002880f:	50                   	push   %eax
c0028810:	8d 83 5c 31 ff ff    	lea    -0xcea4(%ebx),%eax
c0028816:	50                   	push   %eax
c0028817:	68 4b 01 00 00       	push   $0x14b
c002881c:	8d 83 e9 51 ff ff    	lea    -0xae17(%ebx),%eax
c0028822:	50                   	push   %eax
c0028823:	e8 05 09 00 00       	call   c002912d <debug_panic>

c0028828 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0028828:	55                   	push   %ebp
c0028829:	57                   	push   %edi
c002882a:	56                   	push   %esi
c002882b:	53                   	push   %ebx
c002882c:	83 ec 1c             	sub    $0x1c,%esp
c002882f:	e8 0f 79 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0028834:	81 c3 78 54 01 00    	add    $0x15478,%ebx
c002883a:	8b 54 24 34          	mov    0x34(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c002883e:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0028843:	74 75                	je     c00288ba <strlcat+0x92>
  ASSERT (src != NULL);
c0028845:	85 d2                	test   %edx,%edx
c0028847:	0f 84 96 00 00 00    	je     c00288e3 <strlcat+0xbb>

  src_len = strlen (src);
c002884d:	be ff ff ff ff       	mov    $0xffffffff,%esi
c0028852:	b8 00 00 00 00       	mov    $0x0,%eax
c0028857:	89 f1                	mov    %esi,%ecx
c0028859:	89 d7                	mov    %edx,%edi
c002885b:	f2 ae                	repnz scas %es:(%edi),%al
c002885d:	f7 d1                	not    %ecx
c002885f:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
c0028862:	89 f1                	mov    %esi,%ecx
c0028864:	8b 7c 24 30          	mov    0x30(%esp),%edi
c0028868:	f2 ae                	repnz scas %es:(%edi),%al
c002886a:	89 ce                	mov    %ecx,%esi
c002886c:	f7 d6                	not    %esi
c002886e:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size) 
c0028871:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0028876:	74 36                	je     c00288ae <strlcat+0x86>
c0028878:	3b 74 24 38          	cmp    0x38(%esp),%esi
c002887c:	73 30                	jae    c00288ae <strlcat+0x86>
    {
      size_t copy_cnt = size - dst_len - 1;
c002887e:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028882:	83 e8 01             	sub    $0x1,%eax
c0028885:	29 f0                	sub    %esi,%eax
      if (src_len < copy_cnt)
c0028887:	39 c5                	cmp    %eax,%ebp
c0028889:	0f 46 c5             	cmovbe %ebp,%eax
c002888c:	89 c7                	mov    %eax,%edi
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c002888e:	89 f0                	mov    %esi,%eax
c0028890:	03 44 24 30          	add    0x30(%esp),%eax
c0028894:	83 ec 04             	sub    $0x4,%esp
c0028897:	57                   	push   %edi
c0028898:	52                   	push   %edx
c0028899:	89 44 24 18          	mov    %eax,0x18(%esp)
c002889d:	50                   	push   %eax
c002889e:	e8 79 fa ff ff       	call   c002831c <memcpy>
      dst[dst_len + copy_cnt] = '\0';
c00288a3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00288a7:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
c00288ab:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
c00288ae:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
}
c00288b2:	83 c4 1c             	add    $0x1c,%esp
c00288b5:	5b                   	pop    %ebx
c00288b6:	5e                   	pop    %esi
c00288b7:	5f                   	pop    %edi
c00288b8:	5d                   	pop    %ebp
c00288b9:	c3                   	ret    
  ASSERT (dst != NULL);
c00288ba:	83 ec 0c             	sub    $0xc,%esp
c00288bd:	8d 83 0d 52 ff ff    	lea    -0xadf3(%ebx),%eax
c00288c3:	50                   	push   %eax
c00288c4:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00288ca:	50                   	push   %eax
c00288cb:	8d 83 54 31 ff ff    	lea    -0xceac(%ebx),%eax
c00288d1:	50                   	push   %eax
c00288d2:	68 68 01 00 00       	push   $0x168
c00288d7:	8d 83 e9 51 ff ff    	lea    -0xae17(%ebx),%eax
c00288dd:	50                   	push   %eax
c00288de:	e8 4a 08 00 00       	call   c002912d <debug_panic>
  ASSERT (src != NULL);
c00288e3:	83 ec 0c             	sub    $0xc,%esp
c00288e6:	8d 83 19 52 ff ff    	lea    -0xade7(%ebx),%eax
c00288ec:	50                   	push   %eax
c00288ed:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00288f3:	50                   	push   %eax
c00288f4:	8d 83 54 31 ff ff    	lea    -0xceac(%ebx),%eax
c00288fa:	50                   	push   %eax
c00288fb:	68 69 01 00 00       	push   $0x169
c0028900:	8d 83 e9 51 ff ff    	lea    -0xae17(%ebx),%eax
c0028906:	50                   	push   %eax
c0028907:	e8 21 08 00 00       	call   c002912d <debug_panic>

c002890c <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c002890c:	55                   	push   %ebp
c002890d:	57                   	push   %edi
c002890e:	56                   	push   %esi
c002890f:	53                   	push   %ebx
c0028910:	83 ec 1c             	sub    $0x1c,%esp
c0028913:	89 44 24 08          	mov    %eax,0x8(%esp)
c0028917:	89 54 24 0c          	mov    %edx,0xc(%esp)
c002891b:	8b 44 24 30          	mov    0x30(%esp),%eax
c002891f:	8b 54 24 34          	mov    0x34(%esp),%edx
c0028923:	89 04 24             	mov    %eax,(%esp)
c0028926:	89 54 24 04          	mov    %edx,0x4(%esp)
  if ((d >> 32) == 0) 
c002892a:	85 d2                	test   %edx,%edx
c002892c:	0f 84 08 01 00 00    	je     c0028a3a <udiv64+0x12e>
c0028932:	89 d0                	mov    %edx,%eax
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0028934:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0028938:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c002893c:	8b 1c 24             	mov    (%esp),%ebx
c002893f:	8b 74 24 04          	mov    0x4(%esp),%esi
c0028943:	39 df                	cmp    %ebx,%edi
c0028945:	89 ef                	mov    %ebp,%edi
c0028947:	19 f7                	sbb    %esi,%edi
        return 0;
c0028949:	b9 00 00 00 00       	mov    $0x0,%ecx
c002894e:	bb 00 00 00 00       	mov    $0x0,%ebx
      if (n < d)
c0028953:	0f 82 33 01 00 00    	jb     c0028a8c <udiv64+0x180>
  if (x <= 0x0000FFFF)
c0028959:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
c002895f:	77 0a                	ja     c002896b <udiv64+0x5f>
      x <<= 16; 
c0028961:	c1 e0 10             	shl    $0x10,%eax
c0028964:	89 c2                	mov    %eax,%edx
      n += 16;
c0028966:	b9 10 00 00 00       	mov    $0x10,%ecx
  if (x <= 0x00FFFFFF)
c002896b:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
c0028971:	77 06                	ja     c0028979 <udiv64+0x6d>
      n += 8;
c0028973:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c0028976:	c1 e2 08             	shl    $0x8,%edx
  if (x <= 0x0FFFFFFF)
c0028979:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c002897f:	77 06                	ja     c0028987 <udiv64+0x7b>
      n += 4;
c0028981:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c0028984:	c1 e2 04             	shl    $0x4,%edx
  if (x <= 0x3FFFFFFF)
c0028987:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
c002898d:	77 06                	ja     c0028995 <udiv64+0x89>
      n += 2;
c002898f:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c0028992:	c1 e2 02             	shl    $0x2,%edx
    n++;
c0028995:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
c002899b:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c002899e:	8b 7c 24 08          	mov    0x8(%esp),%edi
c00289a2:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00289a6:	89 ea                	mov    %ebp,%edx
c00289a8:	d1 ea                	shr    %edx
c00289aa:	89 d3                	mov    %edx,%ebx
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c00289ac:	89 f8                	mov    %edi,%eax
c00289ae:	89 ea                	mov    %ebp,%edx
c00289b0:	0f ac e8 01          	shrd   $0x1,%ebp,%eax
c00289b4:	d1 ea                	shr    %edx
c00289b6:	89 44 24 10          	mov    %eax,0x10(%esp)
c00289ba:	89 54 24 14          	mov    %edx,0x14(%esp)
c00289be:	8b 34 24             	mov    (%esp),%esi
c00289c1:	8b 7c 24 04          	mov    0x4(%esp),%edi
c00289c5:	0f a5 f7             	shld   %cl,%esi,%edi
c00289c8:	d3 e6                	shl    %cl,%esi
c00289ca:	f6 c1 20             	test   $0x20,%cl
c00289cd:	74 02                	je     c00289d1 <udiv64+0xc5>
c00289cf:	89 f7                	mov    %esi,%edi
  asm ("divl %4"
c00289d1:	89 da                	mov    %ebx,%edx
c00289d3:	8b 44 24 10          	mov    0x10(%esp),%eax
c00289d7:	f7 f7                	div    %edi
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c00289d9:	ba 1f 00 00 00       	mov    $0x1f,%edx
c00289de:	29 ca                	sub    %ecx,%edx
c00289e0:	89 d1                	mov    %edx,%ecx
c00289e2:	d3 e8                	shr    %cl,%eax
c00289e4:	89 c1                	mov    %eax,%ecx
c00289e6:	bb 00 00 00 00       	mov    $0x0,%ebx
          return n - (q - 1) * d < d ? q - 1 : q; 
c00289eb:	89 44 24 10          	mov    %eax,0x10(%esp)
c00289ef:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c00289f3:	83 c1 ff             	add    $0xffffffff,%ecx
c00289f6:	83 d3 ff             	adc    $0xffffffff,%ebx
c00289f9:	89 dd                	mov    %ebx,%ebp
c00289fb:	8b 34 24             	mov    (%esp),%esi
c00289fe:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0028a02:	0f af ee             	imul   %esi,%ebp
c0028a05:	89 f8                	mov    %edi,%eax
c0028a07:	0f af c1             	imul   %ecx,%eax
c0028a0a:	01 c5                	add    %eax,%ebp
c0028a0c:	89 c8                	mov    %ecx,%eax
c0028a0e:	f7 24 24             	mull   (%esp)
c0028a11:	01 ea                	add    %ebp,%edx
c0028a13:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0028a17:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c0028a1b:	29 c7                	sub    %eax,%edi
c0028a1d:	19 d5                	sbb    %edx,%ebp
c0028a1f:	89 f8                	mov    %edi,%eax
c0028a21:	8b 34 24             	mov    (%esp),%esi
c0028a24:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0028a28:	39 f0                	cmp    %esi,%eax
c0028a2a:	89 e8                	mov    %ebp,%eax
c0028a2c:	19 f8                	sbb    %edi,%eax
c0028a2e:	72 5c                	jb     c0028a8c <udiv64+0x180>
c0028a30:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0028a34:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0028a38:	eb 52                	jmp    c0028a8c <udiv64+0x180>
      uint32_t n1 = n >> 32;
c0028a3a:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0028a3e:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c0028a42:	89 e8                	mov    %ebp,%eax
      uint32_t d0 = d;
c0028a44:	8b 0c 24             	mov    (%esp),%ecx
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028a47:	ba 00 00 00 00       	mov    $0x0,%edx
c0028a4c:	f7 f1                	div    %ecx
c0028a4e:	89 c1                	mov    %eax,%ecx
c0028a50:	89 d3                	mov    %edx,%ebx
c0028a52:	89 da                	mov    %ebx,%edx
c0028a54:	b8 00 00 00 00       	mov    $0x0,%eax
c0028a59:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0028a5d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028a64:	00 
c0028a65:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0028a69:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0028a6d:	01 c3                	add    %eax,%ebx
c0028a6f:	11 d6                	adc    %edx,%esi
  asm ("divl %4"
c0028a71:	89 f2                	mov    %esi,%edx
c0028a73:	89 d8                	mov    %ebx,%eax
c0028a75:	f7 34 24             	divl   (%esp)
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028a78:	89 cd                	mov    %ecx,%ebp
c0028a7a:	bf 00 00 00 00       	mov    $0x0,%edi
c0028a7f:	89 f9                	mov    %edi,%ecx
c0028a81:	89 eb                	mov    %ebp,%ebx
c0028a83:	ba 00 00 00 00       	mov    $0x0,%edx
c0028a88:	01 c1                	add    %eax,%ecx
c0028a8a:	11 d3                	adc    %edx,%ebx
        }
    }
}
c0028a8c:	89 c8                	mov    %ecx,%eax
c0028a8e:	89 da                	mov    %ebx,%edx
c0028a90:	83 c4 1c             	add    $0x1c,%esp
c0028a93:	5b                   	pop    %ebx
c0028a94:	5e                   	pop    %esi
c0028a95:	5f                   	pop    %edi
c0028a96:	5d                   	pop    %ebp
c0028a97:	c3                   	ret    

c0028a98 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0028a98:	57                   	push   %edi
c0028a99:	56                   	push   %esi
c0028a9a:	53                   	push   %ebx
c0028a9b:	83 ec 08             	sub    $0x8,%esp
c0028a9e:	89 04 24             	mov    %eax,(%esp)
c0028aa1:	89 54 24 04          	mov    %edx,0x4(%esp)
c0028aa5:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028aa9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028aad:	85 d2                	test   %edx,%edx
c0028aaf:	78 2b                	js     c0028adc <sdiv64+0x44>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028ab1:	89 f1                	mov    %esi,%ecx
c0028ab3:	89 fb                	mov    %edi,%ebx
c0028ab5:	85 ff                	test   %edi,%edi
c0028ab7:	78 2c                	js     c0028ae5 <sdiv64+0x4d>
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028ab9:	53                   	push   %ebx
c0028aba:	51                   	push   %ecx
c0028abb:	e8 4c fe ff ff       	call   c002890c <udiv64>
c0028ac0:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028ac3:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028ac7:	f7 d1                	not    %ecx
c0028ac9:	c1 e9 1f             	shr    $0x1f,%ecx
c0028acc:	89 fb                	mov    %edi,%ebx
c0028ace:	c1 eb 1f             	shr    $0x1f,%ebx
c0028ad1:	38 d9                	cmp    %bl,%cl
c0028ad3:	74 19                	je     c0028aee <sdiv64+0x56>
}
c0028ad5:	83 c4 08             	add    $0x8,%esp
c0028ad8:	5b                   	pop    %ebx
c0028ad9:	5e                   	pop    %esi
c0028ada:	5f                   	pop    %edi
c0028adb:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028adc:	f7 d8                	neg    %eax
c0028ade:	83 d2 00             	adc    $0x0,%edx
c0028ae1:	f7 da                	neg    %edx
c0028ae3:	eb cc                	jmp    c0028ab1 <sdiv64+0x19>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028ae5:	f7 d9                	neg    %ecx
c0028ae7:	83 d3 00             	adc    $0x0,%ebx
c0028aea:	f7 db                	neg    %ebx
c0028aec:	eb cb                	jmp    c0028ab9 <sdiv64+0x21>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028aee:	f7 d8                	neg    %eax
c0028af0:	83 d2 00             	adc    $0x0,%edx
c0028af3:	f7 da                	neg    %edx
c0028af5:	eb de                	jmp    c0028ad5 <sdiv64+0x3d>

c0028af7 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028af7:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c0028afa:	ff 74 24 14          	pushl  0x14(%esp)
c0028afe:	ff 74 24 14          	pushl  0x14(%esp)
c0028b02:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028b06:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028b0a:	e8 89 ff ff ff       	call   c0028a98 <sdiv64>
}
c0028b0f:	83 c4 0c             	add    $0xc,%esp
c0028b12:	c3                   	ret    

c0028b13 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0028b13:	57                   	push   %edi
c0028b14:	56                   	push   %esi
c0028b15:	53                   	push   %ebx
c0028b16:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028b1a:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028b1e:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c0028b22:	57                   	push   %edi
c0028b23:	56                   	push   %esi
c0028b24:	89 d8                	mov    %ebx,%eax
c0028b26:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028b2a:	e8 69 ff ff ff       	call   c0028a98 <sdiv64>
c0028b2f:	83 c4 08             	add    $0x8,%esp
c0028b32:	0f af c6             	imul   %esi,%eax
c0028b35:	29 c3                	sub    %eax,%ebx
  return smod64 (n, d);
c0028b37:	89 d8                	mov    %ebx,%eax
c0028b39:	99                   	cltd   
}
c0028b3a:	5b                   	pop    %ebx
c0028b3b:	5e                   	pop    %esi
c0028b3c:	5f                   	pop    %edi
c0028b3d:	c3                   	ret    

c0028b3e <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0028b3e:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c0028b41:	ff 74 24 14          	pushl  0x14(%esp)
c0028b45:	ff 74 24 14          	pushl  0x14(%esp)
c0028b49:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028b4d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028b51:	e8 b6 fd ff ff       	call   c002890c <udiv64>
}
c0028b56:	83 c4 0c             	add    $0xc,%esp
c0028b59:	c3                   	ret    

c0028b5a <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0028b5a:	57                   	push   %edi
c0028b5b:	56                   	push   %esi
c0028b5c:	53                   	push   %ebx
c0028b5d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028b61:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028b65:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c0028b69:	57                   	push   %edi
c0028b6a:	56                   	push   %esi
c0028b6b:	89 d8                	mov    %ebx,%eax
c0028b6d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028b71:	e8 96 fd ff ff       	call   c002890c <udiv64>
c0028b76:	83 c4 08             	add    $0x8,%esp
c0028b79:	0f af c6             	imul   %esi,%eax
c0028b7c:	29 c3                	sub    %eax,%ebx
  return umod64 (n, d);
c0028b7e:	89 d8                	mov    %ebx,%eax
c0028b80:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0028b85:	5b                   	pop    %ebx
c0028b86:	5e                   	pop    %esi
c0028b87:	5f                   	pop    %edi
c0028b88:	c3                   	ret    

c0028b89 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0028b89:	55                   	push   %ebp
c0028b8a:	57                   	push   %edi
c0028b8b:	56                   	push   %esi
c0028b8c:	53                   	push   %ebx
c0028b8d:	83 ec 04             	sub    $0x4,%esp
c0028b90:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
c0028b93:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0028b99:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ofs = 0; ofs < size; ofs++)
c0028b9e:	85 d2                	test   %edx,%edx
c0028ba0:	74 4d                	je     c0028bef <parse_octal_field+0x66>
      char c = s[ofs];
c0028ba2:	8b 04 24             	mov    (%esp),%eax
c0028ba5:	0f b6 18             	movzbl (%eax),%ebx
      if (c >= '0' && c <= '7')
c0028ba8:	8d 6b d0             	lea    -0x30(%ebx),%ebp
  for (ofs = 0; ofs < size; ofs++)
c0028bab:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
c0028bb0:	bf 00 00 00 00       	mov    $0x0,%edi
      if (c >= '0' && c <= '7')
c0028bb5:	89 e8                	mov    %ebp,%eax
c0028bb7:	3c 07                	cmp    $0x7,%al
c0028bb9:	77 3c                	ja     c0028bf7 <parse_octal_field+0x6e>
          *value = c - '0' + *value * 8;
c0028bbb:	0f be db             	movsbl %bl,%ebx
c0028bbe:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0028bc2:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0028bc4:	83 c6 01             	add    $0x1,%esi
c0028bc7:	39 f2                	cmp    %esi,%edx
c0028bc9:	74 1f                	je     c0028bea <parse_octal_field+0x61>
      char c = s[ofs];
c0028bcb:	8b 04 24             	mov    (%esp),%eax
c0028bce:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
      if (c >= '0' && c <= '7')
c0028bd2:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c0028bd5:	89 e8                	mov    %ebp,%eax
c0028bd7:	3c 07                	cmp    $0x7,%al
c0028bd9:	77 1c                	ja     c0028bf7 <parse_octal_field+0x6e>
          if (*value > ULONG_MAX / 8)
c0028bdb:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0028be1:	76 d8                	jbe    c0028bbb <parse_octal_field+0x32>
              return false;
c0028be3:	b8 00 00 00 00       	mov    $0x0,%eax
c0028be8:	eb 05                	jmp    c0028bef <parse_octal_field+0x66>
  return false;
c0028bea:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028bef:	83 c4 04             	add    $0x4,%esp
c0028bf2:	5b                   	pop    %ebx
c0028bf3:	5e                   	pop    %esi
c0028bf4:	5f                   	pop    %edi
c0028bf5:	5d                   	pop    %ebp
c0028bf6:	c3                   	ret    
          return false;
c0028bf7:	b8 00 00 00 00       	mov    $0x0,%eax
      else if (c == ' ' || c == '\0')
c0028bfc:	f6 c3 df             	test   $0xdf,%bl
c0028bff:	75 ee                	jne    c0028bef <parse_octal_field+0x66>
          return ofs > 0;
c0028c01:	85 f6                	test   %esi,%esi
c0028c03:	0f 95 c0             	setne  %al
c0028c06:	eb e7                	jmp    c0028bef <parse_octal_field+0x66>

c0028c08 <strip_antisocial_prefixes>:
{
c0028c08:	55                   	push   %ebp
c0028c09:	57                   	push   %edi
c0028c0a:	56                   	push   %esi
c0028c0b:	53                   	push   %ebx
c0028c0c:	83 ec 1c             	sub    $0x1c,%esp
c0028c0f:	e8 2f 75 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0028c14:	81 c3 98 50 01 00    	add    $0x15098,%ebx
c0028c1a:	89 c5                	mov    %eax,%ebp
         || !memcmp (file_name, "./", 2)
c0028c1c:	8d bb 5c 46 ff ff    	lea    -0xb9a4(%ebx),%edi
         || !memcmp (file_name, "../", 3))
c0028c22:	8d 83 25 52 ff ff    	lea    -0xaddb(%ebx),%eax
c0028c28:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (*file_name == '/'
c0028c2c:	eb 11                	jmp    c0028c3f <strip_antisocial_prefixes+0x37>
    file_name = strchr (file_name, '/') + 1;
c0028c2e:	83 ec 08             	sub    $0x8,%esp
c0028c31:	6a 2f                	push   $0x2f
c0028c33:	55                   	push   %ebp
c0028c34:	e8 15 f8 ff ff       	call   c002844e <strchr>
c0028c39:	83 c4 10             	add    $0x10,%esp
c0028c3c:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c0028c3f:	0f b6 75 00          	movzbl 0x0(%ebp),%esi
c0028c43:	89 f0                	mov    %esi,%eax
c0028c45:	3c 2f                	cmp    $0x2f,%al
c0028c47:	74 e5                	je     c0028c2e <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "./", 2)
c0028c49:	83 ec 04             	sub    $0x4,%esp
c0028c4c:	6a 02                	push   $0x2
c0028c4e:	57                   	push   %edi
c0028c4f:	55                   	push   %ebp
c0028c50:	e8 41 f7 ff ff       	call   c0028396 <memcmp>
c0028c55:	83 c4 10             	add    $0x10,%esp
c0028c58:	85 c0                	test   %eax,%eax
c0028c5a:	74 d2                	je     c0028c2e <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "../", 3))
c0028c5c:	83 ec 04             	sub    $0x4,%esp
c0028c5f:	6a 03                	push   $0x3
c0028c61:	ff 74 24 14          	pushl  0x14(%esp)
c0028c65:	55                   	push   %ebp
c0028c66:	e8 2b f7 ff ff       	call   c0028396 <memcmp>
c0028c6b:	83 c4 10             	add    $0x10,%esp
c0028c6e:	85 c0                	test   %eax,%eax
c0028c70:	74 bc                	je     c0028c2e <strip_antisocial_prefixes+0x26>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0028c72:	8d 83 db 4b ff ff    	lea    -0xb425(%ebx),%eax
c0028c78:	89 f2                	mov    %esi,%edx
c0028c7a:	84 d2                	test   %dl,%dl
c0028c7c:	74 22                	je     c0028ca0 <strip_antisocial_prefixes+0x98>
c0028c7e:	b9 03 00 00 00       	mov    $0x3,%ecx
c0028c83:	8d bb da 4b ff ff    	lea    -0xb426(%ebx),%edi
c0028c89:	89 ee                	mov    %ebp,%esi
c0028c8b:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0028c8d:	0f 97 c0             	seta   %al
c0028c90:	1c 00                	sbb    $0x0,%al
c0028c92:	0f be c0             	movsbl %al,%eax
c0028c95:	85 c0                	test   %eax,%eax
c0028c97:	8d 83 db 4b ff ff    	lea    -0xb425(%ebx),%eax
c0028c9d:	0f 45 c5             	cmovne %ebp,%eax
}
c0028ca0:	83 c4 1c             	add    $0x1c,%esp
c0028ca3:	5b                   	pop    %ebx
c0028ca4:	5e                   	pop    %esi
c0028ca5:	5f                   	pop    %edi
c0028ca6:	5d                   	pop    %ebp
c0028ca7:	c3                   	ret    

c0028ca8 <ustar_make_header>:
{
c0028ca8:	55                   	push   %ebp
c0028ca9:	57                   	push   %edi
c0028caa:	56                   	push   %esi
c0028cab:	53                   	push   %ebx
c0028cac:	83 ec 1c             	sub    $0x1c,%esp
c0028caf:	e8 8f 74 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0028cb4:	81 c3 f8 4f 01 00    	add    $0x14ff8,%ebx
c0028cba:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028cbe:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028cc2:	83 fd 30             	cmp    $0x30,%ebp
c0028cc5:	0f 94 c2             	sete   %dl
c0028cc8:	83 fd 35             	cmp    $0x35,%ebp
c0028ccb:	0f 94 c0             	sete   %al
c0028cce:	08 c2                	or     %al,%dl
c0028cd0:	88 54 24 0f          	mov    %dl,0xf(%esp)
c0028cd4:	0f 84 77 01 00 00    	je     c0028e51 <ustar_make_header+0x1a9>
  file_name = strip_antisocial_prefixes (file_name);
c0028cda:	8b 44 24 30          	mov    0x30(%esp),%eax
c0028cde:	e8 25 ff ff ff       	call   c0028c08 <strip_antisocial_prefixes>
c0028ce3:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0028ce5:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028cea:	b8 00 00 00 00       	mov    $0x0,%eax
c0028cef:	89 d7                	mov    %edx,%edi
c0028cf1:	f2 ae                	repnz scas %es:(%edi),%al
c0028cf3:	f7 d1                	not    %ecx
c0028cf5:	83 e9 01             	sub    $0x1,%ecx
c0028cf8:	83 f9 63             	cmp    $0x63,%ecx
c0028cfb:	0f 87 76 01 00 00    	ja     c0028e77 <ustar_make_header+0x1cf>
  memset (h, 0, sizeof *h);
c0028d01:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0028d07:	c7 86 fc 01 00 00 00 	movl   $0x0,0x1fc(%esi)
c0028d0e:	00 00 00 
c0028d11:	8d 7e 04             	lea    0x4(%esi),%edi
c0028d14:	83 e7 fc             	and    $0xfffffffc,%edi
c0028d17:	89 f1                	mov    %esi,%ecx
c0028d19:	29 f9                	sub    %edi,%ecx
c0028d1b:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0028d21:	c1 e9 02             	shr    $0x2,%ecx
c0028d24:	b8 00 00 00 00       	mov    $0x0,%eax
c0028d29:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028d2b:	83 ec 04             	sub    $0x4,%esp
c0028d2e:	6a 64                	push   $0x64
c0028d30:	52                   	push   %edx
c0028d31:	56                   	push   %esi
c0028d32:	e8 38 fa ff ff       	call   c002876f <strlcpy>
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028d37:	83 c4 10             	add    $0x10,%esp
c0028d3a:	83 fd 30             	cmp    $0x30,%ebp
c0028d3d:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0028d42:	ba ed 01 00 00       	mov    $0x1ed,%edx
c0028d47:	0f 45 c2             	cmovne %edx,%eax
c0028d4a:	50                   	push   %eax
c0028d4b:	8d 83 53 52 ff ff    	lea    -0xadad(%ebx),%eax
c0028d51:	50                   	push   %eax
c0028d52:	6a 08                	push   $0x8
c0028d54:	8d 46 64             	lea    0x64(%esi),%eax
c0028d57:	50                   	push   %eax
c0028d58:	e8 05 ef ff ff       	call   c0027c62 <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0028d5d:	83 c4 0c             	add    $0xc,%esp
c0028d60:	6a 08                	push   $0x8
c0028d62:	8d bb 58 52 ff ff    	lea    -0xada8(%ebx),%edi
c0028d68:	57                   	push   %edi
c0028d69:	8d 46 6c             	lea    0x6c(%esi),%eax
c0028d6c:	50                   	push   %eax
c0028d6d:	e8 fd f9 ff ff       	call   c002876f <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0028d72:	83 c4 0c             	add    $0xc,%esp
c0028d75:	6a 08                	push   $0x8
c0028d77:	57                   	push   %edi
c0028d78:	8d 46 74             	lea    0x74(%esi),%eax
c0028d7b:	50                   	push   %eax
c0028d7c:	e8 ee f9 ff ff       	call   c002876f <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c0028d81:	ff 74 24 48          	pushl  0x48(%esp)
c0028d85:	8d bb 60 52 ff ff    	lea    -0xada0(%ebx),%edi
c0028d8b:	57                   	push   %edi
c0028d8c:	6a 0c                	push   $0xc
c0028d8e:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028d91:	50                   	push   %eax
c0028d92:	e8 cb ee ff ff       	call   c0027c62 <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0028d97:	83 c4 20             	add    $0x20,%esp
c0028d9a:	68 00 8c b7 43       	push   $0x43b78c00
c0028d9f:	57                   	push   %edi
c0028da0:	6a 0c                	push   $0xc
c0028da2:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0028da8:	50                   	push   %eax
c0028da9:	e8 b4 ee ff ff       	call   c0027c62 <snprintf>
  h->typeflag = type;
c0028dae:	89 e8                	mov    %ebp,%eax
c0028db0:	88 86 9c 00 00 00    	mov    %al,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0028db6:	83 c4 0c             	add    $0xc,%esp
c0028db9:	6a 06                	push   $0x6
c0028dbb:	8d 83 66 52 ff ff    	lea    -0xad9a(%ebx),%eax
c0028dc1:	50                   	push   %eax
c0028dc2:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028dc8:	50                   	push   %eax
c0028dc9:	e8 a1 f9 ff ff       	call   c002876f <strlcpy>
  h->version[0] = h->version[1] = '0';
c0028dce:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0028dd5:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c0028ddc:	83 c4 0c             	add    $0xc,%esp
c0028ddf:	6a 20                	push   $0x20
c0028de1:	8d bb 0c 48 ff ff    	lea    -0xb7f4(%ebx),%edi
c0028de7:	57                   	push   %edi
c0028de8:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c0028dee:	50                   	push   %eax
c0028def:	e8 7b f9 ff ff       	call   c002876f <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0028df4:	83 c4 0c             	add    $0xc,%esp
c0028df7:	6a 20                	push   $0x20
c0028df9:	57                   	push   %edi
c0028dfa:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0028e00:	50                   	push   %eax
c0028e01:	e8 69 f9 ff ff       	call   c002876f <strlcpy>
c0028e06:	83 c4 10             	add    $0x10,%esp
c0028e09:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028e0e:	ba 00 00 00 00       	mov    $0x0,%edx
      chksum += in_chksum_field ? ' ' : header[i];
c0028e13:	bf 20 00 00 00       	mov    $0x20,%edi
c0028e18:	83 f8 07             	cmp    $0x7,%eax
c0028e1b:	77 74                	ja     c0028e91 <ustar_make_header+0x1e9>
c0028e1d:	89 f9                	mov    %edi,%ecx
c0028e1f:	01 ca                	add    %ecx,%edx
c0028e21:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028e24:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028e29:	75 ed                	jne    c0028e18 <ustar_make_header+0x170>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0028e2b:	52                   	push   %edx
c0028e2c:	8d 83 53 52 ff ff    	lea    -0xadad(%ebx),%eax
c0028e32:	50                   	push   %eax
c0028e33:	6a 08                	push   $0x8
c0028e35:	81 c6 94 00 00 00    	add    $0x94,%esi
c0028e3b:	56                   	push   %esi
c0028e3c:	e8 21 ee ff ff       	call   c0027c62 <snprintf>
  return true;
c0028e41:	83 c4 10             	add    $0x10,%esp
}
c0028e44:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c0028e49:	83 c4 1c             	add    $0x1c,%esp
c0028e4c:	5b                   	pop    %ebx
c0028e4d:	5e                   	pop    %esi
c0028e4e:	5f                   	pop    %edi
c0028e4f:	5d                   	pop    %ebp
c0028e50:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028e51:	83 ec 0c             	sub    $0xc,%esp
c0028e54:	8d 83 10 53 ff ff    	lea    -0xacf0(%ebx),%eax
c0028e5a:	50                   	push   %eax
c0028e5b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0028e61:	50                   	push   %eax
c0028e62:	8d 83 70 31 ff ff    	lea    -0xce90(%ebx),%eax
c0028e68:	50                   	push   %eax
c0028e69:	6a 59                	push   $0x59
c0028e6b:	8d 83 29 52 ff ff    	lea    -0xadd7(%ebx),%eax
c0028e71:	50                   	push   %eax
c0028e72:	e8 b6 02 00 00       	call   c002912d <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028e77:	83 ec 08             	sub    $0x8,%esp
c0028e7a:	52                   	push   %edx
c0028e7b:	8d 83 3b 52 ff ff    	lea    -0xadc5(%ebx),%eax
c0028e81:	50                   	push   %eax
c0028e82:	e8 4a e6 ff ff       	call   c00274d1 <printf>
      return false;
c0028e87:	83 c4 10             	add    $0x10,%esp
c0028e8a:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
c0028e8f:	eb b3                	jmp    c0028e44 <ustar_make_header+0x19c>
      chksum += in_chksum_field ? ' ' : header[i];
c0028e91:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c0028e98:	00 
c0028e99:	eb 84                	jmp    c0028e1f <ustar_make_header+0x177>

c0028e9b <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0028e9b:	57                   	push   %edi
c0028e9c:	56                   	push   %esi
c0028e9d:	53                   	push   %ebx
c0028e9e:	83 ec 10             	sub    $0x10,%esp
c0028ea1:	e8 9d 72 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0028ea6:	81 c3 06 4e 01 00    	add    $0x14e06,%ebx
c0028eac:	8b 74 24 20          	mov    0x20(%esp),%esi
  while (cnt-- > 0)
c0028eb0:	8d 96 00 02 00 00    	lea    0x200(%esi),%edx
{
c0028eb6:	89 f0                	mov    %esi,%eax
    if (*block++ != 0)
c0028eb8:	83 c0 01             	add    $0x1,%eax
c0028ebb:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c0028ebf:	0f 85 28 01 00 00    	jne    c0028fed <ustar_parse_header+0x152>
  while (cnt-- > 0)
c0028ec5:	39 c2                	cmp    %eax,%edx
c0028ec7:	75 ef                	jne    c0028eb8 <ustar_parse_header+0x1d>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c0028ec9:	8b 44 24 24          	mov    0x24(%esp),%eax
c0028ecd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0028ed3:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028ed7:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0028edd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0028ee1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0028ee7:	ba 00 00 00 00       	mov    $0x0,%edx
c0028eec:	e9 3d 01 00 00       	jmp    c002902e <ustar_parse_header+0x193>
  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028ef1:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c0028ef5:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c0028efb:	ba 08 00 00 00       	mov    $0x8,%edx
c0028f00:	e8 84 fc ff ff       	call   c0028b89 <parse_octal_field>
    return "corrupt chksum field";
c0028f05:	8d 93 e6 52 ff ff    	lea    -0xad1a(%ebx),%edx
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028f0b:	84 c0                	test   %al,%al
c0028f0d:	0f 84 1b 01 00 00    	je     c002902e <ustar_parse_header+0x193>
c0028f13:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028f18:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0028f1d:	bf 20 00 00 00       	mov    $0x20,%edi
c0028f22:	83 f8 07             	cmp    $0x7,%eax
c0028f25:	0f 87 8b 00 00 00    	ja     c0028fb6 <ustar_parse_header+0x11b>
c0028f2b:	89 fa                	mov    %edi,%edx
c0028f2d:	01 d1                	add    %edx,%ecx
c0028f2f:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028f32:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028f37:	75 e9                	jne    c0028f22 <ustar_parse_header+0x87>
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
c0028f39:	8d 93 a9 52 ff ff    	lea    -0xad57(%ebx),%edx
  else if (chksum != calculate_chksum (h))
c0028f3f:	39 4c 24 0c          	cmp    %ecx,0xc(%esp)
c0028f43:	0f 85 e5 00 00 00    	jne    c002902e <ustar_parse_header+0x193>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
    return "file name too long";
c0028f49:	8d 93 bb 52 ff ff    	lea    -0xad45(%ebx),%edx
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0028f4f:	80 7e 63 00          	cmpb   $0x0,0x63(%esi)
c0028f53:	0f 85 d5 00 00 00    	jne    c002902e <ustar_parse_header+0x193>
c0028f59:	80 be 59 01 00 00 00 	cmpb   $0x0,0x159(%esi)
c0028f60:	0f 85 c8 00 00 00    	jne    c002902e <ustar_parse_header+0x193>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028f66:	0f b6 86 9c 00 00 00 	movzbl 0x9c(%esi),%eax
c0028f6d:	3c 30                	cmp    $0x30,%al
c0028f6f:	74 0e                	je     c0028f7f <ustar_parse_header+0xe4>
    return "unimplemented file type";
c0028f71:	8d 93 ce 52 ff ff    	lea    -0xad32(%ebx),%edx
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028f77:	3c 35                	cmp    $0x35,%al
c0028f79:	0f 85 af 00 00 00    	jne    c002902e <ustar_parse_header+0x193>
  if (h->typeflag == USTAR_REGULAR)
c0028f7f:	3c 30                	cmp    $0x30,%al
c0028f81:	74 40                	je     c0028fc3 <ustar_parse_header+0x128>
        return "corrupt file size field";
      else if (size_ul > INT_MAX)
        return "file too large";
    }
  else
    size_ul = 0;
c0028f83:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0028f8a:	00 

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0028f8b:	89 f0                	mov    %esi,%eax
c0028f8d:	e8 76 fc ff ff       	call   c0028c08 <strip_antisocial_prefixes>
c0028f92:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028f96:	89 07                	mov    %eax,(%edi)
  *type = h->typeflag;
c0028f98:	0f be 86 9c 00 00 00 	movsbl 0x9c(%esi),%eax
c0028f9f:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0028fa3:	89 07                	mov    %eax,(%edi)
  *size = size_ul;
c0028fa5:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028fa9:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0028fad:	89 07                	mov    %eax,(%edi)
  return NULL;
c0028faf:	ba 00 00 00 00       	mov    $0x0,%edx
c0028fb4:	eb 78                	jmp    c002902e <ustar_parse_header+0x193>
      chksum += in_chksum_field ? ' ' : header[i];
c0028fb6:	0f b6 94 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%edx
c0028fbd:	00 
c0028fbe:	e9 6a ff ff ff       	jmp    c0028f2d <ustar_parse_header+0x92>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028fc3:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0028fc7:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028fca:	ba 0c 00 00 00       	mov    $0xc,%edx
c0028fcf:	e8 b5 fb ff ff       	call   c0028b89 <parse_octal_field>
        return "corrupt file size field";
c0028fd4:	8d 93 6c 52 ff ff    	lea    -0xad94(%ebx),%edx
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028fda:	84 c0                	test   %al,%al
c0028fdc:	74 50                	je     c002902e <ustar_parse_header+0x193>
        return "file too large";
c0028fde:	8d 93 84 52 ff ff    	lea    -0xad7c(%ebx),%edx
      else if (size_ul > INT_MAX)
c0028fe4:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028fe9:	79 a0                	jns    c0028f8b <ustar_parse_header+0xf0>
c0028feb:	eb 41                	jmp    c002902e <ustar_parse_header+0x193>
  if (memcmp (h->magic, "ustar", 6))
c0028fed:	83 ec 04             	sub    $0x4,%esp
c0028ff0:	6a 06                	push   $0x6
c0028ff2:	8d 83 66 52 ff ff    	lea    -0xad9a(%ebx),%eax
c0028ff8:	50                   	push   %eax
c0028ff9:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028fff:	50                   	push   %eax
c0029000:	e8 91 f3 ff ff       	call   c0028396 <memcmp>
c0029005:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
c0029008:	8d 93 fb 52 ff ff    	lea    -0xad05(%ebx),%edx
  if (memcmp (h->magic, "ustar", 6))
c002900e:	85 c0                	test   %eax,%eax
c0029010:	75 1c                	jne    c002902e <ustar_parse_header+0x193>
    return "invalid ustar version";
c0029012:	8d 93 93 52 ff ff    	lea    -0xad6d(%ebx),%edx
  else if (h->version[0] != '0' || h->version[1] != '0')
c0029018:	80 be 07 01 00 00 30 	cmpb   $0x30,0x107(%esi)
c002901f:	75 0d                	jne    c002902e <ustar_parse_header+0x193>
c0029021:	80 be 08 01 00 00 30 	cmpb   $0x30,0x108(%esi)
c0029028:	0f 84 c3 fe ff ff    	je     c0028ef1 <ustar_parse_header+0x56>
}
c002902e:	89 d0                	mov    %edx,%eax
c0029030:	83 c4 10             	add    $0x10,%esp
c0029033:	5b                   	pop    %ebx
c0029034:	5e                   	pop    %esi
c0029035:	5f                   	pop    %edi
c0029036:	c3                   	ret    

c0029037 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0029037:	55                   	push   %ebp
c0029038:	89 e5                	mov    %esp,%ebp
c002903a:	57                   	push   %edi
c002903b:	56                   	push   %esi
c002903c:	53                   	push   %ebx
c002903d:	83 ec 0c             	sub    $0xc,%esp
c0029040:	e8 fe 70 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029045:	81 c3 67 4c 01 00    	add    $0x14c67,%ebx
c002904b:	8b 75 08             	mov    0x8(%ebp),%esi
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c002904e:	8b 56 04             	mov    0x4(%esi),%edx
    case THREAD_RUNNING:  
      status = "RUNNING";
      break;

    case THREAD_READY:  
      status = "READY";
c0029051:	8d 83 49 53 ff ff    	lea    -0xacb7(%ebx),%eax
  switch (t->status) {
c0029057:	83 fa 01             	cmp    $0x1,%edx
c002905a:	74 1c                	je     c0029078 <print_stacktrace+0x41>
      status = "RUNNING";
c002905c:	8d 83 91 3e ff ff    	lea    -0xc16f(%ebx),%eax
  switch (t->status) {
c0029062:	85 d2                	test   %edx,%edx
c0029064:	74 12                	je     c0029078 <print_stacktrace+0x41>
  const char *status = "UNKNOWN";
c0029066:	83 fa 02             	cmp    $0x2,%edx
c0029069:	8d 83 4b 3e ff ff    	lea    -0xc1b5(%ebx),%eax
c002906f:	8d 93 41 53 ff ff    	lea    -0xacbf(%ebx),%edx
c0029075:	0f 45 c2             	cmovne %edx,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029078:	83 ec 04             	sub    $0x4,%esp
c002907b:	50                   	push   %eax
c002907c:	8d 46 08             	lea    0x8(%esi),%eax
c002907f:	50                   	push   %eax
c0029080:	8d 83 6c 53 ff ff    	lea    -0xac94(%ebx),%eax
c0029086:	50                   	push   %eax
c0029087:	e8 45 e4 ff ff       	call   c00274d1 <printf>

  if (t == thread_current()) 
c002908c:	e8 38 7f ff ff       	call   c0020fc9 <thread_current>
c0029091:	83 c4 10             	add    $0x10,%esp
c0029094:	39 f0                	cmp    %esi,%eax
c0029096:	74 79                	je     c0029111 <print_stacktrace+0xda>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0029098:	8b 56 18             	mov    0x18(%esi),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c002909b:	81 c6 00 10 00 00    	add    $0x1000,%esi
c00290a1:	39 f2                	cmp    %esi,%edx
c00290a3:	74 74                	je     c0029119 <print_stacktrace+0xe2>
c00290a5:	8b 42 10             	mov    0x10(%edx),%eax
c00290a8:	81 f8 ac 1b 02 c0    	cmp    $0xc0021bac,%eax
c00290ae:	74 69                	je     c0029119 <print_stacktrace+0xe2>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c00290b0:	8b 72 08             	mov    0x8(%edx),%esi
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c00290b3:	83 ec 08             	sub    $0x8,%esp
c00290b6:	50                   	push   %eax
c00290b7:	8d 83 3e 50 ff ff    	lea    -0xafc2(%ebx),%eax
c00290bd:	50                   	push   %eax
c00290be:	e8 0e e4 ff ff       	call   c00274d1 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00290c3:	83 c4 10             	add    $0x10,%esp
c00290c6:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c00290cc:	76 29                	jbe    c00290f7 <print_stacktrace+0xc0>
c00290ce:	83 3e 00             	cmpl   $0x0,(%esi)
c00290d1:	74 24                	je     c00290f7 <print_stacktrace+0xc0>
    printf (" %p", frame[1]);
c00290d3:	8d bb 3e 50 ff ff    	lea    -0xafc2(%ebx),%edi
c00290d9:	83 ec 08             	sub    $0x8,%esp
c00290dc:	ff 76 04             	pushl  0x4(%esi)
c00290df:	57                   	push   %edi
c00290e0:	e8 ec e3 ff ff       	call   c00274d1 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00290e5:	8b 36                	mov    (%esi),%esi
c00290e7:	83 c4 10             	add    $0x10,%esp
c00290ea:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c00290f0:	76 05                	jbe    c00290f7 <print_stacktrace+0xc0>
c00290f2:	83 3e 00             	cmpl   $0x0,(%esi)
c00290f5:	75 e2                	jne    c00290d9 <print_stacktrace+0xa2>
  printf (".\n");
c00290f7:	83 ec 0c             	sub    $0xc,%esp
c00290fa:	8d 83 db 4b ff ff    	lea    -0xb425(%ebx),%eax
c0029100:	50                   	push   %eax
c0029101:	e8 fd 1f 00 00       	call   c002b103 <puts>
c0029106:	83 c4 10             	add    $0x10,%esp
}
c0029109:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002910c:	5b                   	pop    %ebx
c002910d:	5e                   	pop    %esi
c002910e:	5f                   	pop    %edi
c002910f:	5d                   	pop    %ebp
c0029110:	c3                   	ret    
      frame = __builtin_frame_address (1);
c0029111:	8b 75 00             	mov    0x0(%ebp),%esi
      retaddr = __builtin_return_address (0);
c0029114:	8b 45 04             	mov    0x4(%ebp),%eax
c0029117:	eb 9a                	jmp    c00290b3 <print_stacktrace+0x7c>
          printf (" thread was never scheduled.\n");
c0029119:	83 ec 0c             	sub    $0xc,%esp
c002911c:	8d 83 4f 53 ff ff    	lea    -0xacb1(%ebx),%eax
c0029122:	50                   	push   %eax
c0029123:	e8 db 1f 00 00       	call   c002b103 <puts>
          return;
c0029128:	83 c4 10             	add    $0x10,%esp
c002912b:	eb dc                	jmp    c0029109 <print_stacktrace+0xd2>

c002912d <debug_panic>:
{
c002912d:	55                   	push   %ebp
c002912e:	57                   	push   %edi
c002912f:	56                   	push   %esi
c0029130:	53                   	push   %ebx
c0029131:	83 ec 0c             	sub    $0xc,%esp
c0029134:	e8 0a 70 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029139:	81 c3 73 4b 01 00    	add    $0x14b73,%ebx
c002913f:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029143:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029147:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  intr_disable ();
c002914b:	e8 12 8c ff ff       	call   c0021d62 <intr_disable>
  console_panic ();
c0029150:	e8 2d 1f 00 00       	call   c002b082 <console_panic>
  level++;
c0029155:	8b 83 34 1c 00 00    	mov    0x1c34(%ebx),%eax
c002915b:	83 c0 01             	add    $0x1,%eax
c002915e:	89 83 34 1c 00 00    	mov    %eax,0x1c34(%ebx)
  if (level == 1) 
c0029164:	83 f8 01             	cmp    $0x1,%eax
c0029167:	74 11                	je     c002917a <debug_panic+0x4d>
  else if (level == 2)
c0029169:	83 f8 02             	cmp    $0x2,%eax
c002916c:	74 42                	je     c00291b0 <debug_panic+0x83>
  serial_flush ();
c002916e:	e8 87 be ff ff       	call   c0024ffa <serial_flush>
  shutdown ();
c0029173:	e8 e8 db ff ff       	call   c0026d60 <shutdown>
  for (;;);
c0029178:	eb fe                	jmp    c0029178 <debug_panic+0x4b>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c002917a:	55                   	push   %ebp
c002917b:	57                   	push   %edi
c002917c:	56                   	push   %esi
c002917d:	8d 83 94 53 ff ff    	lea    -0xac6c(%ebx),%eax
c0029183:	50                   	push   %eax
c0029184:	e8 48 e3 ff ff       	call   c00274d1 <printf>
      va_start (args, message);
c0029189:	8d 44 24 40          	lea    0x40(%esp),%eax
      vprintf (message, args);
c002918d:	83 c4 08             	add    $0x8,%esp
c0029190:	50                   	push   %eax
c0029191:	ff 74 24 38          	pushl  0x38(%esp)
c0029195:	e8 26 1f 00 00       	call   c002b0c0 <vprintf>
      printf ("\n");
c002919a:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c00291a1:	e8 cf 1f 00 00       	call   c002b175 <putchar>
      debug_backtrace ();
c00291a6:	e8 9c dc ff ff       	call   c0026e47 <debug_backtrace>
c00291ab:	83 c4 10             	add    $0x10,%esp
c00291ae:	eb be                	jmp    c002916e <debug_panic+0x41>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c00291b0:	55                   	push   %ebp
c00291b1:	57                   	push   %edi
c00291b2:	56                   	push   %esi
c00291b3:	8d 83 b4 53 ff ff    	lea    -0xac4c(%ebx),%eax
c00291b9:	50                   	push   %eax
c00291ba:	e8 12 e3 ff ff       	call   c00274d1 <printf>
c00291bf:	83 c4 10             	add    $0x10,%esp
c00291c2:	eb aa                	jmp    c002916e <debug_panic+0x41>

c00291c4 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c00291c4:	56                   	push   %esi
c00291c5:	53                   	push   %ebx
c00291c6:	83 ec 04             	sub    $0x4,%esp
c00291c9:	e8 75 6f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00291ce:	81 c3 de 4a 01 00    	add    $0x14ade,%ebx
  enum intr_level oldlevel = intr_disable ();
c00291d4:	e8 89 8b ff ff       	call   c0021d62 <intr_disable>
c00291d9:	89 c6                	mov    %eax,%esi

  thread_foreach (print_stacktrace, 0);
c00291db:	83 ec 08             	sub    $0x8,%esp
c00291de:	6a 00                	push   $0x0
c00291e0:	8d 83 8b b3 fe ff    	lea    -0x14c75(%ebx),%eax
c00291e6:	50                   	push   %eax
c00291e7:	e8 ee 7e ff ff       	call   c00210da <thread_foreach>
  intr_set_level (oldlevel);
c00291ec:	89 34 24             	mov    %esi,(%esp)
c00291ef:	e8 75 8b ff ff       	call   c0021d69 <intr_set_level>
}
c00291f4:	83 c4 14             	add    $0x14,%esp
c00291f7:	5b                   	pop    %ebx
c00291f8:	5e                   	pop    %esi
c00291f9:	c3                   	ret    

c00291fa <list_init>:
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
}

/* Initializes LIST as an empty list. */
void
list_init(struct list *list) {
c00291fa:	53                   	push   %ebx
c00291fb:	83 ec 08             	sub    $0x8,%esp
c00291fe:	e8 40 6f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029203:	81 c3 a9 4a 01 00    	add    $0x14aa9,%ebx
c0029209:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c002920d:	85 c0                	test   %eax,%eax
c002920f:	74 1b                	je     c002922c <list_init+0x32>
    list->head.prev = NULL;
c0029211:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list->head.next = &list->tail;
c0029217:	8d 50 08             	lea    0x8(%eax),%edx
c002921a:	89 50 04             	mov    %edx,0x4(%eax)
    list->tail.prev = &list->head;
c002921d:	89 40 08             	mov    %eax,0x8(%eax)
    list->tail.next = NULL;
c0029220:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0029227:	83 c4 08             	add    $0x8,%esp
c002922a:	5b                   	pop    %ebx
c002922b:	c3                   	ret    
    ASSERT (list != NULL);
c002922c:	83 ec 0c             	sub    $0xc,%esp
c002922f:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c0029235:	50                   	push   %eax
c0029236:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002923c:	50                   	push   %eax
c002923d:	8d 83 6c 32 ff ff    	lea    -0xcd94(%ebx),%eax
c0029243:	50                   	push   %eax
c0029244:	6a 3b                	push   $0x3b
c0029246:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c002924c:	50                   	push   %eax
c002924d:	e8 db fe ff ff       	call   c002912d <debug_panic>

c0029252 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin(struct list *list) {
c0029252:	53                   	push   %ebx
c0029253:	83 ec 08             	sub    $0x8,%esp
c0029256:	e8 e8 6e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002925b:	81 c3 51 4a 01 00    	add    $0x14a51,%ebx
c0029261:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029265:	85 c0                	test   %eax,%eax
c0029267:	74 08                	je     c0029271 <list_begin+0x1f>
    return list->head.next;
c0029269:	8b 40 04             	mov    0x4(%eax),%eax
}
c002926c:	83 c4 08             	add    $0x8,%esp
c002926f:	5b                   	pop    %ebx
c0029270:	c3                   	ret    
    ASSERT (list != NULL);
c0029271:	83 ec 0c             	sub    $0xc,%esp
c0029274:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c002927a:	50                   	push   %eax
c002927b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029281:	50                   	push   %eax
c0029282:	8d 83 60 32 ff ff    	lea    -0xcda0(%ebx),%eax
c0029288:	50                   	push   %eax
c0029289:	6a 45                	push   $0x45
c002928b:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029291:	50                   	push   %eax
c0029292:	e8 96 fe ff ff       	call   c002912d <debug_panic>

c0029297 <list_next>:

/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next(struct list_elem *elem) {
c0029297:	53                   	push   %ebx
c0029298:	83 ec 08             	sub    $0x8,%esp
c002929b:	e8 a3 6e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00292a0:	81 c3 0c 4a 01 00    	add    $0x14a0c,%ebx
c00292a6:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev == NULL && elem->next != NULL;
c00292aa:	85 c0                	test   %eax,%eax
c00292ac:	74 20                	je     c00292ce <list_next+0x37>
c00292ae:	83 38 00             	cmpl   $0x0,(%eax)
c00292b1:	74 13                	je     c00292c6 <list_next+0x2f>
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00292b3:	83 38 00             	cmpl   $0x0,(%eax)
c00292b6:	74 16                	je     c00292ce <list_next+0x37>
c00292b8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00292bc:	74 10                	je     c00292ce <list_next+0x37>
    ASSERT (is_head(elem) || is_interior(elem));
    return elem->next;
c00292be:	8b 40 04             	mov    0x4(%eax),%eax
}
c00292c1:	83 c4 08             	add    $0x8,%esp
c00292c4:	5b                   	pop    %ebx
c00292c5:	c3                   	ret    
    return elem != NULL && elem->prev == NULL && elem->next != NULL;
c00292c6:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00292ca:	75 f2                	jne    c00292be <list_next+0x27>
c00292cc:	eb e5                	jmp    c00292b3 <list_next+0x1c>
    ASSERT (is_head(elem) || is_interior(elem));
c00292ce:	83 ec 0c             	sub    $0xc,%esp
c00292d1:	8d 83 9c 54 ff ff    	lea    -0xab64(%ebx),%eax
c00292d7:	50                   	push   %eax
c00292d8:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00292de:	50                   	push   %eax
c00292df:	8d 83 54 32 ff ff    	lea    -0xcdac(%ebx),%eax
c00292e5:	50                   	push   %eax
c00292e6:	6a 4e                	push   $0x4e
c00292e8:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c00292ee:	50                   	push   %eax
c00292ef:	e8 39 fe ff ff       	call   c002912d <debug_panic>

c00292f4 <list_end>:

   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end(struct list *list) {
c00292f4:	53                   	push   %ebx
c00292f5:	83 ec 08             	sub    $0x8,%esp
c00292f8:	e8 46 6e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00292fd:	81 c3 af 49 01 00    	add    $0x149af,%ebx
c0029303:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029307:	85 c0                	test   %eax,%eax
c0029309:	74 08                	je     c0029313 <list_end+0x1f>
    return &list->tail;
c002930b:	83 c0 08             	add    $0x8,%eax
}
c002930e:	83 c4 08             	add    $0x8,%esp
c0029311:	5b                   	pop    %ebx
c0029312:	c3                   	ret    
    ASSERT (list != NULL);
c0029313:	83 ec 0c             	sub    $0xc,%esp
c0029316:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c002931c:	50                   	push   %eax
c002931d:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029323:	50                   	push   %eax
c0029324:	8d 83 48 32 ff ff    	lea    -0xcdb8(%ebx),%eax
c002932a:	50                   	push   %eax
c002932b:	6a 59                	push   $0x59
c002932d:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029333:	50                   	push   %eax
c0029334:	e8 f4 fd ff ff       	call   c002912d <debug_panic>

c0029339 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin(struct list *list) {
c0029339:	53                   	push   %ebx
c002933a:	83 ec 08             	sub    $0x8,%esp
c002933d:	e8 01 6e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029342:	81 c3 6a 49 01 00    	add    $0x1496a,%ebx
c0029348:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c002934c:	85 c0                	test   %eax,%eax
c002934e:	74 08                	je     c0029358 <list_rbegin+0x1f>
    return list->tail.prev;
c0029350:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029353:	83 c4 08             	add    $0x8,%esp
c0029356:	5b                   	pop    %ebx
c0029357:	c3                   	ret    
    ASSERT (list != NULL);
c0029358:	83 ec 0c             	sub    $0xc,%esp
c002935b:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c0029361:	50                   	push   %eax
c0029362:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029368:	50                   	push   %eax
c0029369:	8d 83 3c 32 ff ff    	lea    -0xcdc4(%ebx),%eax
c002936f:	50                   	push   %eax
c0029370:	6a 61                	push   $0x61
c0029372:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029378:	50                   	push   %eax
c0029379:	e8 af fd ff ff       	call   c002912d <debug_panic>

c002937e <list_prev>:

/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev(struct list_elem *elem) {
c002937e:	53                   	push   %ebx
c002937f:	83 ec 08             	sub    $0x8,%esp
c0029382:	e8 bc 6d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029387:	81 c3 25 49 01 00    	add    $0x14925,%ebx
c002938d:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029391:	85 c0                	test   %eax,%eax
c0029393:	74 1d                	je     c00293b2 <list_prev+0x34>
c0029395:	83 38 00             	cmpl   $0x0,(%eax)
c0029398:	74 0d                	je     c00293a7 <list_prev+0x29>
c002939a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002939e:	74 07                	je     c00293a7 <list_prev+0x29>
    ASSERT (is_interior(elem) || is_tail(elem));
    return elem->prev;
c00293a0:	8b 00                	mov    (%eax),%eax
}
c00293a2:	83 c4 08             	add    $0x8,%esp
c00293a5:	5b                   	pop    %ebx
c00293a6:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00293a7:	83 38 00             	cmpl   $0x0,(%eax)
c00293aa:	74 06                	je     c00293b2 <list_prev+0x34>
c00293ac:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00293b0:	74 ee                	je     c00293a0 <list_prev+0x22>
    ASSERT (is_interior(elem) || is_tail(elem));
c00293b2:	83 ec 0c             	sub    $0xc,%esp
c00293b5:	8d 83 c0 54 ff ff    	lea    -0xab40(%ebx),%eax
c00293bb:	50                   	push   %eax
c00293bc:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00293c2:	50                   	push   %eax
c00293c3:	8d 83 30 32 ff ff    	lea    -0xcdd0(%ebx),%eax
c00293c9:	50                   	push   %eax
c00293ca:	6a 6a                	push   $0x6a
c00293cc:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c00293d2:	50                   	push   %eax
c00293d3:	e8 55 fd ff ff       	call   c002912d <debug_panic>

c00293d8 <find_end_of_run>:
   given auxiliary data AUX.  Returns the (exclusive) end of the
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run(struct list_elem *a, struct list_elem *b,
                list_less_func *less, void *aux) {
c00293d8:	55                   	push   %ebp
c00293d9:	57                   	push   %edi
c00293da:	56                   	push   %esi
c00293db:	53                   	push   %ebx
c00293dc:	83 ec 1c             	sub    $0x1c,%esp
c00293df:	e8 6b 6d 00 00       	call   c003014f <__x86.get_pc_thunk.di>
c00293e4:	81 c7 c8 48 01 00    	add    $0x148c8,%edi
c00293ea:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c00293ee:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    ASSERT (a != NULL);
c00293f2:	85 c0                	test   %eax,%eax
c00293f4:	74 4e                	je     c0029444 <find_end_of_run+0x6c>
c00293f6:	89 c3                	mov    %eax,%ebx
c00293f8:	89 d6                	mov    %edx,%esi
c00293fa:	89 cf                	mov    %ecx,%edi
    ASSERT (b != NULL);
c00293fc:	85 d2                	test   %edx,%edx
c00293fe:	74 71                	je     c0029471 <find_end_of_run+0x99>
    ASSERT (less != NULL);
c0029400:	85 c9                	test   %ecx,%ecx
c0029402:	0f 84 96 00 00 00    	je     c002949e <find_end_of_run+0xc6>
    ASSERT (a != b);
c0029408:	39 d0                	cmp    %edx,%eax
c002940a:	0f 84 bb 00 00 00    	je     c00294cb <find_end_of_run+0xf3>

    do {
        a = list_next(a);
c0029410:	83 ec 0c             	sub    $0xc,%esp
c0029413:	53                   	push   %ebx
c0029414:	e8 7e fe ff ff       	call   c0029297 <list_next>
c0029419:	83 c4 10             	add    $0x10,%esp
c002941c:	89 c3                	mov    %eax,%ebx
    } while (a != b && !less(a, list_prev(a), aux));
c002941e:	39 c6                	cmp    %eax,%esi
c0029420:	74 18                	je     c002943a <find_end_of_run+0x62>
c0029422:	83 ec 0c             	sub    $0xc,%esp
c0029425:	50                   	push   %eax
c0029426:	e8 53 ff ff ff       	call   c002937e <list_prev>
c002942b:	83 c4 0c             	add    $0xc,%esp
c002942e:	55                   	push   %ebp
c002942f:	50                   	push   %eax
c0029430:	53                   	push   %ebx
c0029431:	ff d7                	call   *%edi
c0029433:	83 c4 10             	add    $0x10,%esp
c0029436:	84 c0                	test   %al,%al
c0029438:	74 d6                	je     c0029410 <find_end_of_run+0x38>
    return a;
}
c002943a:	89 d8                	mov    %ebx,%eax
c002943c:	83 c4 1c             	add    $0x1c,%esp
c002943f:	5b                   	pop    %ebx
c0029440:	5e                   	pop    %esi
c0029441:	5f                   	pop    %edi
c0029442:	5d                   	pop    %ebp
c0029443:	c3                   	ret    
    ASSERT (a != NULL);
c0029444:	83 ec 0c             	sub    $0xc,%esp
c0029447:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002944b:	8d 83 79 42 ff ff    	lea    -0xbd87(%ebx),%eax
c0029451:	50                   	push   %eax
c0029452:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029458:	50                   	push   %eax
c0029459:	8d 83 b4 31 ff ff    	lea    -0xce4c(%ebx),%eax
c002945f:	50                   	push   %eax
c0029460:	68 4d 01 00 00       	push   $0x14d
c0029465:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c002946b:	50                   	push   %eax
c002946c:	e8 bc fc ff ff       	call   c002912d <debug_panic>
    ASSERT (b != NULL);
c0029471:	83 ec 0c             	sub    $0xc,%esp
c0029474:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029478:	8d 83 03 54 ff ff    	lea    -0xabfd(%ebx),%eax
c002947e:	50                   	push   %eax
c002947f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029485:	50                   	push   %eax
c0029486:	8d 83 b4 31 ff ff    	lea    -0xce4c(%ebx),%eax
c002948c:	50                   	push   %eax
c002948d:	68 4e 01 00 00       	push   $0x14e
c0029492:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029498:	50                   	push   %eax
c0029499:	e8 8f fc ff ff       	call   c002912d <debug_panic>
    ASSERT (less != NULL);
c002949e:	83 ec 0c             	sub    $0xc,%esp
c00294a1:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00294a5:	8d 83 0d 54 ff ff    	lea    -0xabf3(%ebx),%eax
c00294ab:	50                   	push   %eax
c00294ac:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00294b2:	50                   	push   %eax
c00294b3:	8d 83 b4 31 ff ff    	lea    -0xce4c(%ebx),%eax
c00294b9:	50                   	push   %eax
c00294ba:	68 4f 01 00 00       	push   $0x14f
c00294bf:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c00294c5:	50                   	push   %eax
c00294c6:	e8 62 fc ff ff       	call   c002912d <debug_panic>
    ASSERT (a != b);
c00294cb:	83 ec 0c             	sub    $0xc,%esp
c00294ce:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00294d2:	8d 83 1a 54 ff ff    	lea    -0xabe6(%ebx),%eax
c00294d8:	50                   	push   %eax
c00294d9:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00294df:	50                   	push   %eax
c00294e0:	8d 83 b4 31 ff ff    	lea    -0xce4c(%ebx),%eax
c00294e6:	50                   	push   %eax
c00294e7:	68 50 01 00 00       	push   $0x150
c00294ec:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c00294f2:	50                   	push   %eax
c00294f3:	e8 35 fc ff ff       	call   c002912d <debug_panic>

c00294f8 <is_sorted>:
          list_less_func *less, void *aux) {
c00294f8:	55                   	push   %ebp
c00294f9:	57                   	push   %edi
c00294fa:	56                   	push   %esi
c00294fb:	53                   	push   %ebx
c00294fc:	83 ec 0c             	sub    $0xc,%esp
c00294ff:	89 c3                	mov    %eax,%ebx
c0029501:	89 d6                	mov    %edx,%esi
c0029503:	89 cd                	mov    %ecx,%ebp
c0029505:	8b 7c 24 20          	mov    0x20(%esp),%edi
    if (a != b)
c0029509:	39 d0                	cmp    %edx,%eax
c002950b:	74 31                	je     c002953e <is_sorted+0x46>
        while ((a = list_next(a)) != b)
c002950d:	83 ec 0c             	sub    $0xc,%esp
c0029510:	53                   	push   %ebx
c0029511:	e8 81 fd ff ff       	call   c0029297 <list_next>
c0029516:	83 c4 10             	add    $0x10,%esp
c0029519:	89 c3                	mov    %eax,%ebx
c002951b:	39 c6                	cmp    %eax,%esi
c002951d:	74 26                	je     c0029545 <is_sorted+0x4d>
            if (less(a, list_prev(a), aux))
c002951f:	83 ec 0c             	sub    $0xc,%esp
c0029522:	53                   	push   %ebx
c0029523:	e8 56 fe ff ff       	call   c002937e <list_prev>
c0029528:	83 c4 0c             	add    $0xc,%esp
c002952b:	57                   	push   %edi
c002952c:	50                   	push   %eax
c002952d:	53                   	push   %ebx
c002952e:	ff d5                	call   *%ebp
c0029530:	83 c4 10             	add    $0x10,%esp
c0029533:	84 c0                	test   %al,%al
c0029535:	74 d6                	je     c002950d <is_sorted+0x15>
                return false;
c0029537:	b8 00 00 00 00       	mov    $0x0,%eax
c002953c:	eb 0c                	jmp    c002954a <is_sorted+0x52>
    return true;
c002953e:	b8 01 00 00 00       	mov    $0x1,%eax
c0029543:	eb 05                	jmp    c002954a <is_sorted+0x52>
c0029545:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002954a:	83 c4 0c             	add    $0xc,%esp
c002954d:	5b                   	pop    %ebx
c002954e:	5e                   	pop    %esi
c002954f:	5f                   	pop    %edi
c0029550:	5d                   	pop    %ebp
c0029551:	c3                   	ret    

c0029552 <list_rend>:
list_rend(struct list *list) {
c0029552:	53                   	push   %ebx
c0029553:	83 ec 08             	sub    $0x8,%esp
c0029556:	e8 e8 6b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002955b:	81 c3 51 47 01 00    	add    $0x14751,%ebx
c0029561:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029565:	85 c0                	test   %eax,%eax
c0029567:	74 05                	je     c002956e <list_rend+0x1c>
}
c0029569:	83 c4 08             	add    $0x8,%esp
c002956c:	5b                   	pop    %ebx
c002956d:	c3                   	ret    
    ASSERT (list != NULL);
c002956e:	83 ec 0c             	sub    $0xc,%esp
c0029571:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c0029577:	50                   	push   %eax
c0029578:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002957e:	50                   	push   %eax
c002957f:	8d 83 24 32 ff ff    	lea    -0xcddc(%ebx),%eax
c0029585:	50                   	push   %eax
c0029586:	6a 7d                	push   $0x7d
c0029588:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c002958e:	50                   	push   %eax
c002958f:	e8 99 fb ff ff       	call   c002912d <debug_panic>

c0029594 <list_head>:
list_head(struct list *list) {
c0029594:	53                   	push   %ebx
c0029595:	83 ec 08             	sub    $0x8,%esp
c0029598:	e8 a6 6b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002959d:	81 c3 0f 47 01 00    	add    $0x1470f,%ebx
c00295a3:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c00295a7:	85 c0                	test   %eax,%eax
c00295a9:	74 05                	je     c00295b0 <list_head+0x1c>
}
c00295ab:	83 c4 08             	add    $0x8,%esp
c00295ae:	5b                   	pop    %ebx
c00295af:	c3                   	ret    
    ASSERT (list != NULL);
c00295b0:	83 ec 0c             	sub    $0xc,%esp
c00295b3:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c00295b9:	50                   	push   %eax
c00295ba:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00295c0:	50                   	push   %eax
c00295c1:	8d 83 18 32 ff ff    	lea    -0xcde8(%ebx),%eax
c00295c7:	50                   	push   %eax
c00295c8:	68 8e 00 00 00       	push   $0x8e
c00295cd:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c00295d3:	50                   	push   %eax
c00295d4:	e8 54 fb ff ff       	call   c002912d <debug_panic>

c00295d9 <list_tail>:
list_tail(struct list *list) {
c00295d9:	53                   	push   %ebx
c00295da:	83 ec 08             	sub    $0x8,%esp
c00295dd:	e8 61 6b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00295e2:	81 c3 ca 46 01 00    	add    $0x146ca,%ebx
c00295e8:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c00295ec:	85 c0                	test   %eax,%eax
c00295ee:	74 08                	je     c00295f8 <list_tail+0x1f>
    return &list->tail;
c00295f0:	83 c0 08             	add    $0x8,%eax
}
c00295f3:	83 c4 08             	add    $0x8,%esp
c00295f6:	5b                   	pop    %ebx
c00295f7:	c3                   	ret    
    ASSERT (list != NULL);
c00295f8:	83 ec 0c             	sub    $0xc,%esp
c00295fb:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c0029601:	50                   	push   %eax
c0029602:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029608:	50                   	push   %eax
c0029609:	8d 83 0c 32 ff ff    	lea    -0xcdf4(%ebx),%eax
c002960f:	50                   	push   %eax
c0029610:	68 95 00 00 00       	push   $0x95
c0029615:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c002961b:	50                   	push   %eax
c002961c:	e8 0c fb ff ff       	call   c002912d <debug_panic>

c0029621 <list_insert>:
list_insert(struct list_elem *before, struct list_elem *elem) {
c0029621:	53                   	push   %ebx
c0029622:	83 ec 08             	sub    $0x8,%esp
c0029625:	e8 19 6b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002962a:	81 c3 82 46 01 00    	add    $0x14682,%ebx
c0029630:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029634:	8b 54 24 14          	mov    0x14(%esp),%edx
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029638:	85 c0                	test   %eax,%eax
c002963a:	74 2d                	je     c0029669 <list_insert+0x48>
c002963c:	83 38 00             	cmpl   $0x0,(%eax)
c002963f:	74 1d                	je     c002965e <list_insert+0x3d>
c0029641:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029645:	74 17                	je     c002965e <list_insert+0x3d>
    ASSERT (elem != NULL);
c0029647:	85 d2                	test   %edx,%edx
c0029649:	74 47                	je     c0029692 <list_insert+0x71>
    elem->prev = before->prev;
c002964b:	8b 08                	mov    (%eax),%ecx
c002964d:	89 0a                	mov    %ecx,(%edx)
    elem->next = before;
c002964f:	89 42 04             	mov    %eax,0x4(%edx)
    before->prev->next = elem;
c0029652:	8b 08                	mov    (%eax),%ecx
c0029654:	89 51 04             	mov    %edx,0x4(%ecx)
    before->prev = elem;
c0029657:	89 10                	mov    %edx,(%eax)
}
c0029659:	83 c4 08             	add    $0x8,%esp
c002965c:	5b                   	pop    %ebx
c002965d:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002965e:	83 38 00             	cmpl   $0x0,(%eax)
c0029661:	74 06                	je     c0029669 <list_insert+0x48>
c0029663:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029667:	74 de                	je     c0029647 <list_insert+0x26>
    ASSERT (is_interior(before) || is_tail(before));
c0029669:	83 ec 0c             	sub    $0xc,%esp
c002966c:	8d 83 e4 54 ff ff    	lea    -0xab1c(%ebx),%eax
c0029672:	50                   	push   %eax
c0029673:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029679:	50                   	push   %eax
c002967a:	8d 83 00 32 ff ff    	lea    -0xce00(%ebx),%eax
c0029680:	50                   	push   %eax
c0029681:	68 9e 00 00 00       	push   $0x9e
c0029686:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c002968c:	50                   	push   %eax
c002968d:	e8 9b fa ff ff       	call   c002912d <debug_panic>
    ASSERT (elem != NULL);
c0029692:	83 ec 0c             	sub    $0xc,%esp
c0029695:	8d 83 21 54 ff ff    	lea    -0xabdf(%ebx),%eax
c002969b:	50                   	push   %eax
c002969c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00296a2:	50                   	push   %eax
c00296a3:	8d 83 00 32 ff ff    	lea    -0xce00(%ebx),%eax
c00296a9:	50                   	push   %eax
c00296aa:	68 9f 00 00 00       	push   $0x9f
c00296af:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c00296b5:	50                   	push   %eax
c00296b6:	e8 72 fa ff ff       	call   c002912d <debug_panic>

c00296bb <list_splice>:
            struct list_elem *first, struct list_elem *last) {
c00296bb:	57                   	push   %edi
c00296bc:	56                   	push   %esi
c00296bd:	53                   	push   %ebx
c00296be:	e8 80 6a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00296c3:	81 c3 e9 45 01 00    	add    $0x145e9,%ebx
c00296c9:	8b 74 24 10          	mov    0x10(%esp),%esi
c00296cd:	8b 7c 24 14          	mov    0x14(%esp),%edi
c00296d1:	8b 44 24 18          	mov    0x18(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00296d5:	85 f6                	test   %esi,%esi
c00296d7:	74 6e                	je     c0029747 <list_splice+0x8c>
c00296d9:	83 3e 00             	cmpl   $0x0,(%esi)
c00296dc:	74 5e                	je     c002973c <list_splice+0x81>
c00296de:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c00296e2:	74 58                	je     c002973c <list_splice+0x81>
    if (first == last)
c00296e4:	39 c7                	cmp    %eax,%edi
c00296e6:	74 50                	je     c0029738 <list_splice+0x7d>
    last = list_prev(last);
c00296e8:	83 ec 0c             	sub    $0xc,%esp
c00296eb:	50                   	push   %eax
c00296ec:	e8 8d fc ff ff       	call   c002937e <list_prev>
c00296f1:	83 c4 10             	add    $0x10,%esp
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00296f4:	85 ff                	test   %edi,%edi
c00296f6:	0f 84 9d 00 00 00    	je     c0029799 <list_splice+0xde>
c00296fc:	8b 17                	mov    (%edi),%edx
c00296fe:	85 d2                	test   %edx,%edx
c0029700:	0f 84 93 00 00 00    	je     c0029799 <list_splice+0xde>
c0029706:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c002970a:	0f 84 89 00 00 00    	je     c0029799 <list_splice+0xde>
c0029710:	85 c0                	test   %eax,%eax
c0029712:	74 5c                	je     c0029770 <list_splice+0xb5>
c0029714:	83 38 00             	cmpl   $0x0,(%eax)
c0029717:	74 57                	je     c0029770 <list_splice+0xb5>
c0029719:	8b 48 04             	mov    0x4(%eax),%ecx
c002971c:	85 c9                	test   %ecx,%ecx
c002971e:	74 50                	je     c0029770 <list_splice+0xb5>
    first->prev->next = last->next;
c0029720:	89 4a 04             	mov    %ecx,0x4(%edx)
    last->next->prev = first->prev;
c0029723:	8b 50 04             	mov    0x4(%eax),%edx
c0029726:	8b 0f                	mov    (%edi),%ecx
c0029728:	89 0a                	mov    %ecx,(%edx)
    first->prev = before->prev;
c002972a:	8b 16                	mov    (%esi),%edx
c002972c:	89 17                	mov    %edx,(%edi)
    last->next = before;
c002972e:	89 70 04             	mov    %esi,0x4(%eax)
    before->prev->next = first;
c0029731:	8b 16                	mov    (%esi),%edx
c0029733:	89 7a 04             	mov    %edi,0x4(%edx)
    before->prev = last;
c0029736:	89 06                	mov    %eax,(%esi)
}
c0029738:	5b                   	pop    %ebx
c0029739:	5e                   	pop    %esi
c002973a:	5f                   	pop    %edi
c002973b:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002973c:	83 3e 00             	cmpl   $0x0,(%esi)
c002973f:	74 06                	je     c0029747 <list_splice+0x8c>
c0029741:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029745:	74 9d                	je     c00296e4 <list_splice+0x29>
    ASSERT (is_interior(before) || is_tail(before));
c0029747:	83 ec 0c             	sub    $0xc,%esp
c002974a:	8d 83 e4 54 ff ff    	lea    -0xab1c(%ebx),%eax
c0029750:	50                   	push   %eax
c0029751:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029757:	50                   	push   %eax
c0029758:	8d 83 f4 31 ff ff    	lea    -0xce0c(%ebx),%eax
c002975e:	50                   	push   %eax
c002975f:	68 ad 00 00 00       	push   $0xad
c0029764:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c002976a:	50                   	push   %eax
c002976b:	e8 bd f9 ff ff       	call   c002912d <debug_panic>
    ASSERT (is_interior(last));
c0029770:	83 ec 0c             	sub    $0xc,%esp
c0029773:	8d 83 2e 54 ff ff    	lea    -0xabd2(%ebx),%eax
c0029779:	50                   	push   %eax
c002977a:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029780:	50                   	push   %eax
c0029781:	8d 83 f4 31 ff ff    	lea    -0xce0c(%ebx),%eax
c0029787:	50                   	push   %eax
c0029788:	68 b3 00 00 00       	push   $0xb3
c002978d:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029793:	50                   	push   %eax
c0029794:	e8 94 f9 ff ff       	call   c002912d <debug_panic>
    ASSERT (is_interior(first));
c0029799:	83 ec 0c             	sub    $0xc,%esp
c002979c:	8d 83 40 54 ff ff    	lea    -0xabc0(%ebx),%eax
c00297a2:	50                   	push   %eax
c00297a3:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00297a9:	50                   	push   %eax
c00297aa:	8d 83 f4 31 ff ff    	lea    -0xce0c(%ebx),%eax
c00297b0:	50                   	push   %eax
c00297b1:	68 b2 00 00 00       	push   $0xb2
c00297b6:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c00297bc:	50                   	push   %eax
c00297bd:	e8 6b f9 ff ff       	call   c002912d <debug_panic>

c00297c2 <list_push_front>:
list_push_front(struct list *list, struct list_elem *elem) {
c00297c2:	83 ec 18             	sub    $0x18,%esp
    list_insert(list_begin(list), elem);
c00297c5:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297c9:	e8 84 fa ff ff       	call   c0029252 <list_begin>
c00297ce:	83 c4 08             	add    $0x8,%esp
c00297d1:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297d5:	50                   	push   %eax
c00297d6:	e8 46 fe ff ff       	call   c0029621 <list_insert>
}
c00297db:	83 c4 1c             	add    $0x1c,%esp
c00297de:	c3                   	ret    

c00297df <list_push_back>:
list_push_back(struct list *list, struct list_elem *elem) {
c00297df:	83 ec 18             	sub    $0x18,%esp
    list_insert(list_end(list), elem);
c00297e2:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297e6:	e8 09 fb ff ff       	call   c00292f4 <list_end>
c00297eb:	83 c4 08             	add    $0x8,%esp
c00297ee:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297f2:	50                   	push   %eax
c00297f3:	e8 29 fe ff ff       	call   c0029621 <list_insert>
}
c00297f8:	83 c4 1c             	add    $0x1c,%esp
c00297fb:	c3                   	ret    

c00297fc <list_remove>:
list_remove(struct list_elem *elem) {
c00297fc:	53                   	push   %ebx
c00297fd:	83 ec 08             	sub    $0x8,%esp
c0029800:	e8 3e 69 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029805:	81 c3 a7 44 01 00    	add    $0x144a7,%ebx
c002980b:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002980f:	85 c0                	test   %eax,%eax
c0029811:	74 1f                	je     c0029832 <list_remove+0x36>
c0029813:	8b 10                	mov    (%eax),%edx
c0029815:	85 d2                	test   %edx,%edx
c0029817:	74 19                	je     c0029832 <list_remove+0x36>
c0029819:	8b 48 04             	mov    0x4(%eax),%ecx
c002981c:	85 c9                	test   %ecx,%ecx
c002981e:	74 12                	je     c0029832 <list_remove+0x36>
    elem->prev->next = elem->next;
c0029820:	89 4a 04             	mov    %ecx,0x4(%edx)
    elem->next->prev = elem->prev;
c0029823:	8b 50 04             	mov    0x4(%eax),%edx
c0029826:	8b 08                	mov    (%eax),%ecx
c0029828:	89 0a                	mov    %ecx,(%edx)
    return elem->next;
c002982a:	8b 40 04             	mov    0x4(%eax),%eax
}
c002982d:	83 c4 08             	add    $0x8,%esp
c0029830:	5b                   	pop    %ebx
c0029831:	c3                   	ret    
    ASSERT (is_interior(elem));
c0029832:	83 ec 0c             	sub    $0xc,%esp
c0029835:	8d 83 53 54 ff ff    	lea    -0xabad(%ebx),%eax
c002983b:	50                   	push   %eax
c002983c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029842:	50                   	push   %eax
c0029843:	8d 83 e8 31 ff ff    	lea    -0xce18(%ebx),%eax
c0029849:	50                   	push   %eax
c002984a:	68 ea 00 00 00       	push   $0xea
c002984f:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029855:	50                   	push   %eax
c0029856:	e8 d2 f8 ff ff       	call   c002912d <debug_panic>

c002985b <list_size>:
list_size(struct list *list) {
c002985b:	57                   	push   %edi
c002985c:	56                   	push   %esi
c002985d:	53                   	push   %ebx
c002985e:	8b 7c 24 10          	mov    0x10(%esp),%edi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029862:	83 ec 0c             	sub    $0xc,%esp
c0029865:	57                   	push   %edi
c0029866:	e8 e7 f9 ff ff       	call   c0029252 <list_begin>
c002986b:	83 c4 10             	add    $0x10,%esp
c002986e:	89 c3                	mov    %eax,%ebx
    size_t cnt = 0;
c0029870:	be 00 00 00 00       	mov    $0x0,%esi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029875:	83 ec 0c             	sub    $0xc,%esp
c0029878:	57                   	push   %edi
c0029879:	e8 76 fa ff ff       	call   c00292f4 <list_end>
c002987e:	83 c4 10             	add    $0x10,%esp
c0029881:	39 d8                	cmp    %ebx,%eax
c0029883:	74 13                	je     c0029898 <list_size+0x3d>
        cnt++;
c0029885:	83 c6 01             	add    $0x1,%esi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029888:	83 ec 0c             	sub    $0xc,%esp
c002988b:	53                   	push   %ebx
c002988c:	e8 06 fa ff ff       	call   c0029297 <list_next>
c0029891:	83 c4 10             	add    $0x10,%esp
c0029894:	89 c3                	mov    %eax,%ebx
c0029896:	eb dd                	jmp    c0029875 <list_size+0x1a>
}
c0029898:	89 f0                	mov    %esi,%eax
c002989a:	5b                   	pop    %ebx
c002989b:	5e                   	pop    %esi
c002989c:	5f                   	pop    %edi
c002989d:	c3                   	ret    

c002989e <list_empty>:
list_empty(struct list *list) {
c002989e:	56                   	push   %esi
c002989f:	53                   	push   %ebx
c00298a0:	83 ec 10             	sub    $0x10,%esp
c00298a3:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    return list_begin(list) == list_end(list);
c00298a7:	53                   	push   %ebx
c00298a8:	e8 a5 f9 ff ff       	call   c0029252 <list_begin>
c00298ad:	89 c6                	mov    %eax,%esi
c00298af:	89 1c 24             	mov    %ebx,(%esp)
c00298b2:	e8 3d fa ff ff       	call   c00292f4 <list_end>
c00298b7:	39 c6                	cmp    %eax,%esi
c00298b9:	0f 94 c0             	sete   %al
}
c00298bc:	83 c4 14             	add    $0x14,%esp
c00298bf:	5b                   	pop    %ebx
c00298c0:	5e                   	pop    %esi
c00298c1:	c3                   	ret    

c00298c2 <list_front>:
list_front(struct list *list) {
c00298c2:	56                   	push   %esi
c00298c3:	53                   	push   %ebx
c00298c4:	83 ec 10             	sub    $0x10,%esp
c00298c7:	e8 77 68 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00298cc:	81 c3 e0 43 01 00    	add    $0x143e0,%ebx
c00298d2:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    ASSERT (!list_empty(list));
c00298d6:	56                   	push   %esi
c00298d7:	e8 c2 ff ff ff       	call   c002989e <list_empty>
c00298dc:	83 c4 10             	add    $0x10,%esp
c00298df:	84 c0                	test   %al,%al
c00298e1:	75 09                	jne    c00298ec <list_front+0x2a>
    return list->head.next;
c00298e3:	8b 46 04             	mov    0x4(%esi),%eax
}
c00298e6:	83 c4 04             	add    $0x4,%esp
c00298e9:	5b                   	pop    %ebx
c00298ea:	5e                   	pop    %esi
c00298eb:	c3                   	ret    
    ASSERT (!list_empty(list));
c00298ec:	83 ec 0c             	sub    $0xc,%esp
c00298ef:	8d 83 65 54 ff ff    	lea    -0xab9b(%ebx),%eax
c00298f5:	50                   	push   %eax
c00298f6:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c00298fc:	50                   	push   %eax
c00298fd:	8d 83 dc 31 ff ff    	lea    -0xce24(%ebx),%eax
c0029903:	50                   	push   %eax
c0029904:	68 06 01 00 00       	push   $0x106
c0029909:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c002990f:	50                   	push   %eax
c0029910:	e8 18 f8 ff ff       	call   c002912d <debug_panic>

c0029915 <list_pop_front>:
list_pop_front(struct list *list) {
c0029915:	53                   	push   %ebx
c0029916:	83 ec 14             	sub    $0x14,%esp
    struct list_elem *front = list_front(list);
c0029919:	ff 74 24 1c          	pushl  0x1c(%esp)
c002991d:	e8 a0 ff ff ff       	call   c00298c2 <list_front>
c0029922:	89 c3                	mov    %eax,%ebx
    list_remove(front);
c0029924:	89 04 24             	mov    %eax,(%esp)
c0029927:	e8 d0 fe ff ff       	call   c00297fc <list_remove>
}
c002992c:	89 d8                	mov    %ebx,%eax
c002992e:	83 c4 18             	add    $0x18,%esp
c0029931:	5b                   	pop    %ebx
c0029932:	c3                   	ret    

c0029933 <list_back>:
list_back(struct list *list) {
c0029933:	56                   	push   %esi
c0029934:	53                   	push   %ebx
c0029935:	83 ec 10             	sub    $0x10,%esp
c0029938:	e8 06 68 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002993d:	81 c3 6f 43 01 00    	add    $0x1436f,%ebx
c0029943:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    ASSERT (!list_empty(list));
c0029947:	56                   	push   %esi
c0029948:	e8 51 ff ff ff       	call   c002989e <list_empty>
c002994d:	83 c4 10             	add    $0x10,%esp
c0029950:	84 c0                	test   %al,%al
c0029952:	75 09                	jne    c002995d <list_back+0x2a>
    return list->tail.prev;
c0029954:	8b 46 08             	mov    0x8(%esi),%eax
}
c0029957:	83 c4 04             	add    $0x4,%esp
c002995a:	5b                   	pop    %ebx
c002995b:	5e                   	pop    %esi
c002995c:	c3                   	ret    
    ASSERT (!list_empty(list));
c002995d:	83 ec 0c             	sub    $0xc,%esp
c0029960:	8d 83 65 54 ff ff    	lea    -0xab9b(%ebx),%eax
c0029966:	50                   	push   %eax
c0029967:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002996d:	50                   	push   %eax
c002996e:	8d 83 d0 31 ff ff    	lea    -0xce30(%ebx),%eax
c0029974:	50                   	push   %eax
c0029975:	68 0e 01 00 00       	push   $0x10e
c002997a:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029980:	50                   	push   %eax
c0029981:	e8 a7 f7 ff ff       	call   c002912d <debug_panic>

c0029986 <list_pop_back>:
list_pop_back(struct list *list) {
c0029986:	53                   	push   %ebx
c0029987:	83 ec 14             	sub    $0x14,%esp
    struct list_elem *back = list_back(list);
c002998a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002998e:	e8 a0 ff ff ff       	call   c0029933 <list_back>
c0029993:	89 c3                	mov    %eax,%ebx
    list_remove(back);
c0029995:	89 04 24             	mov    %eax,(%esp)
c0029998:	e8 5f fe ff ff       	call   c00297fc <list_remove>
}
c002999d:	89 d8                	mov    %ebx,%eax
c002999f:	83 c4 18             	add    $0x18,%esp
c00299a2:	5b                   	pop    %ebx
c00299a3:	c3                   	ret    

c00299a4 <list_reverse>:
list_reverse(struct list *list) {
c00299a4:	56                   	push   %esi
c00299a5:	53                   	push   %ebx
c00299a6:	83 ec 10             	sub    $0x10,%esp
c00299a9:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    if (!list_empty(list)) {
c00299ad:	56                   	push   %esi
c00299ae:	e8 eb fe ff ff       	call   c002989e <list_empty>
c00299b3:	83 c4 10             	add    $0x10,%esp
c00299b6:	84 c0                	test   %al,%al
c00299b8:	74 06                	je     c00299c0 <list_reverse+0x1c>
}
c00299ba:	83 c4 04             	add    $0x4,%esp
c00299bd:	5b                   	pop    %ebx
c00299be:	5e                   	pop    %esi
c00299bf:	c3                   	ret    
        for (e = list_begin(list); e != list_end(list); e = e->prev)
c00299c0:	83 ec 0c             	sub    $0xc,%esp
c00299c3:	56                   	push   %esi
c00299c4:	e8 89 f8 ff ff       	call   c0029252 <list_begin>
c00299c9:	83 c4 10             	add    $0x10,%esp
c00299cc:	89 c3                	mov    %eax,%ebx
c00299ce:	83 ec 0c             	sub    $0xc,%esp
c00299d1:	56                   	push   %esi
c00299d2:	e8 1d f9 ff ff       	call   c00292f4 <list_end>
c00299d7:	83 c4 10             	add    $0x10,%esp
c00299da:	39 d8                	cmp    %ebx,%eax
c00299dc:	74 0e                	je     c00299ec <list_reverse+0x48>
    struct list_elem *t = *a;
c00299de:	8b 13                	mov    (%ebx),%edx
    *a = *b;
c00299e0:	8b 43 04             	mov    0x4(%ebx),%eax
c00299e3:	89 03                	mov    %eax,(%ebx)
    *b = t;
c00299e5:	89 53 04             	mov    %edx,0x4(%ebx)
        for (e = list_begin(list); e != list_end(list); e = e->prev)
c00299e8:	89 c3                	mov    %eax,%ebx
c00299ea:	eb e2                	jmp    c00299ce <list_reverse+0x2a>
    struct list_elem *t = *a;
c00299ec:	8b 46 04             	mov    0x4(%esi),%eax
    *a = *b;
c00299ef:	8b 56 08             	mov    0x8(%esi),%edx
c00299f2:	89 56 04             	mov    %edx,0x4(%esi)
    *b = t;
c00299f5:	89 46 08             	mov    %eax,0x8(%esi)
    struct list_elem *t = *a;
c00299f8:	8b 0a                	mov    (%edx),%ecx
    *a = *b;
c00299fa:	8b 58 04             	mov    0x4(%eax),%ebx
c00299fd:	89 1a                	mov    %ebx,(%edx)
    *b = t;
c00299ff:	89 48 04             	mov    %ecx,0x4(%eax)
}
c0029a02:	eb b6                	jmp    c00299ba <list_reverse+0x16>

c0029a04 <list_sort>:

/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort(struct list *list, list_less_func *less, void *aux) {
c0029a04:	55                   	push   %ebp
c0029a05:	57                   	push   %edi
c0029a06:	56                   	push   %esi
c0029a07:	53                   	push   %ebx
c0029a08:	83 ec 1c             	sub    $0x1c,%esp
c0029a0b:	e8 37 67 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c0029a10:	05 9c 42 01 00       	add    $0x1429c,%eax
c0029a15:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0029a19:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0029a1d:	8b 7c 24 38          	mov    0x38(%esp),%edi
    size_t output_run_cnt;        /* Number of runs output in current pass. */

    ASSERT (list != NULL);
c0029a21:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0029a26:	74 35                	je     c0029a5d <list_sort+0x59>
    ASSERT (less != NULL);
c0029a28:	85 ed                	test   %ebp,%ebp
c0029a2a:	0f 85 41 02 00 00    	jne    c0029c71 <list_sort+0x26d>
c0029a30:	83 ec 0c             	sub    $0xc,%esp
c0029a33:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a37:	8d 83 0d 54 ff ff    	lea    -0xabf3(%ebx),%eax
c0029a3d:	50                   	push   %eax
c0029a3e:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029a44:	50                   	push   %eax
c0029a45:	8d 83 c4 31 ff ff    	lea    -0xce3c(%ebx),%eax
c0029a4b:	50                   	push   %eax
c0029a4c:	68 79 01 00 00       	push   $0x179
c0029a51:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029a57:	50                   	push   %eax
c0029a58:	e8 d0 f6 ff ff       	call   c002912d <debug_panic>
    ASSERT (list != NULL);
c0029a5d:	83 ec 0c             	sub    $0xc,%esp
c0029a60:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a64:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c0029a6a:	50                   	push   %eax
c0029a6b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029a71:	50                   	push   %eax
c0029a72:	8d 83 c4 31 ff ff    	lea    -0xce3c(%ebx),%eax
c0029a78:	50                   	push   %eax
c0029a79:	68 78 01 00 00       	push   $0x178
c0029a7e:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029a84:	50                   	push   %eax
c0029a85:	e8 a3 f6 ff ff       	call   c002912d <debug_panic>
    ASSERT (a0 != NULL);
c0029a8a:	83 ec 0c             	sub    $0xc,%esp
c0029a8d:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a91:	8d 83 77 54 ff ff    	lea    -0xab89(%ebx),%eax
c0029a97:	50                   	push   %eax
c0029a98:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029a9e:	50                   	push   %eax
c0029a9f:	8d 83 a4 31 ff ff    	lea    -0xce5c(%ebx),%eax
c0029aa5:	50                   	push   %eax
c0029aa6:	68 61 01 00 00       	push   $0x161
c0029aab:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029ab1:	50                   	push   %eax
c0029ab2:	e8 76 f6 ff ff       	call   c002912d <debug_panic>
    ASSERT (a1b0 != NULL);
c0029ab7:	83 ec 0c             	sub    $0xc,%esp
c0029aba:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029abe:	8d 83 82 54 ff ff    	lea    -0xab7e(%ebx),%eax
c0029ac4:	50                   	push   %eax
c0029ac5:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029acb:	50                   	push   %eax
c0029acc:	8d 83 a4 31 ff ff    	lea    -0xce5c(%ebx),%eax
c0029ad2:	50                   	push   %eax
c0029ad3:	68 62 01 00 00       	push   $0x162
c0029ad8:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029ade:	50                   	push   %eax
c0029adf:	e8 49 f6 ff ff       	call   c002912d <debug_panic>
    ASSERT (b1 != NULL);
c0029ae4:	83 ec 0c             	sub    $0xc,%esp
c0029ae7:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029aeb:	8d 83 8f 54 ff ff    	lea    -0xab71(%ebx),%eax
c0029af1:	50                   	push   %eax
c0029af2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029af8:	50                   	push   %eax
c0029af9:	8d 83 a4 31 ff ff    	lea    -0xce5c(%ebx),%eax
c0029aff:	50                   	push   %eax
c0029b00:	68 63 01 00 00       	push   $0x163
c0029b05:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029b0b:	50                   	push   %eax
c0029b0c:	e8 1c f6 ff ff       	call   c002912d <debug_panic>
    ASSERT (is_sorted(a0, a1b0, less, aux));
c0029b11:	83 ec 0c             	sub    $0xc,%esp
c0029b14:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029b18:	8d 83 0c 55 ff ff    	lea    -0xaaf4(%ebx),%eax
c0029b1e:	50                   	push   %eax
c0029b1f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029b25:	50                   	push   %eax
c0029b26:	8d 83 a4 31 ff ff    	lea    -0xce5c(%ebx),%eax
c0029b2c:	50                   	push   %eax
c0029b2d:	68 65 01 00 00       	push   $0x165
c0029b32:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029b38:	50                   	push   %eax
c0029b39:	e8 ef f5 ff ff       	call   c002912d <debug_panic>
            a1b0 = list_next(a1b0);
c0029b3e:	83 ec 0c             	sub    $0xc,%esp
c0029b41:	53                   	push   %ebx
c0029b42:	e8 50 f7 ff ff       	call   c0029297 <list_next>
c0029b47:	89 c3                	mov    %eax,%ebx
            list_splice(a0, list_prev(a1b0), a1b0);
c0029b49:	89 04 24             	mov    %eax,(%esp)
c0029b4c:	e8 2d f8 ff ff       	call   c002937e <list_prev>
c0029b51:	83 c4 0c             	add    $0xc,%esp
c0029b54:	53                   	push   %ebx
c0029b55:	50                   	push   %eax
c0029b56:	56                   	push   %esi
c0029b57:	e8 5f fb ff ff       	call   c00296bb <list_splice>
c0029b5c:	83 c4 10             	add    $0x10,%esp
    while (a0 != a1b0 && a1b0 != b1)
c0029b5f:	39 f3                	cmp    %esi,%ebx
c0029b61:	0f 95 c2             	setne  %dl
c0029b64:	39 5c 24 04          	cmp    %ebx,0x4(%esp)
c0029b68:	0f 95 c0             	setne  %al
c0029b6b:	84 c2                	test   %al,%dl
c0029b6d:	74 1f                	je     c0029b8e <list_sort+0x18a>
        if (!less(a1b0, a0, aux))
c0029b6f:	83 ec 04             	sub    $0x4,%esp
c0029b72:	57                   	push   %edi
c0029b73:	56                   	push   %esi
c0029b74:	53                   	push   %ebx
c0029b75:	ff d5                	call   *%ebp
c0029b77:	83 c4 10             	add    $0x10,%esp
c0029b7a:	84 c0                	test   %al,%al
c0029b7c:	75 c0                	jne    c0029b3e <list_sort+0x13a>
            a0 = list_next(a0);
c0029b7e:	83 ec 0c             	sub    $0xc,%esp
c0029b81:	56                   	push   %esi
c0029b82:	e8 10 f7 ff ff       	call   c0029297 <list_next>
c0029b87:	83 c4 10             	add    $0x10,%esp
c0029b8a:	89 c6                	mov    %eax,%esi
c0029b8c:	eb d1                	jmp    c0029b5f <list_sort+0x15b>
        struct list_elem *a0;     /* Start of first run. */
        struct list_elem *a1b0;   /* End of first run, start of second. */
        struct list_elem *b1;     /* End of second run. */

        output_run_cnt = 0;
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029b8e:	8b 74 24 04          	mov    0x4(%esp),%esi
c0029b92:	83 ec 0c             	sub    $0xc,%esp
c0029b95:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029b99:	e8 56 f7 ff ff       	call   c00292f4 <list_end>
c0029b9e:	83 c4 10             	add    $0x10,%esp
c0029ba1:	39 f0                	cmp    %esi,%eax
c0029ba3:	0f 84 c1 00 00 00    	je     c0029c6a <list_sort+0x266>
            /* Each iteration produces one output run. */
            output_run_cnt++;
c0029ba9:	83 44 24 08 01       	addl   $0x1,0x8(%esp)

            /* Locate two adjacent runs of nondecreasing elements
               A0...A1B0 and A1B0...B1. */
            a1b0 = find_end_of_run(a0, list_end(list), less, aux);
c0029bae:	83 ec 0c             	sub    $0xc,%esp
c0029bb1:	57                   	push   %edi
c0029bb2:	89 e9                	mov    %ebp,%ecx
c0029bb4:	89 c2                	mov    %eax,%edx
c0029bb6:	89 f0                	mov    %esi,%eax
c0029bb8:	e8 1b f8 ff ff       	call   c00293d8 <find_end_of_run>
c0029bbd:	89 c3                	mov    %eax,%ebx
            if (a1b0 == list_end(list))
c0029bbf:	83 c4 04             	add    $0x4,%esp
c0029bc2:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029bc6:	e8 29 f7 ff ff       	call   c00292f4 <list_end>
c0029bcb:	83 c4 10             	add    $0x10,%esp
c0029bce:	39 d8                	cmp    %ebx,%eax
c0029bd0:	0f 84 94 00 00 00    	je     c0029c6a <list_sort+0x266>
                break;
            b1 = find_end_of_run(a1b0, list_end(list), less, aux);
c0029bd6:	83 ec 0c             	sub    $0xc,%esp
c0029bd9:	57                   	push   %edi
c0029bda:	89 e9                	mov    %ebp,%ecx
c0029bdc:	89 c2                	mov    %eax,%edx
c0029bde:	89 d8                	mov    %ebx,%eax
c0029be0:	e8 f3 f7 ff ff       	call   c00293d8 <find_end_of_run>
c0029be5:	89 44 24 14          	mov    %eax,0x14(%esp)
    ASSERT (a0 != NULL);
c0029be9:	83 c4 10             	add    $0x10,%esp
c0029bec:	85 f6                	test   %esi,%esi
c0029bee:	0f 84 96 fe ff ff    	je     c0029a8a <list_sort+0x86>
    ASSERT (a1b0 != NULL);
c0029bf4:	85 db                	test   %ebx,%ebx
c0029bf6:	0f 84 bb fe ff ff    	je     c0029ab7 <list_sort+0xb3>
    ASSERT (b1 != NULL);
c0029bfc:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0029c01:	0f 84 dd fe ff ff    	je     c0029ae4 <list_sort+0xe0>
    ASSERT (is_sorted(a0, a1b0, less, aux));
c0029c07:	83 ec 0c             	sub    $0xc,%esp
c0029c0a:	57                   	push   %edi
c0029c0b:	89 e9                	mov    %ebp,%ecx
c0029c0d:	89 da                	mov    %ebx,%edx
c0029c0f:	89 f0                	mov    %esi,%eax
c0029c11:	e8 e2 f8 ff ff       	call   c00294f8 <is_sorted>
c0029c16:	83 c4 10             	add    $0x10,%esp
c0029c19:	84 c0                	test   %al,%al
c0029c1b:	0f 84 f0 fe ff ff    	je     c0029b11 <list_sort+0x10d>
    ASSERT (is_sorted(a1b0, b1, less, aux));
c0029c21:	83 ec 0c             	sub    $0xc,%esp
c0029c24:	57                   	push   %edi
c0029c25:	89 e9                	mov    %ebp,%ecx
c0029c27:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029c2b:	89 d8                	mov    %ebx,%eax
c0029c2d:	e8 c6 f8 ff ff       	call   c00294f8 <is_sorted>
c0029c32:	83 c4 10             	add    $0x10,%esp
c0029c35:	84 c0                	test   %al,%al
c0029c37:	0f 85 22 ff ff ff    	jne    c0029b5f <list_sort+0x15b>
c0029c3d:	83 ec 0c             	sub    $0xc,%esp
c0029c40:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029c44:	8d 83 2c 55 ff ff    	lea    -0xaad4(%ebx),%eax
c0029c4a:	50                   	push   %eax
c0029c4b:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029c51:	50                   	push   %eax
c0029c52:	8d 83 a4 31 ff ff    	lea    -0xce5c(%ebx),%eax
c0029c58:	50                   	push   %eax
c0029c59:	68 66 01 00 00       	push   $0x166
c0029c5e:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029c64:	50                   	push   %eax
c0029c65:	e8 c3 f4 ff ff       	call   c002912d <debug_panic>

            /* Merge the runs. */
            inplace_merge(a0, a1b0, b1, less, aux);
        }
    } while (output_run_cnt > 1);
c0029c6a:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
c0029c6f:	76 1e                	jbe    c0029c8f <list_sort+0x28b>
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029c71:	83 ec 0c             	sub    $0xc,%esp
c0029c74:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029c78:	e8 d5 f5 ff ff       	call   c0029252 <list_begin>
c0029c7d:	83 c4 10             	add    $0x10,%esp
c0029c80:	89 c6                	mov    %eax,%esi
        output_run_cnt = 0;
c0029c82:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0029c89:	00 
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029c8a:	e9 03 ff ff ff       	jmp    c0029b92 <list_sort+0x18e>

    ASSERT (is_sorted(list_begin(list), list_end(list), less, aux));
c0029c8f:	83 ec 0c             	sub    $0xc,%esp
c0029c92:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029c96:	e8 59 f6 ff ff       	call   c00292f4 <list_end>
c0029c9b:	83 c4 04             	add    $0x4,%esp
c0029c9e:	89 c3                	mov    %eax,%ebx
c0029ca0:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029ca4:	e8 a9 f5 ff ff       	call   c0029252 <list_begin>
c0029ca9:	89 3c 24             	mov    %edi,(%esp)
c0029cac:	89 e9                	mov    %ebp,%ecx
c0029cae:	89 da                	mov    %ebx,%edx
c0029cb0:	e8 43 f8 ff ff       	call   c00294f8 <is_sorted>
c0029cb5:	83 c4 10             	add    $0x10,%esp
c0029cb8:	84 c0                	test   %al,%al
c0029cba:	74 08                	je     c0029cc4 <list_sort+0x2c0>
}
c0029cbc:	83 c4 1c             	add    $0x1c,%esp
c0029cbf:	5b                   	pop    %ebx
c0029cc0:	5e                   	pop    %esi
c0029cc1:	5f                   	pop    %edi
c0029cc2:	5d                   	pop    %ebp
c0029cc3:	c3                   	ret    
    ASSERT (is_sorted(list_begin(list), list_end(list), less, aux));
c0029cc4:	83 ec 0c             	sub    $0xc,%esp
c0029cc7:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029ccb:	8d 83 4c 55 ff ff    	lea    -0xaab4(%ebx),%eax
c0029cd1:	50                   	push   %eax
c0029cd2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029cd8:	50                   	push   %eax
c0029cd9:	8d 83 c4 31 ff ff    	lea    -0xce3c(%ebx),%eax
c0029cdf:	50                   	push   %eax
c0029ce0:	68 93 01 00 00       	push   $0x193
c0029ce5:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029ceb:	50                   	push   %eax
c0029cec:	e8 3c f4 ff ff       	call   c002912d <debug_panic>

c0029cf1 <list_insert_ordered>:
/* Inserts ELEM in the proper position in LIST, which must be
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered(struct list *list, struct list_elem *elem,
                    list_less_func *less, void *aux) {
c0029cf1:	55                   	push   %ebp
c0029cf2:	57                   	push   %edi
c0029cf3:	56                   	push   %esi
c0029cf4:	53                   	push   %ebx
c0029cf5:	83 ec 0c             	sub    $0xc,%esp
c0029cf8:	e8 46 64 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029cfd:	81 c3 af 3f 01 00    	add    $0x13faf,%ebx
c0029d03:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029d07:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029d0b:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    struct list_elem *e;

    ASSERT (list != NULL);
c0029d0f:	85 f6                	test   %esi,%esi
c0029d11:	74 54                	je     c0029d67 <list_insert_ordered+0x76>
    ASSERT (elem != NULL);
c0029d13:	85 ff                	test   %edi,%edi
c0029d15:	74 79                	je     c0029d90 <list_insert_ordered+0x9f>
    ASSERT (less != NULL);
c0029d17:	85 ed                	test   %ebp,%ebp
c0029d19:	0f 84 9a 00 00 00    	je     c0029db9 <list_insert_ordered+0xc8>

    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029d1f:	83 ec 0c             	sub    $0xc,%esp
c0029d22:	56                   	push   %esi
c0029d23:	e8 2a f5 ff ff       	call   c0029252 <list_begin>
c0029d28:	83 c4 10             	add    $0x10,%esp
c0029d2b:	89 c3                	mov    %eax,%ebx
c0029d2d:	83 ec 0c             	sub    $0xc,%esp
c0029d30:	56                   	push   %esi
c0029d31:	e8 be f5 ff ff       	call   c00292f4 <list_end>
c0029d36:	83 c4 10             	add    $0x10,%esp
c0029d39:	39 d8                	cmp    %ebx,%eax
c0029d3b:	0f 84 a1 00 00 00    	je     c0029de2 <list_insert_ordered+0xf1>
        if (less(elem, e, aux))
c0029d41:	83 ec 04             	sub    $0x4,%esp
c0029d44:	ff 74 24 30          	pushl  0x30(%esp)
c0029d48:	53                   	push   %ebx
c0029d49:	57                   	push   %edi
c0029d4a:	ff d5                	call   *%ebp
c0029d4c:	83 c4 10             	add    $0x10,%esp
c0029d4f:	84 c0                	test   %al,%al
c0029d51:	0f 85 8b 00 00 00    	jne    c0029de2 <list_insert_ordered+0xf1>
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029d57:	83 ec 0c             	sub    $0xc,%esp
c0029d5a:	53                   	push   %ebx
c0029d5b:	e8 37 f5 ff ff       	call   c0029297 <list_next>
c0029d60:	83 c4 10             	add    $0x10,%esp
c0029d63:	89 c3                	mov    %eax,%ebx
c0029d65:	eb c6                	jmp    c0029d2d <list_insert_ordered+0x3c>
    ASSERT (list != NULL);
c0029d67:	83 ec 0c             	sub    $0xc,%esp
c0029d6a:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c0029d70:	50                   	push   %eax
c0029d71:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029d77:	50                   	push   %eax
c0029d78:	8d 83 90 31 ff ff    	lea    -0xce70(%ebx),%eax
c0029d7e:	50                   	push   %eax
c0029d7f:	68 9e 01 00 00       	push   $0x19e
c0029d84:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029d8a:	50                   	push   %eax
c0029d8b:	e8 9d f3 ff ff       	call   c002912d <debug_panic>
    ASSERT (elem != NULL);
c0029d90:	83 ec 0c             	sub    $0xc,%esp
c0029d93:	8d 83 21 54 ff ff    	lea    -0xabdf(%ebx),%eax
c0029d99:	50                   	push   %eax
c0029d9a:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029da0:	50                   	push   %eax
c0029da1:	8d 83 90 31 ff ff    	lea    -0xce70(%ebx),%eax
c0029da7:	50                   	push   %eax
c0029da8:	68 9f 01 00 00       	push   $0x19f
c0029dad:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029db3:	50                   	push   %eax
c0029db4:	e8 74 f3 ff ff       	call   c002912d <debug_panic>
    ASSERT (less != NULL);
c0029db9:	83 ec 0c             	sub    $0xc,%esp
c0029dbc:	8d 83 0d 54 ff ff    	lea    -0xabf3(%ebx),%eax
c0029dc2:	50                   	push   %eax
c0029dc3:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029dc9:	50                   	push   %eax
c0029dca:	8d 83 90 31 ff ff    	lea    -0xce70(%ebx),%eax
c0029dd0:	50                   	push   %eax
c0029dd1:	68 a0 01 00 00       	push   $0x1a0
c0029dd6:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029ddc:	50                   	push   %eax
c0029ddd:	e8 4b f3 ff ff       	call   c002912d <debug_panic>
            break;
    return list_insert(e, elem);
c0029de2:	83 ec 08             	sub    $0x8,%esp
c0029de5:	57                   	push   %edi
c0029de6:	53                   	push   %ebx
c0029de7:	e8 35 f8 ff ff       	call   c0029621 <list_insert>
}
c0029dec:	83 c4 1c             	add    $0x1c,%esp
c0029def:	5b                   	pop    %ebx
c0029df0:	5e                   	pop    %esi
c0029df1:	5f                   	pop    %edi
c0029df2:	5d                   	pop    %ebp
c0029df3:	c3                   	ret    

c0029df4 <list_unique>:
   set of adjacent elements that are equal according to LESS
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique(struct list *list, struct list *duplicates,
            list_less_func *less, void *aux) {
c0029df4:	55                   	push   %ebp
c0029df5:	57                   	push   %edi
c0029df6:	56                   	push   %esi
c0029df7:	53                   	push   %ebx
c0029df8:	83 ec 0c             	sub    $0xc,%esp
c0029dfb:	e8 43 63 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029e00:	81 c3 ac 3e 01 00    	add    $0x13eac,%ebx
c0029e06:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0029e0a:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    struct list_elem *elem, *next;

    ASSERT (list != NULL);
c0029e0e:	85 ff                	test   %edi,%edi
c0029e10:	74 1c                	je     c0029e2e <list_unique+0x3a>
    ASSERT (less != NULL);
c0029e12:	85 ed                	test   %ebp,%ebp
c0029e14:	74 41                	je     c0029e57 <list_unique+0x63>
    if (list_empty(list))
c0029e16:	83 ec 0c             	sub    $0xc,%esp
c0029e19:	57                   	push   %edi
c0029e1a:	e8 7f fa ff ff       	call   c002989e <list_empty>
c0029e1f:	83 c4 10             	add    $0x10,%esp
c0029e22:	84 c0                	test   %al,%al
c0029e24:	74 5a                	je     c0029e80 <list_unique+0x8c>
            list_remove(next);
            if (duplicates != NULL)
                list_push_back(duplicates, next);
        } else
            elem = next;
}
c0029e26:	83 c4 0c             	add    $0xc,%esp
c0029e29:	5b                   	pop    %ebx
c0029e2a:	5e                   	pop    %esi
c0029e2b:	5f                   	pop    %edi
c0029e2c:	5d                   	pop    %ebp
c0029e2d:	c3                   	ret    
    ASSERT (list != NULL);
c0029e2e:	83 ec 0c             	sub    $0xc,%esp
c0029e31:	8d 83 de 53 ff ff    	lea    -0xac22(%ebx),%eax
c0029e37:	50                   	push   %eax
c0029e38:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029e3e:	50                   	push   %eax
c0029e3f:	8d 83 84 31 ff ff    	lea    -0xce7c(%ebx),%eax
c0029e45:	50                   	push   %eax
c0029e46:	68 b1 01 00 00       	push   $0x1b1
c0029e4b:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029e51:	50                   	push   %eax
c0029e52:	e8 d6 f2 ff ff       	call   c002912d <debug_panic>
    ASSERT (less != NULL);
c0029e57:	83 ec 0c             	sub    $0xc,%esp
c0029e5a:	8d 83 0d 54 ff ff    	lea    -0xabf3(%ebx),%eax
c0029e60:	50                   	push   %eax
c0029e61:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c0029e67:	50                   	push   %eax
c0029e68:	8d 83 84 31 ff ff    	lea    -0xce7c(%ebx),%eax
c0029e6e:	50                   	push   %eax
c0029e6f:	68 b2 01 00 00       	push   $0x1b2
c0029e74:	8d 83 eb 53 ff ff    	lea    -0xac15(%ebx),%eax
c0029e7a:	50                   	push   %eax
c0029e7b:	e8 ad f2 ff ff       	call   c002912d <debug_panic>
    elem = list_begin(list);
c0029e80:	83 ec 0c             	sub    $0xc,%esp
c0029e83:	57                   	push   %edi
c0029e84:	e8 c9 f3 ff ff       	call   c0029252 <list_begin>
c0029e89:	83 c4 10             	add    $0x10,%esp
c0029e8c:	89 c6                	mov    %eax,%esi
    while ((next = list_next(elem)) != list_end(list))
c0029e8e:	eb 04                	jmp    c0029e94 <list_unique+0xa0>
c0029e90:	89 f3                	mov    %esi,%ebx
c0029e92:	89 de                	mov    %ebx,%esi
c0029e94:	83 ec 0c             	sub    $0xc,%esp
c0029e97:	56                   	push   %esi
c0029e98:	e8 fa f3 ff ff       	call   c0029297 <list_next>
c0029e9d:	89 c3                	mov    %eax,%ebx
c0029e9f:	89 3c 24             	mov    %edi,(%esp)
c0029ea2:	e8 4d f4 ff ff       	call   c00292f4 <list_end>
c0029ea7:	83 c4 10             	add    $0x10,%esp
c0029eaa:	39 d8                	cmp    %ebx,%eax
c0029eac:	0f 84 74 ff ff ff    	je     c0029e26 <list_unique+0x32>
        if (!less(elem, next, aux) && !less(next, elem, aux)) {
c0029eb2:	83 ec 04             	sub    $0x4,%esp
c0029eb5:	ff 74 24 30          	pushl  0x30(%esp)
c0029eb9:	53                   	push   %ebx
c0029eba:	56                   	push   %esi
c0029ebb:	ff d5                	call   *%ebp
c0029ebd:	83 c4 10             	add    $0x10,%esp
c0029ec0:	84 c0                	test   %al,%al
c0029ec2:	75 ce                	jne    c0029e92 <list_unique+0x9e>
c0029ec4:	83 ec 04             	sub    $0x4,%esp
c0029ec7:	ff 74 24 30          	pushl  0x30(%esp)
c0029ecb:	56                   	push   %esi
c0029ecc:	53                   	push   %ebx
c0029ecd:	ff d5                	call   *%ebp
c0029ecf:	83 c4 10             	add    $0x10,%esp
c0029ed2:	84 c0                	test   %al,%al
c0029ed4:	75 bc                	jne    c0029e92 <list_unique+0x9e>
            list_remove(next);
c0029ed6:	83 ec 0c             	sub    $0xc,%esp
c0029ed9:	53                   	push   %ebx
c0029eda:	e8 1d f9 ff ff       	call   c00297fc <list_remove>
            if (duplicates != NULL)
c0029edf:	83 c4 10             	add    $0x10,%esp
c0029ee2:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0029ee7:	74 a7                	je     c0029e90 <list_unique+0x9c>
                list_push_back(duplicates, next);
c0029ee9:	83 ec 08             	sub    $0x8,%esp
c0029eec:	53                   	push   %ebx
c0029eed:	ff 74 24 30          	pushl  0x30(%esp)
c0029ef1:	e8 e9 f8 ff ff       	call   c00297df <list_push_back>
c0029ef6:	83 c4 10             	add    $0x10,%esp
c0029ef9:	89 f3                	mov    %esi,%ebx
c0029efb:	eb 95                	jmp    c0029e92 <list_unique+0x9e>

c0029efd <list_max>:
/* Returns the element in LIST with the largest value according
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max(struct list *list, list_less_func *less, void *aux) {
c0029efd:	55                   	push   %ebp
c0029efe:	57                   	push   %edi
c0029eff:	56                   	push   %esi
c0029f00:	53                   	push   %ebx
c0029f01:	83 ec 18             	sub    $0x18,%esp
c0029f04:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029f08:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    struct list_elem *max = list_begin(list);
c0029f0c:	57                   	push   %edi
c0029f0d:	e8 40 f3 ff ff       	call   c0029252 <list_begin>
c0029f12:	89 c6                	mov    %eax,%esi
    if (max != list_end(list)) {
c0029f14:	89 3c 24             	mov    %edi,(%esp)
c0029f17:	e8 d8 f3 ff ff       	call   c00292f4 <list_end>
c0029f1c:	83 c4 10             	add    $0x10,%esp
c0029f1f:	39 f0                	cmp    %esi,%eax
c0029f21:	74 3c                	je     c0029f5f <list_max+0x62>
        struct list_elem *e;

        for (e = list_next(max); e != list_end(list); e = list_next(e))
c0029f23:	83 ec 0c             	sub    $0xc,%esp
c0029f26:	56                   	push   %esi
c0029f27:	e8 6b f3 ff ff       	call   c0029297 <list_next>
c0029f2c:	83 c4 10             	add    $0x10,%esp
c0029f2f:	89 c3                	mov    %eax,%ebx
c0029f31:	83 ec 0c             	sub    $0xc,%esp
c0029f34:	57                   	push   %edi
c0029f35:	e8 ba f3 ff ff       	call   c00292f4 <list_end>
c0029f3a:	83 c4 10             	add    $0x10,%esp
c0029f3d:	39 d8                	cmp    %ebx,%eax
c0029f3f:	74 1e                	je     c0029f5f <list_max+0x62>
            if (less(max, e, aux))
c0029f41:	83 ec 04             	sub    $0x4,%esp
c0029f44:	55                   	push   %ebp
c0029f45:	53                   	push   %ebx
c0029f46:	56                   	push   %esi
c0029f47:	ff 54 24 34          	call   *0x34(%esp)
c0029f4b:	84 c0                	test   %al,%al
                max = e;
c0029f4d:	0f 45 f3             	cmovne %ebx,%esi
        for (e = list_next(max); e != list_end(list); e = list_next(e))
c0029f50:	89 1c 24             	mov    %ebx,(%esp)
c0029f53:	e8 3f f3 ff ff       	call   c0029297 <list_next>
c0029f58:	83 c4 10             	add    $0x10,%esp
c0029f5b:	89 c3                	mov    %eax,%ebx
c0029f5d:	eb d2                	jmp    c0029f31 <list_max+0x34>
    }
    return max;
}
c0029f5f:	89 f0                	mov    %esi,%eax
c0029f61:	83 c4 0c             	add    $0xc,%esp
c0029f64:	5b                   	pop    %ebx
c0029f65:	5e                   	pop    %esi
c0029f66:	5f                   	pop    %edi
c0029f67:	5d                   	pop    %ebp
c0029f68:	c3                   	ret    

c0029f69 <list_min>:
/* Returns the element in LIST with the smallest value according
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min(struct list *list, list_less_func *less, void *aux) {
c0029f69:	55                   	push   %ebp
c0029f6a:	57                   	push   %edi
c0029f6b:	56                   	push   %esi
c0029f6c:	53                   	push   %ebx
c0029f6d:	83 ec 18             	sub    $0x18,%esp
c0029f70:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029f74:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    struct list_elem *min = list_begin(list);
c0029f78:	57                   	push   %edi
c0029f79:	e8 d4 f2 ff ff       	call   c0029252 <list_begin>
c0029f7e:	89 c6                	mov    %eax,%esi
    if (min != list_end(list)) {
c0029f80:	89 3c 24             	mov    %edi,(%esp)
c0029f83:	e8 6c f3 ff ff       	call   c00292f4 <list_end>
c0029f88:	83 c4 10             	add    $0x10,%esp
c0029f8b:	39 f0                	cmp    %esi,%eax
c0029f8d:	74 3c                	je     c0029fcb <list_min+0x62>
        struct list_elem *e;

        for (e = list_next(min); e != list_end(list); e = list_next(e))
c0029f8f:	83 ec 0c             	sub    $0xc,%esp
c0029f92:	56                   	push   %esi
c0029f93:	e8 ff f2 ff ff       	call   c0029297 <list_next>
c0029f98:	83 c4 10             	add    $0x10,%esp
c0029f9b:	89 c3                	mov    %eax,%ebx
c0029f9d:	83 ec 0c             	sub    $0xc,%esp
c0029fa0:	57                   	push   %edi
c0029fa1:	e8 4e f3 ff ff       	call   c00292f4 <list_end>
c0029fa6:	83 c4 10             	add    $0x10,%esp
c0029fa9:	39 d8                	cmp    %ebx,%eax
c0029fab:	74 1e                	je     c0029fcb <list_min+0x62>
            if (less(e, min, aux))
c0029fad:	83 ec 04             	sub    $0x4,%esp
c0029fb0:	55                   	push   %ebp
c0029fb1:	56                   	push   %esi
c0029fb2:	53                   	push   %ebx
c0029fb3:	ff 54 24 34          	call   *0x34(%esp)
c0029fb7:	84 c0                	test   %al,%al
                min = e;
c0029fb9:	0f 45 f3             	cmovne %ebx,%esi
        for (e = list_next(min); e != list_end(list); e = list_next(e))
c0029fbc:	89 1c 24             	mov    %ebx,(%esp)
c0029fbf:	e8 d3 f2 ff ff       	call   c0029297 <list_next>
c0029fc4:	83 c4 10             	add    $0x10,%esp
c0029fc7:	89 c3                	mov    %eax,%ebx
c0029fc9:	eb d2                	jmp    c0029f9d <list_min+0x34>
    }
    return min;
}
c0029fcb:	89 f0                	mov    %esi,%eax
c0029fcd:	83 c4 0c             	add    $0xc,%esp
c0029fd0:	5b                   	pop    %ebx
c0029fd1:	5e                   	pop    %esi
c0029fd2:	5f                   	pop    %edi
c0029fd3:	5d                   	pop    %ebp
c0029fd4:	c3                   	ret    

c0029fd5 <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029fd5:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029fd9:	83 c0 1f             	add    $0x1f,%eax
c0029fdc:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c0029fdf:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c0029fe6:	c3                   	ret    

c0029fe7 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c0029fe7:	56                   	push   %esi
c0029fe8:	53                   	push   %ebx
c0029fe9:	83 ec 04             	sub    $0x4,%esp
c0029fec:	e8 52 61 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0029ff1:	81 c3 bb 3c 01 00    	add    $0x13cbb,%ebx
c0029ff7:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (b != NULL) 
c0029ffb:	85 f6                	test   %esi,%esi
c0029ffd:	74 16                	je     c002a015 <bitmap_destroy+0x2e>
    {
      free (b->bits);
c0029fff:	83 ec 0c             	sub    $0xc,%esp
c002a002:	ff 76 04             	pushl  0x4(%esi)
c002a005:	e8 f2 9f ff ff       	call   c0023ffc <free>
      free (b);
c002a00a:	89 34 24             	mov    %esi,(%esp)
c002a00d:	e8 ea 9f ff ff       	call   c0023ffc <free>
c002a012:	83 c4 10             	add    $0x10,%esp
    }
}
c002a015:	83 c4 04             	add    $0x4,%esp
c002a018:	5b                   	pop    %ebx
c002a019:	5e                   	pop    %esi
c002a01a:	c3                   	ret    

c002a01b <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c002a01b:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a01f:	8b 00                	mov    (%eax),%eax
}
c002a021:	c3                   	ret    

c002a022 <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002a022:	53                   	push   %ebx
c002a023:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a027:	89 cb                	mov    %ecx,%ebx
c002a029:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a02c:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a030:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a033:	b8 01 00 00 00       	mov    $0x1,%eax
c002a038:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a03a:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c002a03d:	5b                   	pop    %ebx
c002a03e:	c3                   	ret    

c002a03f <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002a03f:	53                   	push   %ebx
c002a040:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a044:	89 cb                	mov    %ecx,%ebx
c002a046:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a049:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a04d:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a050:	b8 01 00 00 00       	mov    $0x1,%eax
c002a055:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a057:	f7 d0                	not    %eax
c002a059:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c002a05c:	5b                   	pop    %ebx
c002a05d:	c3                   	ret    

c002a05e <bitmap_set>:
{
c002a05e:	53                   	push   %ebx
c002a05f:	83 ec 08             	sub    $0x8,%esp
c002a062:	e8 dc 60 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a067:	81 c3 45 3c 01 00    	add    $0x13c45,%ebx
c002a06d:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a071:	8b 54 24 14          	mov    0x14(%esp),%edx
c002a075:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c002a079:	85 c0                	test   %eax,%eax
c002a07b:	74 1a                	je     c002a097 <bitmap_set+0x39>
  ASSERT (idx < b->bit_cnt);
c002a07d:	39 10                	cmp    %edx,(%eax)
c002a07f:	76 3f                	jbe    c002a0c0 <bitmap_set+0x62>
  if (value)
c002a081:	84 c9                	test   %cl,%cl
c002a083:	74 64                	je     c002a0e9 <bitmap_set+0x8b>
    bitmap_mark (b, idx);
c002a085:	83 ec 08             	sub    $0x8,%esp
c002a088:	52                   	push   %edx
c002a089:	50                   	push   %eax
c002a08a:	e8 93 ff ff ff       	call   c002a022 <bitmap_mark>
c002a08f:	83 c4 10             	add    $0x10,%esp
}
c002a092:	83 c4 08             	add    $0x8,%esp
c002a095:	5b                   	pop    %ebx
c002a096:	c3                   	ret    
  ASSERT (b != NULL);
c002a097:	83 ec 0c             	sub    $0xc,%esp
c002a09a:	8d 83 03 54 ff ff    	lea    -0xabfd(%ebx),%eax
c002a0a0:	50                   	push   %eax
c002a0a1:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a0a7:	50                   	push   %eax
c002a0a8:	8d 83 d4 32 ff ff    	lea    -0xcd2c(%ebx),%eax
c002a0ae:	50                   	push   %eax
c002a0af:	68 93 00 00 00       	push   $0x93
c002a0b4:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a0ba:	50                   	push   %eax
c002a0bb:	e8 6d f0 ff ff       	call   c002912d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a0c0:	83 ec 0c             	sub    $0xc,%esp
c002a0c3:	8d 83 9d 55 ff ff    	lea    -0xaa63(%ebx),%eax
c002a0c9:	50                   	push   %eax
c002a0ca:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a0d0:	50                   	push   %eax
c002a0d1:	8d 83 d4 32 ff ff    	lea    -0xcd2c(%ebx),%eax
c002a0d7:	50                   	push   %eax
c002a0d8:	68 94 00 00 00       	push   $0x94
c002a0dd:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a0e3:	50                   	push   %eax
c002a0e4:	e8 44 f0 ff ff       	call   c002912d <debug_panic>
    bitmap_reset (b, idx);
c002a0e9:	83 ec 08             	sub    $0x8,%esp
c002a0ec:	52                   	push   %edx
c002a0ed:	50                   	push   %eax
c002a0ee:	e8 4c ff ff ff       	call   c002a03f <bitmap_reset>
c002a0f3:	83 c4 10             	add    $0x10,%esp
}
c002a0f6:	eb 9a                	jmp    c002a092 <bitmap_set+0x34>

c002a0f8 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002a0f8:	53                   	push   %ebx
c002a0f9:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a0fd:	89 cb                	mov    %ecx,%ebx
c002a0ff:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a102:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a106:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a109:	b8 01 00 00 00       	mov    $0x1,%eax
c002a10e:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a110:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c002a113:	5b                   	pop    %ebx
c002a114:	c3                   	ret    

c002a115 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002a115:	53                   	push   %ebx
c002a116:	83 ec 08             	sub    $0x8,%esp
c002a119:	e8 25 60 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a11e:	81 c3 8e 3b 01 00    	add    $0x13b8e,%ebx
c002a124:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a128:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c002a12c:	85 c0                	test   %eax,%eax
c002a12e:	74 1e                	je     c002a14e <bitmap_test+0x39>
  ASSERT (idx < b->bit_cnt);
c002a130:	39 08                	cmp    %ecx,(%eax)
c002a132:	76 43                	jbe    c002a177 <bitmap_test+0x62>
  return bit_idx / ELEM_BITS;
c002a134:	89 cb                	mov    %ecx,%ebx
c002a136:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a139:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a13c:	b8 01 00 00 00       	mov    $0x1,%eax
c002a141:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a143:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c002a146:	0f 95 c0             	setne  %al
}
c002a149:	83 c4 08             	add    $0x8,%esp
c002a14c:	5b                   	pop    %ebx
c002a14d:	c3                   	ret    
  ASSERT (b != NULL);
c002a14e:	83 ec 0c             	sub    $0xc,%esp
c002a151:	8d 83 03 54 ff ff    	lea    -0xabfd(%ebx),%eax
c002a157:	50                   	push   %eax
c002a158:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a15e:	50                   	push   %eax
c002a15f:	8d 83 c8 32 ff ff    	lea    -0xcd38(%ebx),%eax
c002a165:	50                   	push   %eax
c002a166:	68 c8 00 00 00       	push   $0xc8
c002a16b:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a171:	50                   	push   %eax
c002a172:	e8 b6 ef ff ff       	call   c002912d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a177:	83 ec 0c             	sub    $0xc,%esp
c002a17a:	8d 83 9d 55 ff ff    	lea    -0xaa63(%ebx),%eax
c002a180:	50                   	push   %eax
c002a181:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a187:	50                   	push   %eax
c002a188:	8d 83 c8 32 ff ff    	lea    -0xcd38(%ebx),%eax
c002a18e:	50                   	push   %eax
c002a18f:	68 c9 00 00 00       	push   $0xc9
c002a194:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a19a:	50                   	push   %eax
c002a19b:	e8 8d ef ff ff       	call   c002912d <debug_panic>

c002a1a0 <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a1a0:	55                   	push   %ebp
c002a1a1:	57                   	push   %edi
c002a1a2:	56                   	push   %esi
c002a1a3:	53                   	push   %ebx
c002a1a4:	83 ec 0c             	sub    $0xc,%esp
c002a1a7:	e8 ab 5f 00 00       	call   c0030157 <__x86.get_pc_thunk.cx>
c002a1ac:	81 c1 00 3b 01 00    	add    $0x13b00,%ecx
c002a1b2:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a1b6:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a1ba:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a1be:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a1c3:	85 ff                	test   %edi,%edi
c002a1c5:	74 31                	je     c002a1f8 <bitmap_set_multiple+0x58>
  ASSERT (start <= b->bit_cnt);
c002a1c7:	8b 17                	mov    (%edi),%edx
c002a1c9:	39 f2                	cmp    %esi,%edx
c002a1cb:	72 56                	jb     c002a223 <bitmap_set_multiple+0x83>
  ASSERT (start + cnt <= b->bit_cnt);
c002a1cd:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a1d0:	39 ea                	cmp    %ebp,%edx
c002a1d2:	72 7a                	jb     c002a24e <bitmap_set_multiple+0xae>

  for (i = 0; i < cnt; i++)
    bitmap_set (b, start + i, value);
c002a1d4:	0f b6 db             	movzbl %bl,%ebx
  for (i = 0; i < cnt; i++)
c002a1d7:	85 c0                	test   %eax,%eax
c002a1d9:	74 15                	je     c002a1f0 <bitmap_set_multiple+0x50>
    bitmap_set (b, start + i, value);
c002a1db:	83 ec 04             	sub    $0x4,%esp
c002a1de:	53                   	push   %ebx
c002a1df:	56                   	push   %esi
c002a1e0:	57                   	push   %edi
c002a1e1:	e8 78 fe ff ff       	call   c002a05e <bitmap_set>
c002a1e6:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a1e9:	83 c4 10             	add    $0x10,%esp
c002a1ec:	39 f5                	cmp    %esi,%ebp
c002a1ee:	75 eb                	jne    c002a1db <bitmap_set_multiple+0x3b>
}
c002a1f0:	83 c4 0c             	add    $0xc,%esp
c002a1f3:	5b                   	pop    %ebx
c002a1f4:	5e                   	pop    %esi
c002a1f5:	5f                   	pop    %edi
c002a1f6:	5d                   	pop    %ebp
c002a1f7:	c3                   	ret    
  ASSERT (b != NULL);
c002a1f8:	83 ec 0c             	sub    $0xc,%esp
c002a1fb:	8d 81 03 54 ff ff    	lea    -0xabfd(%ecx),%eax
c002a201:	50                   	push   %eax
c002a202:	8d 81 de 36 ff ff    	lea    -0xc922(%ecx),%eax
c002a208:	50                   	push   %eax
c002a209:	8d 81 a4 32 ff ff    	lea    -0xcd5c(%ecx),%eax
c002a20f:	50                   	push   %eax
c002a210:	68 de 00 00 00       	push   $0xde
c002a215:	8d 81 83 55 ff ff    	lea    -0xaa7d(%ecx),%eax
c002a21b:	50                   	push   %eax
c002a21c:	89 cb                	mov    %ecx,%ebx
c002a21e:	e8 0a ef ff ff       	call   c002912d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a223:	83 ec 0c             	sub    $0xc,%esp
c002a226:	8d 81 ae 55 ff ff    	lea    -0xaa52(%ecx),%eax
c002a22c:	50                   	push   %eax
c002a22d:	8d 81 de 36 ff ff    	lea    -0xc922(%ecx),%eax
c002a233:	50                   	push   %eax
c002a234:	8d 81 a4 32 ff ff    	lea    -0xcd5c(%ecx),%eax
c002a23a:	50                   	push   %eax
c002a23b:	68 df 00 00 00       	push   $0xdf
c002a240:	8d 81 83 55 ff ff    	lea    -0xaa7d(%ecx),%eax
c002a246:	50                   	push   %eax
c002a247:	89 cb                	mov    %ecx,%ebx
c002a249:	e8 df ee ff ff       	call   c002912d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a24e:	83 ec 0c             	sub    $0xc,%esp
c002a251:	8d 81 c2 55 ff ff    	lea    -0xaa3e(%ecx),%eax
c002a257:	50                   	push   %eax
c002a258:	8d 81 de 36 ff ff    	lea    -0xc922(%ecx),%eax
c002a25e:	50                   	push   %eax
c002a25f:	8d 81 a4 32 ff ff    	lea    -0xcd5c(%ecx),%eax
c002a265:	50                   	push   %eax
c002a266:	68 e0 00 00 00       	push   $0xe0
c002a26b:	8d 81 83 55 ff ff    	lea    -0xaa7d(%ecx),%eax
c002a271:	50                   	push   %eax
c002a272:	89 cb                	mov    %ecx,%ebx
c002a274:	e8 b4 ee ff ff       	call   c002912d <debug_panic>

c002a279 <bitmap_set_all>:
{
c002a279:	53                   	push   %ebx
c002a27a:	83 ec 08             	sub    $0x8,%esp
c002a27d:	e8 c1 5e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a282:	81 c3 2a 3a 01 00    	add    $0x13a2a,%ebx
c002a288:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a28c:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c002a290:	85 c0                	test   %eax,%eax
c002a292:	74 13                	je     c002a2a7 <bitmap_set_all+0x2e>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a294:	0f b6 d2             	movzbl %dl,%edx
c002a297:	52                   	push   %edx
c002a298:	ff 30                	pushl  (%eax)
c002a29a:	6a 00                	push   $0x0
c002a29c:	50                   	push   %eax
c002a29d:	e8 fe fe ff ff       	call   c002a1a0 <bitmap_set_multiple>
}
c002a2a2:	83 c4 18             	add    $0x18,%esp
c002a2a5:	5b                   	pop    %ebx
c002a2a6:	c3                   	ret    
  ASSERT (b != NULL);
c002a2a7:	83 ec 0c             	sub    $0xc,%esp
c002a2aa:	8d 83 03 54 ff ff    	lea    -0xabfd(%ebx),%eax
c002a2b0:	50                   	push   %eax
c002a2b1:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a2b7:	50                   	push   %eax
c002a2b8:	8d 83 b8 32 ff ff    	lea    -0xcd48(%ebx),%eax
c002a2be:	50                   	push   %eax
c002a2bf:	68 d3 00 00 00       	push   $0xd3
c002a2c4:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a2ca:	50                   	push   %eax
c002a2cb:	e8 5d ee ff ff       	call   c002912d <debug_panic>

c002a2d0 <bitmap_create>:
{
c002a2d0:	57                   	push   %edi
c002a2d1:	56                   	push   %esi
c002a2d2:	53                   	push   %ebx
c002a2d3:	e8 6b 5e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a2d8:	81 c3 d4 39 01 00    	add    $0x139d4,%ebx
c002a2de:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct bitmap *b = malloc (sizeof *b);
c002a2e2:	83 ec 0c             	sub    $0xc,%esp
c002a2e5:	6a 08                	push   $0x8
c002a2e7:	e8 62 9b ff ff       	call   c0023e4e <malloc>
c002a2ec:	89 c6                	mov    %eax,%esi
  if (b != NULL)
c002a2ee:	83 c4 10             	add    $0x10,%esp
c002a2f1:	85 c0                	test   %eax,%eax
c002a2f3:	74 30                	je     c002a325 <bitmap_create+0x55>
      b->bit_cnt = bit_cnt;
c002a2f5:	89 38                	mov    %edi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a2f7:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a2fa:	8d 47 1f             	lea    0x1f(%edi),%eax
c002a2fd:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a300:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c002a303:	50                   	push   %eax
c002a304:	e8 45 9b ff ff       	call   c0023e4e <malloc>
c002a309:	89 46 04             	mov    %eax,0x4(%esi)
      if (b->bits != NULL || bit_cnt == 0)
c002a30c:	83 c4 10             	add    $0x10,%esp
c002a30f:	85 ff                	test   %edi,%edi
c002a311:	74 04                	je     c002a317 <bitmap_create+0x47>
c002a313:	85 c0                	test   %eax,%eax
c002a315:	74 14                	je     c002a32b <bitmap_create+0x5b>
          bitmap_set_all (b, false);
c002a317:	83 ec 08             	sub    $0x8,%esp
c002a31a:	6a 00                	push   $0x0
c002a31c:	56                   	push   %esi
c002a31d:	e8 57 ff ff ff       	call   c002a279 <bitmap_set_all>
          return b;
c002a322:	83 c4 10             	add    $0x10,%esp
}
c002a325:	89 f0                	mov    %esi,%eax
c002a327:	5b                   	pop    %ebx
c002a328:	5e                   	pop    %esi
c002a329:	5f                   	pop    %edi
c002a32a:	c3                   	ret    
      free (b);
c002a32b:	83 ec 0c             	sub    $0xc,%esp
c002a32e:	56                   	push   %esi
c002a32f:	e8 c8 9c ff ff       	call   c0023ffc <free>
c002a334:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002a337:	be 00 00 00 00       	mov    $0x0,%esi
c002a33c:	eb e7                	jmp    c002a325 <bitmap_create+0x55>

c002a33e <bitmap_create_in_buf>:
{
c002a33e:	57                   	push   %edi
c002a33f:	56                   	push   %esi
c002a340:	53                   	push   %ebx
c002a341:	e8 fd 5d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a346:	81 c3 66 39 01 00    	add    $0x13966,%ebx
c002a34c:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002a350:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a354:	57                   	push   %edi
c002a355:	e8 7b fc ff ff       	call   c0029fd5 <bitmap_buf_size>
c002a35a:	83 c4 04             	add    $0x4,%esp
c002a35d:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002a361:	77 1c                	ja     c002a37f <bitmap_create_in_buf+0x41>
  b->bit_cnt = bit_cnt;
c002a363:	89 3e                	mov    %edi,(%esi)
  b->bits = (elem_type *) (b + 1);
c002a365:	8d 46 08             	lea    0x8(%esi),%eax
c002a368:	89 46 04             	mov    %eax,0x4(%esi)
  bitmap_set_all (b, false);
c002a36b:	83 ec 08             	sub    $0x8,%esp
c002a36e:	6a 00                	push   $0x0
c002a370:	56                   	push   %esi
c002a371:	e8 03 ff ff ff       	call   c002a279 <bitmap_set_all>
  return b;
c002a376:	83 c4 10             	add    $0x10,%esp
}
c002a379:	89 f0                	mov    %esi,%eax
c002a37b:	5b                   	pop    %ebx
c002a37c:	5e                   	pop    %esi
c002a37d:	5f                   	pop    %edi
c002a37e:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a37f:	83 ec 0c             	sub    $0xc,%esp
c002a382:	8d 83 dc 55 ff ff    	lea    -0xaa24(%ebx),%eax
c002a388:	50                   	push   %eax
c002a389:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a38f:	50                   	push   %eax
c002a390:	8d 83 e0 32 ff ff    	lea    -0xcd20(%ebx),%eax
c002a396:	50                   	push   %eax
c002a397:	6a 68                	push   $0x68
c002a399:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a39f:	50                   	push   %eax
c002a3a0:	e8 88 ed ff ff       	call   c002912d <debug_panic>

c002a3a5 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a3a5:	55                   	push   %ebp
c002a3a6:	57                   	push   %edi
c002a3a7:	56                   	push   %esi
c002a3a8:	53                   	push   %ebx
c002a3a9:	83 ec 1c             	sub    $0x1c,%esp
c002a3ac:	e8 92 5d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a3b1:	81 c3 fb 38 01 00    	add    $0x138fb,%ebx
c002a3b7:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a3bb:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a3bf:	8b 44 24 38          	mov    0x38(%esp),%eax
c002a3c3:	0f b6 54 24 3c       	movzbl 0x3c(%esp),%edx
c002a3c8:	88 54 24 0f          	mov    %dl,0xf(%esp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002a3cc:	85 ff                	test   %edi,%edi
c002a3ce:	74 44                	je     c002a414 <bitmap_count+0x6f>
  ASSERT (start <= b->bit_cnt);
c002a3d0:	8b 17                	mov    (%edi),%edx
c002a3d2:	39 f2                	cmp    %esi,%edx
c002a3d4:	72 67                	jb     c002a43d <bitmap_count+0x98>
  ASSERT (start + cnt <= b->bit_cnt);
c002a3d6:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a3d9:	39 ea                	cmp    %ebp,%edx
c002a3db:	0f 82 89 00 00 00    	jb     c002a46a <bitmap_count+0xc5>

  value_cnt = 0;
c002a3e1:	bb 00 00 00 00       	mov    $0x0,%ebx
  for (i = 0; i < cnt; i++)
c002a3e6:	85 c0                	test   %eax,%eax
c002a3e8:	74 7c                	je     c002a466 <bitmap_count+0xc1>
    if (bitmap_test (b, start + i) == value)
c002a3ea:	83 ec 08             	sub    $0x8,%esp
c002a3ed:	56                   	push   %esi
c002a3ee:	57                   	push   %edi
c002a3ef:	e8 21 fd ff ff       	call   c002a115 <bitmap_test>
c002a3f4:	83 c4 10             	add    $0x10,%esp
      value_cnt++;
c002a3f7:	3a 44 24 0f          	cmp    0xf(%esp),%al
c002a3fb:	0f 94 c0             	sete   %al
c002a3fe:	0f b6 c0             	movzbl %al,%eax
c002a401:	01 c3                	add    %eax,%ebx
c002a403:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a406:	39 f5                	cmp    %esi,%ebp
c002a408:	75 e0                	jne    c002a3ea <bitmap_count+0x45>
  return value_cnt;
}
c002a40a:	89 d8                	mov    %ebx,%eax
c002a40c:	83 c4 1c             	add    $0x1c,%esp
c002a40f:	5b                   	pop    %ebx
c002a410:	5e                   	pop    %esi
c002a411:	5f                   	pop    %edi
c002a412:	5d                   	pop    %ebp
c002a413:	c3                   	ret    
  ASSERT (b != NULL);
c002a414:	83 ec 0c             	sub    $0xc,%esp
c002a417:	8d 83 03 54 ff ff    	lea    -0xabfd(%ebx),%eax
c002a41d:	50                   	push   %eax
c002a41e:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a424:	50                   	push   %eax
c002a425:	8d 83 94 32 ff ff    	lea    -0xcd6c(%ebx),%eax
c002a42b:	50                   	push   %eax
c002a42c:	68 ed 00 00 00       	push   $0xed
c002a431:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a437:	50                   	push   %eax
c002a438:	e8 f0 ec ff ff       	call   c002912d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a43d:	83 ec 0c             	sub    $0xc,%esp
c002a440:	8d 83 ae 55 ff ff    	lea    -0xaa52(%ebx),%eax
c002a446:	50                   	push   %eax
c002a447:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a44d:	50                   	push   %eax
c002a44e:	8d 83 94 32 ff ff    	lea    -0xcd6c(%ebx),%eax
c002a454:	50                   	push   %eax
c002a455:	68 ee 00 00 00       	push   $0xee
c002a45a:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a460:	50                   	push   %eax
c002a461:	e8 c7 ec ff ff       	call   c002912d <debug_panic>
  value_cnt = 0;
c002a466:	89 c3                	mov    %eax,%ebx
c002a468:	eb a0                	jmp    c002a40a <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c002a46a:	83 ec 0c             	sub    $0xc,%esp
c002a46d:	8d 83 c2 55 ff ff    	lea    -0xaa3e(%ebx),%eax
c002a473:	50                   	push   %eax
c002a474:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a47a:	50                   	push   %eax
c002a47b:	8d 83 94 32 ff ff    	lea    -0xcd6c(%ebx),%eax
c002a481:	50                   	push   %eax
c002a482:	68 ef 00 00 00       	push   $0xef
c002a487:	8d 83 83 55 ff ff    	lea    -0xaa7d(%ebx),%eax
c002a48d:	50                   	push   %eax
c002a48e:	e8 9a ec ff ff       	call   c002912d <debug_panic>

c002a493 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a493:	55                   	push   %ebp
c002a494:	57                   	push   %edi
c002a495:	56                   	push   %esi
c002a496:	53                   	push   %ebx
c002a497:	83 ec 0c             	sub    $0xc,%esp
c002a49a:	e8 b8 5c 00 00       	call   c0030157 <__x86.get_pc_thunk.cx>
c002a49f:	81 c1 0d 38 01 00    	add    $0x1380d,%ecx
c002a4a5:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a4a9:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a4ad:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a4b1:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a4b6:	85 ff                	test   %edi,%edi
c002a4b8:	74 3f                	je     c002a4f9 <bitmap_contains+0x66>
  ASSERT (start <= b->bit_cnt);
c002a4ba:	8b 17                	mov    (%edi),%edx
c002a4bc:	39 f2                	cmp    %esi,%edx
c002a4be:	72 64                	jb     c002a524 <bitmap_contains+0x91>
  ASSERT (start + cnt <= b->bit_cnt);
c002a4c0:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a4c3:	39 ea                	cmp    %ebp,%edx
c002a4c5:	0f 82 84 00 00 00    	jb     c002a54f <bitmap_contains+0xbc>

  for (i = 0; i < cnt; i++)
c002a4cb:	85 c0                	test   %eax,%eax
c002a4cd:	0f 84 ac 00 00 00    	je     c002a57f <bitmap_contains+0xec>
    if (bitmap_test (b, start + i) == value)
c002a4d3:	83 ec 08             	sub    $0x8,%esp
c002a4d6:	56                   	push   %esi
c002a4d7:	57                   	push   %edi
c002a4d8:	e8 38 fc ff ff       	call   c002a115 <bitmap_test>
c002a4dd:	83 c4 10             	add    $0x10,%esp
c002a4e0:	38 d8                	cmp    %bl,%al
c002a4e2:	0f 84 92 00 00 00    	je     c002a57a <bitmap_contains+0xe7>
c002a4e8:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a4eb:	39 f5                	cmp    %esi,%ebp
c002a4ed:	75 e4                	jne    c002a4d3 <bitmap_contains+0x40>
      return true;
  return false;
c002a4ef:	b8 00 00 00 00       	mov    $0x0,%eax
c002a4f4:	e9 86 00 00 00       	jmp    c002a57f <bitmap_contains+0xec>
  ASSERT (b != NULL);
c002a4f9:	83 ec 0c             	sub    $0xc,%esp
c002a4fc:	8d 81 03 54 ff ff    	lea    -0xabfd(%ecx),%eax
c002a502:	50                   	push   %eax
c002a503:	8d 81 de 36 ff ff    	lea    -0xc922(%ecx),%eax
c002a509:	50                   	push   %eax
c002a50a:	8d 81 84 32 ff ff    	lea    -0xcd7c(%ecx),%eax
c002a510:	50                   	push   %eax
c002a511:	68 ff 00 00 00       	push   $0xff
c002a516:	8d 81 83 55 ff ff    	lea    -0xaa7d(%ecx),%eax
c002a51c:	50                   	push   %eax
c002a51d:	89 cb                	mov    %ecx,%ebx
c002a51f:	e8 09 ec ff ff       	call   c002912d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a524:	83 ec 0c             	sub    $0xc,%esp
c002a527:	8d 81 ae 55 ff ff    	lea    -0xaa52(%ecx),%eax
c002a52d:	50                   	push   %eax
c002a52e:	8d 81 de 36 ff ff    	lea    -0xc922(%ecx),%eax
c002a534:	50                   	push   %eax
c002a535:	8d 81 84 32 ff ff    	lea    -0xcd7c(%ecx),%eax
c002a53b:	50                   	push   %eax
c002a53c:	68 00 01 00 00       	push   $0x100
c002a541:	8d 81 83 55 ff ff    	lea    -0xaa7d(%ecx),%eax
c002a547:	50                   	push   %eax
c002a548:	89 cb                	mov    %ecx,%ebx
c002a54a:	e8 de eb ff ff       	call   c002912d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a54f:	83 ec 0c             	sub    $0xc,%esp
c002a552:	8d 81 c2 55 ff ff    	lea    -0xaa3e(%ecx),%eax
c002a558:	50                   	push   %eax
c002a559:	8d 81 de 36 ff ff    	lea    -0xc922(%ecx),%eax
c002a55f:	50                   	push   %eax
c002a560:	8d 81 84 32 ff ff    	lea    -0xcd7c(%ecx),%eax
c002a566:	50                   	push   %eax
c002a567:	68 01 01 00 00       	push   $0x101
c002a56c:	8d 81 83 55 ff ff    	lea    -0xaa7d(%ecx),%eax
c002a572:	50                   	push   %eax
c002a573:	89 cb                	mov    %ecx,%ebx
c002a575:	e8 b3 eb ff ff       	call   c002912d <debug_panic>
      return true;
c002a57a:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a57f:	83 c4 0c             	add    $0xc,%esp
c002a582:	5b                   	pop    %ebx
c002a583:	5e                   	pop    %esi
c002a584:	5f                   	pop    %edi
c002a585:	5d                   	pop    %ebp
c002a586:	c3                   	ret    

c002a587 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a587:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c002a58a:	6a 01                	push   $0x1
c002a58c:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a590:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a594:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a598:	e8 f6 fe ff ff       	call   c002a493 <bitmap_contains>
}
c002a59d:	83 c4 1c             	add    $0x1c,%esp
c002a5a0:	c3                   	ret    

c002a5a1 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a5a1:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c002a5a4:	6a 01                	push   $0x1
c002a5a6:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a5aa:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a5ae:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a5b2:	e8 dc fe ff ff       	call   c002a493 <bitmap_contains>
c002a5b7:	83 f0 01             	xor    $0x1,%eax
}
c002a5ba:	83 c4 1c             	add    $0x1c,%esp
c002a5bd:	c3                   	ret    

c002a5be <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a5be:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c002a5c1:	6a 00                	push   $0x0
c002a5c3:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a5c7:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a5cb:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a5cf:	e8 bf fe ff ff       	call   c002a493 <bitmap_contains>
c002a5d4:	83 f0 01             	xor    $0x1,%eax
}
c002a5d7:	83 c4 1c             	add    $0x1c,%esp
c002a5da:	c3                   	ret    

c002a5db <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a5db:	55                   	push   %ebp
c002a5dc:	57                   	push   %edi
c002a5dd:	56                   	push   %esi
c002a5de:	53                   	push   %ebx
c002a5df:	83 ec 1c             	sub    $0x1c,%esp
c002a5e2:	e8 60 5b 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c002a5e7:	05 c5 36 01 00       	add    $0x136c5,%eax
c002a5ec:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a5f0:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a5f4:	8b 6c 24 38          	mov    0x38(%esp),%ebp
c002a5f8:	0f b6 5c 24 3c       	movzbl 0x3c(%esp),%ebx
  ASSERT (b != NULL);
c002a5fd:	85 ff                	test   %edi,%edi
c002a5ff:	74 43                	je     c002a644 <bitmap_scan+0x69>
  ASSERT (start <= b->bit_cnt);
c002a601:	8b 17                	mov    (%edi),%edx
c002a603:	39 f2                	cmp    %esi,%edx
c002a605:	72 68                	jb     c002a66f <bitmap_scan+0x94>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002a607:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  if (cnt <= b->bit_cnt) 
c002a60c:	39 ea                	cmp    %ebp,%edx
c002a60e:	0f 82 8f 00 00 00    	jb     c002a6a3 <bitmap_scan+0xc8>
      size_t last = b->bit_cnt - cnt;
c002a614:	29 ea                	sub    %ebp,%edx
c002a616:	89 54 24 0c          	mov    %edx,0xc(%esp)
      for (i = start; i <= last; i++)
c002a61a:	39 d6                	cmp    %edx,%esi
c002a61c:	77 7c                	ja     c002a69a <bitmap_scan+0xbf>
        if (!bitmap_contains (b, i, cnt, !value))
c002a61e:	83 f3 01             	xor    $0x1,%ebx
c002a621:	0f b6 db             	movzbl %bl,%ebx
c002a624:	53                   	push   %ebx
c002a625:	55                   	push   %ebp
c002a626:	56                   	push   %esi
c002a627:	57                   	push   %edi
c002a628:	e8 66 fe ff ff       	call   c002a493 <bitmap_contains>
c002a62d:	83 c4 10             	add    $0x10,%esp
c002a630:	84 c0                	test   %al,%al
c002a632:	74 6d                	je     c002a6a1 <bitmap_scan+0xc6>
      for (i = start; i <= last; i++)
c002a634:	83 c6 01             	add    $0x1,%esi
c002a637:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c002a63b:	73 e7                	jae    c002a624 <bitmap_scan+0x49>
  return BITMAP_ERROR;
c002a63d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a642:	eb 5f                	jmp    c002a6a3 <bitmap_scan+0xc8>
  ASSERT (b != NULL);
c002a644:	83 ec 0c             	sub    $0xc,%esp
c002a647:	8d 90 03 54 ff ff    	lea    -0xabfd(%eax),%edx
c002a64d:	52                   	push   %edx
c002a64e:	8d 90 de 36 ff ff    	lea    -0xc922(%eax),%edx
c002a654:	52                   	push   %edx
c002a655:	8d 90 78 32 ff ff    	lea    -0xcd88(%eax),%edx
c002a65b:	52                   	push   %edx
c002a65c:	68 2a 01 00 00       	push   $0x12a
c002a661:	8d 90 83 55 ff ff    	lea    -0xaa7d(%eax),%edx
c002a667:	52                   	push   %edx
c002a668:	89 c3                	mov    %eax,%ebx
c002a66a:	e8 be ea ff ff       	call   c002912d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a66f:	83 ec 0c             	sub    $0xc,%esp
c002a672:	8d 90 ae 55 ff ff    	lea    -0xaa52(%eax),%edx
c002a678:	52                   	push   %edx
c002a679:	8d 90 de 36 ff ff    	lea    -0xc922(%eax),%edx
c002a67f:	52                   	push   %edx
c002a680:	8d 90 78 32 ff ff    	lea    -0xcd88(%eax),%edx
c002a686:	52                   	push   %edx
c002a687:	68 2b 01 00 00       	push   $0x12b
c002a68c:	8d 90 83 55 ff ff    	lea    -0xaa7d(%eax),%edx
c002a692:	52                   	push   %edx
c002a693:	89 c3                	mov    %eax,%ebx
c002a695:	e8 93 ea ff ff       	call   c002912d <debug_panic>
  return BITMAP_ERROR;
c002a69a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a69f:	eb 02                	jmp    c002a6a3 <bitmap_scan+0xc8>
c002a6a1:	89 f0                	mov    %esi,%eax
}
c002a6a3:	83 c4 1c             	add    $0x1c,%esp
c002a6a6:	5b                   	pop    %ebx
c002a6a7:	5e                   	pop    %esi
c002a6a8:	5f                   	pop    %edi
c002a6a9:	5d                   	pop    %ebp
c002a6aa:	c3                   	ret    

c002a6ab <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002a6ab:	55                   	push   %ebp
c002a6ac:	57                   	push   %edi
c002a6ad:	56                   	push   %esi
c002a6ae:	53                   	push   %ebx
c002a6af:	83 ec 0c             	sub    $0xc,%esp
c002a6b2:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a6b6:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002a6ba:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c002a6be:	0f b6 c3             	movzbl %bl,%eax
c002a6c1:	50                   	push   %eax
c002a6c2:	55                   	push   %ebp
c002a6c3:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a6c7:	57                   	push   %edi
c002a6c8:	e8 0e ff ff ff       	call   c002a5db <bitmap_scan>
c002a6cd:	83 c4 10             	add    $0x10,%esp
c002a6d0:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c002a6d2:	83 f8 ff             	cmp    $0xffffffff,%eax
c002a6d5:	75 0a                	jne    c002a6e1 <bitmap_scan_and_flip+0x36>
    bitmap_set_multiple (b, idx, cnt, !value);
  return idx;
}
c002a6d7:	89 f0                	mov    %esi,%eax
c002a6d9:	83 c4 0c             	add    $0xc,%esp
c002a6dc:	5b                   	pop    %ebx
c002a6dd:	5e                   	pop    %esi
c002a6de:	5f                   	pop    %edi
c002a6df:	5d                   	pop    %ebp
c002a6e0:	c3                   	ret    
    bitmap_set_multiple (b, idx, cnt, !value);
c002a6e1:	83 f3 01             	xor    $0x1,%ebx
c002a6e4:	0f b6 db             	movzbl %bl,%ebx
c002a6e7:	53                   	push   %ebx
c002a6e8:	55                   	push   %ebp
c002a6e9:	50                   	push   %eax
c002a6ea:	57                   	push   %edi
c002a6eb:	e8 b0 fa ff ff       	call   c002a1a0 <bitmap_set_multiple>
c002a6f0:	83 c4 10             	add    $0x10,%esp
  return idx;
c002a6f3:	eb e2                	jmp    c002a6d7 <bitmap_scan_and_flip+0x2c>

c002a6f5 <bitmap_file_size>:
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a6f5:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a6f9:	8b 00                	mov    (%eax),%eax
c002a6fb:	83 c0 1f             	add    $0x1f,%eax
c002a6fe:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a701:	c1 e0 02             	shl    $0x2,%eax
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size (const struct bitmap *b) 
{
  return byte_cnt (b->bit_cnt);
}
c002a704:	c3                   	ret    

c002a705 <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool
bitmap_read (struct bitmap *b, struct file *file) 
{
c002a705:	57                   	push   %edi
c002a706:	56                   	push   %esi
c002a707:	53                   	push   %ebx
c002a708:	e8 36 5a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a70d:	81 c3 9f 35 01 00    	add    $0x1359f,%ebx
c002a713:	8b 7c 24 10          	mov    0x10(%esp),%edi
  bool success = true;
  if (b->bit_cnt > 0) 
c002a717:	8b 17                	mov    (%edi),%edx
  bool success = true;
c002a719:	b8 01 00 00 00       	mov    $0x1,%eax
  if (b->bit_cnt > 0) 
c002a71e:	85 d2                	test   %edx,%edx
c002a720:	75 04                	jne    c002a726 <bitmap_read+0x21>
      off_t size = byte_cnt (b->bit_cnt);
      success = file_read_at (file, b->bits, size, 0) == size;
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
    }
  return success;
}
c002a722:	5b                   	pop    %ebx
c002a723:	5e                   	pop    %esi
c002a724:	5f                   	pop    %edi
c002a725:	c3                   	ret    
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a726:	83 c2 1f             	add    $0x1f,%edx
c002a729:	c1 ea 05             	shr    $0x5,%edx
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a72c:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
      success = file_read_at (file, b->bits, size, 0) == size;
c002a733:	6a 00                	push   $0x0
c002a735:	56                   	push   %esi
c002a736:	ff 77 04             	pushl  0x4(%edi)
c002a739:	ff 74 24 20          	pushl  0x20(%esp)
c002a73d:	e8 d7 36 00 00       	call   c002de19 <file_read_at>
c002a742:	83 c4 10             	add    $0x10,%esp
c002a745:	39 f0                	cmp    %esi,%eax
c002a747:	0f 94 c0             	sete   %al
  int last_bits = b->bit_cnt % ELEM_BITS;
c002a74a:	8b 17                	mov    (%edi),%edx
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c002a74c:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002a751:	89 d1                	mov    %edx,%ecx
c002a753:	83 e1 1f             	and    $0x1f,%ecx
c002a756:	74 0a                	je     c002a762 <bitmap_read+0x5d>
c002a758:	be 01 00 00 00       	mov    $0x1,%esi
c002a75d:	d3 e6                	shl    %cl,%esi
c002a75f:	83 ee 01             	sub    $0x1,%esi
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a762:	83 c2 1f             	add    $0x1f,%edx
c002a765:	c1 ea 05             	shr    $0x5,%edx
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
c002a768:	8b 4f 04             	mov    0x4(%edi),%ecx
c002a76b:	21 74 91 fc          	and    %esi,-0x4(%ecx,%edx,4)
c002a76f:	eb b1                	jmp    c002a722 <bitmap_read+0x1d>

c002a771 <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool
bitmap_write (const struct bitmap *b, struct file *file)
{
c002a771:	56                   	push   %esi
c002a772:	53                   	push   %ebx
c002a773:	83 ec 04             	sub    $0x4,%esp
c002a776:	e8 c8 59 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a77b:	81 c3 31 35 01 00    	add    $0x13531,%ebx
c002a781:	8b 44 24 10          	mov    0x10(%esp),%eax
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a785:	8b 10                	mov    (%eax),%edx
c002a787:	8d 72 1f             	lea    0x1f(%edx),%esi
c002a78a:	c1 ee 05             	shr    $0x5,%esi
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a78d:	c1 e6 02             	shl    $0x2,%esi
  off_t size = byte_cnt (b->bit_cnt);
  return file_write_at (file, b->bits, size, 0) == size;
c002a790:	6a 00                	push   $0x0
c002a792:	56                   	push   %esi
c002a793:	ff 70 04             	pushl  0x4(%eax)
c002a796:	ff 74 24 20          	pushl  0x20(%esp)
c002a79a:	e8 d4 36 00 00       	call   c002de73 <file_write_at>
c002a79f:	39 f0                	cmp    %esi,%eax
c002a7a1:	0f 94 c0             	sete   %al
}
c002a7a4:	83 c4 14             	add    $0x14,%esp
c002a7a7:	5b                   	pop    %ebx
c002a7a8:	5e                   	pop    %esi
c002a7a9:	c3                   	ret    

c002a7aa <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002a7aa:	53                   	push   %ebx
c002a7ab:	83 ec 08             	sub    $0x8,%esp
c002a7ae:	e8 90 59 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a7b3:	81 c3 f9 34 01 00    	add    $0x134f9,%ebx
c002a7b9:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a7bd:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a7bf:	8b 02                	mov    (%edx),%eax
c002a7c1:	83 c0 1f             	add    $0x1f,%eax
c002a7c4:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a7c7:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a7ca:	50                   	push   %eax
c002a7cb:	ff 72 04             	pushl  0x4(%edx)
c002a7ce:	6a 00                	push   $0x0
c002a7d0:	e8 aa d4 ff ff       	call   c0027c7f <hex_dump>
}
c002a7d5:	83 c4 18             	add    $0x18,%esp
c002a7d8:	5b                   	pop    %ebx
c002a7d9:	c3                   	ret    

c002a7da <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002a7da:	53                   	push   %ebx
c002a7db:	83 ec 10             	sub    $0x10,%esp
c002a7de:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002a7e0:	ff 70 14             	pushl  0x14(%eax)
c002a7e3:	52                   	push   %edx
c002a7e4:	ff 50 0c             	call   *0xc(%eax)
c002a7e7:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002a7ea:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002a7ed:	21 c2                	and    %eax,%edx
  return &h->buckets[bucket_idx];
c002a7ef:	c1 e2 04             	shl    $0x4,%edx
c002a7f2:	89 d0                	mov    %edx,%eax
c002a7f4:	03 43 08             	add    0x8(%ebx),%eax
}
c002a7f7:	83 c4 18             	add    $0x18,%esp
c002a7fa:	5b                   	pop    %ebx
c002a7fb:	c3                   	ret    

c002a7fc <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002a7fc:	55                   	push   %ebp
c002a7fd:	57                   	push   %edi
c002a7fe:	56                   	push   %esi
c002a7ff:	53                   	push   %ebx
c002a800:	83 ec 28             	sub    $0x28,%esp
c002a803:	e8 3b 59 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a808:	81 c3 a4 34 01 00    	add    $0x134a4,%ebx
c002a80e:	89 c7                	mov    %eax,%edi
c002a810:	89 54 24 18          	mov    %edx,0x18(%esp)
c002a814:	89 cd                	mov    %ecx,%ebp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002a816:	52                   	push   %edx
c002a817:	e8 36 ea ff ff       	call   c0029252 <list_begin>
c002a81c:	89 c6                	mov    %eax,%esi
c002a81e:	83 c4 10             	add    $0x10,%esp
c002a821:	eb 0e                	jmp    c002a831 <find_elem+0x35>
c002a823:	83 ec 0c             	sub    $0xc,%esp
c002a826:	56                   	push   %esi
c002a827:	e8 6b ea ff ff       	call   c0029297 <list_next>
c002a82c:	89 c6                	mov    %eax,%esi
c002a82e:	83 c4 10             	add    $0x10,%esp
c002a831:	83 ec 0c             	sub    $0xc,%esp
c002a834:	ff 74 24 18          	pushl  0x18(%esp)
c002a838:	e8 b7 ea ff ff       	call   c00292f4 <list_end>
c002a83d:	83 c4 10             	add    $0x10,%esp
c002a840:	39 f0                	cmp    %esi,%eax
c002a842:	74 26                	je     c002a86a <find_elem+0x6e>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002a844:	83 ec 04             	sub    $0x4,%esp
c002a847:	ff 77 14             	pushl  0x14(%edi)
c002a84a:	55                   	push   %ebp
c002a84b:	56                   	push   %esi
c002a84c:	ff 57 10             	call   *0x10(%edi)
c002a84f:	83 c4 10             	add    $0x10,%esp
c002a852:	84 c0                	test   %al,%al
c002a854:	75 cd                	jne    c002a823 <find_elem+0x27>
c002a856:	83 ec 04             	sub    $0x4,%esp
c002a859:	ff 77 14             	pushl  0x14(%edi)
c002a85c:	56                   	push   %esi
c002a85d:	55                   	push   %ebp
c002a85e:	ff 57 10             	call   *0x10(%edi)
c002a861:	83 c4 10             	add    $0x10,%esp
c002a864:	84 c0                	test   %al,%al
c002a866:	75 bb                	jne    c002a823 <find_elem+0x27>
c002a868:	eb 05                	jmp    c002a86f <find_elem+0x73>
        return hi; 
    }
  return NULL;
c002a86a:	be 00 00 00 00       	mov    $0x0,%esi
}
c002a86f:	89 f0                	mov    %esi,%eax
c002a871:	83 c4 1c             	add    $0x1c,%esp
c002a874:	5b                   	pop    %ebx
c002a875:	5e                   	pop    %esi
c002a876:	5f                   	pop    %edi
c002a877:	5d                   	pop    %ebp
c002a878:	c3                   	ret    

c002a879 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002a879:	55                   	push   %ebp
c002a87a:	57                   	push   %edi
c002a87b:	56                   	push   %esi
c002a87c:	53                   	push   %ebx
c002a87d:	83 ec 2c             	sub    $0x2c,%esp
c002a880:	e8 be 58 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a885:	81 c3 27 34 01 00    	add    $0x13427,%ebx
c002a88b:	89 44 24 10          	mov    %eax,0x10(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002a88f:	85 c0                	test   %eax,%eax
c002a891:	74 1e                	je     c002a8b1 <rehash+0x38>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c002a893:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a897:	8b 48 04             	mov    0x4(%eax),%ecx
c002a89a:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002a89e:	8b 00                	mov    (%eax),%eax
c002a8a0:	89 c6                	mov    %eax,%esi
c002a8a2:	d1 ee                	shr    %esi
c002a8a4:	83 f8 07             	cmp    $0x7,%eax
c002a8a7:	b8 04 00 00 00       	mov    $0x4,%eax
c002a8ac:	0f 46 f0             	cmovbe %eax,%esi
c002a8af:	eb 2e                	jmp    c002a8df <rehash+0x66>
  ASSERT (h != NULL);
c002a8b1:	83 ec 0c             	sub    $0xc,%esp
c002a8b4:	8d 83 04 56 ff ff    	lea    -0xa9fc(%ebx),%eax
c002a8ba:	50                   	push   %eax
c002a8bb:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002a8c1:	50                   	push   %eax
c002a8c2:	8d 83 34 33 ff ff    	lea    -0xcccc(%ebx),%eax
c002a8c8:	50                   	push   %eax
c002a8c9:	68 66 01 00 00       	push   $0x166
c002a8ce:	8d 83 0e 56 ff ff    	lea    -0xa9f2(%ebx),%eax
c002a8d4:	50                   	push   %eax
c002a8d5:	e8 53 e8 ff ff       	call   c002912d <debug_panic>
  return x & (x - 1);
c002a8da:	8d 46 ff             	lea    -0x1(%esi),%eax
c002a8dd:	21 c6                	and    %eax,%esi
  return x != 0 && turn_off_least_1bit (x) == 0;
c002a8df:	85 f6                	test   %esi,%esi
c002a8e1:	74 f7                	je     c002a8da <rehash+0x61>
  return x & (x - 1);
c002a8e3:	8d 46 ff             	lea    -0x1(%esi),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002a8e6:	85 f0                	test   %esi,%eax
c002a8e8:	75 f0                	jne    c002a8da <rehash+0x61>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002a8ea:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c002a8ee:	0f 84 df 00 00 00    	je     c002a9d3 <rehash+0x15a>
  old_buckets = h->buckets;
c002a8f4:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a8f8:	8b 40 08             	mov    0x8(%eax),%eax
c002a8fb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002a8ff:	89 f5                	mov    %esi,%ebp
c002a901:	c1 e5 04             	shl    $0x4,%ebp
c002a904:	83 ec 0c             	sub    $0xc,%esp
c002a907:	55                   	push   %ebp
c002a908:	e8 41 95 ff ff       	call   c0023e4e <malloc>
c002a90d:	89 44 24 24          	mov    %eax,0x24(%esp)
  if (new_buckets == NULL) 
c002a911:	83 c4 10             	add    $0x10,%esp
c002a914:	85 c0                	test   %eax,%eax
c002a916:	0f 84 b7 00 00 00    	je     c002a9d3 <rehash+0x15a>
c002a91c:	89 c7                	mov    %eax,%edi
c002a91e:	01 c5                	add    %eax,%ebp
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c002a920:	83 ec 0c             	sub    $0xc,%esp
c002a923:	57                   	push   %edi
c002a924:	e8 d1 e8 ff ff       	call   c00291fa <list_init>
c002a929:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < new_bucket_cnt; i++) 
c002a92c:	83 c4 10             	add    $0x10,%esp
c002a92f:	39 fd                	cmp    %edi,%ebp
c002a931:	75 ed                	jne    c002a920 <rehash+0xa7>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002a933:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a937:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002a93b:	89 48 08             	mov    %ecx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002a93e:	89 70 04             	mov    %esi,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002a941:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a945:	85 c0                	test   %eax,%eax
c002a947:	74 7b                	je     c002a9c4 <rehash+0x14b>
c002a949:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002a94d:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002a951:	c1 e0 04             	shl    $0x4,%eax
c002a954:	01 c8                	add    %ecx,%eax
c002a956:	89 44 24 18          	mov    %eax,0x18(%esp)
c002a95a:	eb 0f                	jmp    c002a96b <rehash+0xf2>
c002a95c:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c002a961:	8b 44 24 14          	mov    0x14(%esp),%eax
c002a965:	39 44 24 18          	cmp    %eax,0x18(%esp)
c002a969:	74 59                	je     c002a9c4 <rehash+0x14b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002a96b:	8b 44 24 14          	mov    0x14(%esp),%eax
c002a96f:	89 c7                	mov    %eax,%edi
      for (elem = list_begin (old_bucket);
c002a971:	83 ec 0c             	sub    $0xc,%esp
c002a974:	50                   	push   %eax
c002a975:	e8 d8 e8 ff ff       	call   c0029252 <list_begin>
c002a97a:	89 c6                	mov    %eax,%esi
c002a97c:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002a97f:	83 ec 0c             	sub    $0xc,%esp
c002a982:	57                   	push   %edi
c002a983:	e8 6c e9 ff ff       	call   c00292f4 <list_end>
      for (elem = list_begin (old_bucket);
c002a988:	83 c4 10             	add    $0x10,%esp
c002a98b:	39 f0                	cmp    %esi,%eax
c002a98d:	74 cd                	je     c002a95c <rehash+0xe3>
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002a98f:	89 f2                	mov    %esi,%edx
c002a991:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a995:	e8 40 fe ff ff       	call   c002a7da <find_bucket>
c002a99a:	89 c5                	mov    %eax,%ebp
          next = list_next (elem);
c002a99c:	83 ec 0c             	sub    $0xc,%esp
c002a99f:	56                   	push   %esi
c002a9a0:	e8 f2 e8 ff ff       	call   c0029297 <list_next>
c002a9a5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          list_remove (elem);
c002a9a9:	89 34 24             	mov    %esi,(%esp)
c002a9ac:	e8 4b ee ff ff       	call   c00297fc <list_remove>
          list_push_front (new_bucket, elem);
c002a9b1:	83 c4 08             	add    $0x8,%esp
c002a9b4:	56                   	push   %esi
c002a9b5:	55                   	push   %ebp
c002a9b6:	e8 07 ee ff ff       	call   c00297c2 <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c002a9bb:	83 c4 10             	add    $0x10,%esp
c002a9be:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002a9c2:	eb bb                	jmp    c002a97f <rehash+0x106>
        }
    }

  free (old_buckets);
c002a9c4:	83 ec 0c             	sub    $0xc,%esp
c002a9c7:	ff 74 24 28          	pushl  0x28(%esp)
c002a9cb:	e8 2c 96 ff ff       	call   c0023ffc <free>
c002a9d0:	83 c4 10             	add    $0x10,%esp
}
c002a9d3:	83 c4 2c             	add    $0x2c,%esp
c002a9d6:	5b                   	pop    %ebx
c002a9d7:	5e                   	pop    %esi
c002a9d8:	5f                   	pop    %edi
c002a9d9:	5d                   	pop    %ebp
c002a9da:	c3                   	ret    

c002a9db <hash_clear>:
{
c002a9db:	55                   	push   %ebp
c002a9dc:	57                   	push   %edi
c002a9dd:	56                   	push   %esi
c002a9de:	53                   	push   %ebx
c002a9df:	83 ec 1c             	sub    $0x1c,%esp
c002a9e2:	e8 5c 57 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002a9e7:	81 c3 c5 32 01 00    	add    $0x132c5,%ebx
c002a9ed:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a9f1:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  for (i = 0; i < h->bucket_cnt; i++) 
c002a9f5:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c002a9f9:	74 59                	je     c002aa54 <hash_clear+0x79>
c002a9fb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002aa02:	00 
c002aa03:	eb 1a                	jmp    c002aa1f <hash_clear+0x44>
      list_init (bucket); 
c002aa05:	83 ec 0c             	sub    $0xc,%esp
c002aa08:	56                   	push   %esi
c002aa09:	e8 ec e7 ff ff       	call   c00291fa <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c002aa0e:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
c002aa13:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002aa17:	83 c4 10             	add    $0x10,%esp
c002aa1a:	39 47 04             	cmp    %eax,0x4(%edi)
c002aa1d:	76 35                	jbe    c002aa54 <hash_clear+0x79>
      struct list *bucket = &h->buckets[i];
c002aa1f:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002aa23:	c1 e6 04             	shl    $0x4,%esi
c002aa26:	03 77 08             	add    0x8(%edi),%esi
      if (destructor != NULL) 
c002aa29:	85 ed                	test   %ebp,%ebp
c002aa2b:	74 d8                	je     c002aa05 <hash_clear+0x2a>
        while (!list_empty (bucket)) 
c002aa2d:	83 ec 0c             	sub    $0xc,%esp
c002aa30:	56                   	push   %esi
c002aa31:	e8 68 ee ff ff       	call   c002989e <list_empty>
c002aa36:	83 c4 10             	add    $0x10,%esp
c002aa39:	84 c0                	test   %al,%al
c002aa3b:	75 c8                	jne    c002aa05 <hash_clear+0x2a>
            struct list_elem *list_elem = list_pop_front (bucket);
c002aa3d:	83 ec 0c             	sub    $0xc,%esp
c002aa40:	56                   	push   %esi
c002aa41:	e8 cf ee ff ff       	call   c0029915 <list_pop_front>
            destructor (hash_elem, h->aux);
c002aa46:	83 c4 08             	add    $0x8,%esp
c002aa49:	ff 77 14             	pushl  0x14(%edi)
c002aa4c:	50                   	push   %eax
c002aa4d:	ff d5                	call   *%ebp
c002aa4f:	83 c4 10             	add    $0x10,%esp
c002aa52:	eb d9                	jmp    c002aa2d <hash_clear+0x52>
  h->elem_cnt = 0;
c002aa54:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
c002aa5a:	83 c4 1c             	add    $0x1c,%esp
c002aa5d:	5b                   	pop    %ebx
c002aa5e:	5e                   	pop    %esi
c002aa5f:	5f                   	pop    %edi
c002aa60:	5d                   	pop    %ebp
c002aa61:	c3                   	ret    

c002aa62 <hash_init>:
{
c002aa62:	56                   	push   %esi
c002aa63:	53                   	push   %ebx
c002aa64:	83 ec 10             	sub    $0x10,%esp
c002aa67:	e8 d7 56 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002aa6c:	81 c3 40 32 01 00    	add    $0x13240,%ebx
c002aa72:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  h->elem_cnt = 0;
c002aa76:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  h->bucket_cnt = 4;
c002aa7c:	c7 46 04 04 00 00 00 	movl   $0x4,0x4(%esi)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002aa83:	6a 40                	push   $0x40
c002aa85:	e8 c4 93 ff ff       	call   c0023e4e <malloc>
c002aa8a:	89 c2                	mov    %eax,%edx
c002aa8c:	89 46 08             	mov    %eax,0x8(%esi)
  h->hash = hash;
c002aa8f:	8b 44 24 24          	mov    0x24(%esp),%eax
c002aa93:	89 46 0c             	mov    %eax,0xc(%esi)
  h->less = less;
c002aa96:	8b 44 24 28          	mov    0x28(%esp),%eax
c002aa9a:	89 46 10             	mov    %eax,0x10(%esi)
  h->aux = aux;
c002aa9d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002aaa1:	89 46 14             	mov    %eax,0x14(%esi)
  if (h->buckets != NULL) 
c002aaa4:	83 c4 10             	add    $0x10,%esp
    return false;
c002aaa7:	b8 00 00 00 00       	mov    $0x0,%eax
  if (h->buckets != NULL) 
c002aaac:	85 d2                	test   %edx,%edx
c002aaae:	74 13                	je     c002aac3 <hash_init+0x61>
      hash_clear (h, NULL);
c002aab0:	83 ec 08             	sub    $0x8,%esp
c002aab3:	6a 00                	push   $0x0
c002aab5:	56                   	push   %esi
c002aab6:	e8 20 ff ff ff       	call   c002a9db <hash_clear>
      return true;
c002aabb:	83 c4 10             	add    $0x10,%esp
c002aabe:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002aac3:	83 c4 04             	add    $0x4,%esp
c002aac6:	5b                   	pop    %ebx
c002aac7:	5e                   	pop    %esi
c002aac8:	c3                   	ret    

c002aac9 <hash_destroy>:
{
c002aac9:	56                   	push   %esi
c002aaca:	53                   	push   %ebx
c002aacb:	83 ec 04             	sub    $0x4,%esp
c002aace:	e8 70 56 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002aad3:	81 c3 d9 31 01 00    	add    $0x131d9,%ebx
c002aad9:	8b 74 24 10          	mov    0x10(%esp),%esi
c002aadd:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c002aae1:	85 c0                	test   %eax,%eax
c002aae3:	74 0d                	je     c002aaf2 <hash_destroy+0x29>
    hash_clear (h, destructor);
c002aae5:	83 ec 08             	sub    $0x8,%esp
c002aae8:	50                   	push   %eax
c002aae9:	56                   	push   %esi
c002aaea:	e8 ec fe ff ff       	call   c002a9db <hash_clear>
c002aaef:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002aaf2:	83 ec 0c             	sub    $0xc,%esp
c002aaf5:	ff 76 08             	pushl  0x8(%esi)
c002aaf8:	e8 ff 94 ff ff       	call   c0023ffc <free>
}
c002aafd:	83 c4 14             	add    $0x14,%esp
c002ab00:	5b                   	pop    %ebx
c002ab01:	5e                   	pop    %esi
c002ab02:	c3                   	ret    

c002ab03 <hash_insert>:
{
c002ab03:	55                   	push   %ebp
c002ab04:	57                   	push   %edi
c002ab05:	56                   	push   %esi
c002ab06:	53                   	push   %ebx
c002ab07:	83 ec 0c             	sub    $0xc,%esp
c002ab0a:	e8 34 56 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ab0f:	81 c3 9d 31 01 00    	add    $0x1319d,%ebx
c002ab15:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002ab19:	8b 54 24 24          	mov    0x24(%esp),%edx
c002ab1d:	89 f0                	mov    %esi,%eax
c002ab1f:	e8 b6 fc ff ff       	call   c002a7da <find_bucket>
c002ab24:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002ab26:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002ab2a:	89 c2                	mov    %eax,%edx
c002ab2c:	89 f0                	mov    %esi,%eax
c002ab2e:	e8 c9 fc ff ff       	call   c002a7fc <find_elem>
c002ab33:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c002ab35:	85 c0                	test   %eax,%eax
c002ab37:	74 11                	je     c002ab4a <hash_insert+0x47>
  rehash (h);
c002ab39:	89 f0                	mov    %esi,%eax
c002ab3b:	e8 39 fd ff ff       	call   c002a879 <rehash>
}
c002ab40:	89 f8                	mov    %edi,%eax
c002ab42:	83 c4 0c             	add    $0xc,%esp
c002ab45:	5b                   	pop    %ebx
c002ab46:	5e                   	pop    %esi
c002ab47:	5f                   	pop    %edi
c002ab48:	5d                   	pop    %ebp
c002ab49:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c002ab4a:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002ab4d:	83 ec 08             	sub    $0x8,%esp
c002ab50:	ff 74 24 2c          	pushl  0x2c(%esp)
c002ab54:	55                   	push   %ebp
c002ab55:	e8 68 ec ff ff       	call   c00297c2 <list_push_front>
c002ab5a:	83 c4 10             	add    $0x10,%esp
c002ab5d:	eb da                	jmp    c002ab39 <hash_insert+0x36>

c002ab5f <hash_replace>:
{
c002ab5f:	55                   	push   %ebp
c002ab60:	57                   	push   %edi
c002ab61:	56                   	push   %esi
c002ab62:	53                   	push   %ebx
c002ab63:	83 ec 0c             	sub    $0xc,%esp
c002ab66:	e8 d8 55 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ab6b:	81 c3 41 31 01 00    	add    $0x13141,%ebx
c002ab71:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002ab75:	8b 54 24 24          	mov    0x24(%esp),%edx
c002ab79:	89 f0                	mov    %esi,%eax
c002ab7b:	e8 5a fc ff ff       	call   c002a7da <find_bucket>
c002ab80:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002ab82:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002ab86:	89 c2                	mov    %eax,%edx
c002ab88:	89 f0                	mov    %esi,%eax
c002ab8a:	e8 6d fc ff ff       	call   c002a7fc <find_elem>
c002ab8f:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c002ab91:	85 c0                	test   %eax,%eax
c002ab93:	74 0f                	je     c002aba4 <hash_replace+0x45>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c002ab95:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002ab98:	83 ec 0c             	sub    $0xc,%esp
c002ab9b:	50                   	push   %eax
c002ab9c:	e8 5b ec ff ff       	call   c00297fc <list_remove>
c002aba1:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c002aba4:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002aba7:	83 ec 08             	sub    $0x8,%esp
c002abaa:	ff 74 24 2c          	pushl  0x2c(%esp)
c002abae:	55                   	push   %ebp
c002abaf:	e8 0e ec ff ff       	call   c00297c2 <list_push_front>
  rehash (h);
c002abb4:	89 f0                	mov    %esi,%eax
c002abb6:	e8 be fc ff ff       	call   c002a879 <rehash>
}
c002abbb:	89 f8                	mov    %edi,%eax
c002abbd:	83 c4 1c             	add    $0x1c,%esp
c002abc0:	5b                   	pop    %ebx
c002abc1:	5e                   	pop    %esi
c002abc2:	5f                   	pop    %edi
c002abc3:	5d                   	pop    %ebp
c002abc4:	c3                   	ret    

c002abc5 <hash_find>:
{
c002abc5:	56                   	push   %esi
c002abc6:	53                   	push   %ebx
c002abc7:	83 ec 04             	sub    $0x4,%esp
c002abca:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002abce:	8b 74 24 14          	mov    0x14(%esp),%esi
  return find_elem (h, find_bucket (h, e), e);
c002abd2:	89 f2                	mov    %esi,%edx
c002abd4:	89 d8                	mov    %ebx,%eax
c002abd6:	e8 ff fb ff ff       	call   c002a7da <find_bucket>
c002abdb:	89 f1                	mov    %esi,%ecx
c002abdd:	89 c2                	mov    %eax,%edx
c002abdf:	89 d8                	mov    %ebx,%eax
c002abe1:	e8 16 fc ff ff       	call   c002a7fc <find_elem>
}
c002abe6:	83 c4 04             	add    $0x4,%esp
c002abe9:	5b                   	pop    %ebx
c002abea:	5e                   	pop    %esi
c002abeb:	c3                   	ret    

c002abec <hash_delete>:
{
c002abec:	57                   	push   %edi
c002abed:	56                   	push   %esi
c002abee:	53                   	push   %ebx
c002abef:	e8 4f 55 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002abf4:	81 c3 b8 30 01 00    	add    $0x130b8,%ebx
c002abfa:	8b 74 24 10          	mov    0x10(%esp),%esi
c002abfe:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002ac02:	89 fa                	mov    %edi,%edx
c002ac04:	89 f0                	mov    %esi,%eax
c002ac06:	e8 cf fb ff ff       	call   c002a7da <find_bucket>
c002ac0b:	89 f9                	mov    %edi,%ecx
c002ac0d:	89 c2                	mov    %eax,%edx
c002ac0f:	89 f0                	mov    %esi,%eax
c002ac11:	e8 e6 fb ff ff       	call   c002a7fc <find_elem>
c002ac16:	89 c7                	mov    %eax,%edi
  if (found != NULL) 
c002ac18:	85 c0                	test   %eax,%eax
c002ac1a:	74 16                	je     c002ac32 <hash_delete+0x46>
  h->elem_cnt--;
c002ac1c:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002ac1f:	83 ec 0c             	sub    $0xc,%esp
c002ac22:	50                   	push   %eax
c002ac23:	e8 d4 eb ff ff       	call   c00297fc <list_remove>
      rehash (h); 
c002ac28:	89 f0                	mov    %esi,%eax
c002ac2a:	e8 4a fc ff ff       	call   c002a879 <rehash>
c002ac2f:	83 c4 10             	add    $0x10,%esp
}
c002ac32:	89 f8                	mov    %edi,%eax
c002ac34:	5b                   	pop    %ebx
c002ac35:	5e                   	pop    %esi
c002ac36:	5f                   	pop    %edi
c002ac37:	c3                   	ret    

c002ac38 <hash_apply>:
{
c002ac38:	55                   	push   %ebp
c002ac39:	57                   	push   %edi
c002ac3a:	56                   	push   %esi
c002ac3b:	53                   	push   %ebx
c002ac3c:	83 ec 1c             	sub    $0x1c,%esp
c002ac3f:	e8 ff 54 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ac44:	81 c3 68 30 01 00    	add    $0x13068,%ebx
c002ac4a:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c002ac4e:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c002ac53:	74 16                	je     c002ac6b <hash_apply+0x33>
  for (i = 0; i < h->bucket_cnt; i++) 
c002ac55:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002ac5c:	00 
c002ac5d:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c002ac61:	75 3f                	jne    c002aca2 <hash_apply+0x6a>
}
c002ac63:	83 c4 1c             	add    $0x1c,%esp
c002ac66:	5b                   	pop    %ebx
c002ac67:	5e                   	pop    %esi
c002ac68:	5f                   	pop    %edi
c002ac69:	5d                   	pop    %ebp
c002ac6a:	c3                   	ret    
  ASSERT (action != NULL);
c002ac6b:	83 ec 0c             	sub    $0xc,%esp
c002ac6e:	8d 83 26 56 ff ff    	lea    -0xa9da(%ebx),%eax
c002ac74:	50                   	push   %eax
c002ac75:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ac7b:	50                   	push   %eax
c002ac7c:	8d 83 28 33 ff ff    	lea    -0xccd8(%ebx),%eax
c002ac82:	50                   	push   %eax
c002ac83:	68 a7 00 00 00       	push   $0xa7
c002ac88:	8d 83 0e 56 ff ff    	lea    -0xa9f2(%ebx),%eax
c002ac8e:	50                   	push   %eax
c002ac8f:	e8 99 e4 ff ff       	call   c002912d <debug_panic>
  for (i = 0; i < h->bucket_cnt; i++) 
c002ac94:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
c002ac99:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002ac9d:	39 45 04             	cmp    %eax,0x4(%ebp)
c002aca0:	76 c1                	jbe    c002ac63 <hash_apply+0x2b>
      struct list *bucket = &h->buckets[i];
c002aca2:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002aca6:	c1 e7 04             	shl    $0x4,%edi
c002aca9:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002acac:	83 ec 0c             	sub    $0xc,%esp
c002acaf:	57                   	push   %edi
c002acb0:	e8 9d e5 ff ff       	call   c0029252 <list_begin>
c002acb5:	89 c6                	mov    %eax,%esi
c002acb7:	83 c4 10             	add    $0x10,%esp
c002acba:	83 ec 0c             	sub    $0xc,%esp
c002acbd:	57                   	push   %edi
c002acbe:	e8 31 e6 ff ff       	call   c00292f4 <list_end>
c002acc3:	83 c4 10             	add    $0x10,%esp
c002acc6:	39 f0                	cmp    %esi,%eax
c002acc8:	74 ca                	je     c002ac94 <hash_apply+0x5c>
          next = list_next (elem);
c002acca:	83 ec 0c             	sub    $0xc,%esp
c002accd:	56                   	push   %esi
c002acce:	e8 c4 e5 ff ff       	call   c0029297 <list_next>
c002acd3:	89 44 24 18          	mov    %eax,0x18(%esp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002acd7:	83 c4 08             	add    $0x8,%esp
c002acda:	ff 75 14             	pushl  0x14(%ebp)
c002acdd:	56                   	push   %esi
c002acde:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002ace2:	83 c4 10             	add    $0x10,%esp
c002ace5:	8b 74 24 08          	mov    0x8(%esp),%esi
c002ace9:	eb cf                	jmp    c002acba <hash_apply+0x82>

c002aceb <hash_first>:
{
c002aceb:	56                   	push   %esi
c002acec:	53                   	push   %ebx
c002aced:	83 ec 04             	sub    $0x4,%esp
c002acf0:	e8 4e 54 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002acf5:	81 c3 b7 2f 01 00    	add    $0x12fb7,%ebx
c002acfb:	8b 74 24 10          	mov    0x10(%esp),%esi
c002acff:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c002ad03:	85 f6                	test   %esi,%esi
c002ad05:	74 1e                	je     c002ad25 <hash_first+0x3a>
  ASSERT (h != NULL);
c002ad07:	85 c0                	test   %eax,%eax
c002ad09:	74 43                	je     c002ad4e <hash_first+0x63>
  i->hash = h;
c002ad0b:	89 06                	mov    %eax,(%esi)
  i->bucket = i->hash->buckets;
c002ad0d:	8b 40 08             	mov    0x8(%eax),%eax
c002ad10:	89 46 04             	mov    %eax,0x4(%esi)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002ad13:	83 ec 0c             	sub    $0xc,%esp
c002ad16:	50                   	push   %eax
c002ad17:	e8 78 e8 ff ff       	call   c0029594 <list_head>
c002ad1c:	89 46 08             	mov    %eax,0x8(%esi)
}
c002ad1f:	83 c4 14             	add    $0x14,%esp
c002ad22:	5b                   	pop    %ebx
c002ad23:	5e                   	pop    %esi
c002ad24:	c3                   	ret    
  ASSERT (i != NULL);
c002ad25:	83 ec 0c             	sub    $0xc,%esp
c002ad28:	8d 83 35 56 ff ff    	lea    -0xa9cb(%ebx),%eax
c002ad2e:	50                   	push   %eax
c002ad2f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ad35:	50                   	push   %eax
c002ad36:	8d 83 1c 33 ff ff    	lea    -0xcce4(%ebx),%eax
c002ad3c:	50                   	push   %eax
c002ad3d:	68 ca 00 00 00       	push   $0xca
c002ad42:	8d 83 0e 56 ff ff    	lea    -0xa9f2(%ebx),%eax
c002ad48:	50                   	push   %eax
c002ad49:	e8 df e3 ff ff       	call   c002912d <debug_panic>
  ASSERT (h != NULL);
c002ad4e:	83 ec 0c             	sub    $0xc,%esp
c002ad51:	8d 83 04 56 ff ff    	lea    -0xa9fc(%ebx),%eax
c002ad57:	50                   	push   %eax
c002ad58:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ad5e:	50                   	push   %eax
c002ad5f:	8d 83 1c 33 ff ff    	lea    -0xcce4(%ebx),%eax
c002ad65:	50                   	push   %eax
c002ad66:	68 cb 00 00 00       	push   $0xcb
c002ad6b:	8d 83 0e 56 ff ff    	lea    -0xa9f2(%ebx),%eax
c002ad71:	50                   	push   %eax
c002ad72:	e8 b6 e3 ff ff       	call   c002912d <debug_panic>

c002ad77 <hash_next>:
{
c002ad77:	57                   	push   %edi
c002ad78:	56                   	push   %esi
c002ad79:	53                   	push   %ebx
c002ad7a:	e8 c4 53 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ad7f:	81 c3 2d 2f 01 00    	add    $0x12f2d,%ebx
c002ad85:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (i != NULL);
c002ad89:	85 f6                	test   %esi,%esi
c002ad8b:	74 4f                	je     c002addc <hash_next+0x65>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002ad8d:	83 ec 0c             	sub    $0xc,%esp
c002ad90:	ff 76 08             	pushl  0x8(%esi)
c002ad93:	e8 ff e4 ff ff       	call   c0029297 <list_next>
c002ad98:	89 46 08             	mov    %eax,0x8(%esi)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002ad9b:	83 c4 10             	add    $0x10,%esp
c002ad9e:	8b 7e 08             	mov    0x8(%esi),%edi
c002ada1:	83 ec 0c             	sub    $0xc,%esp
c002ada4:	ff 76 04             	pushl  0x4(%esi)
c002ada7:	e8 48 e5 ff ff       	call   c00292f4 <list_end>
c002adac:	83 c4 10             	add    $0x10,%esp
c002adaf:	39 c7                	cmp    %eax,%edi
c002adb1:	75 59                	jne    c002ae0c <hash_next+0x95>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002adb3:	8b 46 04             	mov    0x4(%esi),%eax
c002adb6:	8d 50 10             	lea    0x10(%eax),%edx
c002adb9:	89 56 04             	mov    %edx,0x4(%esi)
c002adbc:	8b 0e                	mov    (%esi),%ecx
c002adbe:	8b 41 04             	mov    0x4(%ecx),%eax
c002adc1:	c1 e0 04             	shl    $0x4,%eax
c002adc4:	03 41 08             	add    0x8(%ecx),%eax
c002adc7:	39 c2                	cmp    %eax,%edx
c002adc9:	73 3a                	jae    c002ae05 <hash_next+0x8e>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002adcb:	83 ec 0c             	sub    $0xc,%esp
c002adce:	52                   	push   %edx
c002adcf:	e8 7e e4 ff ff       	call   c0029252 <list_begin>
c002add4:	89 46 08             	mov    %eax,0x8(%esi)
c002add7:	83 c4 10             	add    $0x10,%esp
c002adda:	eb c2                	jmp    c002ad9e <hash_next+0x27>
  ASSERT (i != NULL);
c002addc:	83 ec 0c             	sub    $0xc,%esp
c002addf:	8d 83 35 56 ff ff    	lea    -0xa9cb(%ebx),%eax
c002ade5:	50                   	push   %eax
c002ade6:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002adec:	50                   	push   %eax
c002aded:	8d 83 10 33 ff ff    	lea    -0xccf0(%ebx),%eax
c002adf3:	50                   	push   %eax
c002adf4:	68 dd 00 00 00       	push   $0xdd
c002adf9:	8d 83 0e 56 ff ff    	lea    -0xa9f2(%ebx),%eax
c002adff:	50                   	push   %eax
c002ae00:	e8 28 e3 ff ff       	call   c002912d <debug_panic>
          i->elem = NULL;
c002ae05:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  return i->elem;
c002ae0c:	8b 46 08             	mov    0x8(%esi),%eax
}
c002ae0f:	5b                   	pop    %ebx
c002ae10:	5e                   	pop    %esi
c002ae11:	5f                   	pop    %edi
c002ae12:	c3                   	ret    

c002ae13 <hash_cur>:
  return i->elem;
c002ae13:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ae17:	8b 40 08             	mov    0x8(%eax),%eax
}
c002ae1a:	c3                   	ret    

c002ae1b <hash_size>:
  return h->elem_cnt;
c002ae1b:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ae1f:	8b 00                	mov    (%eax),%eax
}
c002ae21:	c3                   	ret    

c002ae22 <hash_empty>:
  return h->elem_cnt == 0;
c002ae22:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ae26:	83 38 00             	cmpl   $0x0,(%eax)
c002ae29:	0f 94 c0             	sete   %al
}
c002ae2c:	c3                   	ret    

c002ae2d <hash_bytes>:
{
c002ae2d:	53                   	push   %ebx
c002ae2e:	83 ec 08             	sub    $0x8,%esp
c002ae31:	e8 0d 53 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ae36:	81 c3 76 2e 01 00    	add    $0x12e76,%ebx
c002ae3c:	8b 54 24 10          	mov    0x10(%esp),%edx
c002ae40:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (buf != NULL);
c002ae44:	85 d2                	test   %edx,%edx
c002ae46:	74 24                	je     c002ae6c <hash_bytes+0x3f>
c002ae48:	8d 1c 0a             	lea    (%edx,%ecx,1),%ebx
  hash = FNV_32_BASIS;
c002ae4b:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (size-- > 0)
c002ae50:	85 c9                	test   %ecx,%ecx
c002ae52:	74 13                	je     c002ae67 <hash_bytes+0x3a>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002ae54:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002ae5a:	83 c2 01             	add    $0x1,%edx
c002ae5d:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
c002ae61:	31 c8                	xor    %ecx,%eax
  while (size-- > 0)
c002ae63:	39 da                	cmp    %ebx,%edx
c002ae65:	75 ed                	jne    c002ae54 <hash_bytes+0x27>
} 
c002ae67:	83 c4 08             	add    $0x8,%esp
c002ae6a:	5b                   	pop    %ebx
c002ae6b:	c3                   	ret    
  ASSERT (buf != NULL);
c002ae6c:	83 ec 0c             	sub    $0xc,%esp
c002ae6f:	8d 83 3f 56 ff ff    	lea    -0xa9c1(%ebx),%eax
c002ae75:	50                   	push   %eax
c002ae76:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ae7c:	50                   	push   %eax
c002ae7d:	8d 83 04 33 ff ff    	lea    -0xccfc(%ebx),%eax
c002ae83:	50                   	push   %eax
c002ae84:	68 10 01 00 00       	push   $0x110
c002ae89:	8d 83 0e 56 ff ff    	lea    -0xa9f2(%ebx),%eax
c002ae8f:	50                   	push   %eax
c002ae90:	e8 98 e2 ff ff       	call   c002912d <debug_panic>

c002ae95 <hash_string>:
{
c002ae95:	56                   	push   %esi
c002ae96:	53                   	push   %ebx
c002ae97:	83 ec 04             	sub    $0x4,%esp
c002ae9a:	e8 a4 52 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ae9f:	81 c3 0d 2e 01 00    	add    $0x12e0d,%ebx
c002aea5:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (s != NULL);
c002aea9:	85 f6                	test   %esi,%esi
c002aeab:	74 27                	je     c002aed4 <hash_string+0x3f>
  while (*s != '\0')
c002aead:	0f b6 16             	movzbl (%esi),%edx
  hash = FNV_32_BASIS;
c002aeb0:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (*s != '\0')
c002aeb5:	84 d2                	test   %dl,%dl
c002aeb7:	74 15                	je     c002aece <hash_string+0x39>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002aeb9:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002aebf:	83 c6 01             	add    $0x1,%esi
c002aec2:	0f b6 c2             	movzbl %dl,%eax
c002aec5:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c002aec7:	0f b6 16             	movzbl (%esi),%edx
c002aeca:	84 d2                	test   %dl,%dl
c002aecc:	75 eb                	jne    c002aeb9 <hash_string+0x24>
}
c002aece:	83 c4 04             	add    $0x4,%esp
c002aed1:	5b                   	pop    %ebx
c002aed2:	5e                   	pop    %esi
c002aed3:	c3                   	ret    
  ASSERT (s != NULL);
c002aed4:	83 ec 0c             	sub    $0xc,%esp
c002aed7:	8d 93 df 51 ff ff    	lea    -0xae21(%ebx),%edx
c002aedd:	52                   	push   %edx
c002aede:	8d 93 de 36 ff ff    	lea    -0xc922(%ebx),%edx
c002aee4:	52                   	push   %edx
c002aee5:	8d 93 f8 32 ff ff    	lea    -0xcd08(%ebx),%edx
c002aeeb:	52                   	push   %edx
c002aeec:	68 20 01 00 00       	push   $0x120
c002aef1:	8d 93 0e 56 ff ff    	lea    -0xa9f2(%ebx),%edx
c002aef7:	52                   	push   %edx
c002aef8:	e8 30 e2 ff ff       	call   c002912d <debug_panic>

c002aefd <hash_int>:
{
c002aefd:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c002af00:	6a 04                	push   $0x4
c002af02:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002af06:	50                   	push   %eax
c002af07:	e8 21 ff ff ff       	call   c002ae2d <hash_bytes>
}
c002af0c:	83 c4 1c             	add    $0x1c,%esp
c002af0f:	c3                   	ret    

c002af10 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002af10:	56                   	push   %esi
c002af11:	53                   	push   %ebx
c002af12:	83 ec 04             	sub    $0x4,%esp
c002af15:	e8 29 52 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002af1a:	81 c3 92 2d 01 00    	add    $0x12d92,%ebx
c002af20:	89 c6                	mov    %eax,%esi
  return (intr_context ()
c002af22:	e8 e1 70 ff ff       	call   c0022008 <intr_context>
          || lock_held_by_current_thread (&console_lock));
c002af27:	84 c0                	test   %al,%al
c002af29:	75 09                	jne    c002af34 <putchar_have_lock+0x24>
          || !use_console_lock
c002af2b:	80 bb 60 1c 00 00 00 	cmpb   $0x0,0x1c60(%ebx)
c002af32:	75 2a                	jne    c002af5e <putchar_have_lock+0x4e>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c002af34:	83 83 54 1c 00 00 01 	addl   $0x1,0x1c54(%ebx)
c002af3b:	83 93 58 1c 00 00 00 	adcl   $0x0,0x1c58(%ebx)
  serial_putc (c);
c002af42:	89 f0                	mov    %esi,%eax
c002af44:	0f b6 f0             	movzbl %al,%esi
c002af47:	83 ec 0c             	sub    $0xc,%esp
c002af4a:	56                   	push   %esi
c002af4b:	e8 0c a0 ff ff       	call   c0024f5c <serial_putc>
  vga_putc (c);
c002af50:	89 34 24             	mov    %esi,(%esp)
c002af53:	e8 ce 9b ff ff       	call   c0024b26 <vga_putc>
}
c002af58:	83 c4 14             	add    $0x14,%esp
c002af5b:	5b                   	pop    %ebx
c002af5c:	5e                   	pop    %esi
c002af5d:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c002af5e:	83 ec 0c             	sub    $0xc,%esp
c002af61:	8d 83 74 1c 00 00    	lea    0x1c74(%ebx),%eax
c002af67:	50                   	push   %eax
c002af68:	e8 9c 82 ff ff       	call   c0023209 <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c002af6d:	83 c4 10             	add    $0x10,%esp
c002af70:	84 c0                	test   %al,%al
c002af72:	75 c0                	jne    c002af34 <putchar_have_lock+0x24>
c002af74:	83 ec 0c             	sub    $0xc,%esp
c002af77:	8d 83 4c 56 ff ff    	lea    -0xa9b4(%ebx),%eax
c002af7d:	50                   	push   %eax
c002af7e:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002af84:	50                   	push   %eax
c002af85:	8d 83 3c 33 ff ff    	lea    -0xccc4(%ebx),%eax
c002af8b:	50                   	push   %eax
c002af8c:	68 bb 00 00 00       	push   $0xbb
c002af91:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c002af97:	50                   	push   %eax
c002af98:	e8 90 e1 ff ff       	call   c002912d <debug_panic>

c002af9d <vprintf_helper>:
{
c002af9d:	83 ec 0c             	sub    $0xc,%esp
c002afa0:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002afa4:	83 00 01             	addl   $0x1,(%eax)
  putchar_have_lock (c);
c002afa7:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002afac:	e8 5f ff ff ff       	call   c002af10 <putchar_have_lock>
}
c002afb1:	83 c4 0c             	add    $0xc,%esp
c002afb4:	c3                   	ret    

c002afb5 <acquire_console>:
{
c002afb5:	53                   	push   %ebx
c002afb6:	83 ec 08             	sub    $0x8,%esp
c002afb9:	e8 85 51 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002afbe:	81 c3 ee 2c 01 00    	add    $0x12cee,%ebx
  if (!intr_context () && use_console_lock) 
c002afc4:	e8 3f 70 ff ff       	call   c0022008 <intr_context>
c002afc9:	84 c0                	test   %al,%al
c002afcb:	75 09                	jne    c002afd6 <acquire_console+0x21>
c002afcd:	80 bb 60 1c 00 00 00 	cmpb   $0x0,0x1c60(%ebx)
c002afd4:	75 05                	jne    c002afdb <acquire_console+0x26>
}
c002afd6:	83 c4 08             	add    $0x8,%esp
c002afd9:	5b                   	pop    %ebx
c002afda:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c002afdb:	83 ec 0c             	sub    $0xc,%esp
c002afde:	8d 83 74 1c 00 00    	lea    0x1c74(%ebx),%eax
c002afe4:	50                   	push   %eax
c002afe5:	e8 1f 82 ff ff       	call   c0023209 <lock_held_by_current_thread>
c002afea:	83 c4 10             	add    $0x10,%esp
c002afed:	84 c0                	test   %al,%al
c002afef:	74 09                	je     c002affa <acquire_console+0x45>
        console_lock_depth++; 
c002aff1:	83 83 5c 1c 00 00 01 	addl   $0x1,0x1c5c(%ebx)
c002aff8:	eb dc                	jmp    c002afd6 <acquire_console+0x21>
        lock_acquire (&console_lock); 
c002affa:	83 ec 0c             	sub    $0xc,%esp
c002affd:	8d 83 74 1c 00 00    	lea    0x1c74(%ebx),%eax
c002b003:	50                   	push   %eax
c002b004:	e8 53 82 ff ff       	call   c002325c <lock_acquire>
c002b009:	83 c4 10             	add    $0x10,%esp
}
c002b00c:	eb c8                	jmp    c002afd6 <acquire_console+0x21>

c002b00e <release_console>:
{
c002b00e:	53                   	push   %ebx
c002b00f:	83 ec 08             	sub    $0x8,%esp
c002b012:	e8 2c 51 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b017:	81 c3 95 2c 01 00    	add    $0x12c95,%ebx
  if (!intr_context () && use_console_lock) 
c002b01d:	e8 e6 6f ff ff       	call   c0022008 <intr_context>
c002b022:	84 c0                	test   %al,%al
c002b024:	75 1c                	jne    c002b042 <release_console+0x34>
c002b026:	80 bb 60 1c 00 00 00 	cmpb   $0x0,0x1c60(%ebx)
c002b02d:	74 13                	je     c002b042 <release_console+0x34>
      if (console_lock_depth > 0)
c002b02f:	8b 83 5c 1c 00 00    	mov    0x1c5c(%ebx),%eax
c002b035:	85 c0                	test   %eax,%eax
c002b037:	7e 0e                	jle    c002b047 <release_console+0x39>
        console_lock_depth--;
c002b039:	83 e8 01             	sub    $0x1,%eax
c002b03c:	89 83 5c 1c 00 00    	mov    %eax,0x1c5c(%ebx)
}
c002b042:	83 c4 08             	add    $0x8,%esp
c002b045:	5b                   	pop    %ebx
c002b046:	c3                   	ret    
        lock_release (&console_lock); 
c002b047:	83 ec 0c             	sub    $0xc,%esp
c002b04a:	8d 83 74 1c 00 00    	lea    0x1c74(%ebx),%eax
c002b050:	50                   	push   %eax
c002b051:	e8 07 84 ff ff       	call   c002345d <lock_release>
c002b056:	83 c4 10             	add    $0x10,%esp
}
c002b059:	eb e7                	jmp    c002b042 <release_console+0x34>

c002b05b <console_init>:
{
c002b05b:	53                   	push   %ebx
c002b05c:	83 ec 14             	sub    $0x14,%esp
c002b05f:	e8 df 50 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b064:	81 c3 48 2c 01 00    	add    $0x12c48,%ebx
  lock_init (&console_lock);
c002b06a:	8d 83 74 1c 00 00    	lea    0x1c74(%ebx),%eax
c002b070:	50                   	push   %eax
c002b071:	e8 3a 81 ff ff       	call   c00231b0 <lock_init>
  use_console_lock = true;
c002b076:	c6 83 60 1c 00 00 01 	movb   $0x1,0x1c60(%ebx)
}
c002b07d:	83 c4 18             	add    $0x18,%esp
c002b080:	5b                   	pop    %ebx
c002b081:	c3                   	ret    

c002b082 <console_panic>:
{
c002b082:	e8 c0 50 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c002b087:	05 25 2c 01 00       	add    $0x12c25,%eax
  use_console_lock = false;
c002b08c:	c6 80 60 1c 00 00 00 	movb   $0x0,0x1c60(%eax)
}
c002b093:	c3                   	ret    

c002b094 <console_print_stats>:
{
c002b094:	53                   	push   %ebx
c002b095:	83 ec 0c             	sub    $0xc,%esp
c002b098:	e8 a6 50 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b09d:	81 c3 0f 2c 01 00    	add    $0x12c0f,%ebx
  printf ("Console: %lld characters output\n", write_cnt);
c002b0a3:	ff b3 58 1c 00 00    	pushl  0x1c58(%ebx)
c002b0a9:	ff b3 54 1c 00 00    	pushl  0x1c54(%ebx)
c002b0af:	8d 83 70 56 ff ff    	lea    -0xa990(%ebx),%eax
c002b0b5:	50                   	push   %eax
c002b0b6:	e8 16 c4 ff ff       	call   c00274d1 <printf>
}
c002b0bb:	83 c4 18             	add    $0x18,%esp
c002b0be:	5b                   	pop    %ebx
c002b0bf:	c3                   	ret    

c002b0c0 <vprintf>:
{
c002b0c0:	53                   	push   %ebx
c002b0c1:	83 ec 18             	sub    $0x18,%esp
c002b0c4:	e8 7a 50 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b0c9:	81 c3 e3 2b 01 00    	add    $0x12be3,%ebx
  int char_cnt = 0;
c002b0cf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002b0d6:	00 
  acquire_console ();
c002b0d7:	e8 d9 fe ff ff       	call   c002afb5 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002b0dc:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002b0e0:	50                   	push   %eax
c002b0e1:	8d 83 f1 d2 fe ff    	lea    -0x12d0f(%ebx),%eax
c002b0e7:	50                   	push   %eax
c002b0e8:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b0ec:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b0f0:	e8 1e c4 ff ff       	call   c0027513 <__vprintf>
  release_console ();
c002b0f5:	e8 14 ff ff ff       	call   c002b00e <release_console>
}
c002b0fa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b0fe:	83 c4 28             	add    $0x28,%esp
c002b101:	5b                   	pop    %ebx
c002b102:	c3                   	ret    

c002b103 <puts>:
{
c002b103:	53                   	push   %ebx
c002b104:	83 ec 08             	sub    $0x8,%esp
c002b107:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002b10b:	e8 a5 fe ff ff       	call   c002afb5 <acquire_console>
  while (*s != '\0')
c002b110:	0f b6 03             	movzbl (%ebx),%eax
c002b113:	84 c0                	test   %al,%al
c002b115:	74 12                	je     c002b129 <puts+0x26>
    putchar_have_lock (*s++);
c002b117:	83 c3 01             	add    $0x1,%ebx
c002b11a:	0f b6 c0             	movzbl %al,%eax
c002b11d:	e8 ee fd ff ff       	call   c002af10 <putchar_have_lock>
  while (*s != '\0')
c002b122:	0f b6 03             	movzbl (%ebx),%eax
c002b125:	84 c0                	test   %al,%al
c002b127:	75 ee                	jne    c002b117 <puts+0x14>
  putchar_have_lock ('\n');
c002b129:	b8 0a 00 00 00       	mov    $0xa,%eax
c002b12e:	e8 dd fd ff ff       	call   c002af10 <putchar_have_lock>
  release_console ();
c002b133:	e8 d6 fe ff ff       	call   c002b00e <release_console>
}
c002b138:	b8 00 00 00 00       	mov    $0x0,%eax
c002b13d:	83 c4 08             	add    $0x8,%esp
c002b140:	5b                   	pop    %ebx
c002b141:	c3                   	ret    

c002b142 <putbuf>:
{
c002b142:	56                   	push   %esi
c002b143:	53                   	push   %ebx
c002b144:	83 ec 04             	sub    $0x4,%esp
c002b147:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002b14b:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c002b14f:	e8 61 fe ff ff       	call   c002afb5 <acquire_console>
  while (n-- > 0)
c002b154:	85 f6                	test   %esi,%esi
c002b156:	74 12                	je     c002b16a <putbuf+0x28>
c002b158:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c002b15a:	83 c3 01             	add    $0x1,%ebx
c002b15d:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002b161:	e8 aa fd ff ff       	call   c002af10 <putchar_have_lock>
  while (n-- > 0)
c002b166:	39 de                	cmp    %ebx,%esi
c002b168:	75 f0                	jne    c002b15a <putbuf+0x18>
  release_console ();
c002b16a:	e8 9f fe ff ff       	call   c002b00e <release_console>
}
c002b16f:	83 c4 04             	add    $0x4,%esp
c002b172:	5b                   	pop    %ebx
c002b173:	5e                   	pop    %esi
c002b174:	c3                   	ret    

c002b175 <putchar>:
{
c002b175:	53                   	push   %ebx
c002b176:	83 ec 08             	sub    $0x8,%esp
c002b179:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002b17d:	e8 33 fe ff ff       	call   c002afb5 <acquire_console>
  putchar_have_lock (c);
c002b182:	0f b6 c3             	movzbl %bl,%eax
c002b185:	e8 86 fd ff ff       	call   c002af10 <putchar_have_lock>
  release_console ();
c002b18a:	e8 7f fe ff ff       	call   c002b00e <release_console>
}
c002b18f:	89 d8                	mov    %ebx,%eax
c002b191:	83 c4 08             	add    $0x8,%esp
c002b194:	5b                   	pop    %ebx
c002b195:	c3                   	ret    

c002b196 <get_file_name>:
        args->argc++;
    }
    return args;
}

char * get_file_name(char * cmd_line) {
c002b196:	55                   	push   %ebp
c002b197:	57                   	push   %edi
c002b198:	56                   	push   %esi
c002b199:	53                   	push   %ebx
c002b19a:	83 ec 18             	sub    $0x18,%esp
c002b19d:	e8 a1 4f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b1a2:	81 c3 0a 2b 01 00    	add    $0x12b0a,%ebx
c002b1a8:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    char * name = (char *) malloc(16);
c002b1ac:	6a 10                	push   $0x10
c002b1ae:	e8 9b 8c ff ff       	call   c0023e4e <malloc>
c002b1b3:	89 c3                	mov    %eax,%ebx
c002b1b5:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i <= strlen(cmd_line); i++) {
c002b1b8:	ba 00 00 00 00       	mov    $0x0,%edx
c002b1bd:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b1c2:	b8 00 00 00 00       	mov    $0x0,%eax
        if (*(cmd_line + i) != ' ') {
c002b1c7:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c002b1cb:	80 f9 20             	cmp    $0x20,%cl
c002b1ce:	74 1f                	je     c002b1ef <get_file_name+0x59>
            name[i] = *(cmd_line + i);
c002b1d0:	88 0c 13             	mov    %cl,(%ebx,%edx,1)
    for (int i = 0; i <= strlen(cmd_line); i++) {
c002b1d3:	83 c2 01             	add    $0x1,%edx
c002b1d6:	89 e9                	mov    %ebp,%ecx
c002b1d8:	89 f7                	mov    %esi,%edi
c002b1da:	f2 ae                	repnz scas %es:(%edi),%al
c002b1dc:	f7 d1                	not    %ecx
c002b1de:	83 e9 01             	sub    $0x1,%ecx
c002b1e1:	39 d1                	cmp    %edx,%ecx
c002b1e3:	73 e2                	jae    c002b1c7 <get_file_name+0x31>
            name[i] = '\0';
            break;
        }
    }
    return name;
}
c002b1e5:	89 d8                	mov    %ebx,%eax
c002b1e7:	83 c4 0c             	add    $0xc,%esp
c002b1ea:	5b                   	pop    %ebx
c002b1eb:	5e                   	pop    %esi
c002b1ec:	5f                   	pop    %edi
c002b1ed:	5d                   	pop    %ebp
c002b1ee:	c3                   	ret    
            name[i] = '\0';
c002b1ef:	c6 04 13 00          	movb   $0x0,(%ebx,%edx,1)
    return name;
c002b1f3:	eb f0                	jmp    c002b1e5 <get_file_name+0x4f>

c002b1f5 <process_execute>:
/* Starts a new thread running a user program loaded from
   FILENAME.  The new thread may be scheduled (and may even exit)
   before process_execute() returns.  Returns the new process's
   thread id, or TID_ERROR if the thread cannot be created. */
tid_t
process_execute(const char *file_name) {
c002b1f5:	55                   	push   %ebp
c002b1f6:	57                   	push   %edi
c002b1f7:	56                   	push   %esi
c002b1f8:	53                   	push   %ebx
c002b1f9:	83 ec 28             	sub    $0x28,%esp
c002b1fc:	e8 42 4f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b201:	81 c3 ab 2a 01 00    	add    $0x12aab,%ebx
c002b207:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    char *fn_copy;
    tid_t tid;
    char * name = (char *) malloc(16);
c002b20b:	6a 10                	push   $0x10
c002b20d:	e8 3c 8c ff ff       	call   c0023e4e <malloc>
c002b212:	89 c5                	mov    %eax,%ebp
    /* Make a copy of FILE_NAME.
       Otherwise there's a race between the caller and load(). */
    fn_copy = palloc_get_page(0);
c002b214:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b21b:	e8 1c 88 ff ff       	call   c0023a3c <palloc_get_page>
c002b220:	89 44 24 1c          	mov    %eax,0x1c(%esp)

    if (fn_copy == NULL)
c002b224:	83 c4 10             	add    $0x10,%esp
c002b227:	85 c0                	test   %eax,%eax
c002b229:	0f 84 9f 00 00 00    	je     c002b2ce <process_execute+0xd9>
        return TID_ERROR;
    strlcpy(fn_copy, file_name, PGSIZE);
c002b22f:	83 ec 04             	sub    $0x4,%esp
c002b232:	68 00 10 00 00       	push   $0x1000
c002b237:	56                   	push   %esi
c002b238:	50                   	push   %eax
c002b239:	e8 31 d5 ff ff       	call   c002876f <strlcpy>
c002b23e:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i <= strlen(file_name); i++) {
c002b241:	ba 00 00 00 00       	mov    $0x0,%edx
c002b246:	b8 00 00 00 00       	mov    $0x0,%eax
        if (*(file_name + i) != ' ') {
c002b24b:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c002b24f:	80 f9 20             	cmp    $0x20,%cl
c002b252:	74 73                	je     c002b2c7 <process_execute+0xd2>
            name[i] = *(file_name + i);
c002b254:	88 4c 15 00          	mov    %cl,0x0(%ebp,%edx,1)
    for (int i = 0; i <= strlen(file_name); i++) {
c002b258:	83 c2 01             	add    $0x1,%edx
c002b25b:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b260:	89 f7                	mov    %esi,%edi
c002b262:	f2 ae                	repnz scas %es:(%edi),%al
c002b264:	f7 d1                	not    %ecx
c002b266:	83 e9 01             	sub    $0x1,%ecx
c002b269:	39 d1                	cmp    %edx,%ecx
c002b26b:	73 de                	jae    c002b24b <process_execute+0x56>
            break;
        }
    }

    /* Create a new thread to execute FILE_NAME. */
    struct start_process_arg * arg = malloc(sizeof(struct start_process_arg));
c002b26d:	83 ec 0c             	sub    $0xc,%esp
c002b270:	6a 1c                	push   $0x1c
c002b272:	e8 d7 8b ff ff       	call   c0023e4e <malloc>
c002b277:	89 c6                	mov    %eax,%esi
    arg->file_name = fn_copy;
c002b279:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b27d:	89 06                	mov    %eax,(%esi)
    sema_init(&arg->sema, 0);
c002b27f:	8d 7e 04             	lea    0x4(%esi),%edi
c002b282:	83 c4 08             	add    $0x8,%esp
c002b285:	6a 00                	push   $0x0
c002b287:	57                   	push   %edi
c002b288:	e8 52 7c ff ff       	call   c0022edf <sema_init>
    tid = thread_create(name, PRI_DEFAULT + 1, start_process, arg);
c002b28d:	56                   	push   %esi
c002b28e:	8d 83 e0 d9 fe ff    	lea    -0x12620(%ebx),%eax
c002b294:	50                   	push   %eax
c002b295:	6a 20                	push   $0x20
c002b297:	55                   	push   %ebp
c002b298:	e8 fe 64 ff ff       	call   c002179b <thread_create>
c002b29d:	89 c5                	mov    %eax,%ebp
    sema_down(&arg->sema);  // wait the process to load file done
c002b29f:	83 c4 14             	add    $0x14,%esp
c002b2a2:	57                   	push   %edi
c002b2a3:	e8 8b 7c ff ff       	call   c0022f33 <sema_down>
    if (!arg->success) {
c002b2a8:	83 c4 10             	add    $0x10,%esp
c002b2ab:	80 7e 18 00          	cmpb   $0x0,0x18(%esi)
c002b2af:	74 24                	je     c002b2d5 <process_execute+0xe0>
        // printf("%s load fail\n", name);
        return -1;
    }
    free(arg);
c002b2b1:	83 ec 0c             	sub    $0xc,%esp
c002b2b4:	56                   	push   %esi
c002b2b5:	e8 42 8d ff ff       	call   c0023ffc <free>
    return tid;
c002b2ba:	83 c4 10             	add    $0x10,%esp
}
c002b2bd:	89 e8                	mov    %ebp,%eax
c002b2bf:	83 c4 1c             	add    $0x1c,%esp
c002b2c2:	5b                   	pop    %ebx
c002b2c3:	5e                   	pop    %esi
c002b2c4:	5f                   	pop    %edi
c002b2c5:	5d                   	pop    %ebp
c002b2c6:	c3                   	ret    
            name[i] = '\0';
c002b2c7:	c6 44 15 00 00       	movb   $0x0,0x0(%ebp,%edx,1)
            break;
c002b2cc:	eb 9f                	jmp    c002b26d <process_execute+0x78>
        return TID_ERROR;
c002b2ce:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b2d3:	eb e8                	jmp    c002b2bd <process_execute+0xc8>
        return -1;
c002b2d5:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b2da:	eb e1                	jmp    c002b2bd <process_execute+0xc8>

c002b2dc <get_child_process>:
       and jump to it. */
    asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
    NOT_REACHED ();
}

struct process_info *get_child_process(tid_t child_tid, struct list child_list) {
c002b2dc:	55                   	push   %ebp
c002b2dd:	57                   	push   %edi
c002b2de:	56                   	push   %esi
c002b2df:	53                   	push   %ebx
c002b2e0:	83 ec 18             	sub    $0x18,%esp
c002b2e3:	e8 5b 4e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b2e8:	81 c3 c4 29 01 00    	add    $0x129c4,%ebx
c002b2ee:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    struct list_elem *e;
    if (list_empty(&child_list)) return NULL;
c002b2f2:	8d 44 24 30          	lea    0x30(%esp),%eax
c002b2f6:	50                   	push   %eax
c002b2f7:	e8 a2 e5 ff ff       	call   c002989e <list_empty>
c002b2fc:	83 c4 10             	add    $0x10,%esp
c002b2ff:	ba 00 00 00 00       	mov    $0x0,%edx
c002b304:	84 c0                	test   %al,%al
c002b306:	75 4e                	jne    c002b356 <get_child_process+0x7a>
    // enum intr_level old_level = intr_disable();
    for (e = list_begin(&child_list); e != list_end(&child_list);
c002b308:	83 ec 0c             	sub    $0xc,%esp
c002b30b:	8d 44 24 30          	lea    0x30(%esp),%eax
c002b30f:	50                   	push   %eax
c002b310:	e8 3d df ff ff       	call   c0029252 <list_begin>
c002b315:	89 c6                	mov    %eax,%esi
c002b317:	83 c4 10             	add    $0x10,%esp
c002b31a:	8d 6c 24 24          	lea    0x24(%esp),%ebp
c002b31e:	eb 13                	jmp    c002b333 <get_child_process+0x57>
         e = list_next(e)) {
        // if (list)
        struct process_info *t = list_entry(e, struct process_info, elem);
c002b320:	8d 56 f4             	lea    -0xc(%esi),%edx
c002b323:	eb 31                	jmp    c002b356 <get_child_process+0x7a>
         e = list_next(e)) {
c002b325:	83 ec 0c             	sub    $0xc,%esp
c002b328:	56                   	push   %esi
c002b329:	e8 69 df ff ff       	call   c0029297 <list_next>
c002b32e:	89 c6                	mov    %eax,%esi
c002b330:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin(&child_list); e != list_end(&child_list);
c002b333:	83 ec 0c             	sub    $0xc,%esp
c002b336:	55                   	push   %ebp
c002b337:	e8 b8 df ff ff       	call   c00292f4 <list_end>
c002b33c:	83 c4 10             	add    $0x10,%esp
c002b33f:	39 f0                	cmp    %esi,%eax
c002b341:	74 0e                	je     c002b351 <get_child_process+0x75>
        if (t->tid == child_tid) {
c002b343:	39 7e f8             	cmp    %edi,-0x8(%esi)
c002b346:	74 d8                	je     c002b320 <get_child_process+0x44>
            return t;
        }
        if (e->next == NULL) break; // shall use lock to prevent this case
c002b348:	8b 56 04             	mov    0x4(%esi),%edx
c002b34b:	85 d2                	test   %edx,%edx
c002b34d:	75 d6                	jne    c002b325 <get_child_process+0x49>
c002b34f:	eb 05                	jmp    c002b356 <get_child_process+0x7a>
    }
    // intr_set_level(old_level);
    return NULL;
c002b351:	ba 00 00 00 00       	mov    $0x0,%edx
}
c002b356:	89 d0                	mov    %edx,%eax
c002b358:	83 c4 0c             	add    $0xc,%esp
c002b35b:	5b                   	pop    %ebx
c002b35c:	5e                   	pop    %esi
c002b35d:	5f                   	pop    %edi
c002b35e:	5d                   	pop    %ebp
c002b35f:	c3                   	ret    

c002b360 <process_wait>:
   immediately, without waiting.

   This function will be implemented in problem 2-2.  For now, it
   does nothing. */
int
process_wait(tid_t child_tid UNUSED) {
c002b360:	57                   	push   %edi
c002b361:	56                   	push   %esi
c002b362:	53                   	push   %ebx
c002b363:	e8 db 4d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b368:	81 c3 44 29 01 00    	add    $0x12944,%ebx
    struct thread *t = thread_current();
c002b36e:	e8 56 5c ff ff       	call   c0020fc9 <thread_current>
c002b373:	89 c6                	mov    %eax,%esi
    if (list_empty(&t->child_list)) {
c002b375:	83 ec 0c             	sub    $0xc,%esp
c002b378:	8d 80 cc 00 00 00    	lea    0xcc(%eax),%eax
c002b37e:	50                   	push   %eax
c002b37f:	e8 1a e5 ff ff       	call   c002989e <list_empty>
c002b384:	83 c4 10             	add    $0x10,%esp
c002b387:	84 c0                	test   %al,%al
c002b389:	75 66                	jne    c002b3f1 <process_wait+0x91>
        return -1;
    }
    struct process_info *child = get_child_process(child_tid, t->child_list);
c002b38b:	83 ec 0c             	sub    $0xc,%esp
c002b38e:	ff b6 d8 00 00 00    	pushl  0xd8(%esi)
c002b394:	ff b6 d4 00 00 00    	pushl  0xd4(%esi)
c002b39a:	ff b6 d0 00 00 00    	pushl  0xd0(%esi)
c002b3a0:	ff b6 cc 00 00 00    	pushl  0xcc(%esi)
c002b3a6:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b3aa:	e8 2d ff ff ff       	call   c002b2dc <get_child_process>
c002b3af:	89 c6                	mov    %eax,%esi
    if (child == NULL || child->is_waiting)
c002b3b1:	83 c4 20             	add    $0x20,%esp
c002b3b4:	85 c0                	test   %eax,%eax
c002b3b6:	74 40                	je     c002b3f8 <process_wait+0x98>
c002b3b8:	80 38 00             	cmpb   $0x0,(%eax)
c002b3bb:	75 42                	jne    c002b3ff <process_wait+0x9f>
        return -1;
    child->is_waiting = true;
c002b3bd:	c6 00 01             	movb   $0x1,(%eax)
    while (!child->has_exited) {
c002b3c0:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
c002b3c4:	75 0b                	jne    c002b3d1 <process_wait+0x71>
        // printf("waiting for god damn %d \n", child_tid);
        thread_yield();
c002b3c6:	e8 3f 63 ff ff       	call   c002170a <thread_yield>
    while (!child->has_exited) {
c002b3cb:	80 7e 01 00          	cmpb   $0x0,0x1(%esi)
c002b3cf:	74 f5                	je     c002b3c6 <process_wait+0x66>
    }
    int exit_status = child->exit_status;
c002b3d1:	8b 7e 08             	mov    0x8(%esi),%edi
    list_remove(&child->elem);
c002b3d4:	83 ec 0c             	sub    $0xc,%esp
c002b3d7:	8d 46 0c             	lea    0xc(%esi),%eax
c002b3da:	50                   	push   %eax
c002b3db:	e8 1c e4 ff ff       	call   c00297fc <list_remove>
    free(child);
c002b3e0:	89 34 24             	mov    %esi,(%esp)
c002b3e3:	e8 14 8c ff ff       	call   c0023ffc <free>
    // printf("waiting by \"%d\" done, ret %d.\n", t->tid, exit_status);
    return exit_status;
c002b3e8:	83 c4 10             	add    $0x10,%esp

}
c002b3eb:	89 f8                	mov    %edi,%eax
c002b3ed:	5b                   	pop    %ebx
c002b3ee:	5e                   	pop    %esi
c002b3ef:	5f                   	pop    %edi
c002b3f0:	c3                   	ret    
        return -1;
c002b3f1:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002b3f6:	eb f3                	jmp    c002b3eb <process_wait+0x8b>
        return -1;
c002b3f8:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002b3fd:	eb ec                	jmp    c002b3eb <process_wait+0x8b>
c002b3ff:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002b404:	eb e5                	jmp    c002b3eb <process_wait+0x8b>

c002b406 <remove_all_children>:

void remove_all_children(struct thread *t) {
c002b406:	56                   	push   %esi
c002b407:	53                   	push   %ebx
c002b408:	83 ec 04             	sub    $0x4,%esp
c002b40b:	e8 33 4d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b410:	81 c3 9c 28 01 00    	add    $0x1289c,%ebx
    struct list_elem *e;
    while (!list_empty(&t->child_list)) {
c002b416:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b41a:	8d b0 cc 00 00 00    	lea    0xcc(%eax),%esi
c002b420:	83 ec 0c             	sub    $0xc,%esp
c002b423:	56                   	push   %esi
c002b424:	e8 75 e4 ff ff       	call   c002989e <list_empty>
c002b429:	83 c4 10             	add    $0x10,%esp
c002b42c:	84 c0                	test   %al,%al
c002b42e:	75 1b                	jne    c002b44b <remove_all_children+0x45>
        e = list_pop_front(&t->child_list);
c002b430:	83 ec 0c             	sub    $0xc,%esp
c002b433:	56                   	push   %esi
c002b434:	e8 dc e4 ff ff       	call   c0029915 <list_pop_front>
        struct process_info *child_info = list_entry(e, struct process_info, elem);
        child_info->thread_->parent = NULL;
c002b439:	8b 40 08             	mov    0x8(%eax),%eax
c002b43c:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%eax)
c002b443:	00 00 00 
c002b446:	83 c4 10             	add    $0x10,%esp
c002b449:	eb d5                	jmp    c002b420 <remove_all_children+0x1a>
    }
}
c002b44b:	83 c4 04             	add    $0x4,%esp
c002b44e:	5b                   	pop    %ebx
c002b44f:	5e                   	pop    %esi
c002b450:	c3                   	ret    

c002b451 <process_exit>:

/* Free the current process's resources. */
void
process_exit(void) {
c002b451:	57                   	push   %edi
c002b452:	56                   	push   %esi
c002b453:	53                   	push   %ebx
c002b454:	83 ec 10             	sub    $0x10,%esp
c002b457:	e8 e7 4c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b45c:	81 c3 50 28 01 00    	add    $0x12850,%ebx
    struct thread *cur = thread_current();
c002b462:	e8 62 5b ff ff       	call   c0020fc9 <thread_current>
c002b467:	89 c6                	mov    %eax,%esi
    uint32_t *pd;
    // kill children processes
    remove_all_children(cur);
c002b469:	83 ec 0c             	sub    $0xc,%esp
c002b46c:	50                   	push   %eax
c002b46d:	e8 94 ff ff ff       	call   c002b406 <remove_all_children>
    if (cur->src_code != NULL)
c002b472:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
c002b478:	83 c4 10             	add    $0x10,%esp
c002b47b:	85 c0                	test   %eax,%eax
c002b47d:	74 0c                	je     c002b48b <process_exit+0x3a>
        file_allow_write(cur->src_code);
c002b47f:	83 ec 0c             	sub    $0xc,%esp
c002b482:	50                   	push   %eax
c002b483:	e8 71 2a 00 00       	call   c002def9 <file_allow_write>
c002b488:	83 c4 10             	add    $0x10,%esp
    struct list brother_list = cur->parent->child_list;
c002b48b:	8b 86 dc 00 00 00    	mov    0xdc(%esi),%eax
c002b491:	8b 90 cc 00 00 00    	mov    0xcc(%eax),%edx
c002b497:	89 14 24             	mov    %edx,(%esp)
c002b49a:	8b 88 d0 00 00 00    	mov    0xd0(%eax),%ecx
c002b4a0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c002b4a4:	8b b8 d4 00 00 00    	mov    0xd4(%eax),%edi
c002b4aa:	89 7c 24 08          	mov    %edi,0x8(%esp)
c002b4ae:	8b 80 d8 00 00 00    	mov    0xd8(%eax),%eax
c002b4b4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    struct process_info *info_t = get_child_process(cur->tid, brother_list);
c002b4b8:	83 ec 0c             	sub    $0xc,%esp
c002b4bb:	50                   	push   %eax
c002b4bc:	57                   	push   %edi
c002b4bd:	51                   	push   %ecx
c002b4be:	52                   	push   %edx
c002b4bf:	ff 36                	pushl  (%esi)
c002b4c1:	e8 16 fe ff ff       	call   c002b2dc <get_child_process>
    if (info_t != NULL) {
c002b4c6:	83 c4 20             	add    $0x20,%esp
c002b4c9:	85 c0                	test   %eax,%eax
c002b4cb:	74 0a                	je     c002b4d7 <process_exit+0x86>
        info_t->exit_status = cur->exit_status;
c002b4cd:	8b 56 2c             	mov    0x2c(%esi),%edx
c002b4d0:	89 50 08             	mov    %edx,0x8(%eax)
        info_t->has_exited = true;
c002b4d3:	c6 40 01 01          	movb   $0x1,0x1(%eax)
    }
    /* Destroy the current process's page directory and switch back
       to the kernel-only page directory. */

#ifdef VM
    mmap_clear();
c002b4d7:	e8 97 1d 00 00       	call   c002d273 <mmap_clear>
    spt_destroy(cur->spt);
c002b4dc:	83 ec 0c             	sub    $0xc,%esp
c002b4df:	ff b6 18 01 00 00    	pushl  0x118(%esi)
c002b4e5:	e8 d8 46 00 00       	call   c002fbc2 <spt_destroy>
    cur->spt = NULL;
c002b4ea:	c7 86 18 01 00 00 00 	movl   $0x0,0x118(%esi)
c002b4f1:	00 00 00 
#endif
    
    pd = cur->pagedir;
c002b4f4:	8b be 10 01 00 00    	mov    0x110(%esi),%edi
    if (pd != NULL) {
c002b4fa:	83 c4 10             	add    $0x10,%esp
c002b4fd:	85 ff                	test   %edi,%edi
c002b4ff:	74 1f                	je     c002b520 <process_exit+0xcf>
           so that a timer interrupt can't switch back to the
           process page directory.  We must activate the base page
           directory before destroying the process's page
           directory, or our active page directory will be one
           that's been freed (and cleared). */
        cur->pagedir = NULL;
c002b501:	c7 86 10 01 00 00 00 	movl   $0x0,0x110(%esi)
c002b508:	00 00 00 
        pagedir_activate(NULL);
c002b50b:	83 ec 0c             	sub    $0xc,%esp
c002b50e:	6a 00                	push   $0x0
c002b510:	e8 84 0d 00 00       	call   c002c299 <pagedir_activate>
        pagedir_destroy(pd);
c002b515:	89 3c 24             	mov    %edi,(%esp)
c002b518:	e8 72 09 00 00       	call   c002be8f <pagedir_destroy>
c002b51d:	83 c4 10             	add    $0x10,%esp
    }
}
c002b520:	83 c4 10             	add    $0x10,%esp
c002b523:	5b                   	pop    %ebx
c002b524:	5e                   	pop    %esi
c002b525:	5f                   	pop    %edi
c002b526:	c3                   	ret    

c002b527 <process_activate>:

/* Sets up the CPU for running user code in the current
   thread.
   This function is called on every context switch. */
void
process_activate(void) {
c002b527:	53                   	push   %ebx
c002b528:	83 ec 08             	sub    $0x8,%esp
c002b52b:	e8 13 4c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b530:	81 c3 7c 27 01 00    	add    $0x1277c,%ebx
    struct thread *t = thread_current();
c002b536:	e8 8e 5a ff ff       	call   c0020fc9 <thread_current>

    /* Activate thread's page tables. */
    pagedir_activate(t->pagedir);
c002b53b:	83 ec 0c             	sub    $0xc,%esp
c002b53e:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002b544:	e8 50 0d 00 00       	call   c002c299 <pagedir_activate>

    /* Set thread's kernel stack for use in processing
       interrupts. */
    tss_update();
c002b549:	e8 ce 22 00 00       	call   c002d81c <tss_update>
}
c002b54e:	83 c4 18             	add    $0x18,%esp
c002b551:	5b                   	pop    %ebx
c002b552:	c3                   	ret    

c002b553 <push_arguments>:
#endif
    }
    return true;
}

void *push_arguments(struct arguments *args, void **esp) {
c002b553:	55                   	push   %ebp
c002b554:	57                   	push   %edi
c002b555:	56                   	push   %esi
c002b556:	53                   	push   %ebx
c002b557:	83 ec 28             	sub    $0x28,%esp
c002b55a:	e8 e4 4b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b55f:	81 c3 4d 27 01 00    	add    $0x1274d,%ebx
c002b565:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c002b569:	8b 74 24 40          	mov    0x40(%esp),%esi
    void **arg_ptr_list = (void **) malloc(args->argc * sizeof(void *));
c002b56d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002b571:	8b 38                	mov    (%eax),%edi
c002b573:	8d 2c bd 00 00 00 00 	lea    0x0(,%edi,4),%ebp
c002b57a:	55                   	push   %ebp
c002b57b:	e8 ce 88 ff ff       	call   c0023e4e <malloc>
c002b580:	89 44 24 10          	mov    %eax,0x10(%esp)
    // push argv[3][...] from right to left
    for (int i = args->argc - 1; i >= 0; i--) {
c002b584:	83 c4 10             	add    $0x10,%esp
c002b587:	85 ff                	test   %edi,%edi
c002b589:	7e 56                	jle    c002b5e1 <push_arguments+0x8e>
c002b58b:	83 ed 04             	sub    $0x4,%ebp
        char *arg_i = args->argv[i];
c002b58e:	8b 44 24 30          	mov    0x30(%esp),%eax
c002b592:	8b 40 04             	mov    0x4(%eax),%eax
c002b595:	8b 14 28             	mov    (%eax,%ebp,1),%edx
        // printf("push argument %s, whose len is %lu\n", arg_i, strlen(arg_i));

        *esp -= (strlen(arg_i) + 1); // also need to pass %0
c002b598:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b59d:	89 d7                	mov    %edx,%edi
c002b59f:	b8 00 00 00 00       	mov    $0x0,%eax
c002b5a4:	f2 ae                	repnz scas %es:(%edi),%al
c002b5a6:	8b 06                	mov    (%esi),%eax
c002b5a8:	8d 5c 08 01          	lea    0x1(%eax,%ecx,1),%ebx
c002b5ac:	89 1e                	mov    %ebx,(%esi)
        memcpy(*esp, arg_i, strlen(arg_i) + 1);
c002b5ae:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b5b3:	89 d7                	mov    %edx,%edi
c002b5b5:	b8 00 00 00 00       	mov    $0x0,%eax
c002b5ba:	f2 ae                	repnz scas %es:(%edi),%al
c002b5bc:	f7 d1                	not    %ecx
c002b5be:	83 ec 04             	sub    $0x4,%esp
c002b5c1:	51                   	push   %ecx
c002b5c2:	52                   	push   %edx
c002b5c3:	53                   	push   %ebx
c002b5c4:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002b5c8:	e8 4f cd ff ff       	call   c002831c <memcpy>
        arg_ptr_list[i] = *esp;
c002b5cd:	8b 06                	mov    (%esi),%eax
c002b5cf:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002b5d3:	89 04 2f             	mov    %eax,(%edi,%ebp,1)
c002b5d6:	83 ed 04             	sub    $0x4,%ebp
    for (int i = args->argc - 1; i >= 0; i--) {
c002b5d9:	83 c4 10             	add    $0x10,%esp
c002b5dc:	83 fd fc             	cmp    $0xfffffffc,%ebp
c002b5df:	75 ad                	jne    c002b58e <push_arguments+0x3b>
    }
    // push word-align, to make *esp % 4 = 0
    int align = ((uint32_t) *esp) % sizeof(uintptr_t);
c002b5e1:	8b 06                	mov    (%esi),%eax
    *esp -= align;
c002b5e3:	89 c1                	mov    %eax,%ecx
c002b5e5:	83 e1 fc             	and    $0xfffffffc,%ecx
c002b5e8:	89 0e                	mov    %ecx,(%esi)
    memset(*esp, 0, align);
c002b5ea:	83 e0 03             	and    $0x3,%eax
c002b5ed:	89 c2                	mov    %eax,%edx
c002b5ef:	74 10                	je     c002b601 <push_arguments+0xae>
c002b5f1:	b8 00 00 00 00       	mov    $0x0,%eax
c002b5f6:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
c002b5fa:	83 c0 01             	add    $0x1,%eax
c002b5fd:	39 d0                	cmp    %edx,%eax
c002b5ff:	72 f5                	jb     c002b5f6 <push_arguments+0xa3>
    // push argv[argc], which must be null
    uint32_t t = 0;
    *esp -= sizeof(uint32_t);
c002b601:	8b 06                	mov    (%esi),%eax
c002b603:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b606:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &t, sizeof(uint32_t));
c002b608:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    // push argument real address
    uint32_t argv_ptr;
    for (int i = args->argc - 1; i >= 0; i--) {
c002b60f:	8b 44 24 30          	mov    0x30(%esp),%eax
c002b613:	8b 00                	mov    (%eax),%eax
c002b615:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002b619:	83 e8 01             	sub    $0x1,%eax
c002b61c:	78 24                	js     c002b642 <push_arguments+0xef>
c002b61e:	8b 3c 24             	mov    (%esp),%edi
c002b621:	eb 08                	jmp    c002b62b <push_arguments+0xd8>
c002b623:	83 e8 01             	sub    $0x1,%eax
c002b626:	83 f8 ff             	cmp    $0xffffffff,%eax
c002b629:	74 17                	je     c002b642 <push_arguments+0xef>
        uint32_t arg_i_addr = (uint32_t) arg_ptr_list[i];
c002b62b:	8b 0c 87             	mov    (%edi,%eax,4),%ecx
        *esp -= sizeof(uint32_t);
c002b62e:	8b 16                	mov    (%esi),%edx
c002b630:	8d 5a fc             	lea    -0x4(%edx),%ebx
c002b633:	89 1e                	mov    %ebx,(%esi)
        memcpy(*esp, &arg_i_addr, sizeof(uint32_t));
c002b635:	89 4a fc             	mov    %ecx,-0x4(%edx)
        if (i == 0) argv_ptr = (uint32_t) *esp;
c002b638:	85 c0                	test   %eax,%eax
c002b63a:	75 e7                	jne    c002b623 <push_arguments+0xd0>
c002b63c:	8b 06                	mov    (%esi),%eax
c002b63e:	89 44 24 08          	mov    %eax,0x8(%esp)
    }
    // push argv
    *esp -= sizeof(uint32_t);
c002b642:	8b 06                	mov    (%esi),%eax
c002b644:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b647:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &argv_ptr, sizeof(uint32_t));
c002b649:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c002b64d:	89 58 fc             	mov    %ebx,-0x4(%eax)
    // push argc
    *esp -= sizeof(int);
c002b650:	8b 06                	mov    (%esi),%eax
c002b652:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b655:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &(args->argc), sizeof(int));
c002b657:	8b 5c 24 30          	mov    0x30(%esp),%ebx
c002b65b:	8b 13                	mov    (%ebx),%edx
c002b65d:	89 50 fc             	mov    %edx,-0x4(%eax)
    // push fake return address
    *esp -= sizeof(void *);
c002b660:	8b 06                	mov    (%esi),%eax
c002b662:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b665:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &args->argv[args->argc], sizeof(void *));
c002b667:	8b 0b                	mov    (%ebx),%ecx
c002b669:	8b 53 04             	mov    0x4(%ebx),%edx
c002b66c:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c002b66f:	89 50 fc             	mov    %edx,-0x4(%eax)
    free(arg_ptr_list);
c002b672:	83 ec 0c             	sub    $0xc,%esp
c002b675:	ff 74 24 0c          	pushl  0xc(%esp)
c002b679:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002b67d:	e8 7a 89 ff ff       	call   c0023ffc <free>
    return *esp;
c002b682:	8b 06                	mov    (%esi),%eax
}
c002b684:	83 c4 2c             	add    $0x2c,%esp
c002b687:	5b                   	pop    %ebx
c002b688:	5e                   	pop    %esi
c002b689:	5f                   	pop    %edi
c002b68a:	5d                   	pop    %ebp
c002b68b:	c3                   	ret    

c002b68c <start_process>:
start_process(void *arg) {
c002b68c:	55                   	push   %ebp
c002b68d:	57                   	push   %edi
c002b68e:	56                   	push   %esi
c002b68f:	53                   	push   %ebx
c002b690:	81 ec ec 00 00 00    	sub    $0xec,%esp
c002b696:	e8 a8 4a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002b69b:	81 c3 11 26 01 00    	add    $0x12611,%ebx
    char *file_name = p_arg->file_name;
c002b6a1:	8b 84 24 00 01 00 00 	mov    0x100(%esp),%eax
c002b6a8:	8b 00                	mov    (%eax),%eax
c002b6aa:	89 44 24 08          	mov    %eax,0x8(%esp)
    memset(&if_, 0, sizeof if_);
c002b6ae:	8d 94 24 90 00 00 00 	lea    0x90(%esp),%edx
c002b6b5:	b9 14 00 00 00       	mov    $0x14,%ecx
c002b6ba:	b8 00 00 00 00       	mov    $0x0,%eax
c002b6bf:	89 d7                	mov    %edx,%edi
c002b6c1:	f3 ab                	rep stos %eax,%es:(%edi)
    if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002b6c3:	66 c7 84 24 dc 00 00 	movw   $0x23,0xdc(%esp)
c002b6ca:	00 23 00 
c002b6cd:	66 c7 84 24 bc 00 00 	movw   $0x23,0xbc(%esp)
c002b6d4:	00 23 00 
c002b6d7:	66 c7 84 24 b8 00 00 	movw   $0x23,0xb8(%esp)
c002b6de:	00 23 00 
c002b6e1:	66 c7 84 24 b4 00 00 	movw   $0x23,0xb4(%esp)
c002b6e8:	00 23 00 
c002b6eb:	66 c7 84 24 b0 00 00 	movw   $0x23,0xb0(%esp)
c002b6f2:	00 23 00 
    if_.cs = SEL_UCSEG;
c002b6f5:	66 c7 84 24 d0 00 00 	movw   $0x1b,0xd0(%esp)
c002b6fc:	00 1b 00 
    if_.eflags = FLAG_IF | FLAG_MBS;
c002b6ff:	c7 84 24 d4 00 00 00 	movl   $0x202,0xd4(%esp)
c002b706:	02 02 00 00 
    struct thread *t = thread_current();
c002b70a:	e8 ba 58 ff ff       	call   c0020fc9 <thread_current>
c002b70f:	89 c6                	mov    %eax,%esi
c002b711:	89 44 24 0c          	mov    %eax,0xc(%esp)
    t->spt = spt_init();
c002b715:	e8 71 44 00 00       	call   c002fb8b <spt_init>
c002b71a:	89 86 18 01 00 00    	mov    %eax,0x118(%esi)
    t->pagedir = pagedir_create();
c002b720:	e8 18 07 00 00       	call   c002be3d <pagedir_create>
c002b725:	89 86 10 01 00 00    	mov    %eax,0x110(%esi)
    if (t->pagedir == NULL)
c002b72b:	85 c0                	test   %eax,%eax
c002b72d:	0f 84 57 01 00 00    	je     c002b88a <start_process+0x1fe>
    process_activate();
c002b733:	e8 ef fd ff ff       	call   c002b527 <process_activate>
    args = (struct arguments *) malloc(sizeof(struct arguments));
c002b738:	83 ec 0c             	sub    $0xc,%esp
c002b73b:	6a 08                	push   $0x8
c002b73d:	e8 0c 87 ff ff       	call   c0023e4e <malloc>
c002b742:	89 c5                	mov    %eax,%ebp
    args->argc = 0;
c002b744:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    args->argv = (char **) palloc_get_page(0); // ??
c002b74a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b751:	e8 e6 82 ff ff       	call   c0023a3c <palloc_get_page>
c002b756:	89 c6                	mov    %eax,%esi
c002b758:	89 45 04             	mov    %eax,0x4(%ebp)
    if (args->argv == NULL) {
c002b75b:	83 c4 10             	add    $0x10,%esp
c002b75e:	85 c0                	test   %eax,%eax
c002b760:	0f 84 f4 00 00 00    	je     c002b85a <start_process+0x1ce>
    for (token = strtok_r(str_input, " ", &saved_ptr); token != NULL;
c002b766:	83 ec 04             	sub    $0x4,%esp
c002b769:	8d 44 24 60          	lea    0x60(%esp),%eax
c002b76d:	50                   	push   %eax
c002b76e:	8d 83 2e 51 ff ff    	lea    -0xaed2(%ebx),%eax
c002b774:	50                   	push   %eax
c002b775:	ff 74 24 14          	pushl  0x14(%esp)
c002b779:	e8 ea cd ff ff       	call   c0028568 <strtok_r>
c002b77e:	83 c4 10             	add    $0x10,%esp
c002b781:	85 c0                	test   %eax,%eax
c002b783:	74 2a                	je     c002b7af <start_process+0x123>
         token = strtok_r(NULL, " ", &saved_ptr)) {
c002b785:	8d 7c 24 5c          	lea    0x5c(%esp),%edi
c002b789:	8d b3 2e 51 ff ff    	lea    -0xaed2(%ebx),%esi
        args->argv[args->argc] = token; // token generated by *s = '\0';
c002b78f:	8b 4d 00             	mov    0x0(%ebp),%ecx
c002b792:	8b 55 04             	mov    0x4(%ebp),%edx
c002b795:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
        args->argc++;
c002b798:	83 45 00 01          	addl   $0x1,0x0(%ebp)
         token = strtok_r(NULL, " ", &saved_ptr)) {
c002b79c:	83 ec 04             	sub    $0x4,%esp
c002b79f:	57                   	push   %edi
c002b7a0:	56                   	push   %esi
c002b7a1:	6a 00                	push   $0x0
c002b7a3:	e8 c0 cd ff ff       	call   c0028568 <strtok_r>
    for (token = strtok_r(str_input, " ", &saved_ptr); token != NULL;
c002b7a8:	83 c4 10             	add    $0x10,%esp
c002b7ab:	85 c0                	test   %eax,%eax
c002b7ad:	75 e0                	jne    c002b78f <start_process+0x103>
    lock_acquire(get_fs_lock());
c002b7af:	e8 6b 10 00 00       	call   c002c81f <get_fs_lock>
c002b7b4:	83 ec 0c             	sub    $0xc,%esp
c002b7b7:	50                   	push   %eax
c002b7b8:	e8 9f 7a ff ff       	call   c002325c <lock_acquire>
    file = filesys_open(args->argv[0]);
c002b7bd:	83 c4 04             	add    $0x4,%esp
c002b7c0:	8b 45 04             	mov    0x4(%ebp),%eax
c002b7c3:	ff 30                	pushl  (%eax)
c002b7c5:	e8 4a 22 00 00       	call   c002da14 <filesys_open>
c002b7ca:	89 c7                	mov    %eax,%edi
    if (file == NULL) {
c002b7cc:	83 c4 10             	add    $0x10,%esp
c002b7cf:	85 c0                	test   %eax,%eax
c002b7d1:	0f 84 9c 00 00 00    	je     c002b873 <start_process+0x1e7>
    file_deny_write(file);
c002b7d7:	83 ec 0c             	sub    $0xc,%esp
c002b7da:	57                   	push   %edi
c002b7db:	e8 be 26 00 00       	call   c002de9e <file_deny_write>
    if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr
c002b7e0:	83 c4 0c             	add    $0xc,%esp
c002b7e3:	6a 34                	push   $0x34
c002b7e5:	8d 44 24 64          	lea    0x64(%esp),%eax
c002b7e9:	50                   	push   %eax
c002b7ea:	57                   	push   %edi
c002b7eb:	e8 fa 25 00 00       	call   c002ddea <file_read>
c002b7f0:	83 c4 10             	add    $0x10,%esp
c002b7f3:	83 f8 34             	cmp    $0x34,%eax
c002b7f6:	0f 85 8e 00 00 00    	jne    c002b88a <start_process+0x1fe>
        || memcmp(ehdr.e_ident, "\177ELF\1\1\1", 7)
c002b7fc:	83 ec 04             	sub    $0x4,%esp
c002b7ff:	6a 07                	push   $0x7
c002b801:	8d 83 c3 56 ff ff    	lea    -0xa93d(%ebx),%eax
c002b807:	50                   	push   %eax
c002b808:	8d 44 24 68          	lea    0x68(%esp),%eax
c002b80c:	50                   	push   %eax
c002b80d:	e8 84 cb ff ff       	call   c0028396 <memcmp>
c002b812:	83 c4 10             	add    $0x10,%esp
c002b815:	89 44 24 10          	mov    %eax,0x10(%esp)
c002b819:	85 c0                	test   %eax,%eax
c002b81b:	75 6d                	jne    c002b88a <start_process+0x1fe>
        || ehdr.e_machine != 3
c002b81d:	81 7c 24 6c 02 00 03 	cmpl   $0x30002,0x6c(%esp)
c002b824:	00 
c002b825:	75 63                	jne    c002b88a <start_process+0x1fe>
        || ehdr.e_version != 1
c002b827:	83 7c 24 70 01       	cmpl   $0x1,0x70(%esp)
c002b82c:	75 5c                	jne    c002b88a <start_process+0x1fe>
        || ehdr.e_phentsize != sizeof(struct Elf32_Phdr)
c002b82e:	66 83 bc 24 86 00 00 	cmpw   $0x20,0x86(%esp)
c002b835:	00 20 
c002b837:	75 51                	jne    c002b88a <start_process+0x1fe>
        || ehdr.e_phnum > 1024) {
c002b839:	66 81 bc 24 88 00 00 	cmpw   $0x400,0x88(%esp)
c002b840:	00 00 04 
c002b843:	77 45                	ja     c002b88a <start_process+0x1fe>
    file_ofs = ehdr.e_phoff;
c002b845:	8b 44 24 78          	mov    0x78(%esp),%eax
c002b849:	89 44 24 28          	mov    %eax,0x28(%esp)
    for (i = 0; i < ehdr.e_phnum; i++) { // Number of program headers
c002b84d:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
c002b851:	89 6c 24 2c          	mov    %ebp,0x2c(%esp)
c002b855:	e9 91 00 00 00       	jmp    c002b8eb <start_process+0x25f>
        palloc_free_page(args->argv);
c002b85a:	83 ec 0c             	sub    $0xc,%esp
c002b85d:	6a 00                	push   $0x0
c002b85f:	e8 43 83 ff ff       	call   c0023ba7 <palloc_free_page>
        free(args);
c002b864:	89 2c 24             	mov    %ebp,(%esp)
c002b867:	e8 90 87 ff ff       	call   c0023ffc <free>
    if (args == NULL) {
c002b86c:	83 c4 10             	add    $0x10,%esp
    args = parse_arguments(file_name); //split into arguments
c002b86f:	89 f5                	mov    %esi,%ebp
c002b871:	eb 17                	jmp    c002b88a <start_process+0x1fe>
        printf ("load: %s: open failed\n", args->argv[0]);
c002b873:	83 ec 08             	sub    $0x8,%esp
c002b876:	8b 45 04             	mov    0x4(%ebp),%eax
c002b879:	ff 30                	pushl  (%eax)
c002b87b:	8d 83 ac 56 ff ff    	lea    -0xa954(%ebx),%eax
c002b881:	50                   	push   %eax
c002b882:	e8 4a bc ff ff       	call   c00274d1 <printf>
c002b887:	83 c4 10             	add    $0x10,%esp
    palloc_free_page(args->argv);
c002b88a:	83 ec 0c             	sub    $0xc,%esp
c002b88d:	ff 75 04             	pushl  0x4(%ebp)
c002b890:	e8 12 83 ff ff       	call   c0023ba7 <palloc_free_page>
    free(args);
c002b895:	89 2c 24             	mov    %ebp,(%esp)
c002b898:	e8 5f 87 ff ff       	call   c0023ffc <free>
    lock_release(get_fs_lock());
c002b89d:	e8 7d 0f 00 00       	call   c002c81f <get_fs_lock>
c002b8a2:	89 04 24             	mov    %eax,(%esp)
c002b8a5:	e8 b3 7b ff ff       	call   c002345d <lock_release>
    palloc_free_page(file_name);
c002b8aa:	83 c4 04             	add    $0x4,%esp
c002b8ad:	ff 74 24 14          	pushl  0x14(%esp)
c002b8b1:	e8 f1 82 ff ff       	call   c0023ba7 <palloc_free_page>
        p_arg->success = false;
c002b8b6:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002b8bd:	c6 40 18 00          	movb   $0x0,0x18(%eax)
        sema_up(&p_arg->sema);
c002b8c1:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002b8c8:	83 c0 04             	add    $0x4,%eax
c002b8cb:	89 04 24             	mov    %eax,(%esp)
c002b8ce:	e8 8b 77 ff ff       	call   c002305e <sema_up>
        thread_exit();
c002b8d3:	e8 50 5d ff ff       	call   c0021628 <thread_exit>
        switch (phdr.p_type) {
c002b8d8:	83 f8 05             	cmp    $0x5,%eax
c002b8db:	0f 84 86 03 00 00    	je     c002bc67 <start_process+0x5db>
c002b8e1:	83 44 24 28 20       	addl   $0x20,0x28(%esp)
    for (i = 0; i < ehdr.e_phnum; i++) { // Number of program headers
c002b8e6:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
c002b8eb:	0f b7 84 24 88 00 00 	movzwl 0x88(%esp),%eax
c002b8f2:	00 
c002b8f3:	39 44 24 10          	cmp    %eax,0x10(%esp)
c002b8f7:	0f 8d e2 01 00 00    	jge    c002badf <start_process+0x453>
        if (file_ofs < 0 || file_ofs > file_length(file))
c002b8fd:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002b901:	85 ff                	test   %edi,%edi
c002b903:	0f 88 3a 03 00 00    	js     c002bc43 <start_process+0x5b7>
c002b909:	83 ec 0c             	sub    $0xc,%esp
c002b90c:	8b 74 24 28          	mov    0x28(%esp),%esi
c002b910:	56                   	push   %esi
c002b911:	e8 7a 26 00 00       	call   c002df90 <file_length>
c002b916:	83 c4 10             	add    $0x10,%esp
c002b919:	39 c7                	cmp    %eax,%edi
c002b91b:	0f 8f 2b 03 00 00    	jg     c002bc4c <start_process+0x5c0>
        file_seek(file, file_ofs);
c002b921:	83 ec 08             	sub    $0x8,%esp
c002b924:	57                   	push   %edi
c002b925:	56                   	push   %esi
c002b926:	e8 b4 26 00 00       	call   c002dfdf <file_seek>
        if (file_read(file, &phdr, sizeof phdr) != sizeof phdr)
c002b92b:	83 c4 0c             	add    $0xc,%esp
c002b92e:	6a 20                	push   $0x20
c002b930:	8d 44 24 44          	lea    0x44(%esp),%eax
c002b934:	50                   	push   %eax
c002b935:	56                   	push   %esi
c002b936:	e8 af 24 00 00       	call   c002ddea <file_read>
c002b93b:	83 c4 10             	add    $0x10,%esp
c002b93e:	83 f8 20             	cmp    $0x20,%eax
c002b941:	0f 85 0e 03 00 00    	jne    c002bc55 <start_process+0x5c9>
        if (phdr.p_filesz == 0xb4)
c002b947:	81 7c 24 4c b4 00 00 	cmpl   $0xb4,0x4c(%esp)
c002b94e:	00 
c002b94f:	74 90                	je     c002b8e1 <start_process+0x255>
        switch (phdr.p_type) {
c002b951:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002b955:	83 f8 03             	cmp    $0x3,%eax
c002b958:	0f 87 7a ff ff ff    	ja     c002b8d8 <start_process+0x24c>
c002b95e:	83 f8 02             	cmp    $0x2,%eax
c002b961:	0f 83 f7 02 00 00    	jae    c002bc5e <start_process+0x5d2>
c002b967:	83 f8 01             	cmp    $0x1,%eax
c002b96a:	0f 85 71 ff ff ff    	jne    c002b8e1 <start_process+0x255>
    if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK))
c002b970:	8b 74 24 40          	mov    0x40(%esp),%esi
c002b974:	89 f0                	mov    %esi,%eax
c002b976:	33 44 24 44          	xor    0x44(%esp),%eax
c002b97a:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002b97f:	74 09                	je     c002b98a <start_process+0x2fe>
c002b981:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002b985:	e9 00 ff ff ff       	jmp    c002b88a <start_process+0x1fe>
    if (phdr->p_offset > (Elf32_Off) file_length(file))
c002b98a:	83 ec 0c             	sub    $0xc,%esp
c002b98d:	ff 74 24 28          	pushl  0x28(%esp)
c002b991:	e8 fa 25 00 00       	call   c002df90 <file_length>
c002b996:	83 c4 10             	add    $0x10,%esp
c002b999:	39 c6                	cmp    %eax,%esi
c002b99b:	0f 87 cf 02 00 00    	ja     c002bc70 <start_process+0x5e4>
    if (phdr->p_memsz < phdr->p_filesz)
c002b9a1:	8b 7c 24 50          	mov    0x50(%esp),%edi
c002b9a5:	8b 6c 24 4c          	mov    0x4c(%esp),%ebp
    if (phdr->p_memsz == 0)
c002b9a9:	85 ff                	test   %edi,%edi
c002b9ab:	0f 84 c8 02 00 00    	je     c002bc79 <start_process+0x5ed>
c002b9b1:	39 ef                	cmp    %ebp,%edi
c002b9b3:	0f 82 c9 02 00 00    	jb     c002bc82 <start_process+0x5f6>
    if (!is_user_vaddr((void *) phdr->p_vaddr))
c002b9b9:	8b 44 24 44          	mov    0x44(%esp),%eax
c002b9bd:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b9c2:	0f 87 c3 02 00 00    	ja     c002bc8b <start_process+0x5ff>
    if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002b9c8:	89 fa                	mov    %edi,%edx
c002b9ca:	01 c2                	add    %eax,%edx
c002b9cc:	89 54 24 14          	mov    %edx,0x14(%esp)
c002b9d0:	0f 92 c1             	setb   %cl
c002b9d3:	89 ce                	mov    %ecx,%esi
    if (phdr->p_vaddr < PGSIZE)
c002b9d5:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002b9da:	0f 96 c1             	setbe  %cl
                if (validate_segment(&phdr, file)) {
c002b9dd:	89 f2                	mov    %esi,%edx
c002b9df:	08 ca                	or     %cl,%dl
c002b9e1:	0f 85 ad 02 00 00    	jne    c002bc94 <start_process+0x608>
c002b9e7:	81 7c 24 14 ff ff ff 	cmpl   $0xbfffffff,0x14(%esp)
c002b9ee:	bf 
c002b9ef:	0f 87 a8 02 00 00    	ja     c002bc9d <start_process+0x611>
                    bool writable = (phdr.p_flags & PF_W) != 0;
c002b9f5:	8b 54 24 54          	mov    0x54(%esp),%edx
c002b9f9:	d1 ea                	shr    %edx
c002b9fb:	83 e2 01             	and    $0x1,%edx
                    uint32_t file_page = phdr.p_offset & ~PGMASK;
c002b9fe:	8b 74 24 40          	mov    0x40(%esp),%esi
c002ba02:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
                    uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002ba08:	89 c1                	mov    %eax,%ecx
c002ba0a:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
                    uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002ba10:	25 ff 0f 00 00       	and    $0xfff,%eax
                    if (phdr.p_filesz > 0) {
c002ba15:	85 ed                	test   %ebp,%ebp
c002ba17:	0f 84 a4 00 00 00    	je     c002bac1 <start_process+0x435>
                        read_bytes = page_offset + phdr.p_filesz;
c002ba1d:	01 c5                	add    %eax,%ebp
                        zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
c002ba1f:	8d 84 38 ff 0f 00 00 	lea    0xfff(%eax,%edi,1),%eax
c002ba26:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002ba2b:	29 e8                	sub    %ebp,%eax
c002ba2d:	89 44 24 14          	mov    %eax,0x14(%esp)
                    if (!load_segment(file, file_page, (void *) mem_page,
c002ba31:	0f b6 c2             	movzbl %dl,%eax
c002ba34:	89 44 24 24          	mov    %eax,0x24(%esp)
c002ba38:	89 cf                	mov    %ecx,%edi
    file_seek(file, ofs);
c002ba3a:	83 ec 08             	sub    $0x8,%esp
c002ba3d:	56                   	push   %esi
c002ba3e:	ff 74 24 28          	pushl  0x28(%esp)
c002ba42:	e8 98 25 00 00       	call   c002dfdf <file_seek>
c002ba47:	83 c4 10             	add    $0x10,%esp
c002ba4a:	29 fe                	sub    %edi,%esi
c002ba4c:	89 74 24 20          	mov    %esi,0x20(%esp)
c002ba50:	8b 44 24 20          	mov    0x20(%esp),%eax
c002ba54:	01 f8                	add    %edi,%eax
c002ba56:	89 44 24 18          	mov    %eax,0x18(%esp)
    while (read_bytes > 0 || zero_bytes > 0) {
c002ba5a:	8b 44 24 14          	mov    0x14(%esp),%eax
c002ba5e:	09 e8                	or     %ebp,%eax
c002ba60:	0f 84 7b fe ff ff    	je     c002b8e1 <start_process+0x255>
        size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002ba66:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
c002ba6c:	be 00 10 00 00       	mov    $0x1000,%esi
c002ba71:	0f 46 f5             	cmovbe %ebp,%esi
        struct thread *cur = thread_current();
c002ba74:	e8 50 55 ff ff       	call   c0020fc9 <thread_current>
        if (!spt_install_file(cur->spt, upage,
c002ba79:	83 ec 04             	sub    $0x4,%esp
c002ba7c:	ff 74 24 28          	pushl  0x28(%esp)
        size_t page_zero_bytes = PGSIZE - page_read_bytes;
c002ba80:	ba 00 10 00 00       	mov    $0x1000,%edx
c002ba85:	29 f2                	sub    %esi,%edx
        if (!spt_install_file(cur->spt, upage,
c002ba87:	52                   	push   %edx
c002ba88:	56                   	push   %esi
c002ba89:	ff 74 24 28          	pushl  0x28(%esp)
c002ba8d:	ff 74 24 30          	pushl  0x30(%esp)
c002ba91:	57                   	push   %edi
c002ba92:	ff b0 18 01 00 00    	pushl  0x118(%eax)
c002ba98:	e8 d7 44 00 00       	call   c002ff74 <spt_install_file>
c002ba9d:	83 c4 20             	add    $0x20,%esp
c002baa0:	84 c0                	test   %al,%al
c002baa2:	0f 84 fe 01 00 00    	je     c002bca6 <start_process+0x61a>
        read_bytes -= page_read_bytes;
c002baa8:	29 f5                	sub    %esi,%ebp
        zero_bytes -= page_zero_bytes;
c002baaa:	8b 44 24 14          	mov    0x14(%esp),%eax
c002baae:	8d 84 06 00 f0 ff ff 	lea    -0x1000(%esi,%eax,1),%eax
c002bab5:	89 44 24 14          	mov    %eax,0x14(%esp)
        upage += PGSIZE;
c002bab9:	81 c7 00 10 00 00    	add    $0x1000,%edi
        ofs += PGSIZE;
c002babf:	eb 8f                	jmp    c002ba50 <start_process+0x3c4>
                        zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
c002bac1:	8d 84 38 ff 0f 00 00 	lea    0xfff(%eax,%edi,1),%eax
c002bac8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bacd:	89 44 24 14          	mov    %eax,0x14(%esp)
                    if (!load_segment(file, file_page, (void *) mem_page,
c002bad1:	0f b6 c2             	movzbl %dl,%eax
c002bad4:	89 44 24 24          	mov    %eax,0x24(%esp)
c002bad8:	89 cf                	mov    %ecx,%edi
    ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002bada:	e9 5b ff ff ff       	jmp    c002ba3a <start_process+0x3ae>
c002badf:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c002bae3:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
//     // printf("setting up stack now\n");
    uint8_t *kpage;
    bool success = false;

#ifdef VM
        kpage = get_frame(((uint8_t *) PHYS_BASE) - PGSIZE, PAL_USER | PAL_ZERO);
c002bae7:	83 ec 08             	sub    $0x8,%esp
c002baea:	6a 06                	push   $0x6
c002baec:	68 00 f0 ff bf       	push   $0xbffff000
c002baf1:	e8 69 3b 00 00       	call   c002f65f <get_frame>
c002baf6:	89 c6                	mov    %eax,%esi
#else
        kpage = palloc_get_page(PAL_USER | PAL_ZERO);
#endif
    if (kpage != NULL) {
c002baf8:	83 c4 10             	add    $0x10,%esp
c002bafb:	85 c0                	test   %eax,%eax
c002bafd:	74 2f                	je     c002bb2e <start_process+0x4a2>
   with palloc_get_page().
   Returns true on success, false if UPAGE is already mapped or
   if memory allocation fails. */
static bool
install_page(void *upage, void *kpage, bool writable) {
    struct thread *t = thread_current();
c002baff:	e8 c5 54 ff ff       	call   c0020fc9 <thread_current>
c002bb04:	89 44 24 10          	mov    %eax,0x10(%esp)

    /* Verify that there's not already a page at that virtual
       address, then map our page there. */
    bool success = (pagedir_get_page (t->pagedir, upage) == NULL);
c002bb08:	83 ec 08             	sub    $0x8,%esp
c002bb0b:	68 00 f0 ff bf       	push   $0xbffff000
c002bb10:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002bb16:	e8 77 06 00 00       	call   c002c192 <pagedir_get_page>
    success = success && pagedir_set_page (t->pagedir, upage, kpage, writable);
c002bb1b:	83 c4 10             	add    $0x10,%esp
c002bb1e:	85 c0                	test   %eax,%eax
c002bb20:	74 28                	je     c002bb4a <start_process+0x4be>
            free_frame(kpage);
c002bb22:	83 ec 0c             	sub    $0xc,%esp
c002bb25:	56                   	push   %esi
c002bb26:	e8 90 39 00 00       	call   c002f4bb <free_frame>
c002bb2b:	83 c4 10             	add    $0x10,%esp
        printf("load: %s: set up stack failed\n", args->argv[0]);
c002bb2e:	83 ec 08             	sub    $0x8,%esp
c002bb31:	8b 45 04             	mov    0x4(%ebp),%eax
c002bb34:	ff 30                	pushl  (%eax)
c002bb36:	8d 83 e4 56 ff ff    	lea    -0xa91c(%ebx),%eax
c002bb3c:	50                   	push   %eax
c002bb3d:	e8 8f b9 ff ff       	call   c00274d1 <printf>
c002bb42:	83 c4 10             	add    $0x10,%esp
c002bb45:	e9 40 fd ff ff       	jmp    c002b88a <start_process+0x1fe>
    success = success && pagedir_set_page (t->pagedir, upage, kpage, writable);
c002bb4a:	6a 01                	push   $0x1
c002bb4c:	56                   	push   %esi
c002bb4d:	68 00 f0 ff bf       	push   $0xbffff000
c002bb52:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002bb56:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002bb5c:	e8 67 04 00 00       	call   c002bfc8 <pagedir_set_page>
#ifdef VM
    success = success && spt_install_frame (t->spt, upage, kpage);
c002bb61:	83 c4 10             	add    $0x10,%esp
c002bb64:	84 c0                	test   %al,%al
c002bb66:	74 ba                	je     c002bb22 <start_process+0x496>
c002bb68:	83 ec 04             	sub    $0x4,%esp
c002bb6b:	56                   	push   %esi
c002bb6c:	68 00 f0 ff bf       	push   $0xbffff000
c002bb71:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002bb75:	ff b0 18 01 00 00    	pushl  0x118(%eax)
c002bb7b:	e8 63 44 00 00       	call   c002ffe3 <spt_install_frame>
    if(success) set_pin_info(kpage, false);
c002bb80:	83 c4 10             	add    $0x10,%esp
c002bb83:	84 c0                	test   %al,%al
c002bb85:	74 9b                	je     c002bb22 <start_process+0x496>
c002bb87:	83 ec 08             	sub    $0x8,%esp
c002bb8a:	6a 00                	push   $0x0
c002bb8c:	56                   	push   %esi
c002bb8d:	e8 d6 3c 00 00       	call   c002f868 <set_pin_info>
            *esp = PHYS_BASE - 12; // prevent invalid use of memory
c002bb92:	c7 84 24 e8 00 00 00 	movl   $0xbffffff4,0xe8(%esp)
c002bb99:	f4 ff ff bf 
            *esp = push_arguments(args, esp); // argument passing
c002bb9d:	83 c4 08             	add    $0x8,%esp
c002bba0:	8d b4 24 98 00 00 00 	lea    0x98(%esp),%esi
c002bba7:	8d 84 24 e0 00 00 00 	lea    0xe0(%esp),%eax
c002bbae:	50                   	push   %eax
c002bbaf:	55                   	push   %ebp
c002bbb0:	e8 9e f9 ff ff       	call   c002b553 <push_arguments>
c002bbb5:	89 84 24 e8 00 00 00 	mov    %eax,0xe8(%esp)
    *eip = (void (*)(void)) ehdr.e_entry;
c002bbbc:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
c002bbc3:	89 84 24 dc 00 00 00 	mov    %eax,0xdc(%esp)
    t->src_code = file;
c002bbca:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002bbce:	89 b8 e0 00 00 00    	mov    %edi,0xe0(%eax)
    palloc_free_page(args->argv);
c002bbd4:	83 c4 04             	add    $0x4,%esp
c002bbd7:	ff 75 04             	pushl  0x4(%ebp)
c002bbda:	e8 c8 7f ff ff       	call   c0023ba7 <palloc_free_page>
    free(args);
c002bbdf:	89 2c 24             	mov    %ebp,(%esp)
c002bbe2:	e8 15 84 ff ff       	call   c0023ffc <free>
    lock_release(get_fs_lock());
c002bbe7:	e8 33 0c 00 00       	call   c002c81f <get_fs_lock>
c002bbec:	89 04 24             	mov    %eax,(%esp)
c002bbef:	e8 69 78 ff ff       	call   c002345d <lock_release>
    palloc_free_page(file_name);
c002bbf4:	83 c4 04             	add    $0x4,%esp
c002bbf7:	ff 74 24 14          	pushl  0x14(%esp)
c002bbfb:	e8 a7 7f ff ff       	call   c0023ba7 <palloc_free_page>
        p_arg->success = true;
c002bc00:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002bc07:	c6 40 18 01          	movb   $0x1,0x18(%eax)
        sema_up(&p_arg->sema);
c002bc0b:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002bc12:	83 c0 04             	add    $0x4,%eax
c002bc15:	89 04 24             	mov    %eax,(%esp)
c002bc18:	e8 41 74 ff ff       	call   c002305e <sema_up>
    asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
c002bc1d:	89 f4                	mov    %esi,%esp
c002bc1f:	e9 e4 66 ff ff       	jmp    c0022308 <intr_exit>
    NOT_REACHED ();
c002bc24:	8d 83 54 3d ff ff    	lea    -0xc2ac(%ebx),%eax
c002bc2a:	50                   	push   %eax
c002bc2b:	8d 83 50 33 ff ff    	lea    -0xccb0(%ebx),%eax
c002bc31:	50                   	push   %eax
c002bc32:	68 98 00 00 00       	push   $0x98
c002bc37:	8d 83 cb 56 ff ff    	lea    -0xa935(%ebx),%eax
c002bc3d:	50                   	push   %eax
c002bc3e:	e8 ea d4 ff ff       	call   c002912d <debug_panic>
c002bc43:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc47:	e9 3e fc ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc4c:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc50:	e9 35 fc ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc55:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc59:	e9 2c fc ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc5e:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc62:	e9 23 fc ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc67:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc6b:	e9 1a fc ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc70:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc74:	e9 11 fc ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc79:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc7d:	e9 08 fc ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc82:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc86:	e9 ff fb ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc8b:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc8f:	e9 f6 fb ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc94:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc98:	e9 ed fb ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bc9d:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bca1:	e9 e4 fb ff ff       	jmp    c002b88a <start_process+0x1fe>
c002bca6:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bcaa:	e9 db fb ff ff       	jmp    c002b88a <start_process+0x1fe>

c002bcaf <lookup_page>:
   If PD does not have a page table for VADDR, behavior depends
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page(uint32_t *pd, const void *vaddr, bool create) {
c002bcaf:	57                   	push   %edi
c002bcb0:	56                   	push   %esi
c002bcb1:	53                   	push   %ebx
c002bcb2:	e8 8c 44 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002bcb7:	81 c3 f5 1f 01 00    	add    $0x11ff5,%ebx
    uint32_t *pt, *pde;

    ASSERT (pd != NULL);
c002bcbd:	85 c0                	test   %eax,%eax
c002bcbf:	0f 84 8a 00 00 00    	je     c002bd4f <lookup_page+0xa0>
c002bcc5:	89 d6                	mov    %edx,%esi

    /* Shouldn't create new kernel virtual mappings. */
    ASSERT (!create || is_user_vaddr(vaddr));
c002bcc7:	80 f9 01             	cmp    $0x1,%cl
c002bcca:	75 0c                	jne    c002bcd8 <lookup_page+0x29>
c002bccc:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002bcd2:	0f 87 9d 00 00 00    	ja     c002bd75 <lookup_page+0xc6>
    return (uintptr_t) va >> PDSHIFT;
c002bcd8:	89 f2                	mov    %esi,%edx
c002bcda:	c1 ea 16             	shr    $0x16,%edx

    /* Check for a page table for VADDR.
       If one is missing, create one if requested. */
    pde = pd + pd_no(vaddr);
c002bcdd:	8d 3c 90             	lea    (%eax,%edx,4),%edi
    if (*pde == 0) {
c002bce0:	83 3f 00             	cmpl   $0x0,(%edi)
c002bce3:	75 3c                	jne    c002bd21 <lookup_page+0x72>
        if (create) {
c002bce5:	84 c9                	test   %cl,%cl
c002bce7:	0f 84 46 01 00 00    	je     c002be33 <lookup_page+0x184>
            pt = palloc_get_page(PAL_ZERO);
c002bced:	83 ec 0c             	sub    $0xc,%esp
c002bcf0:	6a 02                	push   $0x2
c002bcf2:	e8 45 7d ff ff       	call   c0023a3c <palloc_get_page>
            if (pt == NULL)
c002bcf7:	83 c4 10             	add    $0x10,%esp
c002bcfa:	85 c0                	test   %eax,%eax
c002bcfc:	74 4d                	je     c002bd4b <lookup_page+0x9c>
c002bcfe:	89 c2                	mov    %eax,%edx
    ASSERT (pg_ofs(pt) == 0);
c002bd00:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002bd05:	0f 85 90 00 00 00    	jne    c002bd9b <lookup_page+0xec>
    ASSERT (is_kernel_vaddr(vaddr));
c002bd0b:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bd10:	0f 86 ab 00 00 00    	jbe    c002bdc1 <lookup_page+0x112>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002bd16:	81 c2 00 00 00 40    	add    $0x40000000,%edx
    return vtop(pt) | PTE_U | PTE_P | PTE_W;
c002bd1c:	83 ca 07             	or     $0x7,%edx
c002bd1f:	89 17                	mov    %edx,(%edi)
        } else
            return NULL;
    }

    /* Return the page table entry. */
    pt = pde_get_pt(*pde);
c002bd21:	8b 07                	mov    (%edi),%eax
    ASSERT (pde & PTE_P);
c002bd23:	a8 01                	test   $0x1,%al
c002bd25:	0f 84 bc 00 00 00    	je     c002bde7 <lookup_page+0x138>
    return ptov(pde & PTE_ADDR);
c002bd2b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    ASSERT ((void *) paddr < PHYS_BASE);
c002bd30:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bd35:	0f 87 d2 00 00 00    	ja     c002be0d <lookup_page+0x15e>
    return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002bd3b:	c1 ee 0a             	shr    $0xa,%esi
    return &pt[pt_no(vaddr)];
c002bd3e:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
c002bd44:	8d 84 30 00 00 00 c0 	lea    -0x40000000(%eax,%esi,1),%eax
}
c002bd4b:	5b                   	pop    %ebx
c002bd4c:	5e                   	pop    %esi
c002bd4d:	5f                   	pop    %edi
c002bd4e:	c3                   	ret    
    ASSERT (pd != NULL);
c002bd4f:	83 ec 0c             	sub    $0xc,%esp
c002bd52:	8d 83 03 57 ff ff    	lea    -0xa8fd(%ebx),%eax
c002bd58:	50                   	push   %eax
c002bd59:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bd5f:	50                   	push   %eax
c002bd60:	8d 83 94 33 ff ff    	lea    -0xcc6c(%ebx),%eax
c002bd66:	50                   	push   %eax
c002bd67:	6a 3c                	push   $0x3c
c002bd69:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002bd6f:	50                   	push   %eax
c002bd70:	e8 b8 d3 ff ff       	call   c002912d <debug_panic>
    ASSERT (!create || is_user_vaddr(vaddr));
c002bd75:	83 ec 0c             	sub    $0xc,%esp
c002bd78:	8d 83 ac 57 ff ff    	lea    -0xa854(%ebx),%eax
c002bd7e:	50                   	push   %eax
c002bd7f:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bd85:	50                   	push   %eax
c002bd86:	8d 83 94 33 ff ff    	lea    -0xcc6c(%ebx),%eax
c002bd8c:	50                   	push   %eax
c002bd8d:	6a 3f                	push   $0x3f
c002bd8f:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002bd95:	50                   	push   %eax
c002bd96:	e8 92 d3 ff ff       	call   c002912d <debug_panic>
    ASSERT (pg_ofs(pt) == 0);
c002bd9b:	83 ec 0c             	sub    $0xc,%esp
c002bd9e:	8d 83 ce 36 ff ff    	lea    -0xc932(%ebx),%eax
c002bda4:	50                   	push   %eax
c002bda5:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bdab:	50                   	push   %eax
c002bdac:	8d 83 88 33 ff ff    	lea    -0xcc78(%ebx),%eax
c002bdb2:	50                   	push   %eax
c002bdb3:	6a 48                	push   $0x48
c002bdb5:	8d 83 f5 36 ff ff    	lea    -0xc90b(%ebx),%eax
c002bdbb:	50                   	push   %eax
c002bdbc:	e8 6c d3 ff ff       	call   c002912d <debug_panic>
    ASSERT (is_kernel_vaddr(vaddr));
c002bdc1:	83 ec 0c             	sub    $0xc,%esp
c002bdc4:	8d 83 09 37 ff ff    	lea    -0xc8f7(%ebx),%eax
c002bdca:	50                   	push   %eax
c002bdcb:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bdd1:	50                   	push   %eax
c002bdd2:	8d 83 a0 33 ff ff    	lea    -0xcc60(%ebx),%eax
c002bdd8:	50                   	push   %eax
c002bdd9:	6a 55                	push   $0x55
c002bddb:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002bde1:	50                   	push   %eax
c002bde2:	e8 46 d3 ff ff       	call   c002912d <debug_panic>
    ASSERT (pde & PTE_P);
c002bde7:	83 ec 0c             	sub    $0xc,%esp
c002bdea:	8d 83 27 57 ff ff    	lea    -0xa8d9(%ebx),%eax
c002bdf0:	50                   	push   %eax
c002bdf1:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bdf7:	50                   	push   %eax
c002bdf8:	8d 83 c4 33 ff ff    	lea    -0xcc3c(%ebx),%eax
c002bdfe:	50                   	push   %eax
c002bdff:	6a 4f                	push   $0x4f
c002be01:	8d 83 f5 36 ff ff    	lea    -0xc90b(%ebx),%eax
c002be07:	50                   	push   %eax
c002be08:	e8 20 d3 ff ff       	call   c002912d <debug_panic>
    ASSERT ((void *) paddr < PHYS_BASE);
c002be0d:	83 ec 0c             	sub    $0xc,%esp
c002be10:	8d 83 aa 43 ff ff    	lea    -0xbc56(%ebx),%eax
c002be16:	50                   	push   %eax
c002be17:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002be1d:	50                   	push   %eax
c002be1e:	8d 83 bc 33 ff ff    	lea    -0xcc44(%ebx),%eax
c002be24:	50                   	push   %eax
c002be25:	6a 4c                	push   $0x4c
c002be27:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002be2d:	50                   	push   %eax
c002be2e:	e8 fa d2 ff ff       	call   c002912d <debug_panic>
            return NULL;
c002be33:	b8 00 00 00 00       	mov    $0x0,%eax
c002be38:	e9 0e ff ff ff       	jmp    c002bd4b <lookup_page+0x9c>

c002be3d <pagedir_create>:
pagedir_create(void) {
c002be3d:	57                   	push   %edi
c002be3e:	56                   	push   %esi
c002be3f:	53                   	push   %ebx
c002be40:	e8 fe 42 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002be45:	81 c3 67 1e 01 00    	add    $0x11e67,%ebx
    uint32_t *pd = palloc_get_page(0);
c002be4b:	83 ec 0c             	sub    $0xc,%esp
c002be4e:	6a 00                	push   $0x0
c002be50:	e8 e7 7b ff ff       	call   c0023a3c <palloc_get_page>
    if (pd != NULL)
c002be55:	83 c4 10             	add    $0x10,%esp
c002be58:	85 c0                	test   %eax,%eax
c002be5a:	74 2f                	je     c002be8b <pagedir_create+0x4e>
        memcpy(pd, init_page_dir, PGSIZE);
c002be5c:	c7 c2 c4 fc 03 c0    	mov    $0xc003fcc4,%edx
c002be62:	8b 32                	mov    (%edx),%esi
c002be64:	8b 16                	mov    (%esi),%edx
c002be66:	89 10                	mov    %edx,(%eax)
c002be68:	8b 96 fc 0f 00 00    	mov    0xffc(%esi),%edx
c002be6e:	89 90 fc 0f 00 00    	mov    %edx,0xffc(%eax)
c002be74:	8d 78 04             	lea    0x4(%eax),%edi
c002be77:	83 e7 fc             	and    $0xfffffffc,%edi
c002be7a:	89 c1                	mov    %eax,%ecx
c002be7c:	29 f9                	sub    %edi,%ecx
c002be7e:	29 ce                	sub    %ecx,%esi
c002be80:	81 c1 00 10 00 00    	add    $0x1000,%ecx
c002be86:	c1 e9 02             	shr    $0x2,%ecx
c002be89:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
c002be8b:	5b                   	pop    %ebx
c002be8c:	5e                   	pop    %esi
c002be8d:	5f                   	pop    %edi
c002be8e:	c3                   	ret    

c002be8f <pagedir_destroy>:
pagedir_destroy(uint32_t *pd) {
c002be8f:	55                   	push   %ebp
c002be90:	57                   	push   %edi
c002be91:	56                   	push   %esi
c002be92:	53                   	push   %ebx
c002be93:	83 ec 1c             	sub    $0x1c,%esp
c002be96:	e8 a8 42 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002be9b:	81 c3 11 1e 01 00    	add    $0x11e11,%ebx
    if (pd == NULL)
c002bea1:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c002bea6:	0f 84 14 01 00 00    	je     c002bfc0 <pagedir_destroy+0x131>
    ASSERT (pd != init_page_dir);
c002beac:	c7 c0 c4 fc 03 c0    	mov    $0xc003fcc4,%eax
c002beb2:	8b 54 24 30          	mov    0x30(%esp),%edx
c002beb6:	39 10                	cmp    %edx,(%eax)
c002beb8:	74 12                	je     c002becc <pagedir_destroy+0x3d>
    for (pde = pd; pde < pd + pd_no(PHYS_BASE); pde++)
c002beba:	89 d0                	mov    %edx,%eax
c002bebc:	05 00 0c 00 00       	add    $0xc00,%eax
c002bec1:	89 44 24 08          	mov    %eax,0x8(%esp)
c002bec5:	89 d5                	mov    %edx,%ebp
c002bec7:	e9 b6 00 00 00       	jmp    c002bf82 <pagedir_destroy+0xf3>
    ASSERT (pd != init_page_dir);
c002becc:	83 ec 0c             	sub    $0xc,%esp
c002becf:	8d 83 33 57 ff ff    	lea    -0xa8cd(%ebx),%eax
c002bed5:	50                   	push   %eax
c002bed6:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bedc:	50                   	push   %eax
c002bedd:	8d 83 d0 33 ff ff    	lea    -0xcc30(%ebx),%eax
c002bee3:	50                   	push   %eax
c002bee4:	6a 24                	push   $0x24
c002bee6:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002beec:	50                   	push   %eax
c002beed:	e8 3b d2 ff ff       	call   c002912d <debug_panic>
c002bef2:	83 ec 0c             	sub    $0xc,%esp
c002bef5:	8d 83 aa 43 ff ff    	lea    -0xbc56(%ebx),%eax
c002befb:	50                   	push   %eax
c002befc:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bf02:	50                   	push   %eax
c002bf03:	8d 83 bc 33 ff ff    	lea    -0xcc44(%ebx),%eax
c002bf09:	50                   	push   %eax
c002bf0a:	6a 4c                	push   $0x4c
c002bf0c:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002bf12:	50                   	push   %eax
c002bf13:	e8 15 d2 ff ff       	call   c002912d <debug_panic>
c002bf18:	83 ec 0c             	sub    $0xc,%esp
c002bf1b:	8d 83 aa 43 ff ff    	lea    -0xbc56(%ebx),%eax
c002bf21:	50                   	push   %eax
c002bf22:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002bf28:	50                   	push   %eax
c002bf29:	8d 83 bc 33 ff ff    	lea    -0xcc44(%ebx),%eax
c002bf2f:	50                   	push   %eax
c002bf30:	6a 4c                	push   $0x4c
c002bf32:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002bf38:	50                   	push   %eax
c002bf39:	e8 ef d1 ff ff       	call   c002912d <debug_panic>
            for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002bf3e:	83 c6 04             	add    $0x4,%esi
c002bf41:	39 fe                	cmp    %edi,%esi
c002bf43:	74 25                	je     c002bf6a <pagedir_destroy+0xdb>
                if (*pte & PTE_P)
c002bf45:	8b 06                	mov    (%esi),%eax
c002bf47:	a8 01                	test   $0x1,%al
c002bf49:	74 f3                	je     c002bf3e <pagedir_destroy+0xaf>
}

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page(uint32_t pte) {
    return ptov(pte & PTE_ADDR);
c002bf4b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bf50:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bf55:	77 c1                	ja     c002bf18 <pagedir_destroy+0x89>
                    palloc_free_page(pte_get_page(*pte));
c002bf57:	83 ec 0c             	sub    $0xc,%esp
    return (void *) (paddr + PHYS_BASE);
c002bf5a:	2d 00 00 00 40       	sub    $0x40000000,%eax
c002bf5f:	50                   	push   %eax
c002bf60:	e8 42 7c ff ff       	call   c0023ba7 <palloc_free_page>
c002bf65:	83 c4 10             	add    $0x10,%esp
c002bf68:	eb d4                	jmp    c002bf3e <pagedir_destroy+0xaf>
            palloc_free_page(pt);
c002bf6a:	83 ec 0c             	sub    $0xc,%esp
c002bf6d:	ff 74 24 18          	pushl  0x18(%esp)
c002bf71:	e8 31 7c ff ff       	call   c0023ba7 <palloc_free_page>
c002bf76:	83 c4 10             	add    $0x10,%esp
    for (pde = pd; pde < pd + pd_no(PHYS_BASE); pde++)
c002bf79:	83 c5 04             	add    $0x4,%ebp
c002bf7c:	3b 6c 24 08          	cmp    0x8(%esp),%ebp
c002bf80:	74 2f                	je     c002bfb1 <pagedir_destroy+0x122>
        if (*pde & PTE_P) {
c002bf82:	8b 7d 00             	mov    0x0(%ebp),%edi
c002bf85:	f7 c7 01 00 00 00    	test   $0x1,%edi
c002bf8b:	74 ec                	je     c002bf79 <pagedir_destroy+0xea>
    return ptov(pde & PTE_ADDR);
c002bf8d:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
    ASSERT ((void *) paddr < PHYS_BASE);
c002bf93:	81 ff ff ff ff bf    	cmp    $0xbfffffff,%edi
c002bf99:	0f 87 53 ff ff ff    	ja     c002bef2 <pagedir_destroy+0x63>
    return (void *) (paddr + PHYS_BASE);
c002bf9f:	8d b7 00 00 00 c0    	lea    -0x40000000(%edi),%esi
c002bfa5:	89 74 24 0c          	mov    %esi,0xc(%esp)
            for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002bfa9:	81 ef 00 f0 ff 3f    	sub    $0x3ffff000,%edi
c002bfaf:	eb 94                	jmp    c002bf45 <pagedir_destroy+0xb6>
    palloc_free_page(pd);
c002bfb1:	83 ec 0c             	sub    $0xc,%esp
c002bfb4:	ff 74 24 3c          	pushl  0x3c(%esp)
c002bfb8:	e8 ea 7b ff ff       	call   c0023ba7 <palloc_free_page>
c002bfbd:	83 c4 10             	add    $0x10,%esp
}
c002bfc0:	83 c4 1c             	add    $0x1c,%esp
c002bfc3:	5b                   	pop    %ebx
c002bfc4:	5e                   	pop    %esi
c002bfc5:	5f                   	pop    %edi
c002bfc6:	5d                   	pop    %ebp
c002bfc7:	c3                   	ret    

c002bfc8 <pagedir_set_page>:
   If WRITABLE is true, the new page is read/write;
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool
pagedir_set_page(uint32_t *pd, void *upage, void *kpage, bool writable) {
c002bfc8:	55                   	push   %ebp
c002bfc9:	57                   	push   %edi
c002bfca:	56                   	push   %esi
c002bfcb:	53                   	push   %ebx
c002bfcc:	83 ec 0c             	sub    $0xc,%esp
c002bfcf:	e8 6f 41 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002bfd4:	81 c3 d8 1c 01 00    	add    $0x11cd8,%ebx
c002bfda:	8b 44 24 20          	mov    0x20(%esp),%eax
c002bfde:	8b 54 24 24          	mov    0x24(%esp),%edx
c002bfe2:	8b 74 24 28          	mov    0x28(%esp),%esi
c002bfe6:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    uint32_t *pte;

    ASSERT (pg_ofs(upage) == 0);
c002bfea:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002bff0:	0f 85 88 00 00 00    	jne    c002c07e <pagedir_set_page+0xb6>
    ASSERT (pg_ofs(kpage) == 0);
c002bff6:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c002bffc:	0f 85 a2 00 00 00    	jne    c002c0a4 <pagedir_set_page+0xdc>
    ASSERT (is_user_vaddr(upage));
c002c002:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c008:	0f 87 bc 00 00 00    	ja     c002c0ca <pagedir_set_page+0x102>
    ASSERT (is_kernel_vaddr(vaddr));
c002c00e:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002c014:	0f 86 d6 00 00 00    	jbe    c002c0f0 <pagedir_set_page+0x128>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002c01a:	81 c6 00 00 00 40    	add    $0x40000000,%esi
    ASSERT (vtop(kpage) >> PTSHIFT < init_ram_pages);
c002c020:	89 f5                	mov    %esi,%ebp
c002c022:	c1 ed 0c             	shr    $0xc,%ebp
c002c025:	c7 c1 be 01 02 c0    	mov    $0xc00201be,%ecx
c002c02b:	3b 29                	cmp    (%ecx),%ebp
c002c02d:	0f 83 e3 00 00 00    	jae    c002c116 <pagedir_set_page+0x14e>
    ASSERT (pd != init_page_dir);
c002c033:	c7 c1 c4 fc 03 c0    	mov    $0xc003fcc4,%ecx
c002c039:	39 01                	cmp    %eax,(%ecx)
c002c03b:	0f 84 fb 00 00 00    	je     c002c13c <pagedir_set_page+0x174>

    pte = lookup_page(pd, upage, true);
c002c041:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c046:	e8 64 fc ff ff       	call   c002bcaf <lookup_page>

    if (pte != NULL) {
c002c04b:	85 c0                	test   %eax,%eax
c002c04d:	0f 84 35 01 00 00    	je     c002c188 <pagedir_set_page+0x1c0>
        ASSERT ((*pte & PTE_P) == 0);
c002c053:	8b 10                	mov    (%eax),%edx
c002c055:	83 e2 01             	and    $0x1,%edx
c002c058:	0f 85 04 01 00 00    	jne    c002c162 <pagedir_set_page+0x19a>
    return vtop(page) | PTE_P | (writable ? PTE_W : 0);
c002c05e:	89 fb                	mov    %edi,%ebx
c002c060:	84 db                	test   %bl,%bl
c002c062:	b9 02 00 00 00       	mov    $0x2,%ecx
c002c067:	0f 45 d1             	cmovne %ecx,%edx
c002c06a:	09 d6                	or     %edx,%esi
    return pte_create_kernel(page, writable) | PTE_U;
c002c06c:	83 ce 05             	or     $0x5,%esi
c002c06f:	89 30                	mov    %esi,(%eax)
        *pte = pte_create_user(kpage, writable);
        return true;
c002c071:	b8 01 00 00 00       	mov    $0x1,%eax
    } else
        return false;
}
c002c076:	83 c4 0c             	add    $0xc,%esp
c002c079:	5b                   	pop    %ebx
c002c07a:	5e                   	pop    %esi
c002c07b:	5f                   	pop    %edi
c002c07c:	5d                   	pop    %ebp
c002c07d:	c3                   	ret    
    ASSERT (pg_ofs(upage) == 0);
c002c07e:	83 ec 0c             	sub    $0xc,%esp
c002c081:	8d 83 47 57 ff ff    	lea    -0xa8b9(%ebx),%eax
c002c087:	50                   	push   %eax
c002c088:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c08e:	50                   	push   %eax
c002c08f:	8d 83 a8 33 ff ff    	lea    -0xcc58(%ebx),%eax
c002c095:	50                   	push   %eax
c002c096:	6a 62                	push   $0x62
c002c098:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002c09e:	50                   	push   %eax
c002c09f:	e8 89 d0 ff ff       	call   c002912d <debug_panic>
    ASSERT (pg_ofs(kpage) == 0);
c002c0a4:	83 ec 0c             	sub    $0xc,%esp
c002c0a7:	8d 83 5a 57 ff ff    	lea    -0xa8a6(%ebx),%eax
c002c0ad:	50                   	push   %eax
c002c0ae:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c0b4:	50                   	push   %eax
c002c0b5:	8d 83 a8 33 ff ff    	lea    -0xcc58(%ebx),%eax
c002c0bb:	50                   	push   %eax
c002c0bc:	6a 63                	push   $0x63
c002c0be:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002c0c4:	50                   	push   %eax
c002c0c5:	e8 63 d0 ff ff       	call   c002912d <debug_panic>
    ASSERT (is_user_vaddr(upage));
c002c0ca:	83 ec 0c             	sub    $0xc,%esp
c002c0cd:	8d 83 6d 57 ff ff    	lea    -0xa893(%ebx),%eax
c002c0d3:	50                   	push   %eax
c002c0d4:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c0da:	50                   	push   %eax
c002c0db:	8d 83 a8 33 ff ff    	lea    -0xcc58(%ebx),%eax
c002c0e1:	50                   	push   %eax
c002c0e2:	6a 64                	push   $0x64
c002c0e4:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002c0ea:	50                   	push   %eax
c002c0eb:	e8 3d d0 ff ff       	call   c002912d <debug_panic>
    ASSERT (is_kernel_vaddr(vaddr));
c002c0f0:	83 ec 0c             	sub    $0xc,%esp
c002c0f3:	8d 83 09 37 ff ff    	lea    -0xc8f7(%ebx),%eax
c002c0f9:	50                   	push   %eax
c002c0fa:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c100:	50                   	push   %eax
c002c101:	8d 83 a0 33 ff ff    	lea    -0xcc60(%ebx),%eax
c002c107:	50                   	push   %eax
c002c108:	6a 55                	push   $0x55
c002c10a:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002c110:	50                   	push   %eax
c002c111:	e8 17 d0 ff ff       	call   c002912d <debug_panic>
    ASSERT (vtop(kpage) >> PTSHIFT < init_ram_pages);
c002c116:	83 ec 0c             	sub    $0xc,%esp
c002c119:	8d 83 cc 57 ff ff    	lea    -0xa834(%ebx),%eax
c002c11f:	50                   	push   %eax
c002c120:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c126:	50                   	push   %eax
c002c127:	8d 83 a8 33 ff ff    	lea    -0xcc58(%ebx),%eax
c002c12d:	50                   	push   %eax
c002c12e:	6a 65                	push   $0x65
c002c130:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002c136:	50                   	push   %eax
c002c137:	e8 f1 cf ff ff       	call   c002912d <debug_panic>
    ASSERT (pd != init_page_dir);
c002c13c:	83 ec 0c             	sub    $0xc,%esp
c002c13f:	8d 83 33 57 ff ff    	lea    -0xa8cd(%ebx),%eax
c002c145:	50                   	push   %eax
c002c146:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c14c:	50                   	push   %eax
c002c14d:	8d 83 a8 33 ff ff    	lea    -0xcc58(%ebx),%eax
c002c153:	50                   	push   %eax
c002c154:	6a 66                	push   $0x66
c002c156:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002c15c:	50                   	push   %eax
c002c15d:	e8 cb cf ff ff       	call   c002912d <debug_panic>
        ASSERT ((*pte & PTE_P) == 0);
c002c162:	83 ec 0c             	sub    $0xc,%esp
c002c165:	8d 83 82 57 ff ff    	lea    -0xa87e(%ebx),%eax
c002c16b:	50                   	push   %eax
c002c16c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c172:	50                   	push   %eax
c002c173:	8d 83 a8 33 ff ff    	lea    -0xcc58(%ebx),%eax
c002c179:	50                   	push   %eax
c002c17a:	6a 6b                	push   $0x6b
c002c17c:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002c182:	50                   	push   %eax
c002c183:	e8 a5 cf ff ff       	call   c002912d <debug_panic>
        return false;
c002c188:	b8 00 00 00 00       	mov    $0x0,%eax
c002c18d:	e9 e4 fe ff ff       	jmp    c002c076 <pagedir_set_page+0xae>

c002c192 <pagedir_get_page>:
/* Looks up the physical address that corresponds to user virtual
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page(uint32_t *pd, const void *uaddr) {
c002c192:	56                   	push   %esi
c002c193:	53                   	push   %ebx
c002c194:	83 ec 04             	sub    $0x4,%esp
c002c197:	e8 a7 3f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c19c:	81 c3 10 1b 01 00    	add    $0x11b10,%ebx
c002c1a2:	8b 74 24 14          	mov    0x14(%esp),%esi
    uint32_t *pte;

    ASSERT (is_user_vaddr(uaddr));
c002c1a6:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002c1ac:	77 3a                	ja     c002c1e8 <pagedir_get_page+0x56>

    pte = lookup_page(pd, uaddr, false);
c002c1ae:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c1b3:	89 f2                	mov    %esi,%edx
c002c1b5:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c1b9:	e8 f1 fa ff ff       	call   c002bcaf <lookup_page>
    if (pte != NULL && (*pte & PTE_P) != 0)
c002c1be:	85 c0                	test   %eax,%eax
c002c1c0:	74 20                	je     c002c1e2 <pagedir_get_page+0x50>
c002c1c2:	8b 00                	mov    (%eax),%eax
c002c1c4:	a8 01                	test   $0x1,%al
c002c1c6:	74 6c                	je     c002c234 <pagedir_get_page+0xa2>
    return ptov(pte & PTE_ADDR);
c002c1c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    ASSERT ((void *) paddr < PHYS_BASE);
c002c1cd:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c1d2:	77 3a                	ja     c002c20e <pagedir_get_page+0x7c>
    return (uintptr_t) va & PGMASK;
c002c1d4:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
        return pte_get_page(*pte) + pg_ofs(uaddr);
c002c1da:	09 c6                	or     %eax,%esi
c002c1dc:	8d 86 00 00 00 c0    	lea    -0x40000000(%esi),%eax
    else
        return NULL;
}
c002c1e2:	83 c4 04             	add    $0x4,%esp
c002c1e5:	5b                   	pop    %ebx
c002c1e6:	5e                   	pop    %esi
c002c1e7:	c3                   	ret    
    ASSERT (is_user_vaddr(uaddr));
c002c1e8:	83 ec 0c             	sub    $0xc,%esp
c002c1eb:	8d 83 96 57 ff ff    	lea    -0xa86a(%ebx),%eax
c002c1f1:	50                   	push   %eax
c002c1f2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c1f8:	50                   	push   %eax
c002c1f9:	8d 83 74 33 ff ff    	lea    -0xcc8c(%ebx),%eax
c002c1ff:	50                   	push   %eax
c002c200:	6a 7a                	push   $0x7a
c002c202:	8d 83 0e 57 ff ff    	lea    -0xa8f2(%ebx),%eax
c002c208:	50                   	push   %eax
c002c209:	e8 1f cf ff ff       	call   c002912d <debug_panic>
    ASSERT ((void *) paddr < PHYS_BASE);
c002c20e:	83 ec 0c             	sub    $0xc,%esp
c002c211:	8d 83 aa 43 ff ff    	lea    -0xbc56(%ebx),%eax
c002c217:	50                   	push   %eax
c002c218:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c21e:	50                   	push   %eax
c002c21f:	8d 83 bc 33 ff ff    	lea    -0xcc44(%ebx),%eax
c002c225:	50                   	push   %eax
c002c226:	6a 4c                	push   $0x4c
c002c228:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002c22e:	50                   	push   %eax
c002c22f:	e8 f9 ce ff ff       	call   c002912d <debug_panic>
        return NULL;
c002c234:	b8 00 00 00 00       	mov    $0x0,%eax
c002c239:	eb a7                	jmp    c002c1e2 <pagedir_get_page+0x50>

c002c23b <pagedir_is_dirty>:
/* Returns true if the PTE for virtual page VPAGE in PD is dirty,
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool
pagedir_is_dirty(uint32_t *pd, const void *vpage) {
c002c23b:	83 ec 0c             	sub    $0xc,%esp
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c23e:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c243:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c247:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c24b:	e8 5f fa ff ff       	call   c002bcaf <lookup_page>
    return pte != NULL && (*pte & PTE_D) != 0;
c002c250:	ba 00 00 00 00       	mov    $0x0,%edx
c002c255:	85 c0                	test   %eax,%eax
c002c257:	74 08                	je     c002c261 <pagedir_is_dirty+0x26>
c002c259:	8b 10                	mov    (%eax),%edx
c002c25b:	c1 ea 06             	shr    $0x6,%edx
c002c25e:	83 e2 01             	and    $0x1,%edx
c002c261:	89 d0                	mov    %edx,%eax
c002c263:	83 e0 01             	and    $0x1,%eax
}
c002c266:	83 c4 0c             	add    $0xc,%esp
c002c269:	c3                   	ret    

c002c26a <pagedir_is_accessed>:
/* Returns true if the PTE for virtual page VPAGE in PD has been
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool
pagedir_is_accessed(uint32_t *pd, const void *vpage) {
c002c26a:	83 ec 0c             	sub    $0xc,%esp
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c26d:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c272:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c276:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c27a:	e8 30 fa ff ff       	call   c002bcaf <lookup_page>
    return pte != NULL && (*pte & PTE_A) != 0;
c002c27f:	ba 00 00 00 00       	mov    $0x0,%edx
c002c284:	85 c0                	test   %eax,%eax
c002c286:	74 08                	je     c002c290 <pagedir_is_accessed+0x26>
c002c288:	8b 10                	mov    (%eax),%edx
c002c28a:	c1 ea 05             	shr    $0x5,%edx
c002c28d:	83 e2 01             	and    $0x1,%edx
c002c290:	89 d0                	mov    %edx,%eax
c002c292:	83 e0 01             	and    $0x1,%eax
}
c002c295:	83 c4 0c             	add    $0xc,%esp
c002c298:	c3                   	ret    

c002c299 <pagedir_activate>:
}

/* Loads page directory PD into the CPU's page directory base
   register. */
void
pagedir_activate(uint32_t *pd) {
c002c299:	53                   	push   %ebx
c002c29a:	83 ec 08             	sub    $0x8,%esp
c002c29d:	e8 a1 3e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c2a2:	81 c3 0a 1a 01 00    	add    $0x11a0a,%ebx
c002c2a8:	8b 44 24 10          	mov    0x10(%esp),%eax
    if (pd == NULL)
c002c2ac:	85 c0                	test   %eax,%eax
c002c2ae:	74 14                	je     c002c2c4 <pagedir_activate+0x2b>
    ASSERT (is_kernel_vaddr(vaddr));
c002c2b0:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c2b5:	76 17                	jbe    c002c2ce <pagedir_activate+0x35>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002c2b7:	05 00 00 00 40       	add    $0x40000000,%eax
    /* Store the physical address of the page directory into CR3
       aka PDBR (page directory base register).  This activates our
       new page tables immediately.  See [IA32-v2a] "MOV--Move
       to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
       Address of the Page Directory". */
    asm volatile ("movl %0, %%cr3" : : "r" (vtop(pd)) : "memory");
c002c2bc:	0f 22 d8             	mov    %eax,%cr3
}
c002c2bf:	83 c4 08             	add    $0x8,%esp
c002c2c2:	5b                   	pop    %ebx
c002c2c3:	c3                   	ret    
        pd = init_page_dir;
c002c2c4:	c7 c0 c4 fc 03 c0    	mov    $0xc003fcc4,%eax
c002c2ca:	8b 00                	mov    (%eax),%eax
c002c2cc:	eb e2                	jmp    c002c2b0 <pagedir_activate+0x17>
    ASSERT (is_kernel_vaddr(vaddr));
c002c2ce:	83 ec 0c             	sub    $0xc,%esp
c002c2d1:	8d 83 09 37 ff ff    	lea    -0xc8f7(%ebx),%eax
c002c2d7:	50                   	push   %eax
c002c2d8:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c2de:	50                   	push   %eax
c002c2df:	8d 83 a0 33 ff ff    	lea    -0xcc60(%ebx),%eax
c002c2e5:	50                   	push   %eax
c002c2e6:	6a 55                	push   $0x55
c002c2e8:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002c2ee:	50                   	push   %eax
c002c2ef:	e8 39 ce ff ff       	call   c002912d <debug_panic>

c002c2f4 <invalidate_pagedir>:

   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir(uint32_t *pd) {
c002c2f4:	53                   	push   %ebx
c002c2f5:	83 ec 08             	sub    $0x8,%esp
c002c2f8:	e8 46 3e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c2fd:	81 c3 af 19 01 00    	add    $0x119af,%ebx
    asm volatile ("movl %%cr3, %0" : "=r" (pd));
c002c303:	0f 20 da             	mov    %cr3,%edx
    ASSERT ((void *) paddr < PHYS_BASE);
c002c306:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c30c:	77 0f                	ja     c002c31d <invalidate_pagedir+0x29>
    return (void *) (paddr + PHYS_BASE);
c002c30e:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
    if (active_pd() == pd) {
c002c314:	39 d0                	cmp    %edx,%eax
c002c316:	74 2b                	je     c002c343 <invalidate_pagedir+0x4f>
        /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
           "Translation Lookaside Buffers (TLBs)". */
        pagedir_activate(pd);
    }
}
c002c318:	83 c4 08             	add    $0x8,%esp
c002c31b:	5b                   	pop    %ebx
c002c31c:	c3                   	ret    
    ASSERT ((void *) paddr < PHYS_BASE);
c002c31d:	83 ec 0c             	sub    $0xc,%esp
c002c320:	8d 83 aa 43 ff ff    	lea    -0xbc56(%ebx),%eax
c002c326:	50                   	push   %eax
c002c327:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002c32d:	50                   	push   %eax
c002c32e:	8d 83 bc 33 ff ff    	lea    -0xcc44(%ebx),%eax
c002c334:	50                   	push   %eax
c002c335:	6a 4c                	push   $0x4c
c002c337:	8d 83 20 37 ff ff    	lea    -0xc8e0(%ebx),%eax
c002c33d:	50                   	push   %eax
c002c33e:	e8 ea cd ff ff       	call   c002912d <debug_panic>
        pagedir_activate(pd);
c002c343:	83 ec 0c             	sub    $0xc,%esp
c002c346:	50                   	push   %eax
c002c347:	e8 4d ff ff ff       	call   c002c299 <pagedir_activate>
c002c34c:	83 c4 10             	add    $0x10,%esp
}
c002c34f:	eb c7                	jmp    c002c318 <invalidate_pagedir+0x24>

c002c351 <pagedir_clear_page>:
pagedir_clear_page(uint32_t *pd, void *upage) {
c002c351:	56                   	push   %esi
c002c352:	53                   	push   %ebx
c002c353:	83 ec 04             	sub    $0x4,%esp
c002c356:	e8 e8 3d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c35b:	81 c3 51 19 01 00    	add    $0x11951,%ebx
c002c361:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c365:	8b 54 24 14          	mov    0x14(%esp),%edx
    ASSERT (pg_ofs(upage) == 0);
c002c369:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002c36f:	75 25                	jne    c002c396 <pagedir_clear_page+0x45>
    ASSERT (is_user_vaddr(upage));
c002c371:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c377:	77 46                	ja     c002c3bf <pagedir_clear_page+0x6e>
    pte = lookup_page(pd, upage, false);
c002c379:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c37e:	89 f0                	mov    %esi,%eax
c002c380:	e8 2a f9 ff ff       	call   c002bcaf <lookup_page>
    if (pte != NULL && (*pte & PTE_P) != 0) {
c002c385:	85 c0                	test   %eax,%eax
c002c387:	74 07                	je     c002c390 <pagedir_clear_page+0x3f>
c002c389:	8b 10                	mov    (%eax),%edx
c002c38b:	f6 c2 01             	test   $0x1,%dl
c002c38e:	75 58                	jne    c002c3e8 <pagedir_clear_page+0x97>
}
c002c390:	83 c4 04             	add    $0x4,%esp
c002c393:	5b                   	pop    %ebx
c002c394:	5e                   	pop    %esi
c002c395:	c3                   	ret    
    ASSERT (pg_ofs(upage) == 0);
c002c396:	83 ec 0c             	sub    $0xc,%esp
c002c399:	8d 93 47 57 ff ff    	lea    -0xa8b9(%ebx),%edx
c002c39f:	52                   	push   %edx
c002c3a0:	8d 93 de 36 ff ff    	lea    -0xc922(%ebx),%edx
c002c3a6:	52                   	push   %edx
c002c3a7:	8d 93 60 33 ff ff    	lea    -0xcca0(%ebx),%edx
c002c3ad:	52                   	push   %edx
c002c3ae:	68 8b 00 00 00       	push   $0x8b
c002c3b3:	8d 93 0e 57 ff ff    	lea    -0xa8f2(%ebx),%edx
c002c3b9:	52                   	push   %edx
c002c3ba:	e8 6e cd ff ff       	call   c002912d <debug_panic>
    ASSERT (is_user_vaddr(upage));
c002c3bf:	83 ec 0c             	sub    $0xc,%esp
c002c3c2:	8d 93 6d 57 ff ff    	lea    -0xa893(%ebx),%edx
c002c3c8:	52                   	push   %edx
c002c3c9:	8d 93 de 36 ff ff    	lea    -0xc922(%ebx),%edx
c002c3cf:	52                   	push   %edx
c002c3d0:	8d 93 60 33 ff ff    	lea    -0xcca0(%ebx),%edx
c002c3d6:	52                   	push   %edx
c002c3d7:	68 8c 00 00 00       	push   $0x8c
c002c3dc:	8d 93 0e 57 ff ff    	lea    -0xa8f2(%ebx),%edx
c002c3e2:	52                   	push   %edx
c002c3e3:	e8 45 cd ff ff       	call   c002912d <debug_panic>
        *pte &= ~PTE_P;
c002c3e8:	83 e2 fe             	and    $0xfffffffe,%edx
c002c3eb:	89 10                	mov    %edx,(%eax)
        invalidate_pagedir(pd);
c002c3ed:	89 f0                	mov    %esi,%eax
c002c3ef:	e8 00 ff ff ff       	call   c002c2f4 <invalidate_pagedir>
}
c002c3f4:	eb 9a                	jmp    c002c390 <pagedir_clear_page+0x3f>

c002c3f6 <pagedir_set_dirty>:
pagedir_set_dirty(uint32_t *pd, const void *vpage, bool dirty) {
c002c3f6:	56                   	push   %esi
c002c3f7:	53                   	push   %ebx
c002c3f8:	83 ec 04             	sub    $0x4,%esp
c002c3fb:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c3ff:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c403:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c408:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c40c:	89 f0                	mov    %esi,%eax
c002c40e:	e8 9c f8 ff ff       	call   c002bcaf <lookup_page>
    if (pte != NULL) {
c002c413:	85 c0                	test   %eax,%eax
c002c415:	74 07                	je     c002c41e <pagedir_set_dirty+0x28>
        if (dirty)
c002c417:	84 db                	test   %bl,%bl
c002c419:	74 09                	je     c002c424 <pagedir_set_dirty+0x2e>
            *pte |= PTE_D;
c002c41b:	83 08 40             	orl    $0x40,(%eax)
}
c002c41e:	83 c4 04             	add    $0x4,%esp
c002c421:	5b                   	pop    %ebx
c002c422:	5e                   	pop    %esi
c002c423:	c3                   	ret    
            *pte &= ~(uint32_t) PTE_D;
c002c424:	83 20 bf             	andl   $0xffffffbf,(%eax)
            invalidate_pagedir(pd);
c002c427:	89 f0                	mov    %esi,%eax
c002c429:	e8 c6 fe ff ff       	call   c002c2f4 <invalidate_pagedir>
}
c002c42e:	eb ee                	jmp    c002c41e <pagedir_set_dirty+0x28>

c002c430 <pagedir_set_accessed>:
pagedir_set_accessed(uint32_t *pd, const void *vpage, bool accessed) {
c002c430:	56                   	push   %esi
c002c431:	53                   	push   %ebx
c002c432:	83 ec 04             	sub    $0x4,%esp
c002c435:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c439:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c43d:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c442:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c446:	89 f0                	mov    %esi,%eax
c002c448:	e8 62 f8 ff ff       	call   c002bcaf <lookup_page>
    if (pte != NULL) {
c002c44d:	85 c0                	test   %eax,%eax
c002c44f:	74 07                	je     c002c458 <pagedir_set_accessed+0x28>
        if (accessed)
c002c451:	84 db                	test   %bl,%bl
c002c453:	74 09                	je     c002c45e <pagedir_set_accessed+0x2e>
            *pte |= PTE_A;
c002c455:	83 08 20             	orl    $0x20,(%eax)
}
c002c458:	83 c4 04             	add    $0x4,%esp
c002c45b:	5b                   	pop    %ebx
c002c45c:	5e                   	pop    %esi
c002c45d:	c3                   	ret    
            *pte &= ~(uint32_t) PTE_A;
c002c45e:	83 20 df             	andl   $0xffffffdf,(%eax)
            invalidate_pagedir(pd);
c002c461:	89 f0                	mov    %esi,%eax
c002c463:	e8 8c fe ff ff       	call   c002c2f4 <invalidate_pagedir>
}
c002c468:	eb ee                	jmp    c002c458 <pagedir_set_accessed+0x28>

c002c46a <kill>:
    printf("Exception: %lld page faults\n", page_fault_cnt);
}

/* Handler for an exception (probably) caused by a user process. */
static void
kill(struct intr_frame *f) {
c002c46a:	55                   	push   %ebp
c002c46b:	57                   	push   %edi
c002c46c:	56                   	push   %esi
c002c46d:	53                   	push   %ebx
c002c46e:	83 ec 0c             	sub    $0xc,%esp
c002c471:	e8 cd 3c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c476:	81 c3 36 18 01 00    	add    $0x11836,%ebx
c002c47c:	8b 74 24 20          	mov    0x20(%esp),%esi
       exceptions back to the process via signals, but we don't
       implement them. */

    /* The interrupt frame's code segment value tells us where the
       exception originated. */
    switch (f->cs) {
c002c480:	0f b7 7e 40          	movzwl 0x40(%esi),%edi
c002c484:	66 83 ff 08          	cmp    $0x8,%di
c002c488:	74 3a                	je     c002c4c4 <kill+0x5a>
c002c48a:	66 83 ff 1b          	cmp    $0x1b,%di
c002c48e:	75 59                	jne    c002c4e9 <kill+0x7f>
        case SEL_UCSEG:
            /* User's code segment, so it's a user exception, as we
               expected.  Kill the user process.  */
            printf("%s: dying due to interrupt %#04x (%s).\n",
c002c490:	83 ec 0c             	sub    $0xc,%esp
c002c493:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002c497:	50                   	push   %eax
c002c498:	e8 36 5e ff ff       	call   c00222d3 <intr_name>
c002c49d:	89 c5                	mov    %eax,%ebp
c002c49f:	8b 7e 30             	mov    0x30(%esi),%edi
c002c4a2:	e8 16 4c ff ff       	call   c00210bd <thread_name>
c002c4a7:	55                   	push   %ebp
c002c4a8:	57                   	push   %edi
c002c4a9:	50                   	push   %eax
c002c4aa:	8d 83 f4 57 ff ff    	lea    -0xa80c(%ebx),%eax
c002c4b0:	50                   	push   %eax
c002c4b1:	e8 1b b0 ff ff       	call   c00274d1 <printf>
                   thread_name(), f->vec_no, intr_name(f->vec_no));
            intr_dump_frame(f);
c002c4b6:	83 c4 14             	add    $0x14,%esp
c002c4b9:	56                   	push   %esi
c002c4ba:	e8 73 5d ff ff       	call   c0022232 <intr_dump_frame>
            thread_exit();
c002c4bf:	e8 64 51 ff ff       	call   c0021628 <thread_exit>
        case SEL_KCSEG:
            /* Kernel's code segment, which indicates a kernel bug.
               Kernel code shouldn't throw exceptions.  (Page faults
               may cause kernel exceptions--but they shouldn't arrive
               here.)  Panic the kernel to make the point.  */
            intr_dump_frame(f);
c002c4c4:	83 ec 0c             	sub    $0xc,%esp
c002c4c7:	56                   	push   %esi
c002c4c8:	e8 65 5d ff ff       	call   c0022232 <intr_dump_frame>
            PANIC ("Kernel bug - unexpected interrupt in kernel");
c002c4cd:	8d 83 1c 58 ff ff    	lea    -0xa7e4(%ebx),%eax
c002c4d3:	50                   	push   %eax
c002c4d4:	8d 83 e0 33 ff ff    	lea    -0xcc20(%ebx),%eax
c002c4da:	50                   	push   %eax
c002c4db:	6a 6e                	push   $0x6e
c002c4dd:	8d 83 ab 58 ff ff    	lea    -0xa755(%ebx),%eax
c002c4e3:	50                   	push   %eax
c002c4e4:	e8 44 cc ff ff       	call   c002912d <debug_panic>

        default:
            /* Some other code segment?  Shouldn't happen.  Panic the
               kernel. */
            printf("Interrupt %#04x (%s) in unknown segment %04x\n",
c002c4e9:	83 ec 0c             	sub    $0xc,%esp
c002c4ec:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002c4f0:	50                   	push   %eax
c002c4f1:	e8 dd 5d ff ff       	call   c00222d3 <intr_name>
    switch (f->cs) {
c002c4f6:	0f b7 ff             	movzwl %di,%edi
            printf("Interrupt %#04x (%s) in unknown segment %04x\n",
c002c4f9:	57                   	push   %edi
c002c4fa:	50                   	push   %eax
c002c4fb:	ff 76 30             	pushl  0x30(%esi)
c002c4fe:	8d 83 48 58 ff ff    	lea    -0xa7b8(%ebx),%eax
c002c504:	50                   	push   %eax
c002c505:	e8 c7 af ff ff       	call   c00274d1 <printf>
                   f->vec_no, intr_name(f->vec_no), f->cs);
            thread_exit();
c002c50a:	83 c4 20             	add    $0x20,%esp
c002c50d:	e8 16 51 ff ff       	call   c0021628 <thread_exit>

c002c512 <page_fault>:
   example code here shows how to parse that information.  You
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault(struct intr_frame *f) {
c002c512:	55                   	push   %ebp
c002c513:	57                   	push   %edi
c002c514:	56                   	push   %esi
c002c515:	53                   	push   %ebx
c002c516:	83 ec 1c             	sub    $0x1c,%esp
c002c519:	e8 25 3c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c51e:	81 c3 8e 17 01 00    	add    $0x1178e,%ebx
       data.  It is not necessarily the address of the instruction
       that caused the fault (that's f->eip).
       See [IA32-v2a] "MOV--Move to/from Control Registers" and
       [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
       (#PF)". */
    asm ("movl %%cr2, %0" : "=r" (fault_addr));
c002c524:	0f 20 d6             	mov    %cr2,%esi

    /* Turn interrupts back on (they were only off so that we could
       be assured of reading CR2 before it changed). */
    intr_enable();
c002c527:	e8 ed 57 ff ff       	call   c0021d19 <intr_enable>

    /* Count page faults. */
    page_fault_cnt++;
c002c52c:	83 83 9c 1c 00 00 01 	addl   $0x1,0x1c9c(%ebx)
c002c533:	83 93 a0 1c 00 00 00 	adcl   $0x0,0x1ca0(%ebx)

    /* Determine cause. */
    not_present = (f->error_code & PF_P) == 0;
c002c53a:	8b 44 24 30          	mov    0x30(%esp),%eax
c002c53e:	8b 68 34             	mov    0x34(%eax),%ebp
c002c541:	89 e8                	mov    %ebp,%eax
c002c543:	83 e0 01             	and    $0x1,%eax
c002c546:	89 44 24 08          	mov    %eax,0x8(%esp)
    write = (f->error_code & PF_W) != 0;
    user = (f->error_code & PF_U) != 0;
c002c54a:	89 e9                	mov    %ebp,%ecx
c002c54c:	83 e1 04             	and    $0x4,%ecx
c002c54f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)


#ifdef VM
   //for stack growth
   struct thread *cur = thread_current(); /* Current thread. */
c002c553:	e8 71 4a ff ff       	call   c0020fc9 <thread_current>
    return (void *) ((uintptr_t) va & ~PGMASK);
c002c558:	89 f2                	mov    %esi,%edx
c002c55a:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c002c560:	89 54 24 04          	mov    %edx,0x4(%esp)
   void* fault_page = (void*) pg_round_down(fault_addr);

   if (!not_present) {
c002c564:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002c569:	0f 85 a5 00 00 00    	jne    c002c614 <page_fault+0x102>
c002c56f:	89 c7                	mov    %eax,%edi
      // printf(" not_ present error");
    // attempt to write to a read-only region is always killed.
      goto ERROR;
   }

   void* esp = user ? f->esp : cur->stack;
c002c571:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c002c576:	74 67                	je     c002c5df <page_fault+0xcd>
c002c578:	8b 44 24 30          	mov    0x30(%esp),%eax
c002c57c:	8b 50 48             	mov    0x48(%eax),%edx

  // Stack Growth
   bool on_stack_frame, is_stack_addr;
   on_stack_frame = (esp <= fault_addr || fault_addr == f->esp - 4 || fault_addr == f->esp - 32);
c002c57f:	b8 01 00 00 00       	mov    $0x1,%eax
c002c584:	39 f2                	cmp    %esi,%edx
c002c586:	76 1e                	jbe    c002c5a6 <page_fault+0x94>
c002c588:	8b 44 24 30          	mov    0x30(%esp),%eax
c002c58c:	8b 50 48             	mov    0x48(%eax),%edx
c002c58f:	8d 4a fc             	lea    -0x4(%edx),%ecx
c002c592:	b8 01 00 00 00       	mov    $0x1,%eax
c002c597:	39 ce                	cmp    %ecx,%esi
c002c599:	74 0b                	je     c002c5a6 <page_fault+0x94>
c002c59b:	83 ea 20             	sub    $0x20,%edx
c002c59e:	39 d6                	cmp    %edx,%esi
c002c5a0:	0f 94 c0             	sete   %al
c002c5a3:	0f b6 c0             	movzbl %al,%eax
   is_stack_addr = (PHYS_BASE - MAX_STACK_SIZE <= fault_addr && fault_addr < PHYS_BASE);
c002c5a6:	8d 96 00 00 80 40    	lea    0x40800000(%esi),%edx
   if (on_stack_frame && is_stack_addr) {
c002c5ac:	81 fa ff ff 7f 00    	cmp    $0x7fffff,%edx
c002c5b2:	77 04                	ja     c002c5b8 <page_fault+0xa6>
c002c5b4:	85 c0                	test   %eax,%eax
c002c5b6:	75 2c                	jne    c002c5e4 <page_fault+0xd2>
      // printf(" no nonono");
      if (spt_has_item(cur->spt, fault_page) == false)
      spt_install_zeropage(cur->spt, fault_page);
   }

   if(!load_page(cur->spt, cur->pagedir, fault_page)) {
c002c5b8:	83 ec 04             	sub    $0x4,%esp
c002c5bb:	ff 74 24 08          	pushl  0x8(%esp)
c002c5bf:	ff b7 10 01 00 00    	pushl  0x110(%edi)
c002c5c5:	ff b7 18 01 00 00    	pushl  0x118(%edi)
c002c5cb:	e8 c0 36 00 00       	call   c002fc90 <load_page>
c002c5d0:	83 c4 10             	add    $0x10,%esp
c002c5d3:	84 c0                	test   %al,%al
c002c5d5:	74 3d                	je     c002c614 <page_fault+0x102>
           fault_addr,
           not_present ? "not present" : "rights violation",
           write ? "writing" : "reading",
           user ? "user" : "kernel");
    kill(f);
}
c002c5d7:	83 c4 1c             	add    $0x1c,%esp
c002c5da:	5b                   	pop    %ebx
c002c5db:	5e                   	pop    %esi
c002c5dc:	5f                   	pop    %edi
c002c5dd:	5d                   	pop    %ebp
c002c5de:	c3                   	ret    
   void* esp = user ? f->esp : cur->stack;
c002c5df:	8b 50 18             	mov    0x18(%eax),%edx
c002c5e2:	eb 9b                	jmp    c002c57f <page_fault+0x6d>
      if (spt_has_item(cur->spt, fault_page) == false)
c002c5e4:	83 ec 08             	sub    $0x8,%esp
c002c5e7:	ff 74 24 0c          	pushl  0xc(%esp)
c002c5eb:	ff b7 18 01 00 00    	pushl  0x118(%edi)
c002c5f1:	e8 2d 36 00 00       	call   c002fc23 <spt_has_item>
c002c5f6:	83 c4 10             	add    $0x10,%esp
c002c5f9:	84 c0                	test   %al,%al
c002c5fb:	75 bb                	jne    c002c5b8 <page_fault+0xa6>
      spt_install_zeropage(cur->spt, fault_page);
c002c5fd:	83 ec 08             	sub    $0x8,%esp
c002c600:	ff 74 24 0c          	pushl  0xc(%esp)
c002c604:	ff b7 18 01 00 00    	pushl  0x118(%edi)
c002c60a:	e8 42 3a 00 00       	call   c0030051 <spt_install_zeropage>
c002c60f:	83 c4 10             	add    $0x10,%esp
c002c612:	eb a4                	jmp    c002c5b8 <page_fault+0xa6>
    syscall_exit(-1);
c002c614:	83 ec 0c             	sub    $0xc,%esp
c002c617:	6a ff                	push   $0xffffffff
c002c619:	e8 d0 02 00 00       	call   c002c8ee <syscall_exit>
    printf("Page fault at %p: %s error %s page in %s context.\n",
c002c61e:	83 c4 10             	add    $0x10,%esp
c002c621:	8d 8b c6 58 ff ff    	lea    -0xa73a(%ebx),%ecx
c002c627:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c002c62c:	75 06                	jne    c002c634 <page_fault+0x122>
c002c62e:	8d 8b 04 49 ff ff    	lea    -0xb6fc(%ebx),%ecx
c002c634:	8d 93 cb 58 ff ff    	lea    -0xa735(%ebx),%edx
c002c63a:	f7 c5 02 00 00 00    	test   $0x2,%ebp
c002c640:	75 06                	jne    c002c648 <page_fault+0x136>
c002c642:	8d 93 d3 58 ff ff    	lea    -0xa72d(%ebx),%edx
c002c648:	8d 83 db 58 ff ff    	lea    -0xa725(%ebx),%eax
c002c64e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002c653:	74 06                	je     c002c65b <page_fault+0x149>
c002c655:	8d 83 e7 58 ff ff    	lea    -0xa719(%ebx),%eax
c002c65b:	83 ec 0c             	sub    $0xc,%esp
c002c65e:	51                   	push   %ecx
c002c65f:	52                   	push   %edx
c002c660:	50                   	push   %eax
c002c661:	56                   	push   %esi
c002c662:	8d 83 78 58 ff ff    	lea    -0xa788(%ebx),%eax
c002c668:	50                   	push   %eax
c002c669:	e8 63 ae ff ff       	call   c00274d1 <printf>
    kill(f);
c002c66e:	83 c4 14             	add    $0x14,%esp
c002c671:	ff 74 24 3c          	pushl  0x3c(%esp)
c002c675:	e8 f0 fd ff ff       	call   c002c46a <kill>

c002c67a <exception_init>:
exception_init(void) {
c002c67a:	56                   	push   %esi
c002c67b:	53                   	push   %ebx
c002c67c:	83 ec 10             	sub    $0x10,%esp
c002c67f:	e8 bf 3a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c684:	81 c3 28 16 01 00    	add    $0x11628,%ebx
    intr_register_int(3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002c68a:	8d 83 6f 3f ff ff    	lea    -0xc091(%ebx),%eax
c002c690:	50                   	push   %eax
c002c691:	8d b3 be e7 fe ff    	lea    -0x11842(%ebx),%esi
c002c697:	56                   	push   %esi
c002c698:	6a 01                	push   $0x1
c002c69a:	6a 03                	push   $0x3
c002c69c:	6a 03                	push   $0x3
c002c69e:	e8 01 59 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002c6a3:	83 c4 14             	add    $0x14,%esp
c002c6a6:	8d 83 88 3f ff ff    	lea    -0xc078(%ebx),%eax
c002c6ac:	50                   	push   %eax
c002c6ad:	56                   	push   %esi
c002c6ae:	6a 01                	push   $0x1
c002c6b0:	6a 03                	push   $0x3
c002c6b2:	6a 04                	push   $0x4
c002c6b4:	e8 eb 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(5, 3, INTR_ON, kill,
c002c6b9:	83 c4 14             	add    $0x14,%esp
c002c6bc:	8d 83 c4 40 ff ff    	lea    -0xbf3c(%ebx),%eax
c002c6c2:	50                   	push   %eax
c002c6c3:	56                   	push   %esi
c002c6c4:	6a 01                	push   $0x1
c002c6c6:	6a 03                	push   $0x3
c002c6c8:	6a 05                	push   $0x5
c002c6ca:	e8 d5 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(0, 0, INTR_ON, kill, "#DE Divide Error");
c002c6cf:	83 c4 14             	add    $0x14,%esp
c002c6d2:	8d 83 3c 3f ff ff    	lea    -0xc0c4(%ebx),%eax
c002c6d8:	50                   	push   %eax
c002c6d9:	56                   	push   %esi
c002c6da:	6a 01                	push   $0x1
c002c6dc:	6a 00                	push   $0x0
c002c6de:	6a 00                	push   $0x0
c002c6e0:	e8 bf 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(1, 0, INTR_ON, kill, "#DB Debug Exception");
c002c6e5:	83 c4 14             	add    $0x14,%esp
c002c6e8:	8d 83 4d 3f ff ff    	lea    -0xc0b3(%ebx),%eax
c002c6ee:	50                   	push   %eax
c002c6ef:	56                   	push   %esi
c002c6f0:	6a 01                	push   $0x1
c002c6f2:	6a 00                	push   $0x0
c002c6f4:	6a 01                	push   $0x1
c002c6f6:	e8 a9 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002c6fb:	83 c4 14             	add    $0x14,%esp
c002c6fe:	8d 83 9f 3f ff ff    	lea    -0xc061(%ebx),%eax
c002c704:	50                   	push   %eax
c002c705:	56                   	push   %esi
c002c706:	6a 01                	push   $0x1
c002c708:	6a 00                	push   $0x0
c002c70a:	6a 06                	push   $0x6
c002c70c:	e8 93 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(7, 0, INTR_ON, kill,
c002c711:	83 c4 14             	add    $0x14,%esp
c002c714:	8d 83 e8 40 ff ff    	lea    -0xbf18(%ebx),%eax
c002c71a:	50                   	push   %eax
c002c71b:	56                   	push   %esi
c002c71c:	6a 01                	push   $0x1
c002c71e:	6a 00                	push   $0x0
c002c720:	6a 07                	push   $0x7
c002c722:	e8 7d 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002c727:	83 c4 14             	add    $0x14,%esp
c002c72a:	8d 83 0d 40 ff ff    	lea    -0xbff3(%ebx),%eax
c002c730:	50                   	push   %eax
c002c731:	56                   	push   %esi
c002c732:	6a 01                	push   $0x1
c002c734:	6a 00                	push   $0x0
c002c736:	6a 0b                	push   $0xb
c002c738:	e8 67 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002c73d:	83 c4 14             	add    $0x14,%esp
c002c740:	8d 83 25 40 ff ff    	lea    -0xbfdb(%ebx),%eax
c002c746:	50                   	push   %eax
c002c747:	56                   	push   %esi
c002c748:	6a 01                	push   $0x1
c002c74a:	6a 00                	push   $0x0
c002c74c:	6a 0c                	push   $0xc
c002c74e:	e8 51 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002c753:	83 c4 14             	add    $0x14,%esp
c002c756:	8d 83 0c 41 ff ff    	lea    -0xbef4(%ebx),%eax
c002c75c:	50                   	push   %eax
c002c75d:	56                   	push   %esi
c002c75e:	6a 01                	push   $0x1
c002c760:	6a 00                	push   $0x0
c002c762:	6a 0d                	push   $0xd
c002c764:	e8 3b 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002c769:	83 c4 14             	add    $0x14,%esp
c002c76c:	8d 83 30 41 ff ff    	lea    -0xbed0(%ebx),%eax
c002c772:	50                   	push   %eax
c002c773:	56                   	push   %esi
c002c774:	6a 01                	push   $0x1
c002c776:	6a 00                	push   $0x0
c002c778:	6a 10                	push   $0x10
c002c77a:	e8 25 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(19, 0, INTR_ON, kill,
c002c77f:	83 c4 14             	add    $0x14,%esp
c002c782:	8d 83 54 41 ff ff    	lea    -0xbeac(%ebx),%eax
c002c788:	50                   	push   %eax
c002c789:	56                   	push   %esi
c002c78a:	6a 01                	push   $0x1
c002c78c:	6a 00                	push   $0x0
c002c78e:	6a 13                	push   $0x13
c002c790:	e8 0f 58 ff ff       	call   c0021fa4 <intr_register_int>
    intr_register_int(14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002c795:	83 c4 14             	add    $0x14,%esp
c002c798:	8d 83 3f 40 ff ff    	lea    -0xbfc1(%ebx),%eax
c002c79e:	50                   	push   %eax
c002c79f:	8d 83 66 e8 fe ff    	lea    -0x1179a(%ebx),%eax
c002c7a5:	50                   	push   %eax
c002c7a6:	6a 00                	push   $0x0
c002c7a8:	6a 00                	push   $0x0
c002c7aa:	6a 0e                	push   $0xe
c002c7ac:	e8 f3 57 ff ff       	call   c0021fa4 <intr_register_int>
}
c002c7b1:	83 c4 24             	add    $0x24,%esp
c002c7b4:	5b                   	pop    %ebx
c002c7b5:	5e                   	pop    %esi
c002c7b6:	c3                   	ret    

c002c7b7 <exception_print_stats>:
exception_print_stats(void) {
c002c7b7:	53                   	push   %ebx
c002c7b8:	83 ec 0c             	sub    $0xc,%esp
c002c7bb:	e8 83 39 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c7c0:	81 c3 ec 14 01 00    	add    $0x114ec,%ebx
    printf("Exception: %lld page faults\n", page_fault_cnt);
c002c7c6:	ff b3 a0 1c 00 00    	pushl  0x1ca0(%ebx)
c002c7cc:	ff b3 9c 1c 00 00    	pushl  0x1c9c(%ebx)
c002c7d2:	8d 83 f8 58 ff ff    	lea    -0xa708(%ebx),%eax
c002c7d8:	50                   	push   %eax
c002c7d9:	e8 f3 ac ff ff       	call   c00274d1 <printf>
}
c002c7de:	83 c4 18             	add    $0x18,%esp
c002c7e1:	5b                   	pop    %ebx
c002c7e2:	c3                   	ret    

c002c7e3 <syscall_init>:


static struct lock filesystem_lock;

void
syscall_init(void) {
c002c7e3:	53                   	push   %ebx
c002c7e4:	83 ec 14             	sub    $0x14,%esp
c002c7e7:	e8 57 39 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c7ec:	81 c3 c0 14 01 00    	add    $0x114c0,%ebx
    intr_register_int(0x30, 3, INTR_ON, syscall_handler, "syscall");
c002c7f2:	8d 83 15 59 ff ff    	lea    -0xa6eb(%ebx),%eax
c002c7f8:	50                   	push   %eax
c002c7f9:	8d 83 f5 f7 fe ff    	lea    -0x1080b(%ebx),%eax
c002c7ff:	50                   	push   %eax
c002c800:	6a 01                	push   $0x1
c002c802:	6a 03                	push   $0x3
c002c804:	6a 30                	push   $0x30
c002c806:	e8 99 57 ff ff       	call   c0021fa4 <intr_register_int>
    lock_init(&filesystem_lock);
c002c80b:	83 c4 14             	add    $0x14,%esp
c002c80e:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002c814:	50                   	push   %eax
c002c815:	e8 96 69 ff ff       	call   c00231b0 <lock_init>
}
c002c81a:	83 c4 18             	add    $0x18,%esp
c002c81d:	5b                   	pop    %ebx
c002c81e:	c3                   	ret    

c002c81f <get_fs_lock>:

struct lock * get_fs_lock() {
c002c81f:	e8 23 39 00 00       	call   c0030147 <__x86.get_pc_thunk.ax>
c002c824:	05 88 14 01 00       	add    $0x11488,%eax
    return &filesystem_lock;
c002c829:	8d 80 b4 1c 00 00    	lea    0x1cb4(%eax),%eax
}
c002c82f:	c3                   	ret    

c002c830 <load_and_pin>:
//       : "=&a" (result) : "m" (*uaddr));
//   return result;
// }
#ifdef VM
void load_and_pin(const void *buffer, size_t size);
void load_and_pin(const void *buffer, size_t size) {
c002c830:	55                   	push   %ebp
c002c831:	57                   	push   %edi
c002c832:	56                   	push   %esi
c002c833:	53                   	push   %ebx
c002c834:	83 ec 1c             	sub    $0x1c,%esp
c002c837:	e8 07 39 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c83c:	81 c3 70 14 01 00    	add    $0x11470,%ebx
  struct s_page_table *spt = thread_current()->spt;
c002c842:	e8 82 47 ff ff       	call   c0020fc9 <thread_current>
c002c847:	8b b8 18 01 00 00    	mov    0x118(%eax),%edi
  uint32_t *pagedir = thread_current()->pagedir;
c002c84d:	e8 77 47 ff ff       	call   c0020fc9 <thread_current>
c002c852:	8b a8 10 01 00 00    	mov    0x110(%eax),%ebp
c002c858:	8b 74 24 30          	mov    0x30(%esp),%esi
c002c85c:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi

  void *upage;
  for(upage = pg_round_down(buffer); upage < buffer + size; upage += PGSIZE) {
c002c862:	8b 44 24 30          	mov    0x30(%esp),%eax
c002c866:	03 44 24 34          	add    0x34(%esp),%eax
c002c86a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002c86e:	39 c6                	cmp    %eax,%esi
c002c870:	73 24                	jae    c002c896 <load_and_pin+0x66>
    load_page(spt, pagedir, upage);
c002c872:	83 ec 04             	sub    $0x4,%esp
c002c875:	56                   	push   %esi
c002c876:	55                   	push   %ebp
c002c877:	57                   	push   %edi
c002c878:	e8 13 34 00 00       	call   c002fc90 <load_page>
    pin_page (spt, upage);
c002c87d:	83 c4 08             	add    $0x8,%esp
c002c880:	56                   	push   %esi
c002c881:	57                   	push   %edi
c002c882:	e8 4c 38 00 00       	call   c00300d3 <pin_page>
  for(upage = pg_round_down(buffer); upage < buffer + size; upage += PGSIZE) {
c002c887:	81 c6 00 10 00 00    	add    $0x1000,%esi
c002c88d:	83 c4 10             	add    $0x10,%esp
c002c890:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c002c894:	72 dc                	jb     c002c872 <load_and_pin+0x42>
  }
}
c002c896:	83 c4 1c             	add    $0x1c,%esp
c002c899:	5b                   	pop    %ebx
c002c89a:	5e                   	pop    %esi
c002c89b:	5f                   	pop    %edi
c002c89c:	5d                   	pop    %ebp
c002c89d:	c3                   	ret    

c002c89e <un_pin>:
void un_pin(const void *buffer, size_t size);
void un_pin(const void *buffer, size_t size) {
c002c89e:	55                   	push   %ebp
c002c89f:	57                   	push   %edi
c002c8a0:	56                   	push   %esi
c002c8a1:	53                   	push   %ebx
c002c8a2:	83 ec 0c             	sub    $0xc,%esp
c002c8a5:	e8 99 38 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c8aa:	81 c3 02 14 01 00    	add    $0x11402,%ebx
c002c8b0:	8b 7c 24 20          	mov    0x20(%esp),%edi
    struct s_page_table *spt = thread_current()->spt;
c002c8b4:	e8 10 47 ff ff       	call   c0020fc9 <thread_current>
c002c8b9:	8b a8 18 01 00 00    	mov    0x118(%eax),%ebp
c002c8bf:	89 fe                	mov    %edi,%esi
c002c8c1:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi

    void *upage;
    for(upage = pg_round_down(buffer); upage < buffer + size; upage += PGSIZE) {
c002c8c7:	03 7c 24 24          	add    0x24(%esp),%edi
c002c8cb:	39 fe                	cmp    %edi,%esi
c002c8cd:	73 17                	jae    c002c8e6 <un_pin+0x48>
        unpin_page (spt, upage);
c002c8cf:	83 ec 08             	sub    $0x8,%esp
c002c8d2:	56                   	push   %esi
c002c8d3:	55                   	push   %ebp
c002c8d4:	e8 32 38 00 00       	call   c003010b <unpin_page>
    for(upage = pg_round_down(buffer); upage < buffer + size; upage += PGSIZE) {
c002c8d9:	81 c6 00 10 00 00    	add    $0x1000,%esi
c002c8df:	83 c4 10             	add    $0x10,%esp
c002c8e2:	39 fe                	cmp    %edi,%esi
c002c8e4:	72 e9                	jb     c002c8cf <un_pin+0x31>
    }
}
c002c8e6:	83 c4 0c             	add    $0xc,%esp
c002c8e9:	5b                   	pop    %ebx
c002c8ea:	5e                   	pop    %esi
c002c8eb:	5f                   	pop    %edi
c002c8ec:	5d                   	pop    %ebp
c002c8ed:	c3                   	ret    

c002c8ee <syscall_exit>:
            return read_size;
        }
    }
}

void syscall_exit (int status) {
c002c8ee:	55                   	push   %ebp
c002c8ef:	57                   	push   %edi
c002c8f0:	56                   	push   %esi
c002c8f1:	53                   	push   %ebx
c002c8f2:	83 ec 0c             	sub    $0xc,%esp
c002c8f5:	e8 49 38 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c8fa:	81 c3 b2 13 01 00    	add    $0x113b2,%ebx
    struct thread * t = thread_current();
c002c900:	e8 c4 46 ff ff       	call   c0020fc9 <thread_current>
c002c905:	89 c5                	mov    %eax,%ebp
    t->exit_status = status;
c002c907:	8b 44 24 20          	mov    0x20(%esp),%eax
c002c90b:	89 45 2c             	mov    %eax,0x2c(%ebp)
    while (!list_empty(&t->file_descriptor_list)) {
c002c90e:	8d 7d 30             	lea    0x30(%ebp),%edi
c002c911:	83 ec 0c             	sub    $0xc,%esp
c002c914:	57                   	push   %edi
c002c915:	e8 84 cf ff ff       	call   c002989e <list_empty>
c002c91a:	83 c4 10             	add    $0x10,%esp
c002c91d:	84 c0                	test   %al,%al
c002c91f:	75 2e                	jne    c002c94f <syscall_exit+0x61>
        struct file_descriptor * fd_ptr = list_entry(list_pop_front(&t->file_descriptor_list),
c002c921:	83 ec 0c             	sub    $0xc,%esp
c002c924:	57                   	push   %edi
c002c925:	e8 eb cf ff ff       	call   c0029915 <list_pop_front>
c002c92a:	89 c6                	mov    %eax,%esi
                struct file_descriptor, elem);
        file_close(fd_ptr->opened_file);
c002c92c:	83 c4 04             	add    $0x4,%esp
c002c92f:	ff 70 fc             	pushl  -0x4(%eax)
c002c932:	e8 1d 16 00 00       	call   c002df54 <file_close>
        t->fd_used[fd_ptr->fd] = false;
c002c937:	8b 46 f4             	mov    -0xc(%esi),%eax
c002c93a:	c6 44 05 40 00       	movb   $0x0,0x40(%ebp,%eax,1)
        free(fd_ptr);
c002c93f:	83 ee 0c             	sub    $0xc,%esi
c002c942:	89 34 24             	mov    %esi,(%esp)
c002c945:	e8 b2 76 ff ff       	call   c0023ffc <free>
c002c94a:	83 c4 10             	add    $0x10,%esp
c002c94d:	eb c2                	jmp    c002c911 <syscall_exit+0x23>
    }
    // debug_backtrace();
    // printf("stupid child exit %d\n", t->tid);
    printf("%s: exit(%d)\n", thread_current()->name, status);
c002c94f:	e8 75 46 ff ff       	call   c0020fc9 <thread_current>
c002c954:	83 ec 04             	sub    $0x4,%esp
c002c957:	ff 74 24 24          	pushl  0x24(%esp)
c002c95b:	83 c0 08             	add    $0x8,%eax
c002c95e:	50                   	push   %eax
c002c95f:	8d 83 1d 59 ff ff    	lea    -0xa6e3(%ebx),%eax
c002c965:	50                   	push   %eax
c002c966:	e8 66 ab ff ff       	call   c00274d1 <printf>
    thread_exit();
c002c96b:	e8 b8 4c ff ff       	call   c0021628 <thread_exit>

c002c970 <validate_user_addr>:
validate_user_addr(const void *uaddr, unsigned int len) {
c002c970:	57                   	push   %edi
c002c971:	56                   	push   %esi
c002c972:	53                   	push   %ebx
c002c973:	e8 cb 37 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002c978:	81 c3 34 13 01 00    	add    $0x11334,%ebx
    for (const void *addr = uaddr; addr < uaddr + len; ++addr) {
c002c97e:	8d 3c 10             	lea    (%eax,%edx,1),%edi
c002c981:	39 f8                	cmp    %edi,%eax
c002c983:	73 5d                	jae    c002c9e2 <validate_user_addr+0x72>
c002c985:	89 c6                	mov    %eax,%esi
        if ((!addr) || !(is_valid_user_vaddr(addr))) {
c002c987:	85 c0                	test   %eax,%eax
c002c989:	74 43                	je     c002c9ce <validate_user_addr+0x5e>
    return is_user_vaddr(vaddr) && vaddr > ((void *) 0x08048000);
c002c98b:	8d 80 ff 7f fb f7    	lea    -0x8048001(%eax),%eax
c002c991:	3d fe 7f fb b7       	cmp    $0xb7fb7ffe,%eax
c002c996:	77 36                	ja     c002c9ce <validate_user_addr+0x5e>
        if (pagedir_get_page(thread_current()->pagedir, pg_round_down(addr)) == NULL) {
c002c998:	e8 2c 46 ff ff       	call   c0020fc9 <thread_current>
c002c99d:	83 ec 08             	sub    $0x8,%esp
    return (void *) ((uintptr_t) va & ~PGMASK);
c002c9a0:	89 f2                	mov    %esi,%edx
c002c9a2:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c002c9a8:	52                   	push   %edx
c002c9a9:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002c9af:	e8 de f7 ff ff       	call   c002c192 <pagedir_get_page>
c002c9b4:	83 c4 10             	add    $0x10,%esp
c002c9b7:	85 c0                	test   %eax,%eax
c002c9b9:	74 1d                	je     c002c9d8 <validate_user_addr+0x68>
    for (const void *addr = uaddr; addr < uaddr + len; ++addr) {
c002c9bb:	83 c6 01             	add    $0x1,%esi
c002c9be:	39 fe                	cmp    %edi,%esi
c002c9c0:	74 20                	je     c002c9e2 <validate_user_addr+0x72>
        if ((!addr) || !(is_valid_user_vaddr(addr))) {
c002c9c2:	85 f6                	test   %esi,%esi
c002c9c4:	74 08                	je     c002c9ce <validate_user_addr+0x5e>
c002c9c6:	81 fe 00 00 00 c0    	cmp    $0xc0000000,%esi
c002c9cc:	75 ca                	jne    c002c998 <validate_user_addr+0x28>
            syscall_exit(-1);
c002c9ce:	83 ec 0c             	sub    $0xc,%esp
c002c9d1:	6a ff                	push   $0xffffffff
c002c9d3:	e8 16 ff ff ff       	call   c002c8ee <syscall_exit>
            syscall_exit(-1);
c002c9d8:	83 ec 0c             	sub    $0xc,%esp
c002c9db:	6a ff                	push   $0xffffffff
c002c9dd:	e8 0c ff ff ff       	call   c002c8ee <syscall_exit>
}
c002c9e2:	5b                   	pop    %ebx
c002c9e3:	5e                   	pop    %esi
c002c9e4:	5f                   	pop    %edi
c002c9e5:	c3                   	ret    

c002c9e6 <get_syscall_arg>:
get_syscall_arg(struct intr_frame *f, uint32_t *buffer, int argc) {
c002c9e6:	55                   	push   %ebp
c002c9e7:	57                   	push   %edi
c002c9e8:	56                   	push   %esi
c002c9e9:	53                   	push   %ebx
c002c9ea:	83 ec 0c             	sub    $0xc,%esp
    for (int i = 0; i < argc; i++) {
c002c9ed:	85 c9                	test   %ecx,%ecx
c002c9ef:	7e 30                	jle    c002ca21 <get_syscall_arg+0x3b>
c002c9f1:	89 d5                	mov    %edx,%ebp
c002c9f3:	89 c6                	mov    %eax,%esi
c002c9f5:	89 cf                	mov    %ecx,%edi
c002c9f7:	bb 01 00 00 00       	mov    $0x1,%ebx
c002c9fc:	eb 02                	jmp    c002ca00 <get_syscall_arg+0x1a>
c002c9fe:	89 c3                	mov    %eax,%ebx
        validate_user_addr((uint32_t *) f->esp + i + 1, 4);
c002ca00:	8b 46 48             	mov    0x48(%esi),%eax
c002ca03:	8d 04 98             	lea    (%eax,%ebx,4),%eax
c002ca06:	ba 04 00 00 00       	mov    $0x4,%edx
c002ca0b:	e8 60 ff ff ff       	call   c002c970 <validate_user_addr>
        *buffer = *((uint32_t *) f->esp + i + 1);
c002ca10:	8b 46 48             	mov    0x48(%esi),%eax
c002ca13:	8b 04 98             	mov    (%eax,%ebx,4),%eax
c002ca16:	89 44 9d fc          	mov    %eax,-0x4(%ebp,%ebx,4)
        buffer++;
c002ca1a:	8d 43 01             	lea    0x1(%ebx),%eax
    for (int i = 0; i < argc; i++) {
c002ca1d:	39 fb                	cmp    %edi,%ebx
c002ca1f:	75 dd                	jne    c002c9fe <get_syscall_arg+0x18>
}
c002ca21:	83 c4 0c             	add    $0xc,%esp
c002ca24:	5b                   	pop    %ebx
c002ca25:	5e                   	pop    %esi
c002ca26:	5f                   	pop    %edi
c002ca27:	5d                   	pop    %ebp
c002ca28:	c3                   	ret    

c002ca29 <get_syscall_type>:
int get_syscall_type(struct intr_frame *f) {
c002ca29:	53                   	push   %ebx
c002ca2a:	83 ec 08             	sub    $0x8,%esp
c002ca2d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    validate_user_addr(f->esp, sizeof(uint32_t));
c002ca31:	8b 43 48             	mov    0x48(%ebx),%eax
c002ca34:	ba 04 00 00 00       	mov    $0x4,%edx
c002ca39:	e8 32 ff ff ff       	call   c002c970 <validate_user_addr>
    return *((uint32_t *) f->esp);
c002ca3e:	8b 43 48             	mov    0x48(%ebx),%eax
c002ca41:	8b 00                	mov    (%eax),%eax
}
c002ca43:	83 c4 08             	add    $0x8,%esp
c002ca46:	5b                   	pop    %ebx
c002ca47:	c3                   	ret    

c002ca48 <check_stack>:
void check_stack(void * esp) {
c002ca48:	56                   	push   %esi
c002ca49:	53                   	push   %ebx
c002ca4a:	83 ec 04             	sub    $0x4,%esp
c002ca4d:	e8 f1 36 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ca52:	81 c3 5a 12 01 00    	add    $0x1125a,%ebx
c002ca58:	8b 74 24 10          	mov    0x10(%esp),%esi
    return is_user_vaddr(vaddr) && vaddr > ((void *) 0x08048000);
c002ca5c:	8d 86 ff 7f fb f7    	lea    -0x8048001(%esi),%eax
    if (!is_valid_user_vaddr(esp)) {
c002ca62:	3d fe 7f fb b7       	cmp    $0xb7fb7ffe,%eax
c002ca67:	77 2a                	ja     c002ca93 <check_stack+0x4b>
        if (pagedir_get_page(thread_current()->pagedir, pg_round_down(esp + 1)) == NULL)
c002ca69:	e8 5b 45 ff ff       	call   c0020fc9 <thread_current>
c002ca6e:	83 ec 08             	sub    $0x8,%esp
c002ca71:	83 c6 01             	add    $0x1,%esi
    return (void *) ((uintptr_t) va & ~PGMASK);
c002ca74:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c002ca7a:	56                   	push   %esi
c002ca7b:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002ca81:	e8 0c f7 ff ff       	call   c002c192 <pagedir_get_page>
c002ca86:	83 c4 10             	add    $0x10,%esp
c002ca89:	85 c0                	test   %eax,%eax
c002ca8b:	74 10                	je     c002ca9d <check_stack+0x55>
}
c002ca8d:	83 c4 04             	add    $0x4,%esp
c002ca90:	5b                   	pop    %ebx
c002ca91:	5e                   	pop    %esi
c002ca92:	c3                   	ret    
        syscall_exit(-1);
c002ca93:	83 ec 0c             	sub    $0xc,%esp
c002ca96:	6a ff                	push   $0xffffffff
c002ca98:	e8 51 fe ff ff       	call   c002c8ee <syscall_exit>
            syscall_exit(-1);
c002ca9d:	83 ec 0c             	sub    $0xc,%esp
c002caa0:	6a ff                	push   $0xffffffff
c002caa2:	e8 47 fe ff ff       	call   c002c8ee <syscall_exit>

c002caa7 <check_file_addr>:
void check_file_addr(const char * file) {
c002caa7:	53                   	push   %ebx
c002caa8:	83 ec 08             	sub    $0x8,%esp
c002caab:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    if (file == NULL) syscall_exit(-1);
c002caaf:	85 db                	test   %ebx,%ebx
c002cab1:	74 16                	je     c002cac9 <check_file_addr+0x22>
    for (; validate_user_addr(p, 1), *p != '\0'; p++) {
c002cab3:	ba 01 00 00 00       	mov    $0x1,%edx
c002cab8:	89 d8                	mov    %ebx,%eax
c002caba:	e8 b1 fe ff ff       	call   c002c970 <validate_user_addr>
c002cabf:	80 3b 00             	cmpb   $0x0,(%ebx)
c002cac2:	74 0f                	je     c002cad3 <check_file_addr+0x2c>
c002cac4:	83 c3 01             	add    $0x1,%ebx
c002cac7:	eb ea                	jmp    c002cab3 <check_file_addr+0xc>
    if (file == NULL) syscall_exit(-1);
c002cac9:	83 ec 0c             	sub    $0xc,%esp
c002cacc:	6a ff                	push   $0xffffffff
c002cace:	e8 1b fe ff ff       	call   c002c8ee <syscall_exit>
    validate_user_addr(p, 1);
c002cad3:	ba 01 00 00 00       	mov    $0x1,%edx
c002cad8:	89 d8                	mov    %ebx,%eax
c002cada:	e8 91 fe ff ff       	call   c002c970 <validate_user_addr>
}
c002cadf:	83 c4 08             	add    $0x8,%esp
c002cae2:	5b                   	pop    %ebx
c002cae3:	c3                   	ret    

c002cae4 <check_user>:
  if (! ((void*)uaddr < PHYS_BASE)) {
c002cae4:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002cae9:	77 01                	ja     c002caec <check_user+0x8>
c002caeb:	c3                   	ret    
static void check_user (const uint8_t *uaddr) {
c002caec:	83 ec 18             	sub    $0x18,%esp
    syscall_exit(-1);
c002caef:	6a ff                	push   $0xffffffff
c002caf1:	e8 f8 fd ff ff       	call   c002c8ee <syscall_exit>

c002caf6 <syscall_halt>:
}

void syscall_halt(void) {
c002caf6:	53                   	push   %ebx
c002caf7:	83 ec 08             	sub    $0x8,%esp
c002cafa:	e8 44 36 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002caff:	81 c3 ad 11 01 00    	add    $0x111ad,%ebx
    shutdown_power_off();
c002cb05:	e8 ae a1 ff ff       	call   c0026cb8 <shutdown_power_off>

c002cb0a <syscall_remove>:
    NOT_REACHED ();
}

bool syscall_remove (const char *file) {
c002cb0a:	57                   	push   %edi
c002cb0b:	56                   	push   %esi
c002cb0c:	53                   	push   %ebx
c002cb0d:	e8 31 36 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002cb12:	81 c3 9a 11 01 00    	add    $0x1119a,%ebx
c002cb18:	8b 7c 24 10          	mov    0x10(%esp),%edi
    lock_acquire(&filesystem_lock);
c002cb1c:	83 ec 0c             	sub    $0xc,%esp
c002cb1f:	8d b3 b4 1c 00 00    	lea    0x1cb4(%ebx),%esi
c002cb25:	56                   	push   %esi
c002cb26:	e8 31 67 ff ff       	call   c002325c <lock_acquire>
    check_file_addr(file);
c002cb2b:	89 3c 24             	mov    %edi,(%esp)
c002cb2e:	e8 74 ff ff ff       	call   c002caa7 <check_file_addr>
    bool success = filesys_remove(file);
c002cb33:	89 3c 24             	mov    %edi,(%esp)
c002cb36:	e8 2c 0f 00 00       	call   c002da67 <filesys_remove>
c002cb3b:	89 c7                	mov    %eax,%edi
    lock_release(&filesystem_lock);
c002cb3d:	89 34 24             	mov    %esi,(%esp)
c002cb40:	e8 18 69 ff ff       	call   c002345d <lock_release>
    return success;
c002cb45:	83 c4 10             	add    $0x10,%esp
}
c002cb48:	89 f8                	mov    %edi,%eax
c002cb4a:	5b                   	pop    %ebx
c002cb4b:	5e                   	pop    %esi
c002cb4c:	5f                   	pop    %edi
c002cb4d:	c3                   	ret    

c002cb4e <syscall_create>:

bool syscall_create (const char *file, unsigned initial_size) {
c002cb4e:	57                   	push   %edi
c002cb4f:	56                   	push   %esi
c002cb50:	53                   	push   %ebx
c002cb51:	e8 ed 35 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002cb56:	81 c3 56 11 01 00    	add    $0x11156,%ebx
c002cb5c:	8b 7c 24 10          	mov    0x10(%esp),%edi
    lock_acquire(&filesystem_lock);
c002cb60:	83 ec 0c             	sub    $0xc,%esp
c002cb63:	8d b3 b4 1c 00 00    	lea    0x1cb4(%ebx),%esi
c002cb69:	56                   	push   %esi
c002cb6a:	e8 ed 66 ff ff       	call   c002325c <lock_acquire>
    check_file_addr(file);
c002cb6f:	89 3c 24             	mov    %edi,(%esp)
c002cb72:	e8 30 ff ff ff       	call   c002caa7 <check_file_addr>
    bool success = filesys_create(file, initial_size);
c002cb77:	83 c4 08             	add    $0x8,%esp
c002cb7a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cb7e:	57                   	push   %edi
c002cb7f:	e8 f6 0d 00 00       	call   c002d97a <filesys_create>
c002cb84:	89 c7                	mov    %eax,%edi
    lock_release(&filesystem_lock);
c002cb86:	89 34 24             	mov    %esi,(%esp)
c002cb89:	e8 cf 68 ff ff       	call   c002345d <lock_release>
    return success;
c002cb8e:	83 c4 10             	add    $0x10,%esp
}
c002cb91:	89 f8                	mov    %edi,%eax
c002cb93:	5b                   	pop    %ebx
c002cb94:	5e                   	pop    %esi
c002cb95:	5f                   	pop    %edi
c002cb96:	c3                   	ret    

c002cb97 <select_unused_fd>:

int select_unused_fd(struct thread * t) {
c002cb97:	8b 54 24 04          	mov    0x4(%esp),%edx
    for (int i = 3; i < 140; i++) {
        if (!t->fd_used[i]) {
c002cb9b:	80 7a 43 00          	cmpb   $0x0,0x43(%edx)
c002cb9f:	74 18                	je     c002cbb9 <select_unused_fd+0x22>
    for (int i = 3; i < 140; i++) {
c002cba1:	b8 04 00 00 00       	mov    $0x4,%eax
        if (!t->fd_used[i]) {
c002cba6:	80 7c 02 40 00       	cmpb   $0x0,0x40(%edx,%eax,1)
c002cbab:	74 0b                	je     c002cbb8 <select_unused_fd+0x21>
    for (int i = 3; i < 140; i++) {
c002cbad:	83 c0 01             	add    $0x1,%eax
c002cbb0:	3d 8c 00 00 00       	cmp    $0x8c,%eax
c002cbb5:	75 ef                	jne    c002cba6 <select_unused_fd+0xf>
            return i;
        }
    }
}
c002cbb7:	c3                   	ret    
c002cbb8:	c3                   	ret    
    for (int i = 3; i < 140; i++) {
c002cbb9:	b8 03 00 00 00       	mov    $0x3,%eax
            return i;
c002cbbe:	c3                   	ret    

c002cbbf <syscall_open>:

int syscall_open (const char *file) {
c002cbbf:	55                   	push   %ebp
c002cbc0:	57                   	push   %edi
c002cbc1:	56                   	push   %esi
c002cbc2:	53                   	push   %ebx
c002cbc3:	83 ec 28             	sub    $0x28,%esp
c002cbc6:	e8 78 35 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002cbcb:	81 c3 e1 10 01 00    	add    $0x110e1,%ebx
    /*
     * Opens the file called file. Returns a non-negative integer handle called a
     * "file descriptor" (fd), or -1 if the file could not be opened.
     */
    lock_acquire(&filesystem_lock);
c002cbd1:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cbd7:	50                   	push   %eax
c002cbd8:	e8 7f 66 ff ff       	call   c002325c <lock_acquire>
    check_file_addr(file);
c002cbdd:	83 c4 04             	add    $0x4,%esp
c002cbe0:	ff 74 24 3c          	pushl  0x3c(%esp)
c002cbe4:	e8 be fe ff ff       	call   c002caa7 <check_file_addr>
    struct file * fp = filesys_open(file);
c002cbe9:	83 c4 04             	add    $0x4,%esp
c002cbec:	ff 74 24 3c          	pushl  0x3c(%esp)
c002cbf0:	e8 1f 0e 00 00       	call   c002da14 <filesys_open>
c002cbf5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    if (fp == NULL) {
c002cbf9:	83 c4 10             	add    $0x10,%esp
c002cbfc:	85 c0                	test   %eax,%eax
c002cbfe:	74 68                	je     c002cc68 <syscall_open+0xa9>
        lock_release(&filesystem_lock);
        return -1;
    }

    struct thread * t = thread_current();
c002cc00:	e8 c4 43 ff ff       	call   c0020fc9 <thread_current>
c002cc05:	89 c7                	mov    %eax,%edi
    int fd = select_unused_fd(t);
c002cc07:	83 ec 0c             	sub    $0xc,%esp
c002cc0a:	50                   	push   %eax
c002cc0b:	e8 87 ff ff ff       	call   c002cb97 <select_unused_fd>
c002cc10:	89 c5                	mov    %eax,%ebp

    struct file_descriptor * fileDescriptor = malloc (sizeof(struct file_descriptor));
c002cc12:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
c002cc19:	e8 30 72 ff ff       	call   c0023e4e <malloc>
c002cc1e:	89 c6                	mov    %eax,%esi
    // printf("open new file, fd is %d\n", fd);
    fileDescriptor->fd = fd;
c002cc20:	89 28                	mov    %ebp,(%eax)
    fileDescriptor->holder = thread_current();
c002cc22:	e8 a2 43 ff ff       	call   c0020fc9 <thread_current>
c002cc27:	89 46 04             	mov    %eax,0x4(%esi)
    fileDescriptor->name = (char *) file;
c002cc2a:	8b 44 24 40          	mov    0x40(%esp),%eax
c002cc2e:	89 46 14             	mov    %eax,0x14(%esi)
    fileDescriptor->opened_file = fp;
c002cc31:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002cc35:	89 46 08             	mov    %eax,0x8(%esi)

    t->fd_used[fd] = true;
c002cc38:	c6 44 2f 40 01       	movb   $0x1,0x40(%edi,%ebp,1)
    list_push_back(&t->file_descriptor_list, &fileDescriptor->elem );
c002cc3d:	83 c4 08             	add    $0x8,%esp
c002cc40:	83 c6 0c             	add    $0xc,%esi
c002cc43:	56                   	push   %esi
c002cc44:	83 c7 30             	add    $0x30,%edi
c002cc47:	57                   	push   %edi
c002cc48:	e8 92 cb ff ff       	call   c00297df <list_push_back>
    lock_release(&filesystem_lock);
c002cc4d:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cc53:	89 04 24             	mov    %eax,(%esp)
c002cc56:	e8 02 68 ff ff       	call   c002345d <lock_release>
    return fd;
c002cc5b:	83 c4 10             	add    $0x10,%esp

}
c002cc5e:	89 e8                	mov    %ebp,%eax
c002cc60:	83 c4 1c             	add    $0x1c,%esp
c002cc63:	5b                   	pop    %ebx
c002cc64:	5e                   	pop    %esi
c002cc65:	5f                   	pop    %edi
c002cc66:	5d                   	pop    %ebp
c002cc67:	c3                   	ret    
        lock_release(&filesystem_lock);
c002cc68:	83 ec 0c             	sub    $0xc,%esp
c002cc6b:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cc71:	50                   	push   %eax
c002cc72:	e8 e6 67 ff ff       	call   c002345d <lock_release>
        return -1;
c002cc77:	83 c4 10             	add    $0x10,%esp
c002cc7a:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002cc7f:	eb dd                	jmp    c002cc5e <syscall_open+0x9f>

c002cc81 <get_fd_ptr>:

struct file_descriptor * get_fd_ptr(struct thread * t, int fd) {
c002cc81:	55                   	push   %ebp
c002cc82:	57                   	push   %edi
c002cc83:	56                   	push   %esi
c002cc84:	53                   	push   %ebx
c002cc85:	83 ec 18             	sub    $0x18,%esp
c002cc88:	e8 b6 34 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002cc8d:	81 c3 1f 10 01 00    	add    $0x1101f,%ebx
c002cc93:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    struct list_elem * e;
    for (e = list_begin(&t->file_descriptor_list); e != list_end(&t->file_descriptor_list);
c002cc97:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002cc9b:	8d 78 30             	lea    0x30(%eax),%edi
c002cc9e:	57                   	push   %edi
c002cc9f:	e8 ae c5 ff ff       	call   c0029252 <list_begin>
c002cca4:	89 c6                	mov    %eax,%esi
c002cca6:	83 c4 10             	add    $0x10,%esp
c002cca9:	83 ec 0c             	sub    $0xc,%esp
c002ccac:	57                   	push   %edi
c002ccad:	e8 42 c6 ff ff       	call   c00292f4 <list_end>
c002ccb2:	83 c4 10             	add    $0x10,%esp
c002ccb5:	39 f0                	cmp    %esi,%eax
c002ccb7:	74 1a                	je     c002ccd3 <get_fd_ptr+0x52>
         e = list_next(e)) {
        struct file_descriptor * fileDescriptor = list_entry(e, struct file_descriptor, elem);
        if (fileDescriptor->fd == fd) {
c002ccb9:	39 6e f4             	cmp    %ebp,-0xc(%esi)
c002ccbc:	74 10                	je     c002ccce <get_fd_ptr+0x4d>
         e = list_next(e)) {
c002ccbe:	83 ec 0c             	sub    $0xc,%esp
c002ccc1:	56                   	push   %esi
c002ccc2:	e8 d0 c5 ff ff       	call   c0029297 <list_next>
c002ccc7:	89 c6                	mov    %eax,%esi
c002ccc9:	83 c4 10             	add    $0x10,%esp
c002cccc:	eb db                	jmp    c002cca9 <get_fd_ptr+0x28>
        struct file_descriptor * fileDescriptor = list_entry(e, struct file_descriptor, elem);
c002ccce:	8d 46 f4             	lea    -0xc(%esi),%eax
c002ccd1:	eb 05                	jmp    c002ccd8 <get_fd_ptr+0x57>
            return fileDescriptor;
        }
    }
    return NULL;
c002ccd3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ccd8:	83 c4 0c             	add    $0xc,%esp
c002ccdb:	5b                   	pop    %ebx
c002ccdc:	5e                   	pop    %esi
c002ccdd:	5f                   	pop    %edi
c002ccde:	5d                   	pop    %ebp
c002ccdf:	c3                   	ret    

c002cce0 <syscall_write>:
int syscall_write(int fd, const void *buffer, unsigned size) {
c002cce0:	55                   	push   %ebp
c002cce1:	57                   	push   %edi
c002cce2:	56                   	push   %esi
c002cce3:	53                   	push   %ebx
c002cce4:	83 ec 0c             	sub    $0xc,%esp
c002cce7:	e8 57 34 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ccec:	81 c3 c0 0f 01 00    	add    $0x10fc0,%ebx
c002ccf2:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002ccf6:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002ccfa:	8b 74 24 28          	mov    0x28(%esp),%esi
    check_user((const uint8_t*) buffer);
c002ccfe:	89 f8                	mov    %edi,%eax
c002cd00:	e8 df fd ff ff       	call   c002cae4 <check_user>
    check_user((const uint8_t*) buffer + size - 1);
c002cd05:	8d 44 37 ff          	lea    -0x1(%edi,%esi,1),%eax
c002cd09:	e8 d6 fd ff ff       	call   c002cae4 <check_user>
    lock_acquire(&filesystem_lock);
c002cd0e:	83 ec 0c             	sub    $0xc,%esp
c002cd11:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cd17:	50                   	push   %eax
c002cd18:	e8 3f 65 ff ff       	call   c002325c <lock_acquire>
    switch (fd) {
c002cd1d:	83 c4 10             	add    $0x10,%esp
c002cd20:	85 ed                	test   %ebp,%ebp
c002cd22:	74 53                	je     c002cd77 <syscall_write+0x97>
c002cd24:	83 fd 01             	cmp    $0x1,%ebp
c002cd27:	74 69                	je     c002cd92 <syscall_write+0xb2>
            struct file_descriptor * fd_ptr = get_fd_ptr(thread_current(), fd);
c002cd29:	e8 9b 42 ff ff       	call   c0020fc9 <thread_current>
c002cd2e:	83 ec 08             	sub    $0x8,%esp
c002cd31:	55                   	push   %ebp
c002cd32:	50                   	push   %eax
c002cd33:	e8 49 ff ff ff       	call   c002cc81 <get_fd_ptr>
c002cd38:	89 c5                	mov    %eax,%ebp
            if (fd_ptr == NULL) {
c002cd3a:	83 c4 10             	add    $0x10,%esp
c002cd3d:	85 c0                	test   %eax,%eax
c002cd3f:	74 76                	je     c002cdb7 <syscall_write+0xd7>
            load_and_pin(buffer, size);
c002cd41:	83 ec 08             	sub    $0x8,%esp
c002cd44:	56                   	push   %esi
c002cd45:	57                   	push   %edi
c002cd46:	e8 e5 fa ff ff       	call   c002c830 <load_and_pin>
            int write_size = file_write(fd_ptr->opened_file, buffer, size);
c002cd4b:	83 c4 0c             	add    $0xc,%esp
c002cd4e:	56                   	push   %esi
c002cd4f:	57                   	push   %edi
c002cd50:	ff 75 08             	pushl  0x8(%ebp)
c002cd53:	e8 ec 10 00 00       	call   c002de44 <file_write>
c002cd58:	89 c6                	mov    %eax,%esi
            un_pin(buffer, write_size);
c002cd5a:	83 c4 08             	add    $0x8,%esp
c002cd5d:	50                   	push   %eax
c002cd5e:	57                   	push   %edi
c002cd5f:	e8 3a fb ff ff       	call   c002c89e <un_pin>
            lock_release(&filesystem_lock);
c002cd64:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cd6a:	89 04 24             	mov    %eax,(%esp)
c002cd6d:	e8 eb 66 ff ff       	call   c002345d <lock_release>
            return write_size;
c002cd72:	83 c4 10             	add    $0x10,%esp
c002cd75:	eb 36                	jmp    c002cdad <syscall_write+0xcd>
            lock_release(&filesystem_lock);
c002cd77:	83 ec 0c             	sub    $0xc,%esp
c002cd7a:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cd80:	50                   	push   %eax
c002cd81:	e8 d7 66 ff ff       	call   c002345d <lock_release>
            syscall_exit(-1);
c002cd86:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cd8d:	e8 5c fb ff ff       	call   c002c8ee <syscall_exit>
            putbuf((const char *)buffer, size);
c002cd92:	83 ec 08             	sub    $0x8,%esp
c002cd95:	56                   	push   %esi
c002cd96:	57                   	push   %edi
c002cd97:	e8 a6 e3 ff ff       	call   c002b142 <putbuf>
            lock_release(&filesystem_lock);
c002cd9c:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cda2:	89 04 24             	mov    %eax,(%esp)
c002cda5:	e8 b3 66 ff ff       	call   c002345d <lock_release>
            return size;
c002cdaa:	83 c4 10             	add    $0x10,%esp
}
c002cdad:	89 f0                	mov    %esi,%eax
c002cdaf:	83 c4 0c             	add    $0xc,%esp
c002cdb2:	5b                   	pop    %ebx
c002cdb3:	5e                   	pop    %esi
c002cdb4:	5f                   	pop    %edi
c002cdb5:	5d                   	pop    %ebp
c002cdb6:	c3                   	ret    
                lock_release(&filesystem_lock);
c002cdb7:	83 ec 0c             	sub    $0xc,%esp
c002cdba:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cdc0:	50                   	push   %eax
c002cdc1:	e8 97 66 ff ff       	call   c002345d <lock_release>
                syscall_exit(-1);
c002cdc6:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cdcd:	e8 1c fb ff ff       	call   c002c8ee <syscall_exit>

c002cdd2 <syscall_read>:
int syscall_read (int fd, void *buffer, unsigned size) {
c002cdd2:	55                   	push   %ebp
c002cdd3:	57                   	push   %edi
c002cdd4:	56                   	push   %esi
c002cdd5:	53                   	push   %ebx
c002cdd6:	83 ec 0c             	sub    $0xc,%esp
c002cdd9:	e8 65 33 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002cdde:	81 c3 ce 0e 01 00    	add    $0x10ece,%ebx
c002cde4:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002cde8:	8b 74 24 24          	mov    0x24(%esp),%esi
c002cdec:	8b 7c 24 28          	mov    0x28(%esp),%edi
    check_user((const uint8_t*) buffer);
c002cdf0:	89 f0                	mov    %esi,%eax
c002cdf2:	e8 ed fc ff ff       	call   c002cae4 <check_user>
    check_user((const uint8_t*) buffer + size - 1);
c002cdf7:	8d 44 3e ff          	lea    -0x1(%esi,%edi,1),%eax
c002cdfb:	e8 e4 fc ff ff       	call   c002cae4 <check_user>
    lock_acquire(&filesystem_lock);
c002ce00:	83 ec 0c             	sub    $0xc,%esp
c002ce03:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002ce09:	50                   	push   %eax
c002ce0a:	e8 4d 64 ff ff       	call   c002325c <lock_acquire>
    switch (fd) {
c002ce0f:	83 c4 10             	add    $0x10,%esp
c002ce12:	85 ed                	test   %ebp,%ebp
c002ce14:	74 58                	je     c002ce6e <syscall_read+0x9c>
c002ce16:	83 fd 01             	cmp    $0x1,%ebp
c002ce19:	74 6e                	je     c002ce89 <syscall_read+0xb7>
            struct file_descriptor * fd_ptr = get_fd_ptr(thread_current(), fd);
c002ce1b:	e8 a9 41 ff ff       	call   c0020fc9 <thread_current>
c002ce20:	83 ec 08             	sub    $0x8,%esp
c002ce23:	55                   	push   %ebp
c002ce24:	50                   	push   %eax
c002ce25:	e8 57 fe ff ff       	call   c002cc81 <get_fd_ptr>
c002ce2a:	89 c5                	mov    %eax,%ebp
            if (fd_ptr == NULL) {
c002ce2c:	83 c4 10             	add    $0x10,%esp
c002ce2f:	85 c0                	test   %eax,%eax
c002ce31:	74 71                	je     c002cea4 <syscall_read+0xd2>
            load_and_pin(buffer, size);
c002ce33:	83 ec 08             	sub    $0x8,%esp
c002ce36:	57                   	push   %edi
c002ce37:	56                   	push   %esi
c002ce38:	e8 f3 f9 ff ff       	call   c002c830 <load_and_pin>
            int read_size = file_read(fd_ptr->opened_file, buffer, size);
c002ce3d:	83 c4 0c             	add    $0xc,%esp
c002ce40:	57                   	push   %edi
c002ce41:	56                   	push   %esi
c002ce42:	ff 75 08             	pushl  0x8(%ebp)
c002ce45:	e8 a0 0f 00 00       	call   c002ddea <file_read>
c002ce4a:	89 c5                	mov    %eax,%ebp
            un_pin(buffer, size);
c002ce4c:	83 c4 08             	add    $0x8,%esp
c002ce4f:	57                   	push   %edi
c002ce50:	56                   	push   %esi
c002ce51:	e8 48 fa ff ff       	call   c002c89e <un_pin>
            lock_release(&filesystem_lock);
c002ce56:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002ce5c:	89 04 24             	mov    %eax,(%esp)
c002ce5f:	e8 f9 65 ff ff       	call   c002345d <lock_release>
}
c002ce64:	89 e8                	mov    %ebp,%eax
c002ce66:	83 c4 1c             	add    $0x1c,%esp
c002ce69:	5b                   	pop    %ebx
c002ce6a:	5e                   	pop    %esi
c002ce6b:	5f                   	pop    %edi
c002ce6c:	5d                   	pop    %ebp
c002ce6d:	c3                   	ret    
            lock_release(&filesystem_lock);
c002ce6e:	83 ec 0c             	sub    $0xc,%esp
c002ce71:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002ce77:	50                   	push   %eax
c002ce78:	e8 e0 65 ff ff       	call   c002345d <lock_release>
            syscall_exit(-1);
c002ce7d:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002ce84:	e8 65 fa ff ff       	call   c002c8ee <syscall_exit>
            lock_release(&filesystem_lock);
c002ce89:	83 ec 0c             	sub    $0xc,%esp
c002ce8c:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002ce92:	50                   	push   %eax
c002ce93:	e8 c5 65 ff ff       	call   c002345d <lock_release>
            syscall_exit(-1);
c002ce98:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002ce9f:	e8 4a fa ff ff       	call   c002c8ee <syscall_exit>
                lock_release(&filesystem_lock);
c002cea4:	83 ec 0c             	sub    $0xc,%esp
c002cea7:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cead:	50                   	push   %eax
c002ceae:	e8 aa 65 ff ff       	call   c002345d <lock_release>
                syscall_exit(-1);
c002ceb3:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002ceba:	e8 2f fa ff ff       	call   c002c8ee <syscall_exit>

c002cebf <syscall_close>:

void syscall_close(int fd) {
c002cebf:	55                   	push   %ebp
c002cec0:	57                   	push   %edi
c002cec1:	56                   	push   %esi
c002cec2:	53                   	push   %ebx
c002cec3:	83 ec 0c             	sub    $0xc,%esp
c002cec6:	e8 78 32 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002cecb:	81 c3 e1 0d 01 00    	add    $0x10de1,%ebx
c002ced1:	8b 7c 24 20          	mov    0x20(%esp),%edi
    struct thread * t = thread_current();
c002ced5:	e8 ef 40 ff ff       	call   c0020fc9 <thread_current>
c002ceda:	89 c5                	mov    %eax,%ebp
    lock_acquire(&filesystem_lock);
c002cedc:	83 ec 0c             	sub    $0xc,%esp
c002cedf:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cee5:	50                   	push   %eax
c002cee6:	e8 71 63 ff ff       	call   c002325c <lock_acquire>

    if (fd <= 1 || list_empty(&t->file_descriptor_list)) {
c002ceeb:	83 c4 10             	add    $0x10,%esp
c002ceee:	83 ff 01             	cmp    $0x1,%edi
c002cef1:	7e 5f                	jle    c002cf52 <syscall_close+0x93>
c002cef3:	83 ec 0c             	sub    $0xc,%esp
c002cef6:	8d 45 30             	lea    0x30(%ebp),%eax
c002cef9:	50                   	push   %eax
c002cefa:	e8 9f c9 ff ff       	call   c002989e <list_empty>
c002ceff:	83 c4 10             	add    $0x10,%esp
c002cf02:	84 c0                	test   %al,%al
c002cf04:	75 4c                	jne    c002cf52 <syscall_close+0x93>
        // printf("This thread (%s) has no opened file\n", t->name);
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file_descriptor * fd_ptr = get_fd_ptr(t, fd);
c002cf06:	83 ec 08             	sub    $0x8,%esp
c002cf09:	57                   	push   %edi
c002cf0a:	55                   	push   %ebp
c002cf0b:	e8 71 fd ff ff       	call   c002cc81 <get_fd_ptr>
c002cf10:	89 c6                	mov    %eax,%esi
    if (fd_ptr == NULL) {
c002cf12:	83 c4 10             	add    $0x10,%esp
c002cf15:	85 c0                	test   %eax,%eax
c002cf17:	74 54                	je     c002cf6d <syscall_close+0xae>
        // printf("No such fd opened: %d\n", fd);
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    file_close(fd_ptr->opened_file);
c002cf19:	83 ec 0c             	sub    $0xc,%esp
c002cf1c:	ff 70 08             	pushl  0x8(%eax)
c002cf1f:	e8 30 10 00 00       	call   c002df54 <file_close>
    t->fd_used[fd] = false;
c002cf24:	c6 44 3d 40 00       	movb   $0x0,0x40(%ebp,%edi,1)
    list_remove(&fd_ptr->elem);
c002cf29:	8d 46 0c             	lea    0xc(%esi),%eax
c002cf2c:	89 04 24             	mov    %eax,(%esp)
c002cf2f:	e8 c8 c8 ff ff       	call   c00297fc <list_remove>
    free(fd_ptr);
c002cf34:	89 34 24             	mov    %esi,(%esp)
c002cf37:	e8 c0 70 ff ff       	call   c0023ffc <free>
    lock_release(&filesystem_lock);
c002cf3c:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cf42:	89 04 24             	mov    %eax,(%esp)
c002cf45:	e8 13 65 ff ff       	call   c002345d <lock_release>
}
c002cf4a:	83 c4 1c             	add    $0x1c,%esp
c002cf4d:	5b                   	pop    %ebx
c002cf4e:	5e                   	pop    %esi
c002cf4f:	5f                   	pop    %edi
c002cf50:	5d                   	pop    %ebp
c002cf51:	c3                   	ret    
        lock_release(&filesystem_lock);
c002cf52:	83 ec 0c             	sub    $0xc,%esp
c002cf55:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cf5b:	50                   	push   %eax
c002cf5c:	e8 fc 64 ff ff       	call   c002345d <lock_release>
        syscall_exit(-1);
c002cf61:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cf68:	e8 81 f9 ff ff       	call   c002c8ee <syscall_exit>
        lock_release(&filesystem_lock);
c002cf6d:	83 ec 0c             	sub    $0xc,%esp
c002cf70:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cf76:	50                   	push   %eax
c002cf77:	e8 e1 64 ff ff       	call   c002345d <lock_release>
        syscall_exit(-1);
c002cf7c:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cf83:	e8 66 f9 ff ff       	call   c002c8ee <syscall_exit>

c002cf88 <syscall_filesize>:

int syscall_filesize(int fd) {
c002cf88:	56                   	push   %esi
c002cf89:	53                   	push   %ebx
c002cf8a:	83 ec 10             	sub    $0x10,%esp
c002cf8d:	e8 b1 31 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002cf92:	81 c3 1a 0d 01 00    	add    $0x10d1a,%ebx
    // printf("call sys_filesize\n");
    lock_acquire(&filesystem_lock);
c002cf98:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cf9e:	50                   	push   %eax
c002cf9f:	e8 b8 62 ff ff       	call   c002325c <lock_acquire>
    struct file_descriptor * fileDescriptor = get_fd_ptr(thread_current(), fd);
c002cfa4:	e8 20 40 ff ff       	call   c0020fc9 <thread_current>
c002cfa9:	83 c4 08             	add    $0x8,%esp
c002cfac:	ff 74 24 18          	pushl  0x18(%esp)
c002cfb0:	50                   	push   %eax
c002cfb1:	e8 cb fc ff ff       	call   c002cc81 <get_fd_ptr>
    if (fileDescriptor == NULL) {
c002cfb6:	83 c4 10             	add    $0x10,%esp
c002cfb9:	85 c0                	test   %eax,%eax
c002cfbb:	74 23                	je     c002cfe0 <syscall_filesize+0x58>
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file * fp = fileDescriptor->opened_file;
    int ans = file_length(fp);
c002cfbd:	83 ec 0c             	sub    $0xc,%esp
c002cfc0:	ff 70 08             	pushl  0x8(%eax)
c002cfc3:	e8 c8 0f 00 00       	call   c002df90 <file_length>
c002cfc8:	89 c6                	mov    %eax,%esi
    lock_release(&filesystem_lock);
c002cfca:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cfd0:	89 04 24             	mov    %eax,(%esp)
c002cfd3:	e8 85 64 ff ff       	call   c002345d <lock_release>
    return ans;
}
c002cfd8:	89 f0                	mov    %esi,%eax
c002cfda:	83 c4 14             	add    $0x14,%esp
c002cfdd:	5b                   	pop    %ebx
c002cfde:	5e                   	pop    %esi
c002cfdf:	c3                   	ret    
        lock_release(&filesystem_lock);
c002cfe0:	83 ec 0c             	sub    $0xc,%esp
c002cfe3:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002cfe9:	50                   	push   %eax
c002cfea:	e8 6e 64 ff ff       	call   c002345d <lock_release>
        syscall_exit(-1);
c002cfef:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cff6:	e8 f3 f8 ff ff       	call   c002c8ee <syscall_exit>

c002cffb <syscall_exec>:

pid_t syscall_exec (const char *file) {
c002cffb:	56                   	push   %esi
c002cffc:	53                   	push   %ebx
c002cffd:	83 ec 10             	sub    $0x10,%esp
c002d000:	e8 3e 31 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d005:	81 c3 a7 0c 01 00    	add    $0x10ca7,%ebx
c002d00b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    check_file_addr(file);
c002d00f:	56                   	push   %esi
c002d010:	e8 92 fa ff ff       	call   c002caa7 <check_file_addr>
    /*
     * Thus, the parent process cannot return from the exec until it knows whether the child
     * process successfully loaded its executable. You must use appropriate
     * synchronization to ensure this.
     */
    int tid = process_execute(file);
c002d015:	89 34 24             	mov    %esi,(%esp)
c002d018:	e8 d8 e1 ff ff       	call   c002b1f5 <process_execute>
    // printf("exec %s \n", file);
    return tid;
}
c002d01d:	83 c4 14             	add    $0x14,%esp
c002d020:	5b                   	pop    %ebx
c002d021:	5e                   	pop    %esi
c002d022:	c3                   	ret    

c002d023 <syscall_wait>:

int syscall_wait (pid_t pid) {
c002d023:	53                   	push   %ebx
c002d024:	83 ec 14             	sub    $0x14,%esp
c002d027:	e8 17 31 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d02c:	81 c3 80 0c 01 00    	add    $0x10c80,%ebx
    return process_wait(pid);
c002d032:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d036:	e8 25 e3 ff ff       	call   c002b360 <process_wait>
}
c002d03b:	83 c4 18             	add    $0x18,%esp
c002d03e:	5b                   	pop    %ebx
c002d03f:	c3                   	ret    

c002d040 <syscall_seek>:

void syscall_seek (int fd, unsigned position) {
c002d040:	53                   	push   %ebx
c002d041:	83 ec 14             	sub    $0x14,%esp
c002d044:	e8 fa 30 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d049:	81 c3 63 0c 01 00    	add    $0x10c63,%ebx
    lock_acquire(&filesystem_lock);
c002d04f:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d055:	50                   	push   %eax
c002d056:	e8 01 62 ff ff       	call   c002325c <lock_acquire>
    struct file_descriptor * fileDescriptor = get_fd_ptr(thread_current(), fd);
c002d05b:	e8 69 3f ff ff       	call   c0020fc9 <thread_current>
c002d060:	83 c4 08             	add    $0x8,%esp
c002d063:	ff 74 24 18          	pushl  0x18(%esp)
c002d067:	50                   	push   %eax
c002d068:	e8 14 fc ff ff       	call   c002cc81 <get_fd_ptr>
    if (fileDescriptor == NULL) {
c002d06d:	83 c4 10             	add    $0x10,%esp
c002d070:	85 c0                	test   %eax,%eax
c002d072:	74 22                	je     c002d096 <syscall_seek+0x56>
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file * fp = fileDescriptor->opened_file;
    file_seek(fp, position);
c002d074:	83 ec 08             	sub    $0x8,%esp
c002d077:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d07b:	ff 70 08             	pushl  0x8(%eax)
c002d07e:	e8 5c 0f 00 00       	call   c002dfdf <file_seek>
    lock_release(&filesystem_lock);
c002d083:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d089:	89 04 24             	mov    %eax,(%esp)
c002d08c:	e8 cc 63 ff ff       	call   c002345d <lock_release>
}
c002d091:	83 c4 18             	add    $0x18,%esp
c002d094:	5b                   	pop    %ebx
c002d095:	c3                   	ret    
        lock_release(&filesystem_lock);
c002d096:	83 ec 0c             	sub    $0xc,%esp
c002d099:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d09f:	50                   	push   %eax
c002d0a0:	e8 b8 63 ff ff       	call   c002345d <lock_release>
        syscall_exit(-1);
c002d0a5:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002d0ac:	e8 3d f8 ff ff       	call   c002c8ee <syscall_exit>

c002d0b1 <syscall_tell>:

int syscall_tell (int fd) {
c002d0b1:	56                   	push   %esi
c002d0b2:	53                   	push   %ebx
c002d0b3:	83 ec 10             	sub    $0x10,%esp
c002d0b6:	e8 88 30 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d0bb:	81 c3 f1 0b 01 00    	add    $0x10bf1,%ebx
    lock_acquire(&filesystem_lock);
c002d0c1:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d0c7:	50                   	push   %eax
c002d0c8:	e8 8f 61 ff ff       	call   c002325c <lock_acquire>
    struct file_descriptor * fileDescriptor = get_fd_ptr(thread_current(), fd);
c002d0cd:	e8 f7 3e ff ff       	call   c0020fc9 <thread_current>
c002d0d2:	83 c4 08             	add    $0x8,%esp
c002d0d5:	ff 74 24 18          	pushl  0x18(%esp)
c002d0d9:	50                   	push   %eax
c002d0da:	e8 a2 fb ff ff       	call   c002cc81 <get_fd_ptr>
    if (fileDescriptor == NULL) {
c002d0df:	83 c4 10             	add    $0x10,%esp
c002d0e2:	85 c0                	test   %eax,%eax
c002d0e4:	74 23                	je     c002d109 <syscall_tell+0x58>
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file * fp = fileDescriptor->opened_file;
    int pos = file_tell(fp);
c002d0e6:	83 ec 0c             	sub    $0xc,%esp
c002d0e9:	ff 70 08             	pushl  0x8(%eax)
c002d0ec:	e8 67 0f 00 00       	call   c002e058 <file_tell>
c002d0f1:	89 c6                	mov    %eax,%esi
    lock_release(&filesystem_lock);
c002d0f3:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d0f9:	89 04 24             	mov    %eax,(%esp)
c002d0fc:	e8 5c 63 ff ff       	call   c002345d <lock_release>
    return pos;
}
c002d101:	89 f0                	mov    %esi,%eax
c002d103:	83 c4 14             	add    $0x14,%esp
c002d106:	5b                   	pop    %ebx
c002d107:	5e                   	pop    %esi
c002d108:	c3                   	ret    
        lock_release(&filesystem_lock);
c002d109:	83 ec 0c             	sub    $0xc,%esp
c002d10c:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d112:	50                   	push   %eax
c002d113:	e8 45 63 ff ff       	call   c002345d <lock_release>
        syscall_exit(-1);
c002d118:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002d11f:	e8 ca f7 ff ff       	call   c002c8ee <syscall_exit>

c002d124 <get_mmap_info>:


struct mmap_info * get_mmap_info(int mapid) {
c002d124:	55                   	push   %ebp
c002d125:	57                   	push   %edi
c002d126:	56                   	push   %esi
c002d127:	53                   	push   %ebx
c002d128:	83 ec 0c             	sub    $0xc,%esp
c002d12b:	e8 13 30 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d130:	81 c3 7c 0b 01 00    	add    $0x10b7c,%ebx
c002d136:	8b 6c 24 20          	mov    0x20(%esp),%ebp
#ifdef VM
    struct thread * cur = thread_current();
c002d13a:	e8 8a 3e ff ff       	call   c0020fc9 <thread_current>
    if (!list_empty(&cur->mmap_list)) {
c002d13f:	8d b8 1c 01 00 00    	lea    0x11c(%eax),%edi
c002d145:	83 ec 0c             	sub    $0xc,%esp
c002d148:	57                   	push   %edi
c002d149:	e8 50 c7 ff ff       	call   c002989e <list_empty>
c002d14e:	83 c4 10             	add    $0x10,%esp
                return info;
            }
        }
    }
#endif
    return NULL;
c002d151:	be 00 00 00 00       	mov    $0x0,%esi
    if (!list_empty(&cur->mmap_list)) {
c002d156:	84 c0                	test   %al,%al
c002d158:	75 38                	jne    c002d192 <get_mmap_info+0x6e>
        for (e = list_begin(&cur->mmap_list); e != list_end(&cur->mmap_list);
c002d15a:	83 ec 0c             	sub    $0xc,%esp
c002d15d:	57                   	push   %edi
c002d15e:	e8 ef c0 ff ff       	call   c0029252 <list_begin>
c002d163:	89 c6                	mov    %eax,%esi
c002d165:	83 c4 10             	add    $0x10,%esp
c002d168:	83 ec 0c             	sub    $0xc,%esp
c002d16b:	57                   	push   %edi
c002d16c:	e8 83 c1 ff ff       	call   c00292f4 <list_end>
c002d171:	83 c4 10             	add    $0x10,%esp
c002d174:	39 f0                	cmp    %esi,%eax
c002d176:	74 15                	je     c002d18d <get_mmap_info+0x69>
            if (info->id == mapid) {
c002d178:	39 6e 08             	cmp    %ebp,0x8(%esi)
c002d17b:	74 15                	je     c002d192 <get_mmap_info+0x6e>
        e = list_next(e)) {
c002d17d:	83 ec 0c             	sub    $0xc,%esp
c002d180:	56                   	push   %esi
c002d181:	e8 11 c1 ff ff       	call   c0029297 <list_next>
c002d186:	89 c6                	mov    %eax,%esi
c002d188:	83 c4 10             	add    $0x10,%esp
c002d18b:	eb db                	jmp    c002d168 <get_mmap_info+0x44>
    return NULL;
c002d18d:	be 00 00 00 00       	mov    $0x0,%esi
}
c002d192:	89 f0                	mov    %esi,%eax
c002d194:	83 c4 0c             	add    $0xc,%esp
c002d197:	5b                   	pop    %ebx
c002d198:	5e                   	pop    %esi
c002d199:	5f                   	pop    %edi
c002d19a:	5d                   	pop    %ebp
c002d19b:	c3                   	ret    

c002d19c <remove_mapid>:
        remove_mapid(i);
    }
    #endif
}

static void remove_mapid(int mapping) {
c002d19c:	55                   	push   %ebp
c002d19d:	57                   	push   %edi
c002d19e:	56                   	push   %esi
c002d19f:	53                   	push   %ebx
c002d1a0:	83 ec 1c             	sub    $0x1c,%esp
c002d1a3:	e8 9b 2f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d1a8:	81 c3 04 0b 01 00    	add    $0x10b04,%ebx
c002d1ae:	89 c6                	mov    %eax,%esi
#ifdef VM
    struct thread *cur = thread_current();
c002d1b0:	e8 14 3e ff ff       	call   c0020fc9 <thread_current>
c002d1b5:	89 c5                	mov    %eax,%ebp

    struct mmap_info * info = get_mmap_info(mapping);
c002d1b7:	83 ec 0c             	sub    $0xc,%esp
c002d1ba:	56                   	push   %esi
c002d1bb:	e8 64 ff ff ff       	call   c002d124 <get_mmap_info>
    struct list_elem * e,  * next;
    
    if (info == NULL) {
c002d1c0:	83 c4 10             	add    $0x10,%esp
c002d1c3:	85 c0                	test   %eax,%eax
c002d1c5:	0f 84 a0 00 00 00    	je     c002d26b <remove_mapid+0xcf>
c002d1cb:	89 c6                	mov    %eax,%esi
        //printf("really??");
        return;
    }

    size_t off, file_size = info->size;
c002d1cd:	8b 40 10             	mov    0x10(%eax),%eax
c002d1d0:	89 44 24 0c          	mov    %eax,0xc(%esp)
    for (off = 0; off < file_size; off += PGSIZE) {
c002d1d4:	85 c0                	test   %eax,%eax
c002d1d6:	74 5e                	je     c002d236 <remove_mapid+0x9a>
c002d1d8:	b8 00 00 00 00       	mov    $0x0,%eax
        void *addr = info->addr + off;
c002d1dd:	89 c1                	mov    %eax,%ecx
c002d1df:	03 4e 14             	add    0x14(%esi),%ecx
        size_t bytes = (off + PGSIZE < file_size) ? PGSIZE : file_size - off;
c002d1e2:	8d b8 00 10 00 00    	lea    0x1000(%eax),%edi
c002d1e8:	3b 7c 24 0c          	cmp    0xc(%esp),%edi
c002d1ec:	73 25                	jae    c002d213 <remove_mapid+0x77>
        //printf("hello 1");
        spt_unmap(cur->spt, cur->pagedir, addr, info->file, off, bytes);
c002d1ee:	83 ec 08             	sub    $0x8,%esp
c002d1f1:	68 00 10 00 00       	push   $0x1000
c002d1f6:	50                   	push   %eax
c002d1f7:	ff 76 0c             	pushl  0xc(%esi)
c002d1fa:	51                   	push   %ecx
c002d1fb:	ff b5 10 01 00 00    	pushl  0x110(%ebp)
c002d201:	ff b5 18 01 00 00    	pushl  0x118(%ebp)
c002d207:	e8 07 2c 00 00       	call   c002fe13 <spt_unmap>
    for (off = 0; off < file_size; off += PGSIZE) {
c002d20c:	89 f8                	mov    %edi,%eax
c002d20e:	83 c4 20             	add    $0x20,%esp
c002d211:	eb ca                	jmp    c002d1dd <remove_mapid+0x41>
        spt_unmap(cur->spt, cur->pagedir, addr, info->file, off, bytes);
c002d213:	83 ec 08             	sub    $0x8,%esp
        size_t bytes = (off + PGSIZE < file_size) ? PGSIZE : file_size - off;
c002d216:	8b 54 24 14          	mov    0x14(%esp),%edx
c002d21a:	29 c2                	sub    %eax,%edx
        spt_unmap(cur->spt, cur->pagedir, addr, info->file, off, bytes);
c002d21c:	52                   	push   %edx
c002d21d:	50                   	push   %eax
c002d21e:	ff 76 0c             	pushl  0xc(%esi)
c002d221:	51                   	push   %ecx
c002d222:	ff b5 10 01 00 00    	pushl  0x110(%ebp)
c002d228:	ff b5 18 01 00 00    	pushl  0x118(%ebp)
c002d22e:	e8 e0 2b 00 00       	call   c002fe13 <spt_unmap>
c002d233:	83 c4 20             	add    $0x20,%esp
    }
    list_remove(&info->elem);
c002d236:	83 ec 0c             	sub    $0xc,%esp
c002d239:	56                   	push   %esi
c002d23a:	e8 bd c5 ff ff       	call   c00297fc <list_remove>
    lock_acquire (&filesystem_lock);
c002d23f:	8d bb b4 1c 00 00    	lea    0x1cb4(%ebx),%edi
c002d245:	89 3c 24             	mov    %edi,(%esp)
c002d248:	e8 0f 60 ff ff       	call   c002325c <lock_acquire>
    file_close(info->file);
c002d24d:	83 c4 04             	add    $0x4,%esp
c002d250:	ff 76 0c             	pushl  0xc(%esi)
c002d253:	e8 fc 0c 00 00       	call   c002df54 <file_close>
    lock_release(&filesystem_lock);
c002d258:	89 3c 24             	mov    %edi,(%esp)
c002d25b:	e8 fd 61 ff ff       	call   c002345d <lock_release>
    free(info);
c002d260:	89 34 24             	mov    %esi,(%esp)
c002d263:	e8 94 6d ff ff       	call   c0023ffc <free>
c002d268:	83 c4 10             	add    $0x10,%esp
#endif 
}
c002d26b:	83 c4 1c             	add    $0x1c,%esp
c002d26e:	5b                   	pop    %ebx
c002d26f:	5e                   	pop    %esi
c002d270:	5f                   	pop    %edi
c002d271:	5d                   	pop    %ebp
c002d272:	c3                   	ret    

c002d273 <mmap_clear>:
void mmap_clear() {
c002d273:	56                   	push   %esi
c002d274:	53                   	push   %ebx
c002d275:	83 ec 04             	sub    $0x4,%esp
c002d278:	e8 c6 2e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d27d:	81 c3 2f 0a 01 00    	add    $0x10a2f,%ebx
    int r = thread_current()->mapid;
c002d283:	e8 41 3d ff ff       	call   c0020fc9 <thread_current>
c002d288:	8b b0 2c 01 00 00    	mov    0x12c(%eax),%esi
    for (int i = 0; i < r; i++) {
c002d28e:	85 f6                	test   %esi,%esi
c002d290:	7e 13                	jle    c002d2a5 <mmap_clear+0x32>
c002d292:	bb 00 00 00 00       	mov    $0x0,%ebx
        remove_mapid(i);
c002d297:	89 d8                	mov    %ebx,%eax
c002d299:	e8 fe fe ff ff       	call   c002d19c <remove_mapid>
    for (int i = 0; i < r; i++) {
c002d29e:	83 c3 01             	add    $0x1,%ebx
c002d2a1:	39 de                	cmp    %ebx,%esi
c002d2a3:	75 f2                	jne    c002d297 <mmap_clear+0x24>
}
c002d2a5:	83 c4 04             	add    $0x4,%esp
c002d2a8:	5b                   	pop    %ebx
c002d2a9:	5e                   	pop    %esi
c002d2aa:	c3                   	ret    

c002d2ab <syscall_munmap>:


void syscall_munmap (mapid_t mapping) {
c002d2ab:	83 ec 0c             	sub    $0xc,%esp
#ifdef VM
    //printf("call syscall_munmap");
    remove_mapid(mapping);
c002d2ae:	8b 44 24 10          	mov    0x10(%esp),%eax
c002d2b2:	e8 e5 fe ff ff       	call   c002d19c <remove_mapid>
#endif
}
c002d2b7:	83 c4 0c             	add    $0xc,%esp
c002d2ba:	c3                   	ret    

c002d2bb <syscall_mmap>:


mapid_t syscall_mmap (int fd, void *addr) {
c002d2bb:	55                   	push   %ebp
c002d2bc:	57                   	push   %edi
c002d2bd:	56                   	push   %esi
c002d2be:	53                   	push   %ebx
c002d2bf:	83 ec 2c             	sub    $0x2c,%esp
c002d2c2:	e8 7c 2e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d2c7:	81 c3 e5 09 01 00    	add    $0x109e5,%ebx

#ifdef VM
    struct file_descriptor * fileDescriptor = get_fd_ptr(thread_current(), fd);
c002d2cd:	e8 f7 3c ff ff       	call   c0020fc9 <thread_current>
c002d2d2:	83 ec 08             	sub    $0x8,%esp
c002d2d5:	ff 74 24 48          	pushl  0x48(%esp)
c002d2d9:	50                   	push   %eax
c002d2da:	e8 a2 f9 ff ff       	call   c002cc81 <get_fd_ptr>
    struct file *f = NULL;
    if(fileDescriptor && fileDescriptor->opened_file) {
c002d2df:	83 c4 10             	add    $0x10,%esp
        f = file_reopen (fileDescriptor->opened_file);
    }
    void * original_addr = addr;
    if (fileDescriptor == NULL || !is_valid_user_vaddr(addr)) return -1;
c002d2e2:	be ff ff ff ff       	mov    $0xffffffff,%esi
    if(fileDescriptor && fileDescriptor->opened_file) {
c002d2e7:	85 c0                	test   %eax,%eax
c002d2e9:	0f 84 7f 01 00 00    	je     c002d46e <syscall_mmap+0x1b3>
c002d2ef:	89 c7                	mov    %eax,%edi
c002d2f1:	8b 40 08             	mov    0x8(%eax),%eax
c002d2f4:	89 44 24 14          	mov    %eax,0x14(%esp)
c002d2f8:	85 c0                	test   %eax,%eax
c002d2fa:	74 10                	je     c002d30c <syscall_mmap+0x51>
        f = file_reopen (fileDescriptor->opened_file);
c002d2fc:	83 ec 0c             	sub    $0xc,%esp
c002d2ff:	50                   	push   %eax
c002d300:	e8 b7 0a 00 00       	call   c002ddbc <file_reopen>
c002d305:	89 44 24 24          	mov    %eax,0x24(%esp)
c002d309:	83 c4 10             	add    $0x10,%esp
    return is_user_vaddr(vaddr) && vaddr > ((void *) 0x08048000);
c002d30c:	8b 74 24 44          	mov    0x44(%esp),%esi
c002d310:	89 f0                	mov    %esi,%eax
c002d312:	2d 01 80 04 08       	sub    $0x8048001,%eax
    if (fileDescriptor == NULL || !is_valid_user_vaddr(addr)) return -1;
c002d317:	3d fe 7f fb b7       	cmp    $0xb7fb7ffe,%eax
c002d31c:	0f 87 78 01 00 00    	ja     c002d49a <syscall_mmap+0x1df>
    int size = file_length(fileDescriptor->opened_file);
c002d322:	83 ec 0c             	sub    $0xc,%esp
c002d325:	ff 77 08             	pushl  0x8(%edi)
c002d328:	e8 63 0c 00 00       	call   c002df90 <file_length>
c002d32d:	89 c7                	mov    %eax,%edi
c002d32f:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    if ((uint32_t)addr % PGSIZE != 0 || size == 0) return -1;
c002d333:	83 c4 10             	add    $0x10,%esp
c002d336:	f7 44 24 44 ff 0f 00 	testl  $0xfff,0x44(%esp)
c002d33d:	00 
c002d33e:	0f 85 48 01 00 00    	jne    c002d48c <syscall_mmap+0x1d1>
c002d344:	85 c0                	test   %eax,%eax
c002d346:	0f 84 40 01 00 00    	je     c002d48c <syscall_mmap+0x1d1>

    uint32_t read_bytes = size;
    uint32_t zero_bytes = 0;
    off_t ofs = 0;
    struct thread * cur = thread_current();
c002d34c:	e8 78 3c ff ff       	call   c0020fc9 <thread_current>
c002d351:	89 c5                	mov    %eax,%ebp
    // make sure all the page address is NON-EXIESENT.
    for (ofs = 0; ofs < size; ofs += PGSIZE) {
c002d353:	85 ff                	test   %edi,%edi
c002d355:	7e 37                	jle    c002d38e <syscall_mmap+0xd3>
c002d357:	8d 47 ff             	lea    -0x1(%edi),%eax
c002d35a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002d35f:	8b 54 24 44          	mov    0x44(%esp),%edx
c002d363:	8d bc 02 00 10 00 00 	lea    0x1000(%edx,%eax,1),%edi
        void *addr_ = addr + ofs;
        if (spt_has_item(cur->spt, addr_)) return -1;
c002d36a:	83 ec 08             	sub    $0x8,%esp
c002d36d:	56                   	push   %esi
c002d36e:	ff b5 18 01 00 00    	pushl  0x118(%ebp)
c002d374:	e8 aa 28 00 00       	call   c002fc23 <spt_has_item>
c002d379:	83 c4 10             	add    $0x10,%esp
c002d37c:	84 c0                	test   %al,%al
c002d37e:	0f 85 0f 01 00 00    	jne    c002d493 <syscall_mmap+0x1d8>
c002d384:	81 c6 00 10 00 00    	add    $0x1000,%esi
    for (ofs = 0; ofs < size; ofs += PGSIZE) {
c002d38a:	39 f7                	cmp    %esi,%edi
c002d38c:	75 dc                	jne    c002d36a <syscall_mmap+0xaf>
    uint32_t read_bytes = size;
c002d38e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    }
    lock_acquire(&filesystem_lock);
c002d392:	83 ec 0c             	sub    $0xc,%esp
c002d395:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d39b:	50                   	push   %eax
c002d39c:	e8 bb 5e ff ff       	call   c002325c <lock_acquire>
c002d3a1:	83 c4 10             	add    $0x10,%esp
c002d3a4:	8b 44 24 44          	mov    0x44(%esp),%eax
c002d3a8:	89 44 24 10          	mov    %eax,0x10(%esp)
    ofs = 0;
c002d3ac:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d3b3:	00 
    uint32_t zero_bytes = 0;
c002d3b4:	b8 00 00 00 00       	mov    $0x0,%eax
    while (read_bytes > 0) {
        uint32_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002d3b9:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c002d3bd:	89 c5                	mov    %eax,%ebp
c002d3bf:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
c002d3c5:	bf 00 10 00 00       	mov    $0x1000,%edi
c002d3ca:	0f 46 fe             	cmovbe %esi,%edi
        uint32_t page_zero_bytes = PGSIZE - page_read_bytes;
        spt_install_file(cur->spt, addr, f, ofs, read_bytes, zero_bytes, true);
c002d3cd:	83 ec 04             	sub    $0x4,%esp
c002d3d0:	6a 01                	push   $0x1
c002d3d2:	55                   	push   %ebp
c002d3d3:	56                   	push   %esi
c002d3d4:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d3d8:	ff 74 24 28          	pushl  0x28(%esp)
c002d3dc:	ff 74 24 28          	pushl  0x28(%esp)
c002d3e0:	8b 4c 24 34          	mov    0x34(%esp),%ecx
c002d3e4:	ff b1 18 01 00 00    	pushl  0x118(%ecx)
c002d3ea:	e8 85 2b 00 00       	call   c002ff74 <spt_install_file>
        read_bytes -= page_read_bytes;
        zero_bytes -= page_zero_bytes;
c002d3ef:	8d ac 2f 00 f0 ff ff 	lea    -0x1000(%edi,%ebp,1),%ebp
        ofs += page_read_bytes;
c002d3f6:	01 7c 24 2c          	add    %edi,0x2c(%esp)
        addr += PGSIZE;
c002d3fa:	81 44 24 30 00 10 00 	addl   $0x1000,0x30(%esp)
c002d401:	00 
    while (read_bytes > 0) {
c002d402:	83 c4 20             	add    $0x20,%esp
c002d405:	29 fe                	sub    %edi,%esi
c002d407:	75 b6                	jne    c002d3bf <syscall_mmap+0x104>
c002d409:	8b 6c 24 18          	mov    0x18(%esp),%ebp
    }
    mapid_t mapid;
    if (!list_empty(&cur->mmap_list)) {
c002d40d:	8d bd 1c 01 00 00    	lea    0x11c(%ebp),%edi
c002d413:	83 ec 0c             	sub    $0xc,%esp
c002d416:	57                   	push   %edi
c002d417:	e8 82 c4 ff ff       	call   c002989e <list_empty>
c002d41c:	83 c4 10             	add    $0x10,%esp
        mapid = list_entry(list_back(&cur->mmap_list), struct mmap_info, elem)->id + 1;
    } else {
        mapid = 1;
c002d41f:	be 01 00 00 00       	mov    $0x1,%esi
    if (!list_empty(&cur->mmap_list)) {
c002d424:	84 c0                	test   %al,%al
c002d426:	74 50                	je     c002d478 <syscall_mmap+0x1bd>
    }
    struct mmap_info * info = malloc(sizeof(struct mmap_info));
c002d428:	83 ec 0c             	sub    $0xc,%esp
c002d42b:	6a 18                	push   $0x18
c002d42d:	e8 1c 6a ff ff       	call   c0023e4e <malloc>
    info->file = f;
c002d432:	8b 54 24 24          	mov    0x24(%esp),%edx
c002d436:	89 50 0c             	mov    %edx,0xc(%eax)
    info->addr = original_addr;
c002d439:	8b 54 24 54          	mov    0x54(%esp),%edx
c002d43d:	89 50 14             	mov    %edx,0x14(%eax)
    info->size = size;
c002d440:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c002d444:	89 50 10             	mov    %edx,0x10(%eax)
    info->id = mapid;
c002d447:	89 70 08             	mov    %esi,0x8(%eax)
    cur->mapid = mapid + 1;
c002d44a:	8d 56 01             	lea    0x1(%esi),%edx
c002d44d:	89 95 2c 01 00 00    	mov    %edx,0x12c(%ebp)
    list_push_back(&cur->mmap_list, &info->elem);
c002d453:	83 c4 08             	add    $0x8,%esp
c002d456:	50                   	push   %eax
c002d457:	57                   	push   %edi
c002d458:	e8 82 c3 ff ff       	call   c00297df <list_push_back>

    lock_release(&filesystem_lock);
c002d45d:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c002d463:	89 04 24             	mov    %eax,(%esp)
c002d466:	e8 f2 5f ff ff       	call   c002345d <lock_release>

    return mapid;
c002d46b:	83 c4 10             	add    $0x10,%esp
#else
    return 0;
#endif
c002d46e:	89 f0                	mov    %esi,%eax
c002d470:	83 c4 2c             	add    $0x2c,%esp
c002d473:	5b                   	pop    %ebx
c002d474:	5e                   	pop    %esi
c002d475:	5f                   	pop    %edi
c002d476:	5d                   	pop    %ebp
c002d477:	c3                   	ret    
        mapid = list_entry(list_back(&cur->mmap_list), struct mmap_info, elem)->id + 1;
c002d478:	83 ec 0c             	sub    $0xc,%esp
c002d47b:	57                   	push   %edi
c002d47c:	e8 b2 c4 ff ff       	call   c0029933 <list_back>
c002d481:	8b 70 08             	mov    0x8(%eax),%esi
c002d484:	83 c6 01             	add    $0x1,%esi
c002d487:	83 c4 10             	add    $0x10,%esp
c002d48a:	eb 9c                	jmp    c002d428 <syscall_mmap+0x16d>
    if ((uint32_t)addr % PGSIZE != 0 || size == 0) return -1;
c002d48c:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002d491:	eb db                	jmp    c002d46e <syscall_mmap+0x1b3>
        if (spt_has_item(cur->spt, addr_)) return -1;
c002d493:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002d498:	eb d4                	jmp    c002d46e <syscall_mmap+0x1b3>
    if (fileDescriptor == NULL || !is_valid_user_vaddr(addr)) return -1;
c002d49a:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002d49f:	eb cd                	jmp    c002d46e <syscall_mmap+0x1b3>

c002d4a1 <syscall_handler>:
syscall_handler(struct intr_frame *f UNUSED) {
c002d4a1:	56                   	push   %esi
c002d4a2:	53                   	push   %ebx
c002d4a3:	83 ec 14             	sub    $0x14,%esp
c002d4a6:	e8 98 2c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d4ab:	81 c3 01 08 01 00    	add    $0x10801,%ebx
c002d4b1:	8b 74 24 20          	mov    0x20(%esp),%esi
    thread_current()->stack = f->esp;
c002d4b5:	e8 0f 3b ff ff       	call   c0020fc9 <thread_current>
c002d4ba:	8b 56 48             	mov    0x48(%esi),%edx
c002d4bd:	89 50 18             	mov    %edx,0x18(%eax)
    check_stack(f->esp);
c002d4c0:	83 ec 0c             	sub    $0xc,%esp
c002d4c3:	52                   	push   %edx
c002d4c4:	e8 7f f5 ff ff       	call   c002ca48 <check_stack>
    int type = get_syscall_type(f);
c002d4c9:	89 34 24             	mov    %esi,(%esp)
c002d4cc:	e8 58 f5 ff ff       	call   c002ca29 <get_syscall_type>
    switch (type) {
c002d4d1:	83 c4 10             	add    $0x10,%esp
c002d4d4:	83 f8 0e             	cmp    $0xe,%eax
c002d4d7:	0f 87 0f 02 00 00    	ja     c002d6ec <.L161+0x1b>
c002d4dd:	89 d9                	mov    %ebx,%ecx
c002d4df:	03 8c 83 e8 33 ff ff 	add    -0xcc18(%ebx,%eax,4),%ecx
c002d4e6:	ff e1                	jmp    *%ecx

c002d4e8 <.L176>:
    shutdown_power_off();
c002d4e8:	e8 cb 97 ff ff       	call   c0026cb8 <shutdown_power_off>

c002d4ed <.L175>:
            get_syscall_arg(f, syscall_args, 1);
c002d4ed:	89 e2                	mov    %esp,%edx
c002d4ef:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d4f4:	89 f0                	mov    %esi,%eax
c002d4f6:	e8 eb f4 ff ff       	call   c002c9e6 <get_syscall_arg>
            syscall_exit(syscall_args[0]);
c002d4fb:	83 ec 0c             	sub    $0xc,%esp
c002d4fe:	ff 74 24 0c          	pushl  0xc(%esp)
c002d502:	e8 e7 f3 ff ff       	call   c002c8ee <syscall_exit>

c002d507 <.L174>:
            get_syscall_arg(f, syscall_args, 1);
c002d507:	89 e2                	mov    %esp,%edx
c002d509:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d50e:	89 f0                	mov    %esi,%eax
c002d510:	e8 d1 f4 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_exec((char *) syscall_args[0]);
c002d515:	83 ec 0c             	sub    $0xc,%esp
c002d518:	ff 74 24 0c          	pushl  0xc(%esp)
c002d51c:	e8 da fa ff ff       	call   c002cffb <syscall_exec>
c002d521:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d524:	83 c4 10             	add    $0x10,%esp
}
c002d527:	83 c4 14             	add    $0x14,%esp
c002d52a:	5b                   	pop    %ebx
c002d52b:	5e                   	pop    %esi
c002d52c:	c3                   	ret    

c002d52d <.L173>:
            get_syscall_arg(f, syscall_args, 1);
c002d52d:	89 e2                	mov    %esp,%edx
c002d52f:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d534:	89 f0                	mov    %esi,%eax
c002d536:	e8 ab f4 ff ff       	call   c002c9e6 <get_syscall_arg>
    return process_wait(pid);
c002d53b:	83 ec 0c             	sub    $0xc,%esp
c002d53e:	ff 74 24 0c          	pushl  0xc(%esp)
c002d542:	e8 19 de ff ff       	call   c002b360 <process_wait>
            f->eax = syscall_wait(syscall_args[0]);
c002d547:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d54a:	83 c4 10             	add    $0x10,%esp
c002d54d:	eb d8                	jmp    c002d527 <.L174+0x20>

c002d54f <.L172>:
            get_syscall_arg(f, syscall_args, 2);
c002d54f:	89 e2                	mov    %esp,%edx
c002d551:	b9 02 00 00 00       	mov    $0x2,%ecx
c002d556:	89 f0                	mov    %esi,%eax
c002d558:	e8 89 f4 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_create(file, size);
c002d55d:	83 ec 08             	sub    $0x8,%esp
c002d560:	ff 74 24 0c          	pushl  0xc(%esp)
c002d564:	ff 74 24 0c          	pushl  0xc(%esp)
c002d568:	e8 e1 f5 ff ff       	call   c002cb4e <syscall_create>
c002d56d:	0f b6 c0             	movzbl %al,%eax
c002d570:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d573:	83 c4 10             	add    $0x10,%esp
c002d576:	eb af                	jmp    c002d527 <.L174+0x20>

c002d578 <.L171>:
            get_syscall_arg(f, syscall_args, 1);
c002d578:	89 e2                	mov    %esp,%edx
c002d57a:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d57f:	89 f0                	mov    %esi,%eax
c002d581:	e8 60 f4 ff ff       	call   c002c9e6 <get_syscall_arg>
            syscall_remove(file);
c002d586:	83 ec 0c             	sub    $0xc,%esp
c002d589:	ff 74 24 0c          	pushl  0xc(%esp)
c002d58d:	e8 78 f5 ff ff       	call   c002cb0a <syscall_remove>
            break;
c002d592:	83 c4 10             	add    $0x10,%esp
c002d595:	eb 90                	jmp    c002d527 <.L174+0x20>

c002d597 <.L170>:
            get_syscall_arg(f, syscall_args, 1);
c002d597:	89 e2                	mov    %esp,%edx
c002d599:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d59e:	89 f0                	mov    %esi,%eax
c002d5a0:	e8 41 f4 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_open(file);
c002d5a5:	83 ec 0c             	sub    $0xc,%esp
c002d5a8:	ff 74 24 0c          	pushl  0xc(%esp)
c002d5ac:	e8 0e f6 ff ff       	call   c002cbbf <syscall_open>
c002d5b1:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d5b4:	83 c4 10             	add    $0x10,%esp
c002d5b7:	e9 6b ff ff ff       	jmp    c002d527 <.L174+0x20>

c002d5bc <.L169>:
            get_syscall_arg(f, syscall_args, 1);
c002d5bc:	89 e2                	mov    %esp,%edx
c002d5be:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d5c3:	89 f0                	mov    %esi,%eax
c002d5c5:	e8 1c f4 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_filesize(fd);
c002d5ca:	83 ec 0c             	sub    $0xc,%esp
c002d5cd:	ff 74 24 0c          	pushl  0xc(%esp)
c002d5d1:	e8 b2 f9 ff ff       	call   c002cf88 <syscall_filesize>
c002d5d6:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d5d9:	83 c4 10             	add    $0x10,%esp
c002d5dc:	e9 46 ff ff ff       	jmp    c002d527 <.L174+0x20>

c002d5e1 <.L168>:
            get_syscall_arg(f, syscall_args, 3);
c002d5e1:	89 e2                	mov    %esp,%edx
c002d5e3:	b9 03 00 00 00       	mov    $0x3,%ecx
c002d5e8:	89 f0                	mov    %esi,%eax
c002d5ea:	e8 f7 f3 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_read(fd, buffer, size);
c002d5ef:	83 ec 04             	sub    $0x4,%esp
c002d5f2:	ff 74 24 0c          	pushl  0xc(%esp)
c002d5f6:	ff 74 24 0c          	pushl  0xc(%esp)
c002d5fa:	ff 74 24 0c          	pushl  0xc(%esp)
c002d5fe:	e8 cf f7 ff ff       	call   c002cdd2 <syscall_read>
c002d603:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d606:	83 c4 10             	add    $0x10,%esp
c002d609:	e9 19 ff ff ff       	jmp    c002d527 <.L174+0x20>

c002d60e <.L167>:
            get_syscall_arg(f, syscall_args, 3);
c002d60e:	89 e2                	mov    %esp,%edx
c002d610:	b9 03 00 00 00       	mov    $0x3,%ecx
c002d615:	89 f0                	mov    %esi,%eax
c002d617:	e8 ca f3 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_write(fd, buffer, size);
c002d61c:	83 ec 04             	sub    $0x4,%esp
c002d61f:	ff 74 24 0c          	pushl  0xc(%esp)
c002d623:	ff 74 24 0c          	pushl  0xc(%esp)
c002d627:	ff 74 24 0c          	pushl  0xc(%esp)
c002d62b:	e8 b0 f6 ff ff       	call   c002cce0 <syscall_write>
c002d630:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d633:	83 c4 10             	add    $0x10,%esp
c002d636:	e9 ec fe ff ff       	jmp    c002d527 <.L174+0x20>

c002d63b <.L166>:
            get_syscall_arg(f, syscall_args, 2);
c002d63b:	89 e2                	mov    %esp,%edx
c002d63d:	b9 02 00 00 00       	mov    $0x2,%ecx
c002d642:	89 f0                	mov    %esi,%eax
c002d644:	e8 9d f3 ff ff       	call   c002c9e6 <get_syscall_arg>
            syscall_seek(fd, pos);
c002d649:	83 ec 08             	sub    $0x8,%esp
c002d64c:	ff 74 24 0c          	pushl  0xc(%esp)
c002d650:	ff 74 24 0c          	pushl  0xc(%esp)
c002d654:	e8 e7 f9 ff ff       	call   c002d040 <syscall_seek>
            break;
c002d659:	83 c4 10             	add    $0x10,%esp
c002d65c:	e9 c6 fe ff ff       	jmp    c002d527 <.L174+0x20>

c002d661 <.L165>:
            get_syscall_arg(f, syscall_args, 1);
c002d661:	89 e2                	mov    %esp,%edx
c002d663:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d668:	89 f0                	mov    %esi,%eax
c002d66a:	e8 77 f3 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_tell(fd);
c002d66f:	83 ec 0c             	sub    $0xc,%esp
c002d672:	ff 74 24 0c          	pushl  0xc(%esp)
c002d676:	e8 36 fa ff ff       	call   c002d0b1 <syscall_tell>
c002d67b:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d67e:	83 c4 10             	add    $0x10,%esp
c002d681:	e9 a1 fe ff ff       	jmp    c002d527 <.L174+0x20>

c002d686 <.L164>:
            get_syscall_arg(f, syscall_args, 1);
c002d686:	89 e2                	mov    %esp,%edx
c002d688:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d68d:	89 f0                	mov    %esi,%eax
c002d68f:	e8 52 f3 ff ff       	call   c002c9e6 <get_syscall_arg>
            syscall_close(fd);
c002d694:	83 ec 0c             	sub    $0xc,%esp
c002d697:	ff 74 24 0c          	pushl  0xc(%esp)
c002d69b:	e8 1f f8 ff ff       	call   c002cebf <syscall_close>
            break;
c002d6a0:	83 c4 10             	add    $0x10,%esp
c002d6a3:	e9 7f fe ff ff       	jmp    c002d527 <.L174+0x20>

c002d6a8 <.L163>:
            get_syscall_arg(f, syscall_args, 2);
c002d6a8:	89 e2                	mov    %esp,%edx
c002d6aa:	b9 02 00 00 00       	mov    $0x2,%ecx
c002d6af:	89 f0                	mov    %esi,%eax
c002d6b1:	e8 30 f3 ff ff       	call   c002c9e6 <get_syscall_arg>
            f->eax = syscall_mmap(fd, addr);
c002d6b6:	83 ec 08             	sub    $0x8,%esp
c002d6b9:	ff 74 24 0c          	pushl  0xc(%esp)
c002d6bd:	ff 74 24 0c          	pushl  0xc(%esp)
c002d6c1:	e8 f5 fb ff ff       	call   c002d2bb <syscall_mmap>
c002d6c6:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d6c9:	83 c4 10             	add    $0x10,%esp
c002d6cc:	e9 56 fe ff ff       	jmp    c002d527 <.L174+0x20>

c002d6d1 <.L161>:
            get_syscall_arg(f, syscall_args, 1);
c002d6d1:	89 e2                	mov    %esp,%edx
c002d6d3:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d6d8:	89 f0                	mov    %esi,%eax
c002d6da:	e8 07 f3 ff ff       	call   c002c9e6 <get_syscall_arg>
    remove_mapid(mapping);
c002d6df:	8b 04 24             	mov    (%esp),%eax
c002d6e2:	e8 b5 fa ff ff       	call   c002d19c <remove_mapid>
c002d6e7:	e9 3b fe ff ff       	jmp    c002d527 <.L174+0x20>
            printf("other system call...\n");
c002d6ec:	83 ec 0c             	sub    $0xc,%esp
c002d6ef:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002d6f5:	50                   	push   %eax
c002d6f6:	e8 08 da ff ff       	call   c002b103 <puts>
            syscall_exit(-1);
c002d6fb:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002d702:	e8 e7 f1 ff ff       	call   c002c8ee <syscall_exit>

c002d707 <gdt_init>:
static uint64_t make_gdtr_operand(uint16_t limit, void *base);

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void
gdt_init(void) {
c002d707:	53                   	push   %ebx
c002d708:	83 ec 18             	sub    $0x18,%esp
c002d70b:	e8 33 2a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d710:	81 c3 9c 05 01 00    	add    $0x1059c,%ebx
    uint64_t gdtr_operand;

    /* Initialize GDT. */
    gdt[SEL_NULL / sizeof *gdt] = 0;
c002d716:	c7 83 f4 1c 00 00 00 	movl   $0x0,0x1cf4(%ebx)
c002d71d:	00 00 00 
c002d720:	c7 83 f8 1c 00 00 00 	movl   $0x0,0x1cf8(%ebx)
c002d727:	00 00 00 
    gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc(0);
c002d72a:	c7 83 fc 1c 00 00 ff 	movl   $0xffff,0x1cfc(%ebx)
c002d731:	ff 00 00 
c002d734:	c7 83 00 1d 00 00 00 	movl   $0xcf9a00,0x1d00(%ebx)
c002d73b:	9a cf 00 
    gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc(0);
c002d73e:	c7 83 04 1d 00 00 ff 	movl   $0xffff,0x1d04(%ebx)
c002d745:	ff 00 00 
c002d748:	c7 83 08 1d 00 00 00 	movl   $0xcf9200,0x1d08(%ebx)
c002d74f:	92 cf 00 
    gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc(3);
c002d752:	c7 83 0c 1d 00 00 ff 	movl   $0xffff,0x1d0c(%ebx)
c002d759:	ff 00 00 
c002d75c:	c7 83 10 1d 00 00 00 	movl   $0xcffa00,0x1d10(%ebx)
c002d763:	fa cf 00 
    gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc(3);
c002d766:	c7 83 14 1d 00 00 ff 	movl   $0xffff,0x1d14(%ebx)
c002d76d:	ff 00 00 
c002d770:	c7 83 18 1d 00 00 00 	movl   $0xcff200,0x1d18(%ebx)
c002d777:	f2 cf 00 
    gdt[SEL_TSS / sizeof *gdt] = make_tss_desc(tss_get());
c002d77a:	e8 59 00 00 00       	call   c002d7d8 <tss_get>
    ASSERT (granularity == GRAN_BYTE || granularity == GRAN_PAGE);

    e0 = ((limit & 0xffff)             /* Limit 15:0. */
          | (base << 16));             /* Base 15:0. */

    e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002d77f:	89 c2                	mov    %eax,%edx
c002d781:	c1 ea 10             	shr    $0x10,%edx
c002d784:	0f b6 d2             	movzbl %dl,%edx
          | (dpl << 13)                /* Descriptor privilege. */
          | (1 << 15)                  /* Present. */
          | (limit & 0xf0000)          /* Limit 16:19. */
          | (1 << 22)                  /* 32-bit segment. */
          | (granularity << 23)        /* Byte/page granularity. */
          | (base & 0xff000000));      /* Base 31:24. */
c002d787:	89 c1                	mov    %eax,%ecx
c002d789:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
    e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002d78f:	09 ca                	or     %ecx,%edx
c002d791:	81 ca 00 89 40 00    	or     $0x408900,%edx
          | (base << 16));             /* Base 15:0. */
c002d797:	c1 e0 10             	shl    $0x10,%eax
    e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002d79a:	83 c8 67             	or     $0x67,%eax

    return e0 | ((uint64_t) e1 << 32);
c002d79d:	89 83 1c 1d 00 00    	mov    %eax,0x1d1c(%ebx)
c002d7a3:	89 93 20 1d 00 00    	mov    %edx,0x1d20(%ebx)

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand(uint16_t limit, void *base) {
    return limit | ((uint64_t) (uint32_t) base << 16);
c002d7a9:	8d 83 f4 1c 00 00    	lea    0x1cf4(%ebx),%eax
c002d7af:	ba 00 00 00 00       	mov    $0x0,%edx
c002d7b4:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002d7b8:	c1 e0 10             	shl    $0x10,%eax
c002d7bb:	83 c8 2f             	or     $0x2f,%eax
c002d7be:	89 44 24 08          	mov    %eax,0x8(%esp)
c002d7c2:	89 54 24 0c          	mov    %edx,0xc(%esp)
    asm volatile ("lgdt %0" : : "m" (gdtr_operand));
c002d7c6:	0f 01 54 24 08       	lgdtl  0x8(%esp)
    asm volatile ("ltr %w0" : : "q" (SEL_TSS));
c002d7cb:	b8 28 00 00 00       	mov    $0x28,%eax
c002d7d0:	0f 00 d8             	ltr    %ax
}
c002d7d3:	83 c4 18             	add    $0x18,%esp
c002d7d6:	5b                   	pop    %ebx
c002d7d7:	c3                   	ret    

c002d7d8 <tss_get>:
    tss_update();
}

/* Returns the kernel TSS. */
struct tss *
tss_get(void) {
c002d7d8:	53                   	push   %ebx
c002d7d9:	83 ec 08             	sub    $0x8,%esp
c002d7dc:	e8 62 29 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d7e1:	81 c3 cb 04 01 00    	add    $0x104cb,%ebx
    ASSERT (tss != NULL);
c002d7e7:	8b 83 24 1d 00 00    	mov    0x1d24(%ebx),%eax
c002d7ed:	85 c0                	test   %eax,%eax
c002d7ef:	74 05                	je     c002d7f6 <tss_get+0x1e>
    return tss;
}
c002d7f1:	83 c4 08             	add    $0x8,%esp
c002d7f4:	5b                   	pop    %ebx
c002d7f5:	c3                   	ret    
    ASSERT (tss != NULL);
c002d7f6:	83 ec 0c             	sub    $0xc,%esp
c002d7f9:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c002d7ff:	50                   	push   %eax
c002d800:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002d806:	50                   	push   %eax
c002d807:	8d 83 30 34 ff ff    	lea    -0xcbd0(%ebx),%eax
c002d80d:	50                   	push   %eax
c002d80e:	6a 5e                	push   $0x5e
c002d810:	8d 83 4c 59 ff ff    	lea    -0xa6b4(%ebx),%eax
c002d816:	50                   	push   %eax
c002d817:	e8 11 b9 ff ff       	call   c002912d <debug_panic>

c002d81c <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void
tss_update(void) {
c002d81c:	53                   	push   %ebx
c002d81d:	83 ec 08             	sub    $0x8,%esp
c002d820:	e8 1e 29 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d825:	81 c3 87 04 01 00    	add    $0x10487,%ebx
    ASSERT (tss != NULL);
c002d82b:	83 bb 24 1d 00 00 00 	cmpl   $0x0,0x1d24(%ebx)
c002d832:	74 18                	je     c002d84c <tss_update+0x30>
    tss->esp0 = (uint8_t *) thread_current() + PGSIZE;
c002d834:	e8 90 37 ff ff       	call   c0020fc9 <thread_current>
c002d839:	8b 93 24 1d 00 00    	mov    0x1d24(%ebx),%edx
c002d83f:	05 00 10 00 00       	add    $0x1000,%eax
c002d844:	89 42 04             	mov    %eax,0x4(%edx)
}
c002d847:	83 c4 08             	add    $0x8,%esp
c002d84a:	5b                   	pop    %ebx
c002d84b:	c3                   	ret    
    ASSERT (tss != NULL);
c002d84c:	83 ec 0c             	sub    $0xc,%esp
c002d84f:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c002d855:	50                   	push   %eax
c002d856:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002d85c:	50                   	push   %eax
c002d85d:	8d 83 24 34 ff ff    	lea    -0xcbdc(%ebx),%eax
c002d863:	50                   	push   %eax
c002d864:	6a 66                	push   $0x66
c002d866:	8d 83 4c 59 ff ff    	lea    -0xa6b4(%ebx),%eax
c002d86c:	50                   	push   %eax
c002d86d:	e8 bb b8 ff ff       	call   c002912d <debug_panic>

c002d872 <tss_init>:
tss_init(void) {
c002d872:	53                   	push   %ebx
c002d873:	83 ec 14             	sub    $0x14,%esp
c002d876:	e8 c8 28 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d87b:	81 c3 31 04 01 00    	add    $0x10431,%ebx
    tss = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c002d881:	6a 03                	push   $0x3
c002d883:	e8 b4 61 ff ff       	call   c0023a3c <palloc_get_page>
c002d888:	89 83 24 1d 00 00    	mov    %eax,0x1d24(%ebx)
    tss->ss0 = SEL_KDSEG;
c002d88e:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
    tss->bitmap = 0xdfff;
c002d894:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
    tss_update();
c002d89a:	e8 7d ff ff ff       	call   c002d81c <tss_update>
}
c002d89f:	83 c4 18             	add    $0x18,%esp
c002d8a2:	5b                   	pop    %ebx
c002d8a3:	c3                   	ret    

c002d8a4 <filesys_init>:
static void do_format(void);

/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void
filesys_init(bool format) {
c002d8a4:	56                   	push   %esi
c002d8a5:	53                   	push   %ebx
c002d8a6:	83 ec 10             	sub    $0x10,%esp
c002d8a9:	e8 95 28 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d8ae:	81 c3 fe 03 01 00    	add    $0x103fe,%ebx
c002d8b4:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    fs_device = block_get_role(BLOCK_FILESYS);
c002d8b8:	6a 01                	push   $0x1
c002d8ba:	e8 6e 78 ff ff       	call   c002512d <block_get_role>
c002d8bf:	c7 c2 d0 fc 03 c0    	mov    $0xc003fcd0,%edx
c002d8c5:	89 02                	mov    %eax,(%edx)
    if (fs_device == NULL)
c002d8c7:	83 c4 10             	add    $0x10,%esp
c002d8ca:	85 c0                	test   %eax,%eax
c002d8cc:	74 1b                	je     c002d8e9 <filesys_init+0x45>
        PANIC ("No file system device found, can't initialize file system.");

    inode_init();
c002d8ce:	e8 79 0d 00 00       	call   c002e64c <inode_init>
    free_map_init();
c002d8d3:	e8 d5 01 00 00       	call   c002daad <free_map_init>

    if (format)
c002d8d8:	89 f0                	mov    %esi,%eax
c002d8da:	84 c0                	test   %al,%al
c002d8dc:	75 27                	jne    c002d905 <filesys_init+0x61>
        do_format();

    free_map_open();
c002d8de:	e8 29 03 00 00       	call   c002dc0c <free_map_open>
}
c002d8e3:	83 c4 04             	add    $0x4,%esp
c002d8e6:	5b                   	pop    %ebx
c002d8e7:	5e                   	pop    %esi
c002d8e8:	c3                   	ret    
        PANIC ("No file system device found, can't initialize file system.");
c002d8e9:	8d 83 64 59 ff ff    	lea    -0xa69c(%ebx),%eax
c002d8ef:	50                   	push   %eax
c002d8f0:	8d 83 44 34 ff ff    	lea    -0xcbbc(%ebx),%eax
c002d8f6:	50                   	push   %eax
c002d8f7:	6a 16                	push   $0x16
c002d8f9:	8d 83 bf 59 ff ff    	lea    -0xa641(%ebx),%eax
c002d8ff:	50                   	push   %eax
c002d900:	e8 28 b8 ff ff       	call   c002912d <debug_panic>
}

/* Formats the file system. */
static void
do_format(void) {
    printf("Formatting file system...");
c002d905:	83 ec 0c             	sub    $0xc,%esp
c002d908:	8d 83 d7 59 ff ff    	lea    -0xa629(%ebx),%eax
c002d90e:	50                   	push   %eax
c002d90f:	e8 bd 9b ff ff       	call   c00274d1 <printf>
    free_map_create();
c002d914:	e8 90 03 00 00       	call   c002dca9 <free_map_create>
    if (!dir_create(ROOT_DIR_SECTOR, 16))
c002d919:	83 c4 08             	add    $0x8,%esp
c002d91c:	6a 10                	push   $0x10
c002d91e:	6a 01                	push   $0x1
c002d920:	e8 91 08 00 00       	call   c002e1b6 <dir_create>
c002d925:	83 c4 10             	add    $0x10,%esp
c002d928:	84 c0                	test   %al,%al
c002d92a:	74 19                	je     c002d945 <filesys_init+0xa1>
        PANIC ("root directory creation failed");
    free_map_close();
c002d92c:	e8 59 03 00 00       	call   c002dc8a <free_map_close>
    printf("done.\n");
c002d931:	83 ec 0c             	sub    $0xc,%esp
c002d934:	8d 83 b9 42 ff ff    	lea    -0xbd47(%ebx),%eax
c002d93a:	50                   	push   %eax
c002d93b:	e8 c3 d7 ff ff       	call   c002b103 <puts>
c002d940:	83 c4 10             	add    $0x10,%esp
c002d943:	eb 99                	jmp    c002d8de <filesys_init+0x3a>
        PANIC ("root directory creation failed");
c002d945:	8d 83 a0 59 ff ff    	lea    -0xa660(%ebx),%eax
c002d94b:	50                   	push   %eax
c002d94c:	8d 83 38 34 ff ff    	lea    -0xcbc8(%ebx),%eax
c002d952:	50                   	push   %eax
c002d953:	6a 5f                	push   $0x5f
c002d955:	8d 83 bf 59 ff ff    	lea    -0xa641(%ebx),%eax
c002d95b:	50                   	push   %eax
c002d95c:	e8 cc b7 ff ff       	call   c002912d <debug_panic>

c002d961 <filesys_done>:
filesys_done(void) {
c002d961:	53                   	push   %ebx
c002d962:	83 ec 08             	sub    $0x8,%esp
c002d965:	e8 d9 27 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d96a:	81 c3 42 03 01 00    	add    $0x10342,%ebx
    free_map_close();
c002d970:	e8 15 03 00 00       	call   c002dc8a <free_map_close>
}
c002d975:	83 c4 08             	add    $0x8,%esp
c002d978:	5b                   	pop    %ebx
c002d979:	c3                   	ret    

c002d97a <filesys_create>:
filesys_create(const char *name, off_t initial_size) {
c002d97a:	57                   	push   %edi
c002d97b:	56                   	push   %esi
c002d97c:	53                   	push   %ebx
c002d97d:	83 ec 10             	sub    $0x10,%esp
c002d980:	e8 be 27 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002d985:	81 c3 27 03 01 00    	add    $0x10327,%ebx
    block_sector_t inode_sector = 0;
c002d98b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d992:	00 
    struct dir *dir = dir_open_root();
c002d993:	e8 9b 08 00 00       	call   c002e233 <dir_open_root>
c002d998:	89 c6                	mov    %eax,%esi
                    && dir_add(dir, name, inode_sector));
c002d99a:	85 c0                	test   %eax,%eax
c002d99c:	74 16                	je     c002d9b4 <filesys_create+0x3a>
                    && free_map_allocate(1, &inode_sector)
c002d99e:	83 ec 08             	sub    $0x8,%esp
c002d9a1:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d9a5:	50                   	push   %eax
c002d9a6:	6a 01                	push   $0x1
c002d9a8:	e8 6d 01 00 00       	call   c002db1a <free_map_allocate>
c002d9ad:	83 c4 10             	add    $0x10,%esp
c002d9b0:	84 c0                	test   %al,%al
c002d9b2:	75 1d                	jne    c002d9d1 <filesys_create+0x57>
    if (!success && inode_sector != 0)
c002d9b4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d9b8:	bf 00 00 00 00       	mov    $0x0,%edi
c002d9bd:	85 c0                	test   %eax,%eax
c002d9bf:	74 41                	je     c002da02 <filesys_create+0x88>
        free_map_release(inode_sector, 1);
c002d9c1:	83 ec 08             	sub    $0x8,%esp
c002d9c4:	6a 01                	push   $0x1
c002d9c6:	50                   	push   %eax
c002d9c7:	e8 c3 01 00 00       	call   c002db8f <free_map_release>
c002d9cc:	83 c4 10             	add    $0x10,%esp
c002d9cf:	eb 31                	jmp    c002da02 <filesys_create+0x88>
                    && inode_create(inode_sector, initial_size)
c002d9d1:	83 ec 08             	sub    $0x8,%esp
c002d9d4:	ff 74 24 2c          	pushl  0x2c(%esp)
c002d9d8:	ff 74 24 18          	pushl  0x18(%esp)
c002d9dc:	e8 8b 0c 00 00       	call   c002e66c <inode_create>
c002d9e1:	83 c4 10             	add    $0x10,%esp
c002d9e4:	84 c0                	test   %al,%al
c002d9e6:	74 cc                	je     c002d9b4 <filesys_create+0x3a>
                    && dir_add(dir, name, inode_sector));
c002d9e8:	83 ec 04             	sub    $0x4,%esp
c002d9eb:	ff 74 24 10          	pushl  0x10(%esp)
c002d9ef:	ff 74 24 28          	pushl  0x28(%esp)
c002d9f3:	56                   	push   %esi
c002d9f4:	e8 68 09 00 00       	call   c002e361 <dir_add>
c002d9f9:	89 c7                	mov    %eax,%edi
    if (!success && inode_sector != 0)
c002d9fb:	83 c4 10             	add    $0x10,%esp
c002d9fe:	84 c0                	test   %al,%al
c002da00:	74 b2                	je     c002d9b4 <filesys_create+0x3a>
    dir_close(dir);
c002da02:	83 ec 0c             	sub    $0xc,%esp
c002da05:	56                   	push   %esi
c002da06:	e8 72 08 00 00       	call   c002e27d <dir_close>
}
c002da0b:	89 f8                	mov    %edi,%eax
c002da0d:	83 c4 20             	add    $0x20,%esp
c002da10:	5b                   	pop    %ebx
c002da11:	5e                   	pop    %esi
c002da12:	5f                   	pop    %edi
c002da13:	c3                   	ret    

c002da14 <filesys_open>:
filesys_open(const char *name) {
c002da14:	56                   	push   %esi
c002da15:	53                   	push   %ebx
c002da16:	83 ec 14             	sub    $0x14,%esp
c002da19:	e8 25 27 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002da1e:	81 c3 8e 02 01 00    	add    $0x1028e,%ebx
    struct dir *dir = dir_open_root();
c002da24:	e8 0a 08 00 00       	call   c002e233 <dir_open_root>
c002da29:	89 c6                	mov    %eax,%esi
    struct inode *inode = NULL;
c002da2b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002da32:	00 
    if (dir != NULL)
c002da33:	85 c0                	test   %eax,%eax
c002da35:	74 15                	je     c002da4c <filesys_open+0x38>
        dir_lookup(dir, name, &inode);
c002da37:	83 ec 04             	sub    $0x4,%esp
c002da3a:	8d 44 24 10          	lea    0x10(%esp),%eax
c002da3e:	50                   	push   %eax
c002da3f:	ff 74 24 28          	pushl  0x28(%esp)
c002da43:	56                   	push   %esi
c002da44:	e8 6e 08 00 00       	call   c002e2b7 <dir_lookup>
c002da49:	83 c4 10             	add    $0x10,%esp
    dir_close(dir);
c002da4c:	83 ec 0c             	sub    $0xc,%esp
c002da4f:	56                   	push   %esi
c002da50:	e8 28 08 00 00       	call   c002e27d <dir_close>
    return file_open(inode);
c002da55:	83 c4 04             	add    $0x4,%esp
c002da58:	ff 74 24 18          	pushl  0x18(%esp)
c002da5c:	e8 02 03 00 00       	call   c002dd63 <file_open>
}
c002da61:	83 c4 24             	add    $0x24,%esp
c002da64:	5b                   	pop    %ebx
c002da65:	5e                   	pop    %esi
c002da66:	c3                   	ret    

c002da67 <filesys_remove>:
filesys_remove(const char *name) {
c002da67:	57                   	push   %edi
c002da68:	56                   	push   %esi
c002da69:	53                   	push   %ebx
c002da6a:	e8 d4 26 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002da6f:	81 c3 3d 02 01 00    	add    $0x1023d,%ebx
    struct dir *dir = dir_open_root();
c002da75:	e8 b9 07 00 00       	call   c002e233 <dir_open_root>
c002da7a:	89 c7                	mov    %eax,%edi
    bool success = dir != NULL && dir_remove(dir, name);
c002da7c:	be 00 00 00 00       	mov    $0x0,%esi
c002da81:	85 c0                	test   %eax,%eax
c002da83:	74 13                	je     c002da98 <filesys_remove+0x31>
c002da85:	83 ec 08             	sub    $0x8,%esp
c002da88:	ff 74 24 18          	pushl  0x18(%esp)
c002da8c:	50                   	push   %eax
c002da8d:	e8 f9 09 00 00       	call   c002e48b <dir_remove>
c002da92:	0f b6 f0             	movzbl %al,%esi
c002da95:	83 c4 10             	add    $0x10,%esp
    dir_close(dir);
c002da98:	83 ec 0c             	sub    $0xc,%esp
c002da9b:	57                   	push   %edi
c002da9c:	e8 dc 07 00 00       	call   c002e27d <dir_close>
    bool success = dir != NULL && dir_remove(dir, name);
c002daa1:	89 f0                	mov    %esi,%eax
c002daa3:	83 e0 01             	and    $0x1,%eax
    return success;
c002daa6:	83 c4 10             	add    $0x10,%esp
}
c002daa9:	5b                   	pop    %ebx
c002daaa:	5e                   	pop    %esi
c002daab:	5f                   	pop    %edi
c002daac:	c3                   	ret    

c002daad <free_map_init>:
static struct file *free_map_file;   /* Free map file. */
static struct bitmap *free_map;      /* Free map, one bit per sector. */

/* Initializes the free map. */
void
free_map_init(void) {
c002daad:	53                   	push   %ebx
c002daae:	83 ec 14             	sub    $0x14,%esp
c002dab1:	e8 8d 26 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002dab6:	81 c3 f6 01 01 00    	add    $0x101f6,%ebx
    free_map = bitmap_create(block_size(fs_device));
c002dabc:	c7 c0 d0 fc 03 c0    	mov    $0xc003fcd0,%eax
c002dac2:	ff 30                	pushl  (%eax)
c002dac4:	e8 83 78 ff ff       	call   c002534c <block_size>
c002dac9:	89 04 24             	mov    %eax,(%esp)
c002dacc:	e8 ff c7 ff ff       	call   c002a2d0 <bitmap_create>
c002dad1:	89 83 28 1d 00 00    	mov    %eax,0x1d28(%ebx)
    if (free_map == NULL)
c002dad7:	83 c4 10             	add    $0x10,%esp
c002dada:	85 c0                	test   %eax,%eax
c002dadc:	74 20                	je     c002dafe <free_map_init+0x51>
        PANIC ("bitmap creation failed--file system device is too large");
    bitmap_mark(free_map, FREE_MAP_SECTOR);
c002dade:	83 ec 08             	sub    $0x8,%esp
c002dae1:	6a 00                	push   $0x0
c002dae3:	50                   	push   %eax
c002dae4:	e8 39 c5 ff ff       	call   c002a022 <bitmap_mark>
    bitmap_mark(free_map, ROOT_DIR_SECTOR);
c002dae9:	83 c4 08             	add    $0x8,%esp
c002daec:	6a 01                	push   $0x1
c002daee:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002daf4:	e8 29 c5 ff ff       	call   c002a022 <bitmap_mark>
}
c002daf9:	83 c4 18             	add    $0x18,%esp
c002dafc:	5b                   	pop    %ebx
c002dafd:	c3                   	ret    
        PANIC ("bitmap creation failed--file system device is too large");
c002dafe:	8d 83 f4 59 ff ff    	lea    -0xa60c(%ebx),%eax
c002db04:	50                   	push   %eax
c002db05:	8d 83 88 34 ff ff    	lea    -0xcb78(%ebx),%eax
c002db0b:	50                   	push   %eax
c002db0c:	6a 10                	push   $0x10
c002db0e:	8d 83 4e 5a ff ff    	lea    -0xa5b2(%ebx),%eax
c002db14:	50                   	push   %eax
c002db15:	e8 13 b6 ff ff       	call   c002912d <debug_panic>

c002db1a <free_map_allocate>:
   the first into *SECTORP.
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool
free_map_allocate(size_t cnt, block_sector_t *sectorp) {
c002db1a:	57                   	push   %edi
c002db1b:	56                   	push   %esi
c002db1c:	53                   	push   %ebx
c002db1d:	e8 21 26 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002db22:	81 c3 8a 01 01 00    	add    $0x1018a,%ebx
c002db28:	8b 7c 24 10          	mov    0x10(%esp),%edi
    block_sector_t sector = bitmap_scan_and_flip(free_map, 0, cnt, false);
c002db2c:	6a 00                	push   $0x0
c002db2e:	57                   	push   %edi
c002db2f:	6a 00                	push   $0x0
c002db31:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002db37:	e8 6f cb ff ff       	call   c002a6ab <bitmap_scan_and_flip>
c002db3c:	89 c6                	mov    %eax,%esi
    if (sector != BITMAP_ERROR
c002db3e:	83 c4 10             	add    $0x10,%esp
c002db41:	83 f8 ff             	cmp    $0xffffffff,%eax
c002db44:	74 26                	je     c002db6c <free_map_allocate+0x52>
        && free_map_file != NULL
c002db46:	8b 83 2c 1d 00 00    	mov    0x1d2c(%ebx),%eax
c002db4c:	85 c0                	test   %eax,%eax
c002db4e:	74 16                	je     c002db66 <free_map_allocate+0x4c>
        && !bitmap_write(free_map, free_map_file)) {
c002db50:	83 ec 08             	sub    $0x8,%esp
c002db53:	50                   	push   %eax
c002db54:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002db5a:	e8 12 cc ff ff       	call   c002a771 <bitmap_write>
c002db5f:	83 c4 10             	add    $0x10,%esp
c002db62:	84 c0                	test   %al,%al
c002db64:	74 10                	je     c002db76 <free_map_allocate+0x5c>
        bitmap_set_multiple(free_map, sector, cnt, false);
        sector = BITMAP_ERROR;
    }
    if (sector != BITMAP_ERROR)
        *sectorp = sector;
c002db66:	8b 44 24 14          	mov    0x14(%esp),%eax
c002db6a:	89 30                	mov    %esi,(%eax)
    return sector != BITMAP_ERROR;
c002db6c:	83 fe ff             	cmp    $0xffffffff,%esi
c002db6f:	0f 95 c0             	setne  %al
}
c002db72:	5b                   	pop    %ebx
c002db73:	5e                   	pop    %esi
c002db74:	5f                   	pop    %edi
c002db75:	c3                   	ret    
        bitmap_set_multiple(free_map, sector, cnt, false);
c002db76:	6a 00                	push   $0x0
c002db78:	57                   	push   %edi
c002db79:	56                   	push   %esi
c002db7a:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002db80:	e8 1b c6 ff ff       	call   c002a1a0 <bitmap_set_multiple>
c002db85:	83 c4 10             	add    $0x10,%esp
        sector = BITMAP_ERROR;
c002db88:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002db8d:	eb dd                	jmp    c002db6c <free_map_allocate+0x52>

c002db8f <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void
free_map_release(block_sector_t sector, size_t cnt) {
c002db8f:	57                   	push   %edi
c002db90:	56                   	push   %esi
c002db91:	53                   	push   %ebx
c002db92:	e8 ac 25 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002db97:	81 c3 15 01 01 00    	add    $0x10115,%ebx
c002db9d:	8b 74 24 10          	mov    0x10(%esp),%esi
c002dba1:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (bitmap_all(free_map, sector, cnt));
c002dba5:	83 ec 04             	sub    $0x4,%esp
c002dba8:	57                   	push   %edi
c002dba9:	56                   	push   %esi
c002dbaa:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002dbb0:	e8 09 ca ff ff       	call   c002a5be <bitmap_all>
c002dbb5:	83 c4 10             	add    $0x10,%esp
c002dbb8:	84 c0                	test   %al,%al
c002dbba:	74 2a                	je     c002dbe6 <free_map_release+0x57>
    bitmap_set_multiple(free_map, sector, cnt, false);
c002dbbc:	6a 00                	push   $0x0
c002dbbe:	57                   	push   %edi
c002dbbf:	56                   	push   %esi
c002dbc0:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002dbc6:	e8 d5 c5 ff ff       	call   c002a1a0 <bitmap_set_multiple>
    bitmap_write(free_map, free_map_file);
c002dbcb:	83 c4 08             	add    $0x8,%esp
c002dbce:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002dbd4:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002dbda:	e8 92 cb ff ff       	call   c002a771 <bitmap_write>
}
c002dbdf:	83 c4 10             	add    $0x10,%esp
c002dbe2:	5b                   	pop    %ebx
c002dbe3:	5e                   	pop    %esi
c002dbe4:	5f                   	pop    %edi
c002dbe5:	c3                   	ret    
    ASSERT (bitmap_all(free_map, sector, cnt));
c002dbe6:	83 ec 0c             	sub    $0xc,%esp
c002dbe9:	8d 83 2c 5a ff ff    	lea    -0xa5d4(%ebx),%eax
c002dbef:	50                   	push   %eax
c002dbf0:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002dbf6:	50                   	push   %eax
c002dbf7:	8d 83 74 34 ff ff    	lea    -0xcb8c(%ebx),%eax
c002dbfd:	50                   	push   %eax
c002dbfe:	6a 2b                	push   $0x2b
c002dc00:	8d 83 4e 5a ff ff    	lea    -0xa5b2(%ebx),%eax
c002dc06:	50                   	push   %eax
c002dc07:	e8 21 b5 ff ff       	call   c002912d <debug_panic>

c002dc0c <free_map_open>:

/* Opens the free map file and reads it from disk. */
void
free_map_open(void) {
c002dc0c:	53                   	push   %ebx
c002dc0d:	83 ec 14             	sub    $0x14,%esp
c002dc10:	e8 2e 25 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002dc15:	81 c3 97 00 01 00    	add    $0x10097,%ebx
    free_map_file = file_open(inode_open(FREE_MAP_SECTOR));
c002dc1b:	6a 00                	push   $0x0
c002dc1d:	e8 59 0b 00 00       	call   c002e77b <inode_open>
c002dc22:	89 04 24             	mov    %eax,(%esp)
c002dc25:	e8 39 01 00 00       	call   c002dd63 <file_open>
c002dc2a:	89 83 2c 1d 00 00    	mov    %eax,0x1d2c(%ebx)
    if (free_map_file == NULL)
c002dc30:	83 c4 10             	add    $0x10,%esp
c002dc33:	85 c0                	test   %eax,%eax
c002dc35:	74 1b                	je     c002dc52 <free_map_open+0x46>
        PANIC ("can't open free map");
    if (!bitmap_read(free_map, free_map_file))
c002dc37:	83 ec 08             	sub    $0x8,%esp
c002dc3a:	50                   	push   %eax
c002dc3b:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002dc41:	e8 bf ca ff ff       	call   c002a705 <bitmap_read>
c002dc46:	83 c4 10             	add    $0x10,%esp
c002dc49:	84 c0                	test   %al,%al
c002dc4b:	74 21                	je     c002dc6e <free_map_open+0x62>
        PANIC ("can't read free map");
}
c002dc4d:	83 c4 08             	add    $0x8,%esp
c002dc50:	5b                   	pop    %ebx
c002dc51:	c3                   	ret    
        PANIC ("can't open free map");
c002dc52:	8d 83 67 5a ff ff    	lea    -0xa599(%ebx),%eax
c002dc58:	50                   	push   %eax
c002dc59:	8d 83 64 34 ff ff    	lea    -0xcb9c(%ebx),%eax
c002dc5f:	50                   	push   %eax
c002dc60:	6a 35                	push   $0x35
c002dc62:	8d 83 4e 5a ff ff    	lea    -0xa5b2(%ebx),%eax
c002dc68:	50                   	push   %eax
c002dc69:	e8 bf b4 ff ff       	call   c002912d <debug_panic>
        PANIC ("can't read free map");
c002dc6e:	8d 83 7b 5a ff ff    	lea    -0xa585(%ebx),%eax
c002dc74:	50                   	push   %eax
c002dc75:	8d 83 64 34 ff ff    	lea    -0xcb9c(%ebx),%eax
c002dc7b:	50                   	push   %eax
c002dc7c:	6a 37                	push   $0x37
c002dc7e:	8d 83 4e 5a ff ff    	lea    -0xa5b2(%ebx),%eax
c002dc84:	50                   	push   %eax
c002dc85:	e8 a3 b4 ff ff       	call   c002912d <debug_panic>

c002dc8a <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void
free_map_close(void) {
c002dc8a:	53                   	push   %ebx
c002dc8b:	83 ec 14             	sub    $0x14,%esp
c002dc8e:	e8 b0 24 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002dc93:	81 c3 19 00 01 00    	add    $0x10019,%ebx
    file_close(free_map_file);
c002dc99:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002dc9f:	e8 b0 02 00 00       	call   c002df54 <file_close>
}
c002dca4:	83 c4 18             	add    $0x18,%esp
c002dca7:	5b                   	pop    %ebx
c002dca8:	c3                   	ret    

c002dca9 <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void
free_map_create(void) {
c002dca9:	53                   	push   %ebx
c002dcaa:	83 ec 14             	sub    $0x14,%esp
c002dcad:	e8 91 24 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002dcb2:	81 c3 fa ff 00 00    	add    $0xfffa,%ebx
    /* Create inode. */
    if (!inode_create(FREE_MAP_SECTOR, bitmap_file_size(free_map)))
c002dcb8:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002dcbe:	e8 32 ca ff ff       	call   c002a6f5 <bitmap_file_size>
c002dcc3:	83 c4 08             	add    $0x8,%esp
c002dcc6:	50                   	push   %eax
c002dcc7:	6a 00                	push   $0x0
c002dcc9:	e8 9e 09 00 00       	call   c002e66c <inode_create>
c002dcce:	83 c4 10             	add    $0x10,%esp
c002dcd1:	84 c0                	test   %al,%al
c002dcd3:	74 3a                	je     c002dd0f <free_map_create+0x66>
        PANIC ("free map creation failed");

    /* Write bitmap to file. */
    free_map_file = file_open(inode_open(FREE_MAP_SECTOR));
c002dcd5:	83 ec 0c             	sub    $0xc,%esp
c002dcd8:	6a 00                	push   $0x0
c002dcda:	e8 9c 0a 00 00       	call   c002e77b <inode_open>
c002dcdf:	89 04 24             	mov    %eax,(%esp)
c002dce2:	e8 7c 00 00 00       	call   c002dd63 <file_open>
c002dce7:	89 83 2c 1d 00 00    	mov    %eax,0x1d2c(%ebx)
    if (free_map_file == NULL)
c002dced:	83 c4 10             	add    $0x10,%esp
c002dcf0:	85 c0                	test   %eax,%eax
c002dcf2:	74 37                	je     c002dd2b <free_map_create+0x82>
        PANIC ("can't open free map");
    if (!bitmap_write(free_map, free_map_file))
c002dcf4:	83 ec 08             	sub    $0x8,%esp
c002dcf7:	50                   	push   %eax
c002dcf8:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002dcfe:	e8 6e ca ff ff       	call   c002a771 <bitmap_write>
c002dd03:	83 c4 10             	add    $0x10,%esp
c002dd06:	84 c0                	test   %al,%al
c002dd08:	74 3d                	je     c002dd47 <free_map_create+0x9e>
        PANIC ("can't write free map");
}
c002dd0a:	83 c4 08             	add    $0x8,%esp
c002dd0d:	5b                   	pop    %ebx
c002dd0e:	c3                   	ret    
        PANIC ("free map creation failed");
c002dd0f:	8d 83 8f 5a ff ff    	lea    -0xa571(%ebx),%eax
c002dd15:	50                   	push   %eax
c002dd16:	8d 83 54 34 ff ff    	lea    -0xcbac(%ebx),%eax
c002dd1c:	50                   	push   %eax
c002dd1d:	6a 46                	push   $0x46
c002dd1f:	8d 83 4e 5a ff ff    	lea    -0xa5b2(%ebx),%eax
c002dd25:	50                   	push   %eax
c002dd26:	e8 02 b4 ff ff       	call   c002912d <debug_panic>
        PANIC ("can't open free map");
c002dd2b:	8d 83 67 5a ff ff    	lea    -0xa599(%ebx),%eax
c002dd31:	50                   	push   %eax
c002dd32:	8d 83 54 34 ff ff    	lea    -0xcbac(%ebx),%eax
c002dd38:	50                   	push   %eax
c002dd39:	6a 4b                	push   $0x4b
c002dd3b:	8d 83 4e 5a ff ff    	lea    -0xa5b2(%ebx),%eax
c002dd41:	50                   	push   %eax
c002dd42:	e8 e6 b3 ff ff       	call   c002912d <debug_panic>
        PANIC ("can't write free map");
c002dd47:	8d 83 a8 5a ff ff    	lea    -0xa558(%ebx),%eax
c002dd4d:	50                   	push   %eax
c002dd4e:	8d 83 54 34 ff ff    	lea    -0xcbac(%ebx),%eax
c002dd54:	50                   	push   %eax
c002dd55:	6a 4d                	push   $0x4d
c002dd57:	8d 83 4e 5a ff ff    	lea    -0xa5b2(%ebx),%eax
c002dd5d:	50                   	push   %eax
c002dd5e:	e8 ca b3 ff ff       	call   c002912d <debug_panic>

c002dd63 <file_open>:

/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open(struct inode *inode) {
c002dd63:	57                   	push   %edi
c002dd64:	56                   	push   %esi
c002dd65:	53                   	push   %ebx
c002dd66:	e8 d8 23 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002dd6b:	81 c3 41 ff 00 00    	add    $0xff41,%ebx
c002dd71:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct file *file = calloc(1, sizeof *file);
c002dd75:	83 ec 08             	sub    $0x8,%esp
c002dd78:	6a 0c                	push   $0xc
c002dd7a:	6a 01                	push   $0x1
c002dd7c:	e8 2a 62 ff ff       	call   c0023fab <calloc>
c002dd81:	89 c6                	mov    %eax,%esi
    if (inode != NULL && file != NULL) {
c002dd83:	83 c4 10             	add    $0x10,%esp
c002dd86:	85 ff                	test   %edi,%edi
c002dd88:	74 17                	je     c002dda1 <file_open+0x3e>
c002dd8a:	85 c0                	test   %eax,%eax
c002dd8c:	74 13                	je     c002dda1 <file_open+0x3e>
        file->inode = inode;
c002dd8e:	89 38                	mov    %edi,(%eax)
        file->pos = 0;
c002dd90:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        file->deny_write = false;
c002dd97:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    } else {
        inode_close(inode);
        free(file);
        return NULL;
    }
}
c002dd9b:	89 f0                	mov    %esi,%eax
c002dd9d:	5b                   	pop    %ebx
c002dd9e:	5e                   	pop    %esi
c002dd9f:	5f                   	pop    %edi
c002dda0:	c3                   	ret    
        inode_close(inode);
c002dda1:	83 ec 0c             	sub    $0xc,%esp
c002dda4:	57                   	push   %edi
c002dda5:	e8 96 0a 00 00       	call   c002e840 <inode_close>
        free(file);
c002ddaa:	89 34 24             	mov    %esi,(%esp)
c002ddad:	e8 4a 62 ff ff       	call   c0023ffc <free>
        return NULL;
c002ddb2:	83 c4 10             	add    $0x10,%esp
c002ddb5:	be 00 00 00 00       	mov    $0x0,%esi
c002ddba:	eb df                	jmp    c002dd9b <file_open+0x38>

c002ddbc <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen(struct file *file) {
c002ddbc:	53                   	push   %ebx
c002ddbd:	83 ec 14             	sub    $0x14,%esp
c002ddc0:	e8 7e 23 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ddc5:	81 c3 e7 fe 00 00    	add    $0xfee7,%ebx
    return file_open(inode_reopen(file->inode));
c002ddcb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ddcf:	ff 30                	pushl  (%eax)
c002ddd1:	e8 98 09 00 00       	call   c002e76e <inode_reopen>
c002ddd6:	89 04 24             	mov    %eax,(%esp)
c002ddd9:	e8 85 ff ff ff       	call   c002dd63 <file_open>
}
c002ddde:	83 c4 18             	add    $0x18,%esp
c002dde1:	5b                   	pop    %ebx
c002dde2:	c3                   	ret    

c002dde3 <file_get_inode>:
}

/* Returns the inode encapsulated by FILE. */
struct inode *
file_get_inode(struct file *file) {
    return file->inode;
c002dde3:	8b 44 24 04          	mov    0x4(%esp),%eax
c002dde7:	8b 00                	mov    (%eax),%eax
}
c002dde9:	c3                   	ret    

c002ddea <file_read>:
   starting at the file's current position.
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   Advances FILE's position by the number of bytes read. */
off_t
file_read(struct file *file, void *buffer, off_t size) {
c002ddea:	56                   	push   %esi
c002ddeb:	53                   	push   %ebx
c002ddec:	83 ec 04             	sub    $0x4,%esp
c002ddef:	e8 4f 23 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ddf4:	81 c3 b8 fe 00 00    	add    $0xfeb8,%ebx
c002ddfa:	8b 74 24 10          	mov    0x10(%esp),%esi
    off_t bytes_read = inode_read_at(file->inode, buffer, size, file->pos);
c002ddfe:	ff 76 04             	pushl  0x4(%esi)
c002de01:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de05:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de09:	ff 36                	pushl  (%esi)
c002de0b:	e8 f7 0a 00 00       	call   c002e907 <inode_read_at>
    file->pos += bytes_read;
c002de10:	01 46 04             	add    %eax,0x4(%esi)
    return bytes_read;
}
c002de13:	83 c4 14             	add    $0x14,%esp
c002de16:	5b                   	pop    %ebx
c002de17:	5e                   	pop    %esi
c002de18:	c3                   	ret    

c002de19 <file_read_at>:
   starting at offset FILE_OFS in the file.
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   The file's current position is unaffected. */
off_t
file_read_at(struct file *file, void *buffer, off_t size, off_t file_ofs) {
c002de19:	53                   	push   %ebx
c002de1a:	83 ec 08             	sub    $0x8,%esp
c002de1d:	e8 21 23 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002de22:	81 c3 8a fe 00 00    	add    $0xfe8a,%ebx
    return inode_read_at(file->inode, buffer, size, file_ofs);
c002de28:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de2c:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de30:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002de38:	ff 30                	pushl  (%eax)
c002de3a:	e8 c8 0a 00 00       	call   c002e907 <inode_read_at>
}
c002de3f:	83 c4 18             	add    $0x18,%esp
c002de42:	5b                   	pop    %ebx
c002de43:	c3                   	ret    

c002de44 <file_write>:
   which may be less than SIZE if end of file is reached.
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   Advances FILE's position by the number of bytes read. */
off_t
file_write(struct file *file, const void *buffer, off_t size) {
c002de44:	56                   	push   %esi
c002de45:	53                   	push   %ebx
c002de46:	83 ec 04             	sub    $0x4,%esp
c002de49:	e8 f5 22 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002de4e:	81 c3 5e fe 00 00    	add    $0xfe5e,%ebx
c002de54:	8b 74 24 10          	mov    0x10(%esp),%esi
    off_t bytes_written = inode_write_at(file->inode, buffer, size, file->pos);
c002de58:	ff 76 04             	pushl  0x4(%esi)
c002de5b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de5f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de63:	ff 36                	pushl  (%esi)
c002de65:	e8 24 0c 00 00       	call   c002ea8e <inode_write_at>
    file->pos += bytes_written;
c002de6a:	01 46 04             	add    %eax,0x4(%esi)
    return bytes_written;
}
c002de6d:	83 c4 14             	add    $0x14,%esp
c002de70:	5b                   	pop    %ebx
c002de71:	5e                   	pop    %esi
c002de72:	c3                   	ret    

c002de73 <file_write_at>:
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   The file's current position is unaffected. */
off_t
file_write_at(struct file *file, const void *buffer, off_t size,
              off_t file_ofs) {
c002de73:	53                   	push   %ebx
c002de74:	83 ec 08             	sub    $0x8,%esp
c002de77:	e8 c7 22 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002de7c:	81 c3 30 fe 00 00    	add    $0xfe30,%ebx
    return inode_write_at(file->inode, buffer, size, file_ofs);
c002de82:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de86:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de8a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002de8e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002de92:	ff 30                	pushl  (%eax)
c002de94:	e8 f5 0b 00 00       	call   c002ea8e <inode_write_at>
}
c002de99:	83 c4 18             	add    $0x18,%esp
c002de9c:	5b                   	pop    %ebx
c002de9d:	c3                   	ret    

c002de9e <file_deny_write>:

/* Prevents write operations on FILE's underlying inode
   until file_allow_write() is called or FILE is closed. */
void
file_deny_write(struct file *file) {
c002de9e:	53                   	push   %ebx
c002de9f:	83 ec 08             	sub    $0x8,%esp
c002dea2:	e8 9c 22 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002dea7:	81 c3 05 fe 00 00    	add    $0xfe05,%ebx
c002dead:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002deb1:	85 c0                	test   %eax,%eax
c002deb3:	74 0b                	je     c002dec0 <file_deny_write+0x22>
    if (!file->deny_write) {
c002deb5:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002deb9:	74 2b                	je     c002dee6 <file_deny_write+0x48>
        file->deny_write = true;
        inode_deny_write(file->inode);
    }
}
c002debb:	83 c4 08             	add    $0x8,%esp
c002debe:	5b                   	pop    %ebx
c002debf:	c3                   	ret    
    ASSERT (file != NULL);
c002dec0:	83 ec 0c             	sub    $0xc,%esp
c002dec3:	8d 83 bd 5a ff ff    	lea    -0xa543(%ebx),%eax
c002dec9:	50                   	push   %eax
c002deca:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ded0:	50                   	push   %eax
c002ded1:	8d 83 d0 34 ff ff    	lea    -0xcb30(%ebx),%eax
c002ded7:	50                   	push   %eax
c002ded8:	6a 6c                	push   $0x6c
c002deda:	8d 83 ca 5a ff ff    	lea    -0xa536(%ebx),%eax
c002dee0:	50                   	push   %eax
c002dee1:	e8 47 b2 ff ff       	call   c002912d <debug_panic>
        file->deny_write = true;
c002dee6:	c6 40 08 01          	movb   $0x1,0x8(%eax)
        inode_deny_write(file->inode);
c002deea:	83 ec 0c             	sub    $0xc,%esp
c002deed:	ff 30                	pushl  (%eax)
c002deef:	e8 88 0d 00 00       	call   c002ec7c <inode_deny_write>
c002def4:	83 c4 10             	add    $0x10,%esp
}
c002def7:	eb c2                	jmp    c002debb <file_deny_write+0x1d>

c002def9 <file_allow_write>:

/* Re-enables write operations on FILE's underlying inode.
   (Writes might still be denied by some other file that has the
   same inode open.) */
void
file_allow_write(struct file *file) {
c002def9:	53                   	push   %ebx
c002defa:	83 ec 08             	sub    $0x8,%esp
c002defd:	e8 41 22 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002df02:	81 c3 aa fd 00 00    	add    $0xfdaa,%ebx
c002df08:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002df0c:	85 c0                	test   %eax,%eax
c002df0e:	74 0b                	je     c002df1b <file_allow_write+0x22>
    if (file->deny_write) {
c002df10:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002df14:	75 2b                	jne    c002df41 <file_allow_write+0x48>
        file->deny_write = false;
        inode_allow_write(file->inode);
    }
}
c002df16:	83 c4 08             	add    $0x8,%esp
c002df19:	5b                   	pop    %ebx
c002df1a:	c3                   	ret    
    ASSERT (file != NULL);
c002df1b:	83 ec 0c             	sub    $0xc,%esp
c002df1e:	8d 83 bd 5a ff ff    	lea    -0xa543(%ebx),%eax
c002df24:	50                   	push   %eax
c002df25:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002df2b:	50                   	push   %eax
c002df2c:	8d 83 bc 34 ff ff    	lea    -0xcb44(%ebx),%eax
c002df32:	50                   	push   %eax
c002df33:	6a 78                	push   $0x78
c002df35:	8d 83 ca 5a ff ff    	lea    -0xa536(%ebx),%eax
c002df3b:	50                   	push   %eax
c002df3c:	e8 ec b1 ff ff       	call   c002912d <debug_panic>
        file->deny_write = false;
c002df41:	c6 40 08 00          	movb   $0x0,0x8(%eax)
        inode_allow_write(file->inode);
c002df45:	83 ec 0c             	sub    $0xc,%esp
c002df48:	ff 30                	pushl  (%eax)
c002df4a:	e8 7c 0d 00 00       	call   c002eccb <inode_allow_write>
c002df4f:	83 c4 10             	add    $0x10,%esp
}
c002df52:	eb c2                	jmp    c002df16 <file_allow_write+0x1d>

c002df54 <file_close>:
file_close(struct file *file) {
c002df54:	56                   	push   %esi
c002df55:	53                   	push   %ebx
c002df56:	83 ec 04             	sub    $0x4,%esp
c002df59:	e8 e5 21 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002df5e:	81 c3 4e fd 00 00    	add    $0xfd4e,%ebx
c002df64:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (file != NULL) {
c002df68:	85 f6                	test   %esi,%esi
c002df6a:	74 1e                	je     c002df8a <file_close+0x36>
        file_allow_write(file);
c002df6c:	83 ec 0c             	sub    $0xc,%esp
c002df6f:	56                   	push   %esi
c002df70:	e8 84 ff ff ff       	call   c002def9 <file_allow_write>
        inode_close(file->inode);
c002df75:	83 c4 04             	add    $0x4,%esp
c002df78:	ff 36                	pushl  (%esi)
c002df7a:	e8 c1 08 00 00       	call   c002e840 <inode_close>
        free(file);
c002df7f:	89 34 24             	mov    %esi,(%esp)
c002df82:	e8 75 60 ff ff       	call   c0023ffc <free>
c002df87:	83 c4 10             	add    $0x10,%esp
}
c002df8a:	83 c4 04             	add    $0x4,%esp
c002df8d:	5b                   	pop    %ebx
c002df8e:	5e                   	pop    %esi
c002df8f:	c3                   	ret    

c002df90 <file_length>:

/* Returns the size of FILE in bytes. */
off_t
file_length(struct file *file) {
c002df90:	53                   	push   %ebx
c002df91:	83 ec 08             	sub    $0x8,%esp
c002df94:	e8 aa 21 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002df99:	81 c3 13 fd 00 00    	add    $0xfd13,%ebx
c002df9f:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002dfa3:	85 c0                	test   %eax,%eax
c002dfa5:	74 0f                	je     c002dfb6 <file_length+0x26>
    return inode_length(file->inode);
c002dfa7:	83 ec 0c             	sub    $0xc,%esp
c002dfaa:	ff 30                	pushl  (%eax)
c002dfac:	e8 96 0d 00 00       	call   c002ed47 <inode_length>
}
c002dfb1:	83 c4 18             	add    $0x18,%esp
c002dfb4:	5b                   	pop    %ebx
c002dfb5:	c3                   	ret    
    ASSERT (file != NULL);
c002dfb6:	83 ec 0c             	sub    $0xc,%esp
c002dfb9:	8d 83 bd 5a ff ff    	lea    -0xa543(%ebx),%eax
c002dfbf:	50                   	push   %eax
c002dfc0:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002dfc6:	50                   	push   %eax
c002dfc7:	8d 83 b0 34 ff ff    	lea    -0xcb50(%ebx),%eax
c002dfcd:	50                   	push   %eax
c002dfce:	68 82 00 00 00       	push   $0x82
c002dfd3:	8d 83 ca 5a ff ff    	lea    -0xa536(%ebx),%eax
c002dfd9:	50                   	push   %eax
c002dfda:	e8 4e b1 ff ff       	call   c002912d <debug_panic>

c002dfdf <file_seek>:

/* Sets the current position in FILE to NEW_POS bytes from the
   start of the file. */
void
file_seek(struct file *file, off_t new_pos) {
c002dfdf:	53                   	push   %ebx
c002dfe0:	83 ec 08             	sub    $0x8,%esp
c002dfe3:	e8 5b 21 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002dfe8:	81 c3 c4 fc 00 00    	add    $0xfcc4,%ebx
c002dfee:	8b 44 24 10          	mov    0x10(%esp),%eax
c002dff2:	8b 54 24 14          	mov    0x14(%esp),%edx
    ASSERT (file != NULL);
c002dff6:	85 c0                	test   %eax,%eax
c002dff8:	74 0c                	je     c002e006 <file_seek+0x27>
    ASSERT (new_pos >= 0);
c002dffa:	85 d2                	test   %edx,%edx
c002dffc:	78 31                	js     c002e02f <file_seek+0x50>
    file->pos = new_pos;
c002dffe:	89 50 04             	mov    %edx,0x4(%eax)
}
c002e001:	83 c4 08             	add    $0x8,%esp
c002e004:	5b                   	pop    %ebx
c002e005:	c3                   	ret    
    ASSERT (file != NULL);
c002e006:	83 ec 0c             	sub    $0xc,%esp
c002e009:	8d 83 bd 5a ff ff    	lea    -0xa543(%ebx),%eax
c002e00f:	50                   	push   %eax
c002e010:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e016:	50                   	push   %eax
c002e017:	8d 83 a4 34 ff ff    	lea    -0xcb5c(%ebx),%eax
c002e01d:	50                   	push   %eax
c002e01e:	68 8a 00 00 00       	push   $0x8a
c002e023:	8d 83 ca 5a ff ff    	lea    -0xa536(%ebx),%eax
c002e029:	50                   	push   %eax
c002e02a:	e8 fe b0 ff ff       	call   c002912d <debug_panic>
    ASSERT (new_pos >= 0);
c002e02f:	83 ec 0c             	sub    $0xc,%esp
c002e032:	8d 83 df 5a ff ff    	lea    -0xa521(%ebx),%eax
c002e038:	50                   	push   %eax
c002e039:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e03f:	50                   	push   %eax
c002e040:	8d 83 a4 34 ff ff    	lea    -0xcb5c(%ebx),%eax
c002e046:	50                   	push   %eax
c002e047:	68 8b 00 00 00       	push   $0x8b
c002e04c:	8d 83 ca 5a ff ff    	lea    -0xa536(%ebx),%eax
c002e052:	50                   	push   %eax
c002e053:	e8 d5 b0 ff ff       	call   c002912d <debug_panic>

c002e058 <file_tell>:

/* Returns the current position in FILE as a byte offset from the
   start of the file. */
off_t
file_tell(struct file *file) {
c002e058:	53                   	push   %ebx
c002e059:	83 ec 08             	sub    $0x8,%esp
c002e05c:	e8 e2 20 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e061:	81 c3 4b fc 00 00    	add    $0xfc4b,%ebx
c002e067:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002e06b:	85 c0                	test   %eax,%eax
c002e06d:	74 08                	je     c002e077 <file_tell+0x1f>
    return file->pos;
c002e06f:	8b 40 04             	mov    0x4(%eax),%eax
}
c002e072:	83 c4 08             	add    $0x8,%esp
c002e075:	5b                   	pop    %ebx
c002e076:	c3                   	ret    
    ASSERT (file != NULL);
c002e077:	83 ec 0c             	sub    $0xc,%esp
c002e07a:	8d 83 bd 5a ff ff    	lea    -0xa543(%ebx),%eax
c002e080:	50                   	push   %eax
c002e081:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e087:	50                   	push   %eax
c002e088:	8d 83 98 34 ff ff    	lea    -0xcb68(%ebx),%eax
c002e08e:	50                   	push   %eax
c002e08f:	68 93 00 00 00       	push   $0x93
c002e094:	8d 83 ca 5a ff ff    	lea    -0xa536(%ebx),%eax
c002e09a:	50                   	push   %eax
c002e09b:	e8 8d b0 ff ff       	call   c002912d <debug_panic>

c002e0a0 <lookup>:
   if EP is non-null, and sets *OFSP to the byte offset of the
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup(const struct dir *dir, const char *name,
       struct dir_entry *ep, off_t *ofsp) {
c002e0a0:	55                   	push   %ebp
c002e0a1:	57                   	push   %edi
c002e0a2:	56                   	push   %esi
c002e0a3:	53                   	push   %ebx
c002e0a4:	83 ec 4c             	sub    $0x4c,%esp
c002e0a7:	e8 97 20 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e0ac:	81 c3 00 fc 00 00    	add    $0xfc00,%ebx
c002e0b2:	89 54 24 14          	mov    %edx,0x14(%esp)
c002e0b6:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    struct dir_entry e;
    size_t ofs;

    ASSERT (dir != NULL);
c002e0ba:	85 c0                	test   %eax,%eax
c002e0bc:	74 20                	je     c002e0de <lookup+0x3e>
c002e0be:	89 c5                	mov    %eax,%ebp
    ASSERT (name != NULL);
c002e0c0:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002e0c5:	74 3d                	je     c002e104 <lookup+0x64>

    for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e0c7:	be 00 00 00 00       	mov    $0x0,%esi
c002e0cc:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e0d0:	89 44 24 0c          	mov    %eax,0xc(%esp)
         ofs += sizeof e)
        if (e.in_use && !strcmp(name, e.name)) {
c002e0d4:	8d 44 24 30          	lea    0x30(%esp),%eax
c002e0d8:	89 44 24 18          	mov    %eax,0x18(%esp)
c002e0dc:	eb 4f                	jmp    c002e12d <lookup+0x8d>
    ASSERT (dir != NULL);
c002e0de:	83 ec 0c             	sub    $0xc,%esp
c002e0e1:	8d 83 ec 5a ff ff    	lea    -0xa514(%ebx),%eax
c002e0e7:	50                   	push   %eax
c002e0e8:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e0ee:	50                   	push   %eax
c002e0ef:	8d 83 f4 34 ff ff    	lea    -0xcb0c(%ebx),%eax
c002e0f5:	50                   	push   %eax
c002e0f6:	6a 55                	push   $0x55
c002e0f8:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e0fe:	50                   	push   %eax
c002e0ff:	e8 29 b0 ff ff       	call   c002912d <debug_panic>
    ASSERT (name != NULL);
c002e104:	83 ec 0c             	sub    $0xc,%esp
c002e107:	8d 83 08 3e ff ff    	lea    -0xc1f8(%ebx),%eax
c002e10d:	50                   	push   %eax
c002e10e:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e114:	50                   	push   %eax
c002e115:	8d 83 f4 34 ff ff    	lea    -0xcb0c(%ebx),%eax
c002e11b:	50                   	push   %eax
c002e11c:	6a 56                	push   $0x56
c002e11e:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e124:	50                   	push   %eax
c002e125:	e8 03 b0 ff ff       	call   c002912d <debug_panic>
         ofs += sizeof e)
c002e12a:	83 c6 14             	add    $0x14,%esi
    for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e12d:	89 74 24 10          	mov    %esi,0x10(%esp)
c002e131:	56                   	push   %esi
c002e132:	6a 14                	push   $0x14
c002e134:	ff 74 24 14          	pushl  0x14(%esp)
c002e138:	ff 75 00             	pushl  0x0(%ebp)
c002e13b:	e8 c7 07 00 00       	call   c002e907 <inode_read_at>
c002e140:	83 c4 10             	add    $0x10,%esp
c002e143:	83 f8 14             	cmp    $0x14,%eax
c002e146:	75 5f                	jne    c002e1a7 <lookup+0x107>
        if (e.in_use && !strcmp(name, e.name)) {
c002e148:	0f b6 7c 24 3f       	movzbl 0x3f(%esp),%edi
c002e14d:	89 f8                	mov    %edi,%eax
c002e14f:	84 c0                	test   %al,%al
c002e151:	74 d7                	je     c002e12a <lookup+0x8a>
c002e153:	83 ec 08             	sub    $0x8,%esp
c002e156:	ff 74 24 20          	pushl  0x20(%esp)
c002e15a:	ff 74 24 20          	pushl  0x20(%esp)
c002e15e:	e8 80 a2 ff ff       	call   c00283e3 <strcmp>
c002e163:	83 c4 10             	add    $0x10,%esp
c002e166:	85 c0                	test   %eax,%eax
c002e168:	75 c0                	jne    c002e12a <lookup+0x8a>
            if (ep != NULL)
c002e16a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002e16e:	85 d2                	test   %edx,%edx
c002e170:	74 22                	je     c002e194 <lookup+0xf4>
                *ep = e;
c002e172:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002e176:	89 02                	mov    %eax,(%edx)
c002e178:	8b 44 24 30          	mov    0x30(%esp),%eax
c002e17c:	89 42 04             	mov    %eax,0x4(%edx)
c002e17f:	8b 44 24 34          	mov    0x34(%esp),%eax
c002e183:	89 42 08             	mov    %eax,0x8(%edx)
c002e186:	8b 44 24 38          	mov    0x38(%esp),%eax
c002e18a:	89 42 0c             	mov    %eax,0xc(%edx)
c002e18d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002e191:	89 42 10             	mov    %eax,0x10(%edx)
            if (ofsp != NULL)
c002e194:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
c002e199:	74 11                	je     c002e1ac <lookup+0x10c>
                *ofsp = ofs;
c002e19b:	8b 44 24 60          	mov    0x60(%esp),%eax
c002e19f:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002e1a3:	89 08                	mov    %ecx,(%eax)
c002e1a5:	eb 05                	jmp    c002e1ac <lookup+0x10c>
            return true;
        }
    return false;
c002e1a7:	bf 00 00 00 00       	mov    $0x0,%edi
}
c002e1ac:	89 f8                	mov    %edi,%eax
c002e1ae:	83 c4 4c             	add    $0x4c,%esp
c002e1b1:	5b                   	pop    %ebx
c002e1b2:	5e                   	pop    %esi
c002e1b3:	5f                   	pop    %edi
c002e1b4:	5d                   	pop    %ebp
c002e1b5:	c3                   	ret    

c002e1b6 <dir_create>:
dir_create(block_sector_t sector, size_t entry_cnt) {
c002e1b6:	53                   	push   %ebx
c002e1b7:	83 ec 10             	sub    $0x10,%esp
c002e1ba:	e8 84 1f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e1bf:	81 c3 ed fa 00 00    	add    $0xfaed,%ebx
c002e1c5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    return inode_create(sector, entry_cnt * sizeof(struct dir_entry));
c002e1c9:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002e1cc:	c1 e0 02             	shl    $0x2,%eax
c002e1cf:	50                   	push   %eax
c002e1d0:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e1d4:	e8 93 04 00 00       	call   c002e66c <inode_create>
}
c002e1d9:	83 c4 18             	add    $0x18,%esp
c002e1dc:	5b                   	pop    %ebx
c002e1dd:	c3                   	ret    

c002e1de <dir_open>:
dir_open(struct inode *inode) {
c002e1de:	57                   	push   %edi
c002e1df:	56                   	push   %esi
c002e1e0:	53                   	push   %ebx
c002e1e1:	e8 5d 1f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e1e6:	81 c3 c6 fa 00 00    	add    $0xfac6,%ebx
c002e1ec:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct dir *dir = calloc(1, sizeof *dir);
c002e1f0:	83 ec 08             	sub    $0x8,%esp
c002e1f3:	6a 08                	push   $0x8
c002e1f5:	6a 01                	push   $0x1
c002e1f7:	e8 af 5d ff ff       	call   c0023fab <calloc>
c002e1fc:	89 c6                	mov    %eax,%esi
    if (inode != NULL && dir != NULL) {
c002e1fe:	83 c4 10             	add    $0x10,%esp
c002e201:	85 ff                	test   %edi,%edi
c002e203:	74 13                	je     c002e218 <dir_open+0x3a>
c002e205:	85 c0                	test   %eax,%eax
c002e207:	74 0f                	je     c002e218 <dir_open+0x3a>
        dir->inode = inode;
c002e209:	89 38                	mov    %edi,(%eax)
        dir->pos = 0;
c002e20b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
c002e212:	89 f0                	mov    %esi,%eax
c002e214:	5b                   	pop    %ebx
c002e215:	5e                   	pop    %esi
c002e216:	5f                   	pop    %edi
c002e217:	c3                   	ret    
        inode_close(inode);
c002e218:	83 ec 0c             	sub    $0xc,%esp
c002e21b:	57                   	push   %edi
c002e21c:	e8 1f 06 00 00       	call   c002e840 <inode_close>
        free(dir);
c002e221:	89 34 24             	mov    %esi,(%esp)
c002e224:	e8 d3 5d ff ff       	call   c0023ffc <free>
        return NULL;
c002e229:	83 c4 10             	add    $0x10,%esp
c002e22c:	be 00 00 00 00       	mov    $0x0,%esi
c002e231:	eb df                	jmp    c002e212 <dir_open+0x34>

c002e233 <dir_open_root>:
dir_open_root(void) {
c002e233:	53                   	push   %ebx
c002e234:	83 ec 14             	sub    $0x14,%esp
c002e237:	e8 07 1f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e23c:	81 c3 70 fa 00 00    	add    $0xfa70,%ebx
    return dir_open(inode_open(ROOT_DIR_SECTOR));
c002e242:	6a 01                	push   $0x1
c002e244:	e8 32 05 00 00       	call   c002e77b <inode_open>
c002e249:	89 04 24             	mov    %eax,(%esp)
c002e24c:	e8 8d ff ff ff       	call   c002e1de <dir_open>
}
c002e251:	83 c4 18             	add    $0x18,%esp
c002e254:	5b                   	pop    %ebx
c002e255:	c3                   	ret    

c002e256 <dir_reopen>:
dir_reopen(struct dir *dir) {
c002e256:	53                   	push   %ebx
c002e257:	83 ec 14             	sub    $0x14,%esp
c002e25a:	e8 e4 1e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e25f:	81 c3 4d fa 00 00    	add    $0xfa4d,%ebx
    return dir_open(inode_reopen(dir->inode));
c002e265:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e269:	ff 30                	pushl  (%eax)
c002e26b:	e8 fe 04 00 00       	call   c002e76e <inode_reopen>
c002e270:	89 04 24             	mov    %eax,(%esp)
c002e273:	e8 66 ff ff ff       	call   c002e1de <dir_open>
}
c002e278:	83 c4 18             	add    $0x18,%esp
c002e27b:	5b                   	pop    %ebx
c002e27c:	c3                   	ret    

c002e27d <dir_close>:
dir_close(struct dir *dir) {
c002e27d:	56                   	push   %esi
c002e27e:	53                   	push   %ebx
c002e27f:	83 ec 04             	sub    $0x4,%esp
c002e282:	e8 bc 1e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e287:	81 c3 25 fa 00 00    	add    $0xfa25,%ebx
c002e28d:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (dir != NULL) {
c002e291:	85 f6                	test   %esi,%esi
c002e293:	74 15                	je     c002e2aa <dir_close+0x2d>
        inode_close(dir->inode);
c002e295:	83 ec 0c             	sub    $0xc,%esp
c002e298:	ff 36                	pushl  (%esi)
c002e29a:	e8 a1 05 00 00       	call   c002e840 <inode_close>
        free(dir);
c002e29f:	89 34 24             	mov    %esi,(%esp)
c002e2a2:	e8 55 5d ff ff       	call   c0023ffc <free>
c002e2a7:	83 c4 10             	add    $0x10,%esp
}
c002e2aa:	83 c4 04             	add    $0x4,%esp
c002e2ad:	5b                   	pop    %ebx
c002e2ae:	5e                   	pop    %esi
c002e2af:	c3                   	ret    

c002e2b0 <dir_get_inode>:
    return dir->inode;
c002e2b0:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e2b4:	8b 00                	mov    (%eax),%eax
}
c002e2b6:	c3                   	ret    

c002e2b7 <dir_lookup>:
   and returns true if one exists, false otherwise.
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool
dir_lookup(const struct dir *dir, const char *name,
           struct inode **inode) {
c002e2b7:	56                   	push   %esi
c002e2b8:	53                   	push   %ebx
c002e2b9:	83 ec 24             	sub    $0x24,%esp
c002e2bc:	e8 82 1e 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e2c1:	81 c3 eb f9 00 00    	add    $0xf9eb,%ebx
c002e2c7:	8b 44 24 30          	mov    0x30(%esp),%eax
c002e2cb:	8b 54 24 34          	mov    0x34(%esp),%edx
c002e2cf:	8b 74 24 38          	mov    0x38(%esp),%esi
    struct dir_entry e;

    ASSERT (dir != NULL);
c002e2d3:	85 c0                	test   %eax,%eax
c002e2d5:	74 2b                	je     c002e302 <dir_lookup+0x4b>
    ASSERT (name != NULL);
c002e2d7:	85 d2                	test   %edx,%edx
c002e2d9:	74 4d                	je     c002e328 <dir_lookup+0x71>

    if (lookup(dir, name, &e, NULL))
c002e2db:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002e2df:	83 ec 0c             	sub    $0xc,%esp
c002e2e2:	6a 00                	push   $0x0
c002e2e4:	e8 b7 fd ff ff       	call   c002e0a0 <lookup>
c002e2e9:	83 c4 10             	add    $0x10,%esp
c002e2ec:	84 c0                	test   %al,%al
c002e2ee:	75 5e                	jne    c002e34e <dir_lookup+0x97>
        *inode = inode_open(e.inode_sector);
    else
        *inode = NULL;
c002e2f0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)

    return *inode != NULL;
c002e2f6:	83 3e 00             	cmpl   $0x0,(%esi)
c002e2f9:	0f 95 c0             	setne  %al
}
c002e2fc:	83 c4 24             	add    $0x24,%esp
c002e2ff:	5b                   	pop    %ebx
c002e300:	5e                   	pop    %esi
c002e301:	c3                   	ret    
    ASSERT (dir != NULL);
c002e302:	83 ec 0c             	sub    $0xc,%esp
c002e305:	8d 83 ec 5a ff ff    	lea    -0xa514(%ebx),%eax
c002e30b:	50                   	push   %eax
c002e30c:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e312:	50                   	push   %eax
c002e313:	8d 83 fc 34 ff ff    	lea    -0xcb04(%ebx),%eax
c002e319:	50                   	push   %eax
c002e31a:	6a 6d                	push   $0x6d
c002e31c:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e322:	50                   	push   %eax
c002e323:	e8 05 ae ff ff       	call   c002912d <debug_panic>
    ASSERT (name != NULL);
c002e328:	83 ec 0c             	sub    $0xc,%esp
c002e32b:	8d 83 08 3e ff ff    	lea    -0xc1f8(%ebx),%eax
c002e331:	50                   	push   %eax
c002e332:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e338:	50                   	push   %eax
c002e339:	8d 83 fc 34 ff ff    	lea    -0xcb04(%ebx),%eax
c002e33f:	50                   	push   %eax
c002e340:	6a 6e                	push   $0x6e
c002e342:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e348:	50                   	push   %eax
c002e349:	e8 df ad ff ff       	call   c002912d <debug_panic>
        *inode = inode_open(e.inode_sector);
c002e34e:	83 ec 0c             	sub    $0xc,%esp
c002e351:	ff 74 24 18          	pushl  0x18(%esp)
c002e355:	e8 21 04 00 00       	call   c002e77b <inode_open>
c002e35a:	89 06                	mov    %eax,(%esi)
c002e35c:	83 c4 10             	add    $0x10,%esp
c002e35f:	eb 95                	jmp    c002e2f6 <dir_lookup+0x3f>

c002e361 <dir_add>:
   INODE_SECTOR.
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool
dir_add(struct dir *dir, const char *name, block_sector_t inode_sector) {
c002e361:	55                   	push   %ebp
c002e362:	57                   	push   %edi
c002e363:	56                   	push   %esi
c002e364:	53                   	push   %ebx
c002e365:	83 ec 2c             	sub    $0x2c,%esp
c002e368:	e8 d6 1d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e36d:	81 c3 3f f9 00 00    	add    $0xf93f,%ebx
c002e373:	8b 6c 24 40          	mov    0x40(%esp),%ebp
    struct dir_entry e;
    off_t ofs;
    bool success = false;

    ASSERT (dir != NULL);
c002e377:	85 ed                	test   %ebp,%ebp
c002e379:	74 34                	je     c002e3af <dir_add+0x4e>
    ASSERT (name != NULL);
c002e37b:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
c002e380:	74 56                	je     c002e3d8 <dir_add+0x77>

    /* Check NAME for validity. */
    if (*name == '\0' || strlen(name) > NAME_MAX)
        return false;
c002e382:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*name == '\0' || strlen(name) > NAME_MAX)
c002e387:	8b 54 24 44          	mov    0x44(%esp),%edx
c002e38b:	80 3a 00             	cmpb   $0x0,(%edx)
c002e38e:	74 17                	je     c002e3a7 <dir_add+0x46>
c002e390:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002e395:	89 d7                	mov    %edx,%edi
c002e397:	f2 ae                	repnz scas %es:(%edi),%al
c002e399:	89 ca                	mov    %ecx,%edx
c002e39b:	f7 d2                	not    %edx
c002e39d:	89 d1                	mov    %edx,%ecx
c002e39f:	83 e9 01             	sub    $0x1,%ecx
c002e3a2:	83 f9 0e             	cmp    $0xe,%ecx
c002e3a5:	76 5a                	jbe    c002e401 <dir_add+0xa0>
    e.inode_sector = inode_sector;
    success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;

    done:
    return success;
}
c002e3a7:	83 c4 2c             	add    $0x2c,%esp
c002e3aa:	5b                   	pop    %ebx
c002e3ab:	5e                   	pop    %esi
c002e3ac:	5f                   	pop    %edi
c002e3ad:	5d                   	pop    %ebp
c002e3ae:	c3                   	ret    
    ASSERT (dir != NULL);
c002e3af:	83 ec 0c             	sub    $0xc,%esp
c002e3b2:	8d 83 ec 5a ff ff    	lea    -0xa514(%ebx),%eax
c002e3b8:	50                   	push   %eax
c002e3b9:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e3bf:	50                   	push   %eax
c002e3c0:	8d 83 ec 34 ff ff    	lea    -0xcb14(%ebx),%eax
c002e3c6:	50                   	push   %eax
c002e3c7:	68 84 00 00 00       	push   $0x84
c002e3cc:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e3d2:	50                   	push   %eax
c002e3d3:	e8 55 ad ff ff       	call   c002912d <debug_panic>
    ASSERT (name != NULL);
c002e3d8:	83 ec 0c             	sub    $0xc,%esp
c002e3db:	8d 83 08 3e ff ff    	lea    -0xc1f8(%ebx),%eax
c002e3e1:	50                   	push   %eax
c002e3e2:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e3e8:	50                   	push   %eax
c002e3e9:	8d 83 ec 34 ff ff    	lea    -0xcb14(%ebx),%eax
c002e3ef:	50                   	push   %eax
c002e3f0:	68 85 00 00 00       	push   $0x85
c002e3f5:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e3fb:	50                   	push   %eax
c002e3fc:	e8 2c ad ff ff       	call   c002912d <debug_panic>
    if (lookup(dir, name, NULL, NULL))
c002e401:	83 ec 0c             	sub    $0xc,%esp
c002e404:	6a 00                	push   $0x0
c002e406:	b9 00 00 00 00       	mov    $0x0,%ecx
c002e40b:	8b 54 24 54          	mov    0x54(%esp),%edx
c002e40f:	89 e8                	mov    %ebp,%eax
c002e411:	e8 8a fc ff ff       	call   c002e0a0 <lookup>
c002e416:	89 c2                	mov    %eax,%edx
c002e418:	83 c4 10             	add    $0x10,%esp
    bool success = false;
c002e41b:	b8 00 00 00 00       	mov    $0x0,%eax
    if (lookup(dir, name, NULL, NULL))
c002e420:	84 d2                	test   %dl,%dl
c002e422:	75 83                	jne    c002e3a7 <dir_add+0x46>
    for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e424:	be 00 00 00 00       	mov    $0x0,%esi
c002e429:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002e42d:	56                   	push   %esi
c002e42e:	6a 14                	push   $0x14
c002e430:	57                   	push   %edi
c002e431:	ff 75 00             	pushl  0x0(%ebp)
c002e434:	e8 ce 04 00 00       	call   c002e907 <inode_read_at>
c002e439:	83 c4 10             	add    $0x10,%esp
c002e43c:	83 f8 14             	cmp    $0x14,%eax
c002e43f:	75 0c                	jne    c002e44d <dir_add+0xec>
        if (!e.in_use)
c002e441:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c002e446:	74 05                	je     c002e44d <dir_add+0xec>
c002e448:	83 c6 14             	add    $0x14,%esi
c002e44b:	eb e0                	jmp    c002e42d <dir_add+0xcc>
    e.in_use = true;
c002e44d:	c6 44 24 1f 01       	movb   $0x1,0x1f(%esp)
    strlcpy(e.name, name, sizeof e.name);
c002e452:	83 ec 04             	sub    $0x4,%esp
c002e455:	6a 0f                	push   $0xf
c002e457:	ff 74 24 4c          	pushl  0x4c(%esp)
c002e45b:	8d 7c 24 18          	lea    0x18(%esp),%edi
c002e45f:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002e463:	50                   	push   %eax
c002e464:	e8 06 a3 ff ff       	call   c002876f <strlcpy>
    e.inode_sector = inode_sector;
c002e469:	8b 44 24 58          	mov    0x58(%esp),%eax
c002e46d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e471:	56                   	push   %esi
c002e472:	6a 14                	push   $0x14
c002e474:	57                   	push   %edi
c002e475:	ff 75 00             	pushl  0x0(%ebp)
c002e478:	e8 11 06 00 00       	call   c002ea8e <inode_write_at>
c002e47d:	83 c4 20             	add    $0x20,%esp
c002e480:	83 f8 14             	cmp    $0x14,%eax
c002e483:	0f 94 c0             	sete   %al
c002e486:	e9 1c ff ff ff       	jmp    c002e3a7 <dir_add+0x46>

c002e48b <dir_remove>:

/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool
dir_remove(struct dir *dir, const char *name) {
c002e48b:	55                   	push   %ebp
c002e48c:	57                   	push   %edi
c002e48d:	56                   	push   %esi
c002e48e:	53                   	push   %ebx
c002e48f:	83 ec 2c             	sub    $0x2c,%esp
c002e492:	e8 ac 1c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e497:	81 c3 15 f8 00 00    	add    $0xf815,%ebx
c002e49d:	8b 7c 24 40          	mov    0x40(%esp),%edi
c002e4a1:	8b 54 24 44          	mov    0x44(%esp),%edx
    struct dir_entry e;
    struct inode *inode = NULL;
    bool success = false;
    off_t ofs;

    ASSERT (dir != NULL);
c002e4a5:	85 ff                	test   %edi,%edi
c002e4a7:	74 38                	je     c002e4e1 <dir_remove+0x56>
    ASSERT (name != NULL);
c002e4a9:	85 d2                	test   %edx,%edx
c002e4ab:	74 5d                	je     c002e50a <dir_remove+0x7f>

    /* Find directory entry. */
    if (!lookup(dir, name, &e, &ofs))
c002e4ad:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002e4b1:	83 ec 0c             	sub    $0xc,%esp
c002e4b4:	8d 44 24 14          	lea    0x14(%esp),%eax
c002e4b8:	50                   	push   %eax
c002e4b9:	89 f8                	mov    %edi,%eax
c002e4bb:	e8 e0 fb ff ff       	call   c002e0a0 <lookup>
c002e4c0:	89 c6                	mov    %eax,%esi
c002e4c2:	83 c4 10             	add    $0x10,%esp
    struct inode *inode = NULL;
c002e4c5:	bd 00 00 00 00       	mov    $0x0,%ebp
    if (!lookup(dir, name, &e, &ofs))
c002e4ca:	84 c0                	test   %al,%al
c002e4cc:	75 65                	jne    c002e533 <dir_remove+0xa8>
    /* Remove inode. */
    inode_remove(inode);
    success = true;

    done:
    inode_close(inode);
c002e4ce:	83 ec 0c             	sub    $0xc,%esp
c002e4d1:	55                   	push   %ebp
c002e4d2:	e8 69 03 00 00       	call   c002e840 <inode_close>
    return success;
}
c002e4d7:	89 f0                	mov    %esi,%eax
c002e4d9:	83 c4 3c             	add    $0x3c,%esp
c002e4dc:	5b                   	pop    %ebx
c002e4dd:	5e                   	pop    %esi
c002e4de:	5f                   	pop    %edi
c002e4df:	5d                   	pop    %ebp
c002e4e0:	c3                   	ret    
    ASSERT (dir != NULL);
c002e4e1:	83 ec 0c             	sub    $0xc,%esp
c002e4e4:	8d 83 ec 5a ff ff    	lea    -0xa514(%ebx),%eax
c002e4ea:	50                   	push   %eax
c002e4eb:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e4f1:	50                   	push   %eax
c002e4f2:	8d 83 e0 34 ff ff    	lea    -0xcb20(%ebx),%eax
c002e4f8:	50                   	push   %eax
c002e4f9:	68 af 00 00 00       	push   $0xaf
c002e4fe:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e504:	50                   	push   %eax
c002e505:	e8 23 ac ff ff       	call   c002912d <debug_panic>
    ASSERT (name != NULL);
c002e50a:	83 ec 0c             	sub    $0xc,%esp
c002e50d:	8d 83 08 3e ff ff    	lea    -0xc1f8(%ebx),%eax
c002e513:	50                   	push   %eax
c002e514:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e51a:	50                   	push   %eax
c002e51b:	8d 83 e0 34 ff ff    	lea    -0xcb20(%ebx),%eax
c002e521:	50                   	push   %eax
c002e522:	68 b0 00 00 00       	push   $0xb0
c002e527:	8d 83 f8 5a ff ff    	lea    -0xa508(%ebx),%eax
c002e52d:	50                   	push   %eax
c002e52e:	e8 fa ab ff ff       	call   c002912d <debug_panic>
    inode = inode_open(e.inode_sector);
c002e533:	83 ec 0c             	sub    $0xc,%esp
c002e536:	ff 74 24 18          	pushl  0x18(%esp)
c002e53a:	e8 3c 02 00 00       	call   c002e77b <inode_open>
c002e53f:	89 c5                	mov    %eax,%ebp
    if (inode == NULL)
c002e541:	83 c4 10             	add    $0x10,%esp
c002e544:	85 c0                	test   %eax,%eax
c002e546:	74 3a                	je     c002e582 <dir_remove+0xf7>
    e.in_use = false;
c002e548:	c6 44 24 1f 00       	movb   $0x0,0x1f(%esp)
    if (inode_write_at(dir->inode, &e, sizeof e, ofs) != sizeof e)
c002e54d:	ff 74 24 08          	pushl  0x8(%esp)
c002e551:	6a 14                	push   $0x14
c002e553:	8d 44 24 14          	lea    0x14(%esp),%eax
c002e557:	50                   	push   %eax
c002e558:	ff 37                	pushl  (%edi)
c002e55a:	e8 2f 05 00 00       	call   c002ea8e <inode_write_at>
c002e55f:	83 c4 10             	add    $0x10,%esp
c002e562:	83 f8 14             	cmp    $0x14,%eax
c002e565:	74 0a                	je     c002e571 <dir_remove+0xe6>
    bool success = false;
c002e567:	be 00 00 00 00       	mov    $0x0,%esi
c002e56c:	e9 5d ff ff ff       	jmp    c002e4ce <dir_remove+0x43>
    inode_remove(inode);
c002e571:	83 ec 0c             	sub    $0xc,%esp
c002e574:	55                   	push   %ebp
c002e575:	e8 44 03 00 00       	call   c002e8be <inode_remove>
c002e57a:	83 c4 10             	add    $0x10,%esp
c002e57d:	e9 4c ff ff ff       	jmp    c002e4ce <dir_remove+0x43>
    bool success = false;
c002e582:	be 00 00 00 00       	mov    $0x0,%esi
c002e587:	e9 42 ff ff ff       	jmp    c002e4ce <dir_remove+0x43>

c002e58c <dir_readdir>:

/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool
dir_readdir(struct dir *dir, char name[NAME_MAX + 1]) {
c002e58c:	55                   	push   %ebp
c002e58d:	57                   	push   %edi
c002e58e:	56                   	push   %esi
c002e58f:	53                   	push   %ebx
c002e590:	83 ec 2c             	sub    $0x2c,%esp
c002e593:	e8 ab 1b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e598:	81 c3 14 f7 00 00    	add    $0xf714,%ebx
c002e59e:	8b 74 24 40          	mov    0x40(%esp),%esi
    struct dir_entry e;

    while (inode_read_at(dir->inode, &e, sizeof e, dir->pos) == sizeof e) {
c002e5a2:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c002e5a6:	ff 76 04             	pushl  0x4(%esi)
c002e5a9:	6a 14                	push   $0x14
c002e5ab:	55                   	push   %ebp
c002e5ac:	ff 36                	pushl  (%esi)
c002e5ae:	e8 54 03 00 00       	call   c002e907 <inode_read_at>
c002e5b3:	83 c4 10             	add    $0x10,%esp
c002e5b6:	83 f8 14             	cmp    $0x14,%eax
c002e5b9:	75 27                	jne    c002e5e2 <dir_readdir+0x56>
        dir->pos += sizeof e;
c002e5bb:	83 46 04 14          	addl   $0x14,0x4(%esi)
        if (e.in_use) {
c002e5bf:	0f b6 7c 24 1f       	movzbl 0x1f(%esp),%edi
c002e5c4:	89 f8                	mov    %edi,%eax
c002e5c6:	84 c0                	test   %al,%al
c002e5c8:	74 dc                	je     c002e5a6 <dir_readdir+0x1a>
            strlcpy(name, e.name, NAME_MAX + 1);
c002e5ca:	83 ec 04             	sub    $0x4,%esp
c002e5cd:	6a 0f                	push   $0xf
c002e5cf:	8d 44 24 18          	lea    0x18(%esp),%eax
c002e5d3:	50                   	push   %eax
c002e5d4:	ff 74 24 50          	pushl  0x50(%esp)
c002e5d8:	e8 92 a1 ff ff       	call   c002876f <strlcpy>
            return true;
c002e5dd:	83 c4 10             	add    $0x10,%esp
c002e5e0:	eb 05                	jmp    c002e5e7 <dir_readdir+0x5b>
        }
    }
    return false;
c002e5e2:	bf 00 00 00 00       	mov    $0x0,%edi
}
c002e5e7:	89 f8                	mov    %edi,%eax
c002e5e9:	83 c4 2c             	add    $0x2c,%esp
c002e5ec:	5b                   	pop    %ebx
c002e5ed:	5e                   	pop    %esi
c002e5ee:	5f                   	pop    %edi
c002e5ef:	5d                   	pop    %ebp
c002e5f0:	c3                   	ret    

c002e5f1 <byte_to_sector>:
/* Returns the block device sector that contains byte offset POS
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector(const struct inode *inode, off_t pos) {
c002e5f1:	53                   	push   %ebx
c002e5f2:	83 ec 08             	sub    $0x8,%esp
c002e5f5:	e8 49 1b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e5fa:	81 c3 b2 f6 00 00    	add    $0xf6b2,%ebx
    ASSERT (inode != NULL);
c002e600:	85 c0                	test   %eax,%eax
c002e602:	74 22                	je     c002e626 <byte_to_sector+0x35>
    if (pos < inode->data.length)
        return inode->data.start + pos / BLOCK_SECTOR_SIZE;
    else
        return -1;
c002e604:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    if (pos < inode->data.length)
c002e609:	39 50 1c             	cmp    %edx,0x1c(%eax)
c002e60c:	7e 11                	jle    c002e61f <byte_to_sector+0x2e>
        return inode->data.start + pos / BLOCK_SECTOR_SIZE;
c002e60e:	8d 8a ff 01 00 00    	lea    0x1ff(%edx),%ecx
c002e614:	85 d2                	test   %edx,%edx
c002e616:	0f 49 ca             	cmovns %edx,%ecx
c002e619:	c1 f9 09             	sar    $0x9,%ecx
c002e61c:	03 48 18             	add    0x18(%eax),%ecx
}
c002e61f:	89 c8                	mov    %ecx,%eax
c002e621:	83 c4 08             	add    $0x8,%esp
c002e624:	5b                   	pop    %ebx
c002e625:	c3                   	ret    
    ASSERT (inode != NULL);
c002e626:	83 ec 0c             	sub    $0xc,%esp
c002e629:	8d 83 12 5b ff ff    	lea    -0xa4ee(%ebx),%eax
c002e62f:	50                   	push   %eax
c002e630:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e636:	50                   	push   %eax
c002e637:	8d 83 30 35 ff ff    	lea    -0xcad0(%ebx),%eax
c002e63d:	50                   	push   %eax
c002e63e:	6a 2d                	push   $0x2d
c002e640:	8d 83 20 5b ff ff    	lea    -0xa4e0(%ebx),%eax
c002e646:	50                   	push   %eax
c002e647:	e8 e1 aa ff ff       	call   c002912d <debug_panic>

c002e64c <inode_init>:
   returns the same `struct inode'. */
static struct list open_inodes;

/* Initializes the inode module. */
void
inode_init(void) {
c002e64c:	53                   	push   %ebx
c002e64d:	83 ec 14             	sub    $0x14,%esp
c002e650:	e8 ee 1a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e655:	81 c3 57 f6 00 00    	add    $0xf657,%ebx
    list_init(&open_inodes);
c002e65b:	8d 83 34 1f 00 00    	lea    0x1f34(%ebx),%eax
c002e661:	50                   	push   %eax
c002e662:	e8 93 ab ff ff       	call   c00291fa <list_init>
}
c002e667:	83 c4 18             	add    $0x18,%esp
c002e66a:	5b                   	pop    %ebx
c002e66b:	c3                   	ret    

c002e66c <inode_create>:
   writes the new inode to sector SECTOR on the file system
   device.
   Returns true if successful.
   Returns false if memory or disk allocation fails. */
bool
inode_create(block_sector_t sector, off_t length) {
c002e66c:	55                   	push   %ebp
c002e66d:	57                   	push   %edi
c002e66e:	56                   	push   %esi
c002e66f:	53                   	push   %ebx
c002e670:	83 ec 1c             	sub    $0x1c,%esp
c002e673:	e8 cb 1a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e678:	81 c3 34 f6 00 00    	add    $0xf634,%ebx
c002e67e:	8b 7c 24 34          	mov    0x34(%esp),%edi
    struct inode_disk *disk_inode = NULL;
    bool success = false;

    ASSERT (length >= 0);
c002e682:	85 ff                	test   %edi,%edi
c002e684:	78 6c                	js     c002e6f2 <inode_create+0x86>

    /* If this assertion fails, the inode structure is not exactly
       one sector in size, and you should fix that. */
    ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

    disk_inode = calloc(1, sizeof *disk_inode);
c002e686:	83 ec 08             	sub    $0x8,%esp
c002e689:	68 00 02 00 00       	push   $0x200
c002e68e:	6a 01                	push   $0x1
c002e690:	e8 16 59 ff ff       	call   c0023fab <calloc>
c002e695:	89 c6                	mov    %eax,%esi
    if (disk_inode != NULL) {
c002e697:	83 c4 10             	add    $0x10,%esp
    bool success = false;
c002e69a:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
    if (disk_inode != NULL) {
c002e69f:	85 c0                	test   %eax,%eax
c002e6a1:	74 42                	je     c002e6e5 <inode_create+0x79>
    return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002e6a3:	8d af fe 03 00 00    	lea    0x3fe(%edi),%ebp
c002e6a9:	89 f8                	mov    %edi,%eax
c002e6ab:	05 ff 01 00 00       	add    $0x1ff,%eax
c002e6b0:	0f 49 e8             	cmovns %eax,%ebp
c002e6b3:	c1 fd 09             	sar    $0x9,%ebp
c002e6b6:	89 6c 24 08          	mov    %ebp,0x8(%esp)
        size_t sectors = bytes_to_sectors(length);
        disk_inode->length = length;
c002e6ba:	89 7e 04             	mov    %edi,0x4(%esi)
        disk_inode->magic = INODE_MAGIC;
c002e6bd:	c7 46 08 44 4f 4e 49 	movl   $0x494e4f44,0x8(%esi)
        if (free_map_allocate(sectors, &disk_inode->start)) {
c002e6c4:	83 ec 08             	sub    $0x8,%esp
c002e6c7:	56                   	push   %esi
c002e6c8:	55                   	push   %ebp
c002e6c9:	e8 4c f4 ff ff       	call   c002db1a <free_map_allocate>
c002e6ce:	88 44 24 17          	mov    %al,0x17(%esp)
c002e6d2:	83 c4 10             	add    $0x10,%esp
c002e6d5:	84 c0                	test   %al,%al
c002e6d7:	75 3f                	jne    c002e718 <inode_create+0xac>
                for (i = 0; i < sectors; i++)
                    block_write(fs_device, disk_inode->start + i, zeros);
            }
            success = true;
        }
        free(disk_inode);
c002e6d9:	83 ec 0c             	sub    $0xc,%esp
c002e6dc:	56                   	push   %esi
c002e6dd:	e8 1a 59 ff ff       	call   c0023ffc <free>
c002e6e2:	83 c4 10             	add    $0x10,%esp
    }
    return success;
}
c002e6e5:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c002e6ea:	83 c4 1c             	add    $0x1c,%esp
c002e6ed:	5b                   	pop    %ebx
c002e6ee:	5e                   	pop    %esi
c002e6ef:	5f                   	pop    %edi
c002e6f0:	5d                   	pop    %ebp
c002e6f1:	c3                   	ret    
    ASSERT (length >= 0);
c002e6f2:	83 ec 0c             	sub    $0xc,%esp
c002e6f5:	8d 83 36 5b ff ff    	lea    -0xa4ca(%ebx),%eax
c002e6fb:	50                   	push   %eax
c002e6fc:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e702:	50                   	push   %eax
c002e703:	8d 83 50 35 ff ff    	lea    -0xcab0(%ebx),%eax
c002e709:	50                   	push   %eax
c002e70a:	6a 48                	push   $0x48
c002e70c:	8d 83 20 5b ff ff    	lea    -0xa4e0(%ebx),%eax
c002e712:	50                   	push   %eax
c002e713:	e8 15 aa ff ff       	call   c002912d <debug_panic>
            block_write(fs_device, sector, disk_inode);
c002e718:	83 ec 04             	sub    $0x4,%esp
c002e71b:	56                   	push   %esi
c002e71c:	ff 74 24 38          	pushl  0x38(%esp)
c002e720:	c7 c0 d0 fc 03 c0    	mov    $0xc003fcd0,%eax
c002e726:	ff 30                	pushl  (%eax)
c002e728:	e8 b1 6b ff ff       	call   c00252de <block_write>
            if (sectors > 0) {
c002e72d:	83 c4 10             	add    $0x10,%esp
c002e730:	85 ed                	test   %ebp,%ebp
c002e732:	74 a5                	je     c002e6d9 <inode_create+0x6d>
                for (i = 0; i < sectors; i++)
c002e734:	bf 00 00 00 00       	mov    $0x0,%edi
                    block_write(fs_device, disk_inode->start + i, zeros);
c002e739:	8d ab 34 1d 00 00    	lea    0x1d34(%ebx),%ebp
c002e73f:	c7 c0 d0 fc 03 c0    	mov    $0xc003fcd0,%eax
c002e745:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002e749:	83 ec 04             	sub    $0x4,%esp
c002e74c:	55                   	push   %ebp
c002e74d:	89 f8                	mov    %edi,%eax
c002e74f:	03 06                	add    (%esi),%eax
c002e751:	50                   	push   %eax
c002e752:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e756:	ff 30                	pushl  (%eax)
c002e758:	e8 81 6b ff ff       	call   c00252de <block_write>
                for (i = 0; i < sectors; i++)
c002e75d:	83 c7 01             	add    $0x1,%edi
c002e760:	83 c4 10             	add    $0x10,%esp
c002e763:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002e767:	75 e0                	jne    c002e749 <inode_create+0xdd>
c002e769:	e9 6b ff ff ff       	jmp    c002e6d9 <inode_create+0x6d>

c002e76e <inode_reopen>:
    return inode;
}

/* Reopens and returns INODE. */
struct inode *
inode_reopen(struct inode *inode) {
c002e76e:	8b 44 24 04          	mov    0x4(%esp),%eax
    if (inode != NULL)
c002e772:	85 c0                	test   %eax,%eax
c002e774:	74 04                	je     c002e77a <inode_reopen+0xc>
        inode->open_cnt++;
c002e776:	83 40 0c 01          	addl   $0x1,0xc(%eax)
    return inode;
}
c002e77a:	c3                   	ret    

c002e77b <inode_open>:
inode_open(block_sector_t sector) {
c002e77b:	55                   	push   %ebp
c002e77c:	57                   	push   %edi
c002e77d:	56                   	push   %esi
c002e77e:	53                   	push   %ebx
c002e77f:	83 ec 18             	sub    $0x18,%esp
c002e782:	e8 bc 19 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e787:	81 c3 25 f5 00 00    	add    $0xf525,%ebx
c002e78d:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    for (e = list_begin(&open_inodes); e != list_end(&open_inodes);
c002e791:	8d 83 34 1f 00 00    	lea    0x1f34(%ebx),%eax
c002e797:	50                   	push   %eax
c002e798:	e8 b5 aa ff ff       	call   c0029252 <list_begin>
c002e79d:	89 c6                	mov    %eax,%esi
c002e79f:	83 c4 10             	add    $0x10,%esp
c002e7a2:	8d ab 34 1f 00 00    	lea    0x1f34(%ebx),%ebp
c002e7a8:	83 ec 0c             	sub    $0xc,%esp
c002e7ab:	55                   	push   %ebp
c002e7ac:	e8 43 ab ff ff       	call   c00292f4 <list_end>
c002e7b1:	83 c4 10             	add    $0x10,%esp
c002e7b4:	39 f0                	cmp    %esi,%eax
c002e7b6:	74 2b                	je     c002e7e3 <inode_open+0x68>
        if (inode->sector == sector) {
c002e7b8:	39 7e 08             	cmp    %edi,0x8(%esi)
c002e7bb:	74 10                	je     c002e7cd <inode_open+0x52>
         e = list_next(e)) {
c002e7bd:	83 ec 0c             	sub    $0xc,%esp
c002e7c0:	56                   	push   %esi
c002e7c1:	e8 d1 aa ff ff       	call   c0029297 <list_next>
c002e7c6:	89 c6                	mov    %eax,%esi
c002e7c8:	83 c4 10             	add    $0x10,%esp
c002e7cb:	eb db                	jmp    c002e7a8 <inode_open+0x2d>
            inode_reopen(inode);
c002e7cd:	83 ec 0c             	sub    $0xc,%esp
c002e7d0:	56                   	push   %esi
c002e7d1:	e8 98 ff ff ff       	call   c002e76e <inode_reopen>
            return inode;
c002e7d6:	83 c4 10             	add    $0x10,%esp
}
c002e7d9:	89 f0                	mov    %esi,%eax
c002e7db:	83 c4 0c             	add    $0xc,%esp
c002e7de:	5b                   	pop    %ebx
c002e7df:	5e                   	pop    %esi
c002e7e0:	5f                   	pop    %edi
c002e7e1:	5d                   	pop    %ebp
c002e7e2:	c3                   	ret    
    inode = malloc(sizeof *inode);
c002e7e3:	83 ec 0c             	sub    $0xc,%esp
c002e7e6:	68 18 02 00 00       	push   $0x218
c002e7eb:	e8 5e 56 ff ff       	call   c0023e4e <malloc>
c002e7f0:	89 c6                	mov    %eax,%esi
    if (inode == NULL)
c002e7f2:	83 c4 10             	add    $0x10,%esp
c002e7f5:	85 c0                	test   %eax,%eax
c002e7f7:	74 e0                	je     c002e7d9 <inode_open+0x5e>
    list_push_front(&open_inodes, &inode->elem);
c002e7f9:	83 ec 08             	sub    $0x8,%esp
c002e7fc:	50                   	push   %eax
c002e7fd:	8d 83 34 1f 00 00    	lea    0x1f34(%ebx),%eax
c002e803:	50                   	push   %eax
c002e804:	e8 b9 af ff ff       	call   c00297c2 <list_push_front>
    inode->sector = sector;
c002e809:	89 7e 08             	mov    %edi,0x8(%esi)
    inode->open_cnt = 1;
c002e80c:	c7 46 0c 01 00 00 00 	movl   $0x1,0xc(%esi)
    inode->deny_write_cnt = 0;
c002e813:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
    inode->removed = false;
c002e81a:	c6 46 10 00          	movb   $0x0,0x10(%esi)
    block_read(fs_device, inode->sector, &inode->data);
c002e81e:	83 c4 0c             	add    $0xc,%esp
c002e821:	8d 46 18             	lea    0x18(%esi),%eax
c002e824:	50                   	push   %eax
c002e825:	57                   	push   %edi
c002e826:	c7 c0 d0 fc 03 c0    	mov    $0xc003fcd0,%eax
c002e82c:	ff 30                	pushl  (%eax)
c002e82e:	e8 77 6a ff ff       	call   c00252aa <block_read>
    return inode;
c002e833:	83 c4 10             	add    $0x10,%esp
c002e836:	eb a1                	jmp    c002e7d9 <inode_open+0x5e>

c002e838 <inode_get_inumber>:

/* Returns INODE's inode number. */
block_sector_t
inode_get_inumber(const struct inode *inode) {
    return inode->sector;
c002e838:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e83c:	8b 40 08             	mov    0x8(%eax),%eax
}
c002e83f:	c3                   	ret    

c002e840 <inode_close>:

/* Closes INODE and writes it to disk.
   If this was the last reference to INODE, frees its memory.
   If INODE was also a removed inode, frees its blocks. */
void
inode_close(struct inode *inode) {
c002e840:	56                   	push   %esi
c002e841:	53                   	push   %ebx
c002e842:	83 ec 04             	sub    $0x4,%esp
c002e845:	e8 f9 18 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e84a:	81 c3 62 f4 00 00    	add    $0xf462,%ebx
c002e850:	8b 74 24 10          	mov    0x10(%esp),%esi
    /* Ignore null pointer. */
    if (inode == NULL)
c002e854:	85 f6                	test   %esi,%esi
c002e856:	74 0b                	je     c002e863 <inode_close+0x23>
        return;

    /* Release resources if this was the last opener. */
    if (--inode->open_cnt == 0) {
c002e858:	8b 46 0c             	mov    0xc(%esi),%eax
c002e85b:	83 e8 01             	sub    $0x1,%eax
c002e85e:	89 46 0c             	mov    %eax,0xc(%esi)
c002e861:	74 06                	je     c002e869 <inode_close+0x29>
                             bytes_to_sectors(inode->data.length));
        }

        free(inode);
    }
}
c002e863:	83 c4 04             	add    $0x4,%esp
c002e866:	5b                   	pop    %ebx
c002e867:	5e                   	pop    %esi
c002e868:	c3                   	ret    
        list_remove(&inode->elem);
c002e869:	83 ec 0c             	sub    $0xc,%esp
c002e86c:	56                   	push   %esi
c002e86d:	e8 8a af ff ff       	call   c00297fc <list_remove>
        if (inode->removed) {
c002e872:	83 c4 10             	add    $0x10,%esp
c002e875:	80 7e 10 00          	cmpb   $0x0,0x10(%esi)
c002e879:	75 0e                	jne    c002e889 <inode_close+0x49>
        free(inode);
c002e87b:	83 ec 0c             	sub    $0xc,%esp
c002e87e:	56                   	push   %esi
c002e87f:	e8 78 57 ff ff       	call   c0023ffc <free>
c002e884:	83 c4 10             	add    $0x10,%esp
c002e887:	eb da                	jmp    c002e863 <inode_close+0x23>
            free_map_release(inode->sector, 1);
c002e889:	83 ec 08             	sub    $0x8,%esp
c002e88c:	6a 01                	push   $0x1
c002e88e:	ff 76 08             	pushl  0x8(%esi)
c002e891:	e8 f9 f2 ff ff       	call   c002db8f <free_map_release>
            free_map_release(inode->data.start,
c002e896:	83 c4 08             	add    $0x8,%esp
    return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002e899:	8b 56 1c             	mov    0x1c(%esi),%edx
c002e89c:	8d 8a ff 01 00 00    	lea    0x1ff(%edx),%ecx
c002e8a2:	8d 82 fe 03 00 00    	lea    0x3fe(%edx),%eax
c002e8a8:	85 c9                	test   %ecx,%ecx
c002e8aa:	0f 49 c1             	cmovns %ecx,%eax
c002e8ad:	c1 f8 09             	sar    $0x9,%eax
            free_map_release(inode->data.start,
c002e8b0:	50                   	push   %eax
c002e8b1:	ff 76 18             	pushl  0x18(%esi)
c002e8b4:	e8 d6 f2 ff ff       	call   c002db8f <free_map_release>
c002e8b9:	83 c4 10             	add    $0x10,%esp
c002e8bc:	eb bd                	jmp    c002e87b <inode_close+0x3b>

c002e8be <inode_remove>:

/* Marks INODE to be deleted when it is closed by the last caller who
   has it open. */
void
inode_remove(struct inode *inode) {
c002e8be:	53                   	push   %ebx
c002e8bf:	83 ec 08             	sub    $0x8,%esp
c002e8c2:	e8 7c 18 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e8c7:	81 c3 e5 f3 00 00    	add    $0xf3e5,%ebx
c002e8cd:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (inode != NULL);
c002e8d1:	85 c0                	test   %eax,%eax
c002e8d3:	74 09                	je     c002e8de <inode_remove+0x20>
    inode->removed = true;
c002e8d5:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c002e8d9:	83 c4 08             	add    $0x8,%esp
c002e8dc:	5b                   	pop    %ebx
c002e8dd:	c3                   	ret    
    ASSERT (inode != NULL);
c002e8de:	83 ec 0c             	sub    $0xc,%esp
c002e8e1:	8d 83 12 5b ff ff    	lea    -0xa4ee(%ebx),%eax
c002e8e7:	50                   	push   %eax
c002e8e8:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002e8ee:	50                   	push   %eax
c002e8ef:	8d 83 40 35 ff ff    	lea    -0xcac0(%ebx),%eax
c002e8f5:	50                   	push   %eax
c002e8f6:	68 af 00 00 00       	push   $0xaf
c002e8fb:	8d 83 20 5b ff ff    	lea    -0xa4e0(%ebx),%eax
c002e901:	50                   	push   %eax
c002e902:	e8 26 a8 ff ff       	call   c002912d <debug_panic>

c002e907 <inode_read_at>:

/* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
   Returns the number of bytes actually read, which may be less
   than SIZE if an error occurs or end of file is reached. */
off_t
inode_read_at(struct inode *inode, void *buffer_, off_t size, off_t offset) {
c002e907:	55                   	push   %ebp
c002e908:	89 e5                	mov    %esp,%ebp
c002e90a:	57                   	push   %edi
c002e90b:	56                   	push   %esi
c002e90c:	53                   	push   %ebx
c002e90d:	83 ec 2c             	sub    $0x2c,%esp
c002e910:	e8 2e 18 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002e915:	81 c3 97 f3 00 00    	add    $0xf397,%ebx
    uint8_t *buffer = buffer_;
    off_t bytes_read = 0;
    uint8_t *bounce = NULL;

    while (size > 0) {
c002e91b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e91f:	0f 8e 56 01 00 00    	jle    c002ea7b <inode_read_at+0x174>
    uint8_t *bounce = NULL;
c002e925:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    off_t bytes_read = 0;
c002e92c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            if (bounce == NULL) {
                bounce = malloc(BLOCK_SECTOR_SIZE);
                if (bounce == NULL)
                    break;
            }
            block_read(fs_device, sector_idx, bounce);
c002e933:	c7 c0 d0 fc 03 c0    	mov    $0xc003fcd0,%eax
c002e939:	89 45 d8             	mov    %eax,-0x28(%ebp)
            block_read(fs_device, sector_idx, buffer + bytes_read);
c002e93c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c002e93f:	e9 83 00 00 00       	jmp    c002e9c7 <inode_read_at+0xc0>
c002e944:	83 ec 04             	sub    $0x4,%esp
c002e947:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e94a:	03 45 0c             	add    0xc(%ebp),%eax
c002e94d:	50                   	push   %eax
c002e94e:	57                   	push   %edi
c002e94f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e952:	ff 30                	pushl  (%eax)
c002e954:	e8 51 69 ff ff       	call   c00252aa <block_read>
c002e959:	83 c4 10             	add    $0x10,%esp
c002e95c:	eb 57                	jmp    c002e9b5 <inode_read_at+0xae>
                bounce = malloc(BLOCK_SECTOR_SIZE);
c002e95e:	83 ec 0c             	sub    $0xc,%esp
c002e961:	68 00 02 00 00       	push   $0x200
c002e966:	e8 e3 54 ff ff       	call   c0023e4e <malloc>
c002e96b:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (bounce == NULL)
c002e96e:	83 c4 10             	add    $0x10,%esp
c002e971:	85 c0                	test   %eax,%eax
c002e973:	0f 85 b1 00 00 00    	jne    c002ea2a <inode_read_at+0x123>
        /* Advance. */
        size -= chunk_size;
        offset += chunk_size;
        bytes_read += chunk_size;
    }
    free(bounce);
c002e979:	83 ec 0c             	sub    $0xc,%esp
c002e97c:	ff 75 e0             	pushl  -0x20(%ebp)
c002e97f:	e8 78 56 ff ff       	call   c0023ffc <free>

    return bytes_read;
c002e984:	83 c4 10             	add    $0x10,%esp
}
c002e987:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e98a:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e98d:	5b                   	pop    %ebx
c002e98e:	5e                   	pop    %esi
c002e98f:	5f                   	pop    %edi
c002e990:	5d                   	pop    %ebp
c002e991:	c3                   	ret    
            memcpy(buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002e992:	8b 06                	mov    (%esi),%eax
c002e994:	89 01                	mov    %eax,(%ecx)
c002e996:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e999:	8b 44 32 fc          	mov    -0x4(%edx,%esi,1),%eax
c002e99d:	89 44 0a fc          	mov    %eax,-0x4(%edx,%ecx,1)
c002e9a1:	8d 79 04             	lea    0x4(%ecx),%edi
c002e9a4:	83 e7 fc             	and    $0xfffffffc,%edi
c002e9a7:	29 f9                	sub    %edi,%ecx
c002e9a9:	29 ce                	sub    %ecx,%esi
c002e9ab:	01 d1                	add    %edx,%ecx
c002e9ad:	c1 e9 02             	shr    $0x2,%ecx
c002e9b0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c002e9b2:	83 c4 10             	add    $0x10,%esp
        size -= chunk_size;
c002e9b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e9b8:	29 45 10             	sub    %eax,0x10(%ebp)
        offset += chunk_size;
c002e9bb:	01 45 14             	add    %eax,0x14(%ebp)
        bytes_read += chunk_size;
c002e9be:	01 45 dc             	add    %eax,-0x24(%ebp)
    while (size > 0) {
c002e9c1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e9c5:	7e b2                	jle    c002e979 <inode_read_at+0x72>
        block_sector_t sector_idx = byte_to_sector(inode, offset);
c002e9c7:	8b 55 14             	mov    0x14(%ebp),%edx
c002e9ca:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9cd:	e8 1f fc ff ff       	call   c002e5f1 <byte_to_sector>
c002e9d2:	89 c7                	mov    %eax,%edi
        int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e9d4:	8b 45 14             	mov    0x14(%ebp),%eax
c002e9d7:	c1 f8 1f             	sar    $0x1f,%eax
c002e9da:	c1 e8 17             	shr    $0x17,%eax
c002e9dd:	89 c6                	mov    %eax,%esi
c002e9df:	03 75 14             	add    0x14(%ebp),%esi
c002e9e2:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
c002e9e8:	29 c6                	sub    %eax,%esi
        off_t inode_left = inode_length(inode) - offset;
c002e9ea:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9ed:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e9f0:	2b 45 14             	sub    0x14(%ebp),%eax
        int chunk_size = size < min_left ? size : min_left;
c002e9f3:	3b 45 10             	cmp    0x10(%ebp),%eax
c002e9f6:	0f 4f 45 10          	cmovg  0x10(%ebp),%eax
        int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002e9fa:	ba 00 02 00 00       	mov    $0x200,%edx
c002e9ff:	29 f2                	sub    %esi,%edx
        int chunk_size = size < min_left ? size : min_left;
c002ea01:	39 d0                	cmp    %edx,%eax
c002ea03:	0f 4f c2             	cmovg  %edx,%eax
c002ea06:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (chunk_size <= 0)
c002ea09:	85 c0                	test   %eax,%eax
c002ea0b:	0f 8e 68 ff ff ff    	jle    c002e979 <inode_read_at+0x72>
        if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE) {
c002ea11:	85 f6                	test   %esi,%esi
c002ea13:	75 0b                	jne    c002ea20 <inode_read_at+0x119>
c002ea15:	3d 00 02 00 00       	cmp    $0x200,%eax
c002ea1a:	0f 84 24 ff ff ff    	je     c002e944 <inode_read_at+0x3d>
            if (bounce == NULL) {
c002ea20:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002ea24:	0f 84 34 ff ff ff    	je     c002e95e <inode_read_at+0x57>
            block_read(fs_device, sector_idx, bounce);
c002ea2a:	83 ec 04             	sub    $0x4,%esp
c002ea2d:	ff 75 e0             	pushl  -0x20(%ebp)
c002ea30:	57                   	push   %edi
c002ea31:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c002ea34:	ff 31                	pushl  (%ecx)
c002ea36:	e8 6f 68 ff ff       	call   c00252aa <block_read>
            memcpy(buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002ea3b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c002ea3e:	03 4d 0c             	add    0xc(%ebp),%ecx
c002ea41:	03 75 e0             	add    -0x20(%ebp),%esi
c002ea44:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c002ea47:	83 ff 04             	cmp    $0x4,%edi
c002ea4a:	0f 83 42 ff ff ff    	jae    c002e992 <inode_read_at+0x8b>
c002ea50:	85 ff                	test   %edi,%edi
c002ea52:	0f 84 5a ff ff ff    	je     c002e9b2 <inode_read_at+0xab>
c002ea58:	0f b6 06             	movzbl (%esi),%eax
c002ea5b:	88 01                	mov    %al,(%ecx)
c002ea5d:	f7 c7 02 00 00 00    	test   $0x2,%edi
c002ea63:	0f 84 49 ff ff ff    	je     c002e9b2 <inode_read_at+0xab>
c002ea69:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c002ea6c:	0f b7 44 37 fe       	movzwl -0x2(%edi,%esi,1),%eax
c002ea71:	66 89 44 0f fe       	mov    %ax,-0x2(%edi,%ecx,1)
c002ea76:	e9 37 ff ff ff       	jmp    c002e9b2 <inode_read_at+0xab>
    off_t bytes_read = 0;
c002ea7b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    uint8_t *bounce = NULL;
c002ea82:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c002ea89:	e9 eb fe ff ff       	jmp    c002e979 <inode_read_at+0x72>

c002ea8e <inode_write_at>:
   less than SIZE if end of file is reached or an error occurs.
   (Normally a write at end of file would extend the inode, but
   growth is not yet implemented.) */
off_t
inode_write_at(struct inode *inode, const void *buffer_, off_t size,
               off_t offset) {
c002ea8e:	55                   	push   %ebp
c002ea8f:	57                   	push   %edi
c002ea90:	56                   	push   %esi
c002ea91:	53                   	push   %ebx
c002ea92:	83 ec 2c             	sub    $0x2c,%esp
c002ea95:	e8 a9 16 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ea9a:	81 c3 12 f2 00 00    	add    $0xf212,%ebx
    const uint8_t *buffer = buffer_;
    off_t bytes_written = 0;
    uint8_t *bounce = NULL;

    if (inode->deny_write_cnt)
c002eaa0:	8b 44 24 40          	mov    0x40(%esp),%eax
c002eaa4:	8b 40 14             	mov    0x14(%eax),%eax
c002eaa7:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002eaab:	85 c0                	test   %eax,%eax
c002eaad:	0f 85 bc 01 00 00    	jne    c002ec6f <inode_write_at+0x1e1>
        return 0;

    while (size > 0) {
c002eab3:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002eab8:	0f 8e a4 01 00 00    	jle    c002ec62 <inode_write_at+0x1d4>
    uint8_t *bounce = NULL;
c002eabe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002eac5:	00 
            if (sector_ofs > 0 || chunk_size < sector_left)
                block_read(fs_device, sector_idx, bounce);
            else
                memset(bounce, 0, BLOCK_SECTOR_SIZE);
            memcpy(bounce + sector_ofs, buffer + bytes_written, chunk_size);
            block_write(fs_device, sector_idx, bounce);
c002eac6:	c7 c0 d0 fc 03 c0    	mov    $0xc003fcd0,%eax
c002eacc:	89 44 24 18          	mov    %eax,0x18(%esp)
                block_read(fs_device, sector_idx, bounce);
c002ead0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002ead4:	e9 f0 00 00 00       	jmp    c002ebc9 <inode_write_at+0x13b>
            block_write(fs_device, sector_idx, buffer + bytes_written);
c002ead9:	83 ec 04             	sub    $0x4,%esp
c002eadc:	8b 44 24 10          	mov    0x10(%esp),%eax
c002eae0:	03 44 24 48          	add    0x48(%esp),%eax
c002eae4:	50                   	push   %eax
c002eae5:	52                   	push   %edx
c002eae6:	c7 c0 d0 fc 03 c0    	mov    $0xc003fcd0,%eax
c002eaec:	ff 30                	pushl  (%eax)
c002eaee:	e8 eb 67 ff ff       	call   c00252de <block_write>
c002eaf3:	83 c4 10             	add    $0x10,%esp
c002eaf6:	e9 b7 00 00 00       	jmp    c002ebb2 <inode_write_at+0x124>
                bounce = malloc(BLOCK_SECTOR_SIZE);
c002eafb:	83 ec 0c             	sub    $0xc,%esp
c002eafe:	68 00 02 00 00       	push   $0x200
c002eb03:	e8 46 53 ff ff       	call   c0023e4e <malloc>
c002eb08:	89 44 24 18          	mov    %eax,0x18(%esp)
                if (bounce == NULL)
c002eb0c:	83 c4 10             	add    $0x10,%esp
c002eb0f:	85 c0                	test   %eax,%eax
c002eb11:	0f 85 26 01 00 00    	jne    c002ec3d <inode_write_at+0x1af>
        /* Advance. */
        size -= chunk_size;
        offset += chunk_size;
        bytes_written += chunk_size;
    }
    free(bounce);
c002eb17:	83 ec 0c             	sub    $0xc,%esp
c002eb1a:	ff 74 24 14          	pushl  0x14(%esp)
c002eb1e:	e8 d9 54 ff ff       	call   c0023ffc <free>

    return bytes_written;
c002eb23:	83 c4 10             	add    $0x10,%esp
}
c002eb26:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002eb2a:	83 c4 2c             	add    $0x2c,%esp
c002eb2d:	5b                   	pop    %ebx
c002eb2e:	5e                   	pop    %esi
c002eb2f:	5f                   	pop    %edi
c002eb30:	5d                   	pop    %ebp
c002eb31:	c3                   	ret    
                block_read(fs_device, sector_idx, bounce);
c002eb32:	83 ec 04             	sub    $0x4,%esp
c002eb35:	ff 74 24 0c          	pushl  0xc(%esp)
c002eb39:	ff 74 24 1c          	pushl  0x1c(%esp)
c002eb3d:	8b 44 24 28          	mov    0x28(%esp),%eax
c002eb41:	ff 30                	pushl  (%eax)
c002eb43:	e8 62 67 ff ff       	call   c00252aa <block_read>
c002eb48:	83 c4 10             	add    $0x10,%esp
            memcpy(bounce + sector_ofs, buffer + bytes_written, chunk_size);
c002eb4b:	8b 44 24 08          	mov    0x8(%esp),%eax
c002eb4f:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
c002eb52:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002eb56:	03 74 24 44          	add    0x44(%esp),%esi
c002eb5a:	83 fd 04             	cmp    $0x4,%ebp
c002eb5d:	73 1d                	jae    c002eb7c <inode_write_at+0xee>
c002eb5f:	85 ed                	test   %ebp,%ebp
c002eb61:	74 36                	je     c002eb99 <inode_write_at+0x10b>
c002eb63:	0f b6 06             	movzbl (%esi),%eax
c002eb66:	88 01                	mov    %al,(%ecx)
c002eb68:	f7 c5 02 00 00 00    	test   $0x2,%ebp
c002eb6e:	74 29                	je     c002eb99 <inode_write_at+0x10b>
c002eb70:	0f b7 44 35 fe       	movzwl -0x2(%ebp,%esi,1),%eax
c002eb75:	66 89 44 0d fe       	mov    %ax,-0x2(%ebp,%ecx,1)
c002eb7a:	eb 1d                	jmp    c002eb99 <inode_write_at+0x10b>
c002eb7c:	8b 06                	mov    (%esi),%eax
c002eb7e:	89 01                	mov    %eax,(%ecx)
c002eb80:	8b 44 35 fc          	mov    -0x4(%ebp,%esi,1),%eax
c002eb84:	89 44 0d fc          	mov    %eax,-0x4(%ebp,%ecx,1)
c002eb88:	8d 79 04             	lea    0x4(%ecx),%edi
c002eb8b:	83 e7 fc             	and    $0xfffffffc,%edi
c002eb8e:	29 f9                	sub    %edi,%ecx
c002eb90:	29 ce                	sub    %ecx,%esi
c002eb92:	01 e9                	add    %ebp,%ecx
c002eb94:	c1 e9 02             	shr    $0x2,%ecx
c002eb97:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
            block_write(fs_device, sector_idx, bounce);
c002eb99:	83 ec 04             	sub    $0x4,%esp
c002eb9c:	ff 74 24 0c          	pushl  0xc(%esp)
c002eba0:	ff 74 24 1c          	pushl  0x1c(%esp)
c002eba4:	8b 44 24 24          	mov    0x24(%esp),%eax
c002eba8:	ff 30                	pushl  (%eax)
c002ebaa:	e8 2f 67 ff ff       	call   c00252de <block_write>
c002ebaf:	83 c4 10             	add    $0x10,%esp
        size -= chunk_size;
c002ebb2:	29 6c 24 48          	sub    %ebp,0x48(%esp)
        offset += chunk_size;
c002ebb6:	01 6c 24 4c          	add    %ebp,0x4c(%esp)
        bytes_written += chunk_size;
c002ebba:	01 6c 24 0c          	add    %ebp,0xc(%esp)
    while (size > 0) {
c002ebbe:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002ebc3:	0f 8e 4e ff ff ff    	jle    c002eb17 <inode_write_at+0x89>
        block_sector_t sector_idx = byte_to_sector(inode, offset);
c002ebc9:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c002ebcd:	8b 44 24 40          	mov    0x40(%esp),%eax
c002ebd1:	e8 1b fa ff ff       	call   c002e5f1 <byte_to_sector>
c002ebd6:	89 c2                	mov    %eax,%edx
c002ebd8:	89 44 24 14          	mov    %eax,0x14(%esp)
        int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002ebdc:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002ebe0:	c1 f8 1f             	sar    $0x1f,%eax
c002ebe3:	c1 e8 17             	shr    $0x17,%eax
c002ebe6:	89 c6                	mov    %eax,%esi
c002ebe8:	03 74 24 4c          	add    0x4c(%esp),%esi
c002ebec:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
c002ebf2:	29 c6                	sub    %eax,%esi
        int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002ebf4:	bf 00 02 00 00       	mov    $0x200,%edi
c002ebf9:	29 f7                	sub    %esi,%edi
        off_t inode_left = inode_length(inode) - offset;
c002ebfb:	8b 44 24 40          	mov    0x40(%esp),%eax
c002ebff:	8b 40 1c             	mov    0x1c(%eax),%eax
c002ec02:	89 44 24 10          	mov    %eax,0x10(%esp)
c002ec06:	89 c5                	mov    %eax,%ebp
c002ec08:	2b 6c 24 4c          	sub    0x4c(%esp),%ebp
        int chunk_size = size < min_left ? size : min_left;
c002ec0c:	3b 6c 24 48          	cmp    0x48(%esp),%ebp
c002ec10:	0f 4f 6c 24 48       	cmovg  0x48(%esp),%ebp
c002ec15:	39 fd                	cmp    %edi,%ebp
c002ec17:	0f 4f ef             	cmovg  %edi,%ebp
        if (chunk_size <= 0)
c002ec1a:	85 ed                	test   %ebp,%ebp
c002ec1c:	0f 8e f5 fe ff ff    	jle    c002eb17 <inode_write_at+0x89>
        if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE) {
c002ec22:	85 f6                	test   %esi,%esi
c002ec24:	75 0c                	jne    c002ec32 <inode_write_at+0x1a4>
c002ec26:	81 fd 00 02 00 00    	cmp    $0x200,%ebp
c002ec2c:	0f 84 a7 fe ff ff    	je     c002ead9 <inode_write_at+0x4b>
            if (bounce == NULL) {
c002ec32:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002ec37:	0f 84 be fe ff ff    	je     c002eafb <inode_write_at+0x6d>
            if (sector_ofs > 0 || chunk_size < sector_left)
c002ec3d:	85 f6                	test   %esi,%esi
c002ec3f:	0f 8f ed fe ff ff    	jg     c002eb32 <inode_write_at+0xa4>
c002ec45:	39 ef                	cmp    %ebp,%edi
c002ec47:	0f 8f e5 fe ff ff    	jg     c002eb32 <inode_write_at+0xa4>
                memset(bounce, 0, BLOCK_SECTOR_SIZE);
c002ec4d:	b9 80 00 00 00       	mov    $0x80,%ecx
c002ec52:	b8 00 00 00 00       	mov    $0x0,%eax
c002ec57:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002ec5b:	f3 ab                	rep stos %eax,%es:(%edi)
c002ec5d:	e9 e9 fe ff ff       	jmp    c002eb4b <inode_write_at+0xbd>
    uint8_t *bounce = NULL;
c002ec62:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002ec69:	00 
c002ec6a:	e9 a8 fe ff ff       	jmp    c002eb17 <inode_write_at+0x89>
        return 0;
c002ec6f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002ec76:	00 
c002ec77:	e9 aa fe ff ff       	jmp    c002eb26 <inode_write_at+0x98>

c002ec7c <inode_deny_write>:

/* Disables writes to INODE.
   May be called at most once per inode opener. */
void
inode_deny_write(struct inode *inode) {
c002ec7c:	53                   	push   %ebx
c002ec7d:	83 ec 08             	sub    $0x8,%esp
c002ec80:	e8 be 14 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ec85:	81 c3 27 f0 00 00    	add    $0xf027,%ebx
c002ec8b:	8b 54 24 10          	mov    0x10(%esp),%edx
    inode->deny_write_cnt++;
c002ec8f:	8b 42 14             	mov    0x14(%edx),%eax
c002ec92:	83 c0 01             	add    $0x1,%eax
c002ec95:	89 42 14             	mov    %eax,0x14(%edx)
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002ec98:	3b 42 0c             	cmp    0xc(%edx),%eax
c002ec9b:	7f 05                	jg     c002eca2 <inode_deny_write+0x26>
}
c002ec9d:	83 c4 08             	add    $0x8,%esp
c002eca0:	5b                   	pop    %ebx
c002eca1:	c3                   	ret    
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002eca2:	83 ec 0c             	sub    $0xc,%esp
c002eca5:	8d 83 5c 5b ff ff    	lea    -0xa4a4(%ebx),%eax
c002ecab:	50                   	push   %eax
c002ecac:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ecb2:	50                   	push   %eax
c002ecb3:	8d 83 1c 35 ff ff    	lea    -0xcae4(%ebx),%eax
c002ecb9:	50                   	push   %eax
c002ecba:	68 27 01 00 00       	push   $0x127
c002ecbf:	8d 83 20 5b ff ff    	lea    -0xa4e0(%ebx),%eax
c002ecc5:	50                   	push   %eax
c002ecc6:	e8 62 a4 ff ff       	call   c002912d <debug_panic>

c002eccb <inode_allow_write>:

/* Re-enables writes to INODE.
   Must be called once by each inode opener who has called
   inode_deny_write() on the inode, before closing the inode. */
void
inode_allow_write(struct inode *inode) {
c002eccb:	53                   	push   %ebx
c002eccc:	83 ec 08             	sub    $0x8,%esp
c002eccf:	e8 6f 14 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ecd4:	81 c3 d8 ef 00 00    	add    $0xefd8,%ebx
c002ecda:	8b 54 24 10          	mov    0x10(%esp),%edx
    ASSERT (inode->deny_write_cnt > 0);
c002ecde:	8b 42 14             	mov    0x14(%edx),%eax
c002ece1:	85 c0                	test   %eax,%eax
c002ece3:	7e 10                	jle    c002ecf5 <inode_allow_write+0x2a>
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002ece5:	3b 42 0c             	cmp    0xc(%edx),%eax
c002ece8:	7f 34                	jg     c002ed1e <inode_allow_write+0x53>
    inode->deny_write_cnt--;
c002ecea:	83 e8 01             	sub    $0x1,%eax
c002eced:	89 42 14             	mov    %eax,0x14(%edx)
}
c002ecf0:	83 c4 08             	add    $0x8,%esp
c002ecf3:	5b                   	pop    %ebx
c002ecf4:	c3                   	ret    
    ASSERT (inode->deny_write_cnt > 0);
c002ecf5:	83 ec 0c             	sub    $0xc,%esp
c002ecf8:	8d 83 42 5b ff ff    	lea    -0xa4be(%ebx),%eax
c002ecfe:	50                   	push   %eax
c002ecff:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ed05:	50                   	push   %eax
c002ed06:	8d 83 08 35 ff ff    	lea    -0xcaf8(%ebx),%eax
c002ed0c:	50                   	push   %eax
c002ed0d:	68 2f 01 00 00       	push   $0x12f
c002ed12:	8d 83 20 5b ff ff    	lea    -0xa4e0(%ebx),%eax
c002ed18:	50                   	push   %eax
c002ed19:	e8 0f a4 ff ff       	call   c002912d <debug_panic>
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002ed1e:	83 ec 0c             	sub    $0xc,%esp
c002ed21:	8d 83 5c 5b ff ff    	lea    -0xa4a4(%ebx),%eax
c002ed27:	50                   	push   %eax
c002ed28:	8d 83 de 36 ff ff    	lea    -0xc922(%ebx),%eax
c002ed2e:	50                   	push   %eax
c002ed2f:	8d 83 08 35 ff ff    	lea    -0xcaf8(%ebx),%eax
c002ed35:	50                   	push   %eax
c002ed36:	68 30 01 00 00       	push   $0x130
c002ed3b:	8d 83 20 5b ff ff    	lea    -0xa4e0(%ebx),%eax
c002ed41:	50                   	push   %eax
c002ed42:	e8 e6 a3 ff ff       	call   c002912d <debug_panic>

c002ed47 <inode_length>:

/* Returns the length, in bytes, of INODE's data. */
off_t
inode_length(const struct inode *inode) {
    return inode->data.length;
c002ed47:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ed4b:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002ed4e:	c3                   	ret    

c002ed4f <fsutil_ls>:
#include "threads/palloc.h"
#include "threads/vaddr.h"

/* List files in the root directory. */
void
fsutil_ls(char **argv UNUSED) {
c002ed4f:	57                   	push   %edi
c002ed50:	56                   	push   %esi
c002ed51:	53                   	push   %ebx
c002ed52:	83 ec 1c             	sub    $0x1c,%esp
c002ed55:	e8 e9 13 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ed5a:	81 c3 52 ef 00 00    	add    $0xef52,%ebx
    struct dir *dir;
    char name[NAME_MAX + 1];

    printf("Files in the root directory:\n");
c002ed60:	8d 83 85 5b ff ff    	lea    -0xa47b(%ebx),%eax
c002ed66:	50                   	push   %eax
c002ed67:	e8 97 c3 ff ff       	call   c002b103 <puts>
    dir = dir_open_root();
c002ed6c:	e8 c2 f4 ff ff       	call   c002e233 <dir_open_root>
    if (dir == NULL)
c002ed71:	83 c4 10             	add    $0x10,%esp
c002ed74:	85 c0                	test   %eax,%eax
c002ed76:	74 25                	je     c002ed9d <fsutil_ls+0x4e>
c002ed78:	89 c7                	mov    %eax,%edi
        PANIC ("root dir open failed");
    while (dir_readdir(dir, name))
c002ed7a:	8d 74 24 01          	lea    0x1(%esp),%esi
c002ed7e:	83 ec 08             	sub    $0x8,%esp
c002ed81:	56                   	push   %esi
c002ed82:	57                   	push   %edi
c002ed83:	e8 04 f8 ff ff       	call   c002e58c <dir_readdir>
c002ed88:	83 c4 10             	add    $0x10,%esp
c002ed8b:	84 c0                	test   %al,%al
c002ed8d:	74 2a                	je     c002edb9 <fsutil_ls+0x6a>
        printf("%s\n", name);
c002ed8f:	83 ec 0c             	sub    $0xc,%esp
c002ed92:	56                   	push   %esi
c002ed93:	e8 6b c3 ff ff       	call   c002b103 <puts>
c002ed98:	83 c4 10             	add    $0x10,%esp
c002ed9b:	eb e1                	jmp    c002ed7e <fsutil_ls+0x2f>
        PANIC ("root dir open failed");
c002ed9d:	8d 83 a2 5b ff ff    	lea    -0xa45e(%ebx),%eax
c002eda3:	50                   	push   %eax
c002eda4:	8d 83 98 35 ff ff    	lea    -0xca68(%ebx),%eax
c002edaa:	50                   	push   %eax
c002edab:	6a 17                	push   $0x17
c002edad:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002edb3:	50                   	push   %eax
c002edb4:	e8 74 a3 ff ff       	call   c002912d <debug_panic>
    dir_close(dir);
c002edb9:	83 ec 0c             	sub    $0xc,%esp
c002edbc:	57                   	push   %edi
c002edbd:	e8 bb f4 ff ff       	call   c002e27d <dir_close>
    printf("End of listing.\n");
c002edc2:	8d 83 ce 5b ff ff    	lea    -0xa432(%ebx),%eax
c002edc8:	89 04 24             	mov    %eax,(%esp)
c002edcb:	e8 33 c3 ff ff       	call   c002b103 <puts>
}
c002edd0:	83 c4 20             	add    $0x20,%esp
c002edd3:	5b                   	pop    %ebx
c002edd4:	5e                   	pop    %esi
c002edd5:	5f                   	pop    %edi
c002edd6:	c3                   	ret    

c002edd7 <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void
fsutil_cat(char **argv) {
c002edd7:	55                   	push   %ebp
c002edd8:	57                   	push   %edi
c002edd9:	56                   	push   %esi
c002edda:	53                   	push   %ebx
c002eddb:	83 ec 14             	sub    $0x14,%esp
c002edde:	e8 60 13 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ede3:	81 c3 c9 ee 00 00    	add    $0xeec9,%ebx
    const char *file_name = argv[1];
c002ede9:	8b 44 24 28          	mov    0x28(%esp),%eax
c002eded:	8b 78 04             	mov    0x4(%eax),%edi

    struct file *file;
    char *buffer;

    printf("Printing '%s' to the console...\n", file_name);
c002edf0:	57                   	push   %edi
c002edf1:	8d 83 a8 5c ff ff    	lea    -0xa358(%ebx),%eax
c002edf7:	50                   	push   %eax
c002edf8:	e8 d4 86 ff ff       	call   c00274d1 <printf>
    file = filesys_open(file_name);
c002edfd:	89 3c 24             	mov    %edi,(%esp)
c002ee00:	e8 0f ec ff ff       	call   c002da14 <filesys_open>
    if (file == NULL)
c002ee05:	83 c4 10             	add    $0x10,%esp
c002ee08:	85 c0                	test   %eax,%eax
c002ee0a:	74 41                	je     c002ee4d <fsutil_cat+0x76>
c002ee0c:	89 c6                	mov    %eax,%esi
        PANIC ("%s: open failed", file_name);
    buffer = palloc_get_page(PAL_ASSERT);
c002ee0e:	83 ec 0c             	sub    $0xc,%esp
c002ee11:	6a 01                	push   $0x1
c002ee13:	e8 24 4c ff ff       	call   c0023a3c <palloc_get_page>
c002ee18:	89 c7                	mov    %eax,%edi
c002ee1a:	83 c4 10             	add    $0x10,%esp
    for (;;) {
        off_t pos = file_tell(file);
c002ee1d:	83 ec 0c             	sub    $0xc,%esp
c002ee20:	56                   	push   %esi
c002ee21:	e8 32 f2 ff ff       	call   c002e058 <file_tell>
c002ee26:	89 c5                	mov    %eax,%ebp
        off_t n = file_read(file, buffer, PGSIZE);
c002ee28:	83 c4 0c             	add    $0xc,%esp
c002ee2b:	68 00 10 00 00       	push   $0x1000
c002ee30:	57                   	push   %edi
c002ee31:	56                   	push   %esi
c002ee32:	e8 b3 ef ff ff       	call   c002ddea <file_read>
        if (n == 0)
c002ee37:	83 c4 10             	add    $0x10,%esp
c002ee3a:	85 c0                	test   %eax,%eax
c002ee3c:	74 2f                	je     c002ee6d <fsutil_cat+0x96>
            break;

        hex_dump(pos, buffer, n, true);
c002ee3e:	6a 01                	push   $0x1
c002ee40:	50                   	push   %eax
c002ee41:	57                   	push   %edi
c002ee42:	55                   	push   %ebp
c002ee43:	e8 37 8e ff ff       	call   c0027c7f <hex_dump>
    for (;;) {
c002ee48:	83 c4 10             	add    $0x10,%esp
c002ee4b:	eb d0                	jmp    c002ee1d <fsutil_cat+0x46>
        PANIC ("%s: open failed", file_name);
c002ee4d:	83 ec 0c             	sub    $0xc,%esp
c002ee50:	57                   	push   %edi
c002ee51:	8d 83 de 5b ff ff    	lea    -0xa422(%ebx),%eax
c002ee57:	50                   	push   %eax
c002ee58:	8d 83 8c 35 ff ff    	lea    -0xca74(%ebx),%eax
c002ee5e:	50                   	push   %eax
c002ee5f:	6a 2a                	push   $0x2a
c002ee61:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002ee67:	50                   	push   %eax
c002ee68:	e8 c0 a2 ff ff       	call   c002912d <debug_panic>
    }
    palloc_free_page(buffer);
c002ee6d:	83 ec 0c             	sub    $0xc,%esp
c002ee70:	57                   	push   %edi
c002ee71:	e8 31 4d ff ff       	call   c0023ba7 <palloc_free_page>
    file_close(file);
c002ee76:	89 34 24             	mov    %esi,(%esp)
c002ee79:	e8 d6 f0 ff ff       	call   c002df54 <file_close>
}
c002ee7e:	83 c4 1c             	add    $0x1c,%esp
c002ee81:	5b                   	pop    %ebx
c002ee82:	5e                   	pop    %esi
c002ee83:	5f                   	pop    %edi
c002ee84:	5d                   	pop    %ebp
c002ee85:	c3                   	ret    

c002ee86 <fsutil_rm>:

/* Deletes file ARGV[1]. */
void
fsutil_rm(char **argv) {
c002ee86:	56                   	push   %esi
c002ee87:	53                   	push   %ebx
c002ee88:	83 ec 0c             	sub    $0xc,%esp
c002ee8b:	e8 b3 12 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ee90:	81 c3 1c ee 00 00    	add    $0xee1c,%ebx
    const char *file_name = argv[1];
c002ee96:	8b 44 24 18          	mov    0x18(%esp),%eax
c002ee9a:	8b 70 04             	mov    0x4(%eax),%esi

    printf("Deleting '%s'...\n", file_name);
c002ee9d:	56                   	push   %esi
c002ee9e:	8d 83 ee 5b ff ff    	lea    -0xa412(%ebx),%eax
c002eea4:	50                   	push   %eax
c002eea5:	e8 27 86 ff ff       	call   c00274d1 <printf>
    if (!filesys_remove(file_name))
c002eeaa:	89 34 24             	mov    %esi,(%esp)
c002eead:	e8 b5 eb ff ff       	call   c002da67 <filesys_remove>
c002eeb2:	83 c4 10             	add    $0x10,%esp
c002eeb5:	84 c0                	test   %al,%al
c002eeb7:	74 06                	je     c002eebf <fsutil_rm+0x39>
        PANIC ("%s: delete failed\n", file_name);
}
c002eeb9:	83 c4 04             	add    $0x4,%esp
c002eebc:	5b                   	pop    %ebx
c002eebd:	5e                   	pop    %esi
c002eebe:	c3                   	ret    
        PANIC ("%s: delete failed\n", file_name);
c002eebf:	83 ec 0c             	sub    $0xc,%esp
c002eec2:	56                   	push   %esi
c002eec3:	8d 83 00 5c ff ff    	lea    -0xa400(%ebx),%eax
c002eec9:	50                   	push   %eax
c002eeca:	8d 83 80 35 ff ff    	lea    -0xca80(%ebx),%eax
c002eed0:	50                   	push   %eax
c002eed1:	6a 3f                	push   $0x3f
c002eed3:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002eed9:	50                   	push   %eax
c002eeda:	e8 4e a2 ff ff       	call   c002912d <debug_panic>

c002eedf <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void
fsutil_extract(char **argv UNUSED) {
c002eedf:	55                   	push   %ebp
c002eee0:	57                   	push   %edi
c002eee1:	56                   	push   %esi
c002eee2:	53                   	push   %ebx
c002eee3:	83 ec 38             	sub    $0x38,%esp
c002eee6:	e8 58 12 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002eeeb:	81 c3 c1 ed 00 00    	add    $0xedc1,%ebx

    struct block *src;
    void *header, *data;

    /* Allocate buffers. */
    header = malloc(BLOCK_SECTOR_SIZE);
c002eef1:	68 00 02 00 00       	push   $0x200
c002eef6:	e8 53 4f ff ff       	call   c0023e4e <malloc>
c002eefb:	89 c7                	mov    %eax,%edi
c002eefd:	89 44 24 14          	mov    %eax,0x14(%esp)
    data = malloc(BLOCK_SECTOR_SIZE);
c002ef01:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002ef08:	e8 41 4f ff ff       	call   c0023e4e <malloc>
c002ef0d:	89 c5                	mov    %eax,%ebp
    if (header == NULL || data == NULL)
c002ef0f:	83 c4 10             	add    $0x10,%esp
c002ef12:	85 ff                	test   %edi,%edi
c002ef14:	74 3d                	je     c002ef53 <fsutil_extract+0x74>
c002ef16:	85 c0                	test   %eax,%eax
c002ef18:	74 39                	je     c002ef53 <fsutil_extract+0x74>
        PANIC ("couldn't allocate buffers");

    /* Open source block device. */
    src = block_get_role(BLOCK_SCRATCH);
c002ef1a:	83 ec 0c             	sub    $0xc,%esp
c002ef1d:	6a 02                	push   $0x2
c002ef1f:	e8 09 62 ff ff       	call   c002512d <block_get_role>
c002ef24:	89 44 24 10          	mov    %eax,0x10(%esp)
    if (src == NULL)
c002ef28:	83 c4 10             	add    $0x10,%esp
c002ef2b:	85 c0                	test   %eax,%eax
c002ef2d:	74 40                	je     c002ef6f <fsutil_extract+0x90>
        PANIC ("couldn't open scratch device");

    printf("Extracting ustar archive from scratch device "
c002ef2f:	83 ec 0c             	sub    $0xc,%esp
c002ef32:	8d 83 cc 5c ff ff    	lea    -0xa334(%ebx),%eax
c002ef38:	50                   	push   %eax
c002ef39:	e8 c5 c1 ff ff       	call   c002b103 <puts>
c002ef3e:	83 c4 10             	add    $0x10,%esp
        enum ustar_type type;
        int size;

        /* Read and parse ustar header. */
        block_read(src, sector++, header);
        error = ustar_parse_header(header, &file_name, &type, &size);
c002ef41:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002ef45:	89 44 24 08          	mov    %eax,0x8(%esp)
c002ef49:	8d 44 24 18          	lea    0x18(%esp),%eax
c002ef4d:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002ef51:	eb 78                	jmp    c002efcb <fsutil_extract+0xec>
        PANIC ("couldn't allocate buffers");
c002ef53:	8d 83 13 5c ff ff    	lea    -0xa3ed(%ebx),%eax
c002ef59:	50                   	push   %eax
c002ef5a:	8d 83 70 35 ff ff    	lea    -0xca90(%ebx),%eax
c002ef60:	50                   	push   %eax
c002ef61:	6a 4f                	push   $0x4f
c002ef63:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002ef69:	50                   	push   %eax
c002ef6a:	e8 be a1 ff ff       	call   c002912d <debug_panic>
        PANIC ("couldn't open scratch device");
c002ef6f:	8d 83 2d 5c ff ff    	lea    -0xa3d3(%ebx),%eax
c002ef75:	50                   	push   %eax
c002ef76:	8d 83 70 35 ff ff    	lea    -0xca90(%ebx),%eax
c002ef7c:	50                   	push   %eax
c002ef7d:	6a 54                	push   $0x54
c002ef7f:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002ef85:	50                   	push   %eax
c002ef86:	e8 a2 a1 ff ff       	call   c002912d <debug_panic>
        if (error != NULL)
            PANIC ("bad ustar header in sector %"
c002ef8b:	83 ec 08             	sub    $0x8,%esp
c002ef8e:	50                   	push   %eax
c002ef8f:	8b 83 48 1f 00 00    	mov    0x1f48(%ebx),%eax
c002ef95:	83 e8 01             	sub    $0x1,%eax
c002ef98:	50                   	push   %eax
c002ef99:	8d 83 10 5d ff ff    	lea    -0xa2f0(%ebx),%eax
c002ef9f:	50                   	push   %eax
c002efa0:	8d 83 70 35 ff ff    	lea    -0xca90(%ebx),%eax
c002efa6:	50                   	push   %eax
c002efa7:	6a 65                	push   $0x65
c002efa9:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002efaf:	50                   	push   %eax
c002efb0:	e8 78 a1 ff ff       	call   c002912d <debug_panic>

        if (type == USTAR_EOF) {
            /* End of archive. */
            break;
        } else if (type == USTAR_DIRECTORY)
            printf("ignoring directory %s\n", file_name);
c002efb5:	83 ec 08             	sub    $0x8,%esp
c002efb8:	ff 74 24 1c          	pushl  0x1c(%esp)
c002efbc:	8d 83 4a 5c ff ff    	lea    -0xa3b6(%ebx),%eax
c002efc2:	50                   	push   %eax
c002efc3:	e8 09 85 ff ff       	call   c00274d1 <printf>
c002efc8:	83 c4 10             	add    $0x10,%esp
        block_read(src, sector++, header);
c002efcb:	8b 83 48 1f 00 00    	mov    0x1f48(%ebx),%eax
c002efd1:	8d 50 01             	lea    0x1(%eax),%edx
c002efd4:	89 93 48 1f 00 00    	mov    %edx,0x1f48(%ebx)
c002efda:	83 ec 04             	sub    $0x4,%esp
c002efdd:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002efe1:	57                   	push   %edi
c002efe2:	50                   	push   %eax
c002efe3:	ff 74 24 0c          	pushl  0xc(%esp)
c002efe7:	e8 be 62 ff ff       	call   c00252aa <block_read>
        error = ustar_parse_header(header, &file_name, &type, &size);
c002efec:	ff 74 24 18          	pushl  0x18(%esp)
c002eff0:	ff 74 24 20          	pushl  0x20(%esp)
c002eff4:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002eff8:	50                   	push   %eax
c002eff9:	57                   	push   %edi
c002effa:	e8 9c 9e ff ff       	call   c0028e9b <ustar_parse_header>
        if (error != NULL)
c002efff:	83 c4 20             	add    $0x20,%esp
c002f002:	85 c0                	test   %eax,%eax
c002f004:	75 85                	jne    c002ef8b <fsutil_extract+0xac>
        if (type == USTAR_EOF) {
c002f006:	8b 44 24 18          	mov    0x18(%esp),%eax
c002f00a:	83 f8 ff             	cmp    $0xffffffff,%eax
c002f00d:	0f 84 23 01 00 00    	je     c002f136 <fsutil_extract+0x257>
        } else if (type == USTAR_DIRECTORY)
c002f013:	83 f8 35             	cmp    $0x35,%eax
c002f016:	74 9d                	je     c002efb5 <fsutil_extract+0xd6>
        else if (type == USTAR_REGULAR) {
c002f018:	83 f8 30             	cmp    $0x30,%eax
c002f01b:	75 ae                	jne    c002efcb <fsutil_extract+0xec>
            struct file *dst;

            printf("Putting '%s' into the file system...\n", file_name);
c002f01d:	83 ec 08             	sub    $0x8,%esp
c002f020:	ff 74 24 1c          	pushl  0x1c(%esp)
c002f024:	8d 83 34 5d ff ff    	lea    -0xa2cc(%ebx),%eax
c002f02a:	50                   	push   %eax
c002f02b:	e8 a1 84 ff ff       	call   c00274d1 <printf>

            /* Create destination file. */
            if (!filesys_create(file_name, size))
c002f030:	83 c4 08             	add    $0x8,%esp
c002f033:	ff 74 24 24          	pushl  0x24(%esp)
c002f037:	ff 74 24 20          	pushl  0x20(%esp)
c002f03b:	e8 3a e9 ff ff       	call   c002d97a <filesys_create>
c002f040:	83 c4 10             	add    $0x10,%esp
c002f043:	84 c0                	test   %al,%al
c002f045:	74 7f                	je     c002f0c6 <fsutil_extract+0x1e7>
                PANIC ("%s: create failed", file_name);
            dst = filesys_open(file_name);
c002f047:	83 ec 0c             	sub    $0xc,%esp
c002f04a:	ff 74 24 20          	pushl  0x20(%esp)
c002f04e:	e8 c1 e9 ff ff       	call   c002da14 <filesys_open>
c002f053:	89 c7                	mov    %eax,%edi
            if (dst == NULL)
c002f055:	83 c4 10             	add    $0x10,%esp
c002f058:	85 c0                	test   %eax,%eax
c002f05a:	0f 84 89 00 00 00    	je     c002f0e9 <fsutil_extract+0x20a>
                PANIC ("%s: open failed", file_name);

            /* Do copy. */
            while (size > 0) {
c002f060:	8b 74 24 1c          	mov    0x1c(%esp),%esi
c002f064:	85 f6                	test   %esi,%esi
c002f066:	7e 4d                	jle    c002f0b5 <fsutil_extract+0x1d6>
                int chunk_size = (size > BLOCK_SECTOR_SIZE
c002f068:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c002f06e:	b8 00 02 00 00       	mov    $0x200,%eax
c002f073:	0f 4f f0             	cmovg  %eax,%esi
                                  ? BLOCK_SECTOR_SIZE
                                  : size);
                block_read(src, sector++, data);
c002f076:	8b 83 48 1f 00 00    	mov    0x1f48(%ebx),%eax
c002f07c:	8d 50 01             	lea    0x1(%eax),%edx
c002f07f:	89 93 48 1f 00 00    	mov    %edx,0x1f48(%ebx)
c002f085:	83 ec 04             	sub    $0x4,%esp
c002f088:	55                   	push   %ebp
c002f089:	50                   	push   %eax
c002f08a:	ff 74 24 0c          	pushl  0xc(%esp)
c002f08e:	e8 17 62 ff ff       	call   c00252aa <block_read>
                if (file_write(dst, data, chunk_size) != chunk_size)
c002f093:	83 c4 0c             	add    $0xc,%esp
c002f096:	56                   	push   %esi
c002f097:	55                   	push   %ebp
c002f098:	57                   	push   %edi
c002f099:	e8 a6 ed ff ff       	call   c002de44 <file_write>
c002f09e:	83 c4 10             	add    $0x10,%esp
c002f0a1:	39 f0                	cmp    %esi,%eax
c002f0a3:	75 67                	jne    c002f10c <fsutil_extract+0x22d>
                    PANIC ("%s: write failed with %d bytes unwritten",
                           file_name, size);
                size -= chunk_size;
c002f0a5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002f0a9:	29 f0                	sub    %esi,%eax
c002f0ab:	89 c6                	mov    %eax,%esi
c002f0ad:	89 44 24 1c          	mov    %eax,0x1c(%esp)
            while (size > 0) {
c002f0b1:	85 c0                	test   %eax,%eax
c002f0b3:	7f b3                	jg     c002f068 <fsutil_extract+0x189>
            }

            /* Finish up. */
            file_close(dst);
c002f0b5:	83 ec 0c             	sub    $0xc,%esp
c002f0b8:	57                   	push   %edi
c002f0b9:	e8 96 ee ff ff       	call   c002df54 <file_close>
c002f0be:	83 c4 10             	add    $0x10,%esp
    for (;;) {
c002f0c1:	e9 05 ff ff ff       	jmp    c002efcb <fsutil_extract+0xec>
                PANIC ("%s: create failed", file_name);
c002f0c6:	83 ec 0c             	sub    $0xc,%esp
c002f0c9:	ff 74 24 20          	pushl  0x20(%esp)
c002f0cd:	8d 83 61 5c ff ff    	lea    -0xa39f(%ebx),%eax
c002f0d3:	50                   	push   %eax
c002f0d4:	8d 83 70 35 ff ff    	lea    -0xca90(%ebx),%eax
c002f0da:	50                   	push   %eax
c002f0db:	6a 73                	push   $0x73
c002f0dd:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f0e3:	50                   	push   %eax
c002f0e4:	e8 44 a0 ff ff       	call   c002912d <debug_panic>
                PANIC ("%s: open failed", file_name);
c002f0e9:	83 ec 0c             	sub    $0xc,%esp
c002f0ec:	ff 74 24 20          	pushl  0x20(%esp)
c002f0f0:	8d 83 de 5b ff ff    	lea    -0xa422(%ebx),%eax
c002f0f6:	50                   	push   %eax
c002f0f7:	8d 83 70 35 ff ff    	lea    -0xca90(%ebx),%eax
c002f0fd:	50                   	push   %eax
c002f0fe:	6a 76                	push   $0x76
c002f100:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f106:	50                   	push   %eax
c002f107:	e8 21 a0 ff ff       	call   c002912d <debug_panic>
                    PANIC ("%s: write failed with %d bytes unwritten",
c002f10c:	83 ec 08             	sub    $0x8,%esp
c002f10f:	ff 74 24 24          	pushl  0x24(%esp)
c002f113:	ff 74 24 20          	pushl  0x20(%esp)
c002f117:	8d 83 5c 5d ff ff    	lea    -0xa2a4(%ebx),%eax
c002f11d:	50                   	push   %eax
c002f11e:	8d 83 70 35 ff ff    	lea    -0xca90(%ebx),%eax
c002f124:	50                   	push   %eax
c002f125:	68 80 00 00 00       	push   $0x80
c002f12a:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f130:	50                   	push   %eax
c002f131:	e8 f7 9f ff ff       	call   c002912d <debug_panic>

    /* Erase the ustar header from the start of the block device,
       so that the extraction operation is idempotent.  We erase
       two blocks because two blocks of zeros are the ustar
       end-of-archive marker. */
    printf("Erasing ustar archive...\n");
c002f136:	83 ec 0c             	sub    $0xc,%esp
c002f139:	8d 83 73 5c ff ff    	lea    -0xa38d(%ebx),%eax
c002f13f:	50                   	push   %eax
c002f140:	e8 be bf ff ff       	call   c002b103 <puts>
    memset(header, 0, BLOCK_SECTOR_SIZE);
c002f145:	b9 80 00 00 00       	mov    $0x80,%ecx
c002f14a:	b8 00 00 00 00       	mov    $0x0,%eax
c002f14f:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002f153:	f3 ab                	rep stos %eax,%es:(%edi)
    block_write(src, 0, header);
c002f155:	83 c4 0c             	add    $0xc,%esp
c002f158:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002f15c:	57                   	push   %edi
c002f15d:	6a 00                	push   $0x0
c002f15f:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002f163:	56                   	push   %esi
c002f164:	e8 75 61 ff ff       	call   c00252de <block_write>
    block_write(src, 1, header);
c002f169:	83 c4 0c             	add    $0xc,%esp
c002f16c:	57                   	push   %edi
c002f16d:	6a 01                	push   $0x1
c002f16f:	56                   	push   %esi
c002f170:	e8 69 61 ff ff       	call   c00252de <block_write>

    free(data);
c002f175:	89 2c 24             	mov    %ebp,(%esp)
c002f178:	e8 7f 4e ff ff       	call   c0023ffc <free>
    free(header);
c002f17d:	89 3c 24             	mov    %edi,(%esp)
c002f180:	e8 77 4e ff ff       	call   c0023ffc <free>
}
c002f185:	83 c4 3c             	add    $0x3c,%esp
c002f188:	5b                   	pop    %ebx
c002f189:	5e                   	pop    %esi
c002f18a:	5f                   	pop    %edi
c002f18b:	5d                   	pop    %ebp
c002f18c:	c3                   	ret    

c002f18d <fsutil_append>:
   beginning of the scratch device.  Later calls advance across
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void
fsutil_append(char **argv) {
c002f18d:	55                   	push   %ebp
c002f18e:	57                   	push   %edi
c002f18f:	56                   	push   %esi
c002f190:	53                   	push   %ebx
c002f191:	83 ec 24             	sub    $0x24,%esp
c002f194:	e8 aa 0f 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f199:	81 c3 13 eb 00 00    	add    $0xeb13,%ebx
    static block_sector_t sector = 0;

    const char *file_name = argv[1];
c002f19f:	8b 44 24 38          	mov    0x38(%esp),%eax
c002f1a3:	8b 40 04             	mov    0x4(%eax),%eax
c002f1a6:	89 44 24 14          	mov    %eax,0x14(%esp)
    void *buffer;
    struct file *src;
    struct block *dst;
    off_t size;

    printf("Appending '%s' to ustar archive on scratch device...\n", file_name);
c002f1aa:	50                   	push   %eax
c002f1ab:	8d 83 88 5d ff ff    	lea    -0xa278(%ebx),%eax
c002f1b1:	50                   	push   %eax
c002f1b2:	e8 1a 83 ff ff       	call   c00274d1 <printf>

    /* Allocate buffer. */
    buffer = malloc(BLOCK_SECTOR_SIZE);
c002f1b7:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002f1be:	e8 8b 4c ff ff       	call   c0023e4e <malloc>
    if (buffer == NULL)
c002f1c3:	83 c4 10             	add    $0x10,%esp
c002f1c6:	85 c0                	test   %eax,%eax
c002f1c8:	0f 84 52 01 00 00    	je     c002f320 <fsutil_append+0x193>
c002f1ce:	89 c5                	mov    %eax,%ebp
        PANIC ("couldn't allocate buffer");

    /* Open source file. */
    src = filesys_open(file_name);
c002f1d0:	83 ec 0c             	sub    $0xc,%esp
c002f1d3:	ff 74 24 18          	pushl  0x18(%esp)
c002f1d7:	e8 38 e8 ff ff       	call   c002da14 <filesys_open>
c002f1dc:	89 44 24 18          	mov    %eax,0x18(%esp)
    if (src == NULL)
c002f1e0:	83 c4 10             	add    $0x10,%esp
c002f1e3:	85 c0                	test   %eax,%eax
c002f1e5:	0f 84 54 01 00 00    	je     c002f33f <fsutil_append+0x1b2>
        PANIC ("%s: open failed", file_name);
    size = file_length(src);
c002f1eb:	83 ec 0c             	sub    $0xc,%esp
c002f1ee:	ff 74 24 14          	pushl  0x14(%esp)
c002f1f2:	e8 99 ed ff ff       	call   c002df90 <file_length>
c002f1f7:	89 c7                	mov    %eax,%edi

    /* Open target block device. */
    dst = block_get_role(BLOCK_SCRATCH);
c002f1f9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c002f200:	e8 28 5f ff ff       	call   c002512d <block_get_role>
c002f205:	89 44 24 14          	mov    %eax,0x14(%esp)
    if (dst == NULL)
c002f209:	83 c4 10             	add    $0x10,%esp
c002f20c:	85 c0                	test   %eax,%eax
c002f20e:	0f 84 51 01 00 00    	je     c002f365 <fsutil_append+0x1d8>
        PANIC ("couldn't open scratch device");

    /* Write ustar header to first sector. */
    if (!ustar_make_header(file_name, USTAR_REGULAR, size, buffer))
c002f214:	55                   	push   %ebp
c002f215:	57                   	push   %edi
c002f216:	6a 30                	push   $0x30
c002f218:	ff 74 24 18          	pushl  0x18(%esp)
c002f21c:	e8 87 9a ff ff       	call   c0028ca8 <ustar_make_header>
c002f221:	83 c4 10             	add    $0x10,%esp
c002f224:	84 c0                	test   %al,%al
c002f226:	0f 84 58 01 00 00    	je     c002f384 <fsutil_append+0x1f7>
        PANIC ("%s: name too long for ustar format", file_name);
    block_write(dst, sector++, buffer);
c002f22c:	8b 83 44 1f 00 00    	mov    0x1f44(%ebx),%eax
c002f232:	8d 50 01             	lea    0x1(%eax),%edx
c002f235:	89 93 44 1f 00 00    	mov    %edx,0x1f44(%ebx)
c002f23b:	83 ec 04             	sub    $0x4,%esp
c002f23e:	55                   	push   %ebp
c002f23f:	50                   	push   %eax
c002f240:	ff 74 24 10          	pushl  0x10(%esp)
c002f244:	e8 95 60 ff ff       	call   c00252de <block_write>

    /* Do copy. */
    while (size > 0) {
c002f249:	83 c4 10             	add    $0x10,%esp
c002f24c:	85 ff                	test   %edi,%edi
c002f24e:	7e 7f                	jle    c002f2cf <fsutil_append+0x142>
        int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c002f250:	81 ff 00 02 00 00    	cmp    $0x200,%edi
c002f256:	be 00 02 00 00       	mov    $0x200,%esi
c002f25b:	0f 4e f7             	cmovle %edi,%esi
        if (sector >= block_size(dst))
c002f25e:	83 ec 0c             	sub    $0xc,%esp
c002f261:	ff 74 24 10          	pushl  0x10(%esp)
c002f265:	e8 e2 60 ff ff       	call   c002534c <block_size>
c002f26a:	83 c4 10             	add    $0x10,%esp
c002f26d:	3b 83 44 1f 00 00    	cmp    0x1f44(%ebx),%eax
c002f273:	0f 86 31 01 00 00    	jbe    c002f3aa <fsutil_append+0x21d>
            PANIC ("%s: out of space on scratch device", file_name);
        if (file_read(src, buffer, chunk_size) != chunk_size)
c002f279:	83 ec 04             	sub    $0x4,%esp
c002f27c:	56                   	push   %esi
c002f27d:	55                   	push   %ebp
c002f27e:	ff 74 24 14          	pushl  0x14(%esp)
c002f282:	e8 63 eb ff ff       	call   c002ddea <file_read>
c002f287:	83 c4 10             	add    $0x10,%esp
c002f28a:	39 f0                	cmp    %esi,%eax
c002f28c:	0f 85 3e 01 00 00    	jne    c002f3d0 <fsutil_append+0x243>
            PANIC ("%s: read failed with %"
                           PROTd
                           " bytes unread", file_name, size);
        memset(buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c002f292:	ba 00 02 00 00       	mov    $0x200,%edx
c002f297:	29 f2                	sub    %esi,%edx
c002f299:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
c002f29d:	83 ec 04             	sub    $0x4,%esp
c002f2a0:	52                   	push   %edx
c002f2a1:	6a 00                	push   $0x0
c002f2a3:	50                   	push   %eax
c002f2a4:	e8 f3 93 ff ff       	call   c002869c <memset>
        block_write(dst, sector++, buffer);
c002f2a9:	8b 83 44 1f 00 00    	mov    0x1f44(%ebx),%eax
c002f2af:	8d 50 01             	lea    0x1(%eax),%edx
c002f2b2:	89 93 44 1f 00 00    	mov    %edx,0x1f44(%ebx)
c002f2b8:	83 c4 0c             	add    $0xc,%esp
c002f2bb:	55                   	push   %ebp
c002f2bc:	50                   	push   %eax
c002f2bd:	ff 74 24 10          	pushl  0x10(%esp)
c002f2c1:	e8 18 60 ff ff       	call   c00252de <block_write>
        size -= chunk_size;
c002f2c6:	29 f7                	sub    %esi,%edi
    while (size > 0) {
c002f2c8:	83 c4 10             	add    $0x10,%esp
c002f2cb:	85 ff                	test   %edi,%edi
c002f2cd:	7f 81                	jg     c002f250 <fsutil_append+0xc3>
    }

    /* Write ustar end-of-archive marker, which is two consecutive
       sectors full of zeros.  Don't advance our position past
       them, though, in case we have more files to append. */
    memset(buffer, 0, BLOCK_SECTOR_SIZE);
c002f2cf:	b9 80 00 00 00       	mov    $0x80,%ecx
c002f2d4:	b8 00 00 00 00       	mov    $0x0,%eax
c002f2d9:	89 ef                	mov    %ebp,%edi
c002f2db:	f3 ab                	rep stos %eax,%es:(%edi)
    block_write(dst, sector, buffer);
c002f2dd:	83 ec 04             	sub    $0x4,%esp
c002f2e0:	55                   	push   %ebp
c002f2e1:	ff b3 44 1f 00 00    	pushl  0x1f44(%ebx)
c002f2e7:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002f2eb:	57                   	push   %edi
c002f2ec:	e8 ed 5f ff ff       	call   c00252de <block_write>
    block_write(dst, sector, buffer + 1);
c002f2f1:	83 c4 0c             	add    $0xc,%esp
c002f2f4:	8d 45 01             	lea    0x1(%ebp),%eax
c002f2f7:	50                   	push   %eax
c002f2f8:	ff b3 44 1f 00 00    	pushl  0x1f44(%ebx)
c002f2fe:	57                   	push   %edi
c002f2ff:	e8 da 5f ff ff       	call   c00252de <block_write>

    /* Finish up. */
    file_close(src);
c002f304:	83 c4 04             	add    $0x4,%esp
c002f307:	ff 74 24 14          	pushl  0x14(%esp)
c002f30b:	e8 44 ec ff ff       	call   c002df54 <file_close>
    free(buffer);
c002f310:	89 2c 24             	mov    %ebp,(%esp)
c002f313:	e8 e4 4c ff ff       	call   c0023ffc <free>
}
c002f318:	83 c4 2c             	add    $0x2c,%esp
c002f31b:	5b                   	pop    %ebx
c002f31c:	5e                   	pop    %esi
c002f31d:	5f                   	pop    %edi
c002f31e:	5d                   	pop    %ebp
c002f31f:	c3                   	ret    
        PANIC ("couldn't allocate buffer");
c002f320:	8d 83 8c 5c ff ff    	lea    -0xa374(%ebx),%eax
c002f326:	50                   	push   %eax
c002f327:	8d 83 60 35 ff ff    	lea    -0xcaa0(%ebx),%eax
c002f32d:	50                   	push   %eax
c002f32e:	68 ad 00 00 00       	push   $0xad
c002f333:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f339:	50                   	push   %eax
c002f33a:	e8 ee 9d ff ff       	call   c002912d <debug_panic>
        PANIC ("%s: open failed", file_name);
c002f33f:	83 ec 0c             	sub    $0xc,%esp
c002f342:	ff 74 24 18          	pushl  0x18(%esp)
c002f346:	8d 83 de 5b ff ff    	lea    -0xa422(%ebx),%eax
c002f34c:	50                   	push   %eax
c002f34d:	8d 83 60 35 ff ff    	lea    -0xcaa0(%ebx),%eax
c002f353:	50                   	push   %eax
c002f354:	68 b2 00 00 00       	push   $0xb2
c002f359:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f35f:	50                   	push   %eax
c002f360:	e8 c8 9d ff ff       	call   c002912d <debug_panic>
        PANIC ("couldn't open scratch device");
c002f365:	8d 83 2d 5c ff ff    	lea    -0xa3d3(%ebx),%eax
c002f36b:	50                   	push   %eax
c002f36c:	8d 83 60 35 ff ff    	lea    -0xcaa0(%ebx),%eax
c002f372:	50                   	push   %eax
c002f373:	68 b8 00 00 00       	push   $0xb8
c002f378:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f37e:	50                   	push   %eax
c002f37f:	e8 a9 9d ff ff       	call   c002912d <debug_panic>
        PANIC ("%s: name too long for ustar format", file_name);
c002f384:	83 ec 0c             	sub    $0xc,%esp
c002f387:	ff 74 24 18          	pushl  0x18(%esp)
c002f38b:	8d 83 c0 5d ff ff    	lea    -0xa240(%ebx),%eax
c002f391:	50                   	push   %eax
c002f392:	8d 83 60 35 ff ff    	lea    -0xcaa0(%ebx),%eax
c002f398:	50                   	push   %eax
c002f399:	68 bc 00 00 00       	push   $0xbc
c002f39e:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f3a4:	50                   	push   %eax
c002f3a5:	e8 83 9d ff ff       	call   c002912d <debug_panic>
            PANIC ("%s: out of space on scratch device", file_name);
c002f3aa:	83 ec 0c             	sub    $0xc,%esp
c002f3ad:	ff 74 24 18          	pushl  0x18(%esp)
c002f3b1:	8d 83 e4 5d ff ff    	lea    -0xa21c(%ebx),%eax
c002f3b7:	50                   	push   %eax
c002f3b8:	8d 83 60 35 ff ff    	lea    -0xcaa0(%ebx),%eax
c002f3be:	50                   	push   %eax
c002f3bf:	68 c3 00 00 00       	push   $0xc3
c002f3c4:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f3ca:	50                   	push   %eax
c002f3cb:	e8 5d 9d ff ff       	call   c002912d <debug_panic>
            PANIC ("%s: read failed with %"
c002f3d0:	83 ec 08             	sub    $0x8,%esp
c002f3d3:	57                   	push   %edi
c002f3d4:	ff 74 24 18          	pushl  0x18(%esp)
c002f3d8:	8d 83 08 5e ff ff    	lea    -0xa1f8(%ebx),%eax
c002f3de:	50                   	push   %eax
c002f3df:	8d 83 60 35 ff ff    	lea    -0xcaa0(%ebx),%eax
c002f3e5:	50                   	push   %eax
c002f3e6:	68 c7 00 00 00       	push   $0xc7
c002f3eb:	8d 83 b7 5b ff ff    	lea    -0xa449(%ebx),%eax
c002f3f1:	50                   	push   %eax
c002f3f2:	e8 36 9d ff ff       	call   c002912d <debug_panic>

c002f3f7 <frame_hash_less>:

//reconstruct
static bool frame_hash_less(const struct hash_elem *x, const struct hash_elem *y, void *aux UNUSED) {
    const struct frame_item * xx = hash_entry(x, struct frame_item, hash_elem);
    const struct frame_item * yy = hash_entry(y, struct frame_item, hash_elem);
    return xx->frame < yy->frame;
c002f3f7:	8b 54 24 04          	mov    0x4(%esp),%edx
c002f3fb:	8b 44 24 08          	mov    0x8(%esp),%eax
c002f3ff:	8b 40 ec             	mov    -0x14(%eax),%eax
c002f402:	39 42 ec             	cmp    %eax,-0x14(%edx)
c002f405:	0f 92 c0             	setb   %al
}
c002f408:	c3                   	ret    

c002f409 <frame_hash>:

//reconstruct
static bool frame_hash(const struct hash_elem *x, void *aux UNUSED) {
c002f409:	53                   	push   %ebx
c002f40a:	83 ec 10             	sub    $0x10,%esp
c002f40d:	e8 31 0d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f412:	81 c3 9a e8 00 00    	add    $0xe89a,%ebx
    const struct frame_item *xx = hash_entry(x, struct frame_item, hash_elem);
    return hash_bytes(&xx->frame, sizeof(xx->frame));
c002f418:	6a 04                	push   $0x4
c002f41a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002f41e:	83 e8 14             	sub    $0x14,%eax
c002f421:	50                   	push   %eax
c002f422:	e8 06 ba ff ff       	call   c002ae2d <hash_bytes>
c002f427:	85 c0                	test   %eax,%eax
c002f429:	0f 95 c0             	setne  %al
}
c002f42c:	83 c4 18             	add    $0x18,%esp
c002f42f:	5b                   	pop    %ebx
c002f430:	c3                   	ret    

c002f431 <find_frame>:

//method
void *find_frame(void *frame) {
c002f431:	53                   	push   %ebx
c002f432:	83 ec 30             	sub    $0x30,%esp
c002f435:	e8 09 0d 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f43a:	81 c3 72 e8 00 00    	add    $0xe872,%ebx
    struct frame_item p;
    struct hash_elem *q;
    p.frame = frame;
c002f440:	8b 44 24 38          	mov    0x38(%esp),%eax
c002f444:	89 44 24 08          	mov    %eax,0x8(%esp)
    q = hash_find(&frame_table, &p.hash_elem);
c002f448:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002f44c:	50                   	push   %eax
c002f44d:	8d 83 a8 1f 00 00    	lea    0x1fa8(%ebx),%eax
c002f453:	50                   	push   %eax
c002f454:	e8 6c b7 ff ff       	call   c002abc5 <hash_find>
    if (q == NULL) return NULL;
    return hash_entry(q, struct frame_item, hash_elem);
c002f459:	8d 50 ec             	lea    -0x14(%eax),%edx
c002f45c:	85 c0                	test   %eax,%eax
c002f45e:	0f 45 c2             	cmovne %edx,%eax
}
c002f461:	83 c4 38             	add    $0x38,%esp
c002f464:	5b                   	pop    %ebx
c002f465:	c3                   	ret    

c002f466 <frame_init>:

static void free_frame_without_lock (void *kpage);

void frame_init() {
c002f466:	53                   	push   %ebx
c002f467:	83 ec 14             	sub    $0x14,%esp
c002f46a:	e8 d4 0c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f46f:	81 c3 3d e8 00 00    	add    $0xe83d,%ebx
    frame_ptr = NULL;
c002f475:	c7 83 54 1f 00 00 00 	movl   $0x0,0x1f54(%ebx)
c002f47c:	00 00 00 
    lock_init(&frame_lock);
c002f47f:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f485:	50                   	push   %eax
c002f486:	e8 25 3d ff ff       	call   c00231b0 <lock_init>
    hash_init(&frame_table, frame_hash, frame_hash_less, NULL);
c002f48b:	6a 00                	push   $0x0
c002f48d:	8d 83 4b 17 ff ff    	lea    -0xe8b5(%ebx),%eax
c002f493:	50                   	push   %eax
c002f494:	8d 83 5d 17 ff ff    	lea    -0xe8a3(%ebx),%eax
c002f49a:	50                   	push   %eax
c002f49b:	8d 83 a8 1f 00 00    	lea    0x1fa8(%ebx),%eax
c002f4a1:	50                   	push   %eax
c002f4a2:	e8 bb b5 ff ff       	call   c002aa62 <hash_init>
    list_init(&frame_clock_list);
c002f4a7:	83 c4 14             	add    $0x14,%esp
c002f4aa:	8d 83 98 1f 00 00    	lea    0x1f98(%ebx),%eax
c002f4b0:	50                   	push   %eax
c002f4b1:	e8 44 9d ff ff       	call   c00291fa <list_init>
}
c002f4b6:	83 c4 18             	add    $0x18,%esp
c002f4b9:	5b                   	pop    %ebx
c002f4ba:	c3                   	ret    

c002f4bb <free_frame>:
    }

    return frame_addr;
}

void free_frame(void *frame) {
c002f4bb:	57                   	push   %edi
c002f4bc:	56                   	push   %esi
c002f4bd:	53                   	push   %ebx
c002f4be:	e8 80 0c 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f4c3:	81 c3 e9 e7 00 00    	add    $0xe7e9,%ebx
c002f4c9:	8b 7c 24 10          	mov    0x10(%esp),%edi
    if (frame == NULL) return;
c002f4cd:	85 ff                	test   %edi,%edi
c002f4cf:	74 5f                	je     c002f530 <free_frame+0x75>
    lock_acquire(&frame_lock);
c002f4d1:	83 ec 0c             	sub    $0xc,%esp
c002f4d4:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f4da:	50                   	push   %eax
c002f4db:	e8 7c 3d ff ff       	call   c002325c <lock_acquire>

    struct frame_item *t = find_frame(frame);
c002f4e0:	89 3c 24             	mov    %edi,(%esp)
c002f4e3:	e8 49 ff ff ff       	call   c002f431 <find_frame>
c002f4e8:	89 c6                	mov    %eax,%esi

    if (t != NULL) {
c002f4ea:	83 c4 10             	add    $0x10,%esp
c002f4ed:	85 c0                	test   %eax,%eax
c002f4ef:	74 43                	je     c002f534 <free_frame+0x79>
        hash_delete(&frame_table, &t->hash_elem);
c002f4f1:	83 ec 08             	sub    $0x8,%esp
c002f4f4:	8d 40 14             	lea    0x14(%eax),%eax
c002f4f7:	50                   	push   %eax
c002f4f8:	8d 83 a8 1f 00 00    	lea    0x1fa8(%ebx),%eax
c002f4fe:	50                   	push   %eax
c002f4ff:	e8 e8 b6 ff ff       	call   c002abec <hash_delete>
        list_remove(&t->list_elem);
c002f504:	8d 46 0c             	lea    0xc(%esi),%eax
c002f507:	89 04 24             	mov    %eax,(%esp)
c002f50a:	e8 ed a2 ff ff       	call   c00297fc <list_remove>
        palloc_free_page (frame);
c002f50f:	89 3c 24             	mov    %edi,(%esp)
c002f512:	e8 90 46 ff ff       	call   c0023ba7 <palloc_free_page>
        free(t);
c002f517:	89 34 24             	mov    %esi,(%esp)
c002f51a:	e8 dd 4a ff ff       	call   c0023ffc <free>
        lock_release (&frame_lock);
c002f51f:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f525:	89 04 24             	mov    %eax,(%esp)
c002f528:	e8 30 3f ff ff       	call   c002345d <lock_release>
c002f52d:	83 c4 10             	add    $0x10,%esp
    else {
        lock_release (&frame_lock);
        PANIC ("frame not exist");
    }

}
c002f530:	5b                   	pop    %ebx
c002f531:	5e                   	pop    %esi
c002f532:	5f                   	pop    %edi
c002f533:	c3                   	ret    
        lock_release (&frame_lock);
c002f534:	83 ec 0c             	sub    $0xc,%esp
c002f537:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f53d:	50                   	push   %eax
c002f53e:	e8 1a 3f ff ff       	call   c002345d <lock_release>
        PANIC ("frame not exist");
c002f543:	8d 83 30 5e ff ff    	lea    -0xa1d0(%ebx),%eax
c002f549:	50                   	push   %eax
c002f54a:	8d 83 c0 35 ff ff    	lea    -0xca40(%ebx),%eax
c002f550:	50                   	push   %eax
c002f551:	6a 6d                	push   $0x6d
c002f553:	8d 83 40 5e ff ff    	lea    -0xa1c0(%ebx),%eax
c002f559:	50                   	push   %eax
c002f55a:	e8 ce 9b ff ff       	call   c002912d <debug_panic>

c002f55f <clock_frame_next>:
        }
        return e;
    }
    PANIC ("no space");
}
struct frame_item* clock_frame_next(void){
c002f55f:	53                   	push   %ebx
c002f560:	83 ec 08             	sub    $0x8,%esp
c002f563:	e8 db 0b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f568:	81 c3 44 e7 00 00    	add    $0xe744,%ebx
    if (frame_ptr == NULL || frame_ptr == list_end(&frame_clock_list))
c002f56e:	83 bb 54 1f 00 00 00 	cmpl   $0x0,0x1f54(%ebx)
c002f575:	74 30                	je     c002f5a7 <clock_frame_next+0x48>
c002f577:	83 ec 0c             	sub    $0xc,%esp
c002f57a:	8d 83 98 1f 00 00    	lea    0x1f98(%ebx),%eax
c002f580:	50                   	push   %eax
c002f581:	e8 6e 9d ff ff       	call   c00292f4 <list_end>
c002f586:	8b 93 54 1f 00 00    	mov    0x1f54(%ebx),%edx
c002f58c:	83 c4 10             	add    $0x10,%esp
c002f58f:	39 d0                	cmp    %edx,%eax
c002f591:	74 14                	je     c002f5a7 <clock_frame_next+0x48>
        frame_ptr = list_begin (&frame_clock_list);
    else
        frame_ptr = list_next (frame_ptr);
c002f593:	83 ec 0c             	sub    $0xc,%esp
c002f596:	52                   	push   %edx
c002f597:	e8 fb 9c ff ff       	call   c0029297 <list_next>
c002f59c:	89 83 54 1f 00 00    	mov    %eax,0x1f54(%ebx)
c002f5a2:	83 c4 10             	add    $0x10,%esp
c002f5a5:	eb 18                	jmp    c002f5bf <clock_frame_next+0x60>
        frame_ptr = list_begin (&frame_clock_list);
c002f5a7:	83 ec 0c             	sub    $0xc,%esp
c002f5aa:	8d 83 98 1f 00 00    	lea    0x1f98(%ebx),%eax
c002f5b0:	50                   	push   %eax
c002f5b1:	e8 9c 9c ff ff       	call   c0029252 <list_begin>
c002f5b6:	89 83 54 1f 00 00    	mov    %eax,0x1f54(%ebx)
c002f5bc:	83 c4 10             	add    $0x10,%esp
    struct frame_item *e = list_entry(frame_ptr, struct frame_item, list_elem);
c002f5bf:	8b 83 54 1f 00 00    	mov    0x1f54(%ebx),%eax
c002f5c5:	83 e8 0c             	sub    $0xc,%eax
    return e;
}
c002f5c8:	83 c4 08             	add    $0x8,%esp
c002f5cb:	5b                   	pop    %ebx
c002f5cc:	c3                   	ret    

c002f5cd <frame_evict>:
struct frame_item* frame_evict( uint32_t *pagedir ){
c002f5cd:	55                   	push   %ebp
c002f5ce:	57                   	push   %edi
c002f5cf:	56                   	push   %esi
c002f5d0:	53                   	push   %ebx
c002f5d1:	83 ec 18             	sub    $0x18,%esp
c002f5d4:	e8 6a 0b 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f5d9:	81 c3 d3 e6 00 00    	add    $0xe6d3,%ebx
    size_t n = hash_size(&frame_table);
c002f5df:	8d 83 a8 1f 00 00    	lea    0x1fa8(%ebx),%eax
c002f5e5:	50                   	push   %eax
c002f5e6:	e8 30 b8 ff ff       	call   c002ae1b <hash_size>
    for(size_t i = 0; i <= 2*n; ++i){
c002f5eb:	8d 2c 00             	lea    (%eax,%eax,1),%ebp
c002f5ee:	83 c4 10             	add    $0x10,%esp
c002f5f1:	bf 00 00 00 00       	mov    $0x0,%edi
c002f5f6:	eb 1b                	jmp    c002f613 <frame_evict+0x46>
            pagedir_set_accessed(pagedir, e->page, false);
c002f5f8:	83 ec 04             	sub    $0x4,%esp
c002f5fb:	6a 00                	push   $0x0
c002f5fd:	ff 76 08             	pushl  0x8(%esi)
c002f600:	ff 74 24 2c          	pushl  0x2c(%esp)
c002f604:	e8 27 ce ff ff       	call   c002c430 <pagedir_set_accessed>
            continue;
c002f609:	83 c4 10             	add    $0x10,%esp
    for(size_t i = 0; i <= 2*n; ++i){
c002f60c:	83 c7 01             	add    $0x1,%edi
c002f60f:	39 ef                	cmp    %ebp,%edi
c002f611:	77 2d                	ja     c002f640 <frame_evict+0x73>
        struct frame_item *e = clock_frame_next();
c002f613:	e8 47 ff ff ff       	call   c002f55f <clock_frame_next>
c002f618:	89 c6                	mov    %eax,%esi
        if(e->pinned) continue;
c002f61a:	80 78 1c 00          	cmpb   $0x0,0x1c(%eax)
c002f61e:	75 ec                	jne    c002f60c <frame_evict+0x3f>
        else if( pagedir_is_accessed(pagedir, e->page)) {
c002f620:	83 ec 08             	sub    $0x8,%esp
c002f623:	ff 70 08             	pushl  0x8(%eax)
c002f626:	ff 74 24 2c          	pushl  0x2c(%esp)
c002f62a:	e8 3b cc ff ff       	call   c002c26a <pagedir_is_accessed>
c002f62f:	83 c4 10             	add    $0x10,%esp
c002f632:	84 c0                	test   %al,%al
c002f634:	75 c2                	jne    c002f5f8 <frame_evict+0x2b>
}
c002f636:	89 f0                	mov    %esi,%eax
c002f638:	83 c4 0c             	add    $0xc,%esp
c002f63b:	5b                   	pop    %ebx
c002f63c:	5e                   	pop    %esi
c002f63d:	5f                   	pop    %edi
c002f63e:	5d                   	pop    %ebp
c002f63f:	c3                   	ret    
    PANIC ("no space");
c002f640:	8d 83 51 5e ff ff    	lea    -0xa1af(%ebx),%eax
c002f646:	50                   	push   %eax
c002f647:	8d 83 b4 35 ff ff    	lea    -0xca4c(%ebx),%eax
c002f64d:	50                   	push   %eax
c002f64e:	68 8d 00 00 00       	push   $0x8d
c002f653:	8d 83 40 5e ff ff    	lea    -0xa1c0(%ebx),%eax
c002f659:	50                   	push   %eax
c002f65a:	e8 ce 9a ff ff       	call   c002912d <debug_panic>

c002f65f <get_frame>:
void* get_frame (void *page, enum palloc_flags flags){
c002f65f:	55                   	push   %ebp
c002f660:	57                   	push   %edi
c002f661:	56                   	push   %esi
c002f662:	53                   	push   %ebx
c002f663:	83 ec 18             	sub    $0x18,%esp
c002f666:	e8 d8 0a 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f66b:	81 c3 41 e6 00 00    	add    $0xe641,%ebx
    lock_acquire (&frame_lock);
c002f671:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f677:	50                   	push   %eax
c002f678:	e8 df 3b ff ff       	call   c002325c <lock_acquire>
    void *frame_addr = palloc_get_page (PAL_USER | flags);
c002f67d:	8b 74 24 34          	mov    0x34(%esp),%esi
c002f681:	83 ce 04             	or     $0x4,%esi
c002f684:	89 34 24             	mov    %esi,(%esp)
c002f687:	e8 b0 43 ff ff       	call   c0023a3c <palloc_get_page>
c002f68c:	89 c7                	mov    %eax,%edi
    if (frame_addr == NULL) {
c002f68e:	83 c4 10             	add    $0x10,%esp
c002f691:	85 c0                	test   %eax,%eax
c002f693:	74 5f                	je     c002f6f4 <get_frame+0x95>
        struct frame_item *t = malloc (sizeof (struct frame_item));
c002f695:	83 ec 0c             	sub    $0xc,%esp
c002f698:	6a 20                	push   $0x20
c002f69a:	e8 af 47 ff ff       	call   c0023e4e <malloc>
c002f69f:	89 c6                	mov    %eax,%esi
        t->page = page;
c002f6a1:	8b 44 24 30          	mov    0x30(%esp),%eax
c002f6a5:	89 46 08             	mov    %eax,0x8(%esi)
        t->frame = frame_addr;
c002f6a8:	89 3e                	mov    %edi,(%esi)
        t->thread_use = thread_current();
c002f6aa:	e8 1a 19 ff ff       	call   c0020fc9 <thread_current>
c002f6af:	89 46 04             	mov    %eax,0x4(%esi)
        t->pinned = true;
c002f6b2:	c6 46 1c 01          	movb   $0x1,0x1c(%esi)
        hash_insert(&frame_table, &t->hash_elem);
c002f6b6:	83 c4 08             	add    $0x8,%esp
c002f6b9:	8d 46 14             	lea    0x14(%esi),%eax
c002f6bc:	50                   	push   %eax
c002f6bd:	8d 83 a8 1f 00 00    	lea    0x1fa8(%ebx),%eax
c002f6c3:	50                   	push   %eax
c002f6c4:	e8 3a b4 ff ff       	call   c002ab03 <hash_insert>
        list_push_back(&frame_clock_list, &t->list_elem);
c002f6c9:	83 c4 08             	add    $0x8,%esp
c002f6cc:	83 c6 0c             	add    $0xc,%esi
c002f6cf:	56                   	push   %esi
c002f6d0:	8d 83 98 1f 00 00    	lea    0x1f98(%ebx),%eax
c002f6d6:	50                   	push   %eax
c002f6d7:	e8 03 a1 ff ff       	call   c00297df <list_push_back>
        lock_release(&frame_lock);
c002f6dc:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f6e2:	89 04 24             	mov    %eax,(%esp)
c002f6e5:	e8 73 3d ff ff       	call   c002345d <lock_release>
}
c002f6ea:	89 f8                	mov    %edi,%eax
c002f6ec:	83 c4 1c             	add    $0x1c,%esp
c002f6ef:	5b                   	pop    %ebx
c002f6f0:	5e                   	pop    %esi
c002f6f1:	5f                   	pop    %edi
c002f6f2:	5d                   	pop    %ebp
c002f6f3:	c3                   	ret    
        struct frame_item *frame_ptr_ = frame_evict( thread_current()->pagedir );
c002f6f4:	e8 d0 18 ff ff       	call   c0020fc9 <thread_current>
c002f6f9:	83 ec 0c             	sub    $0xc,%esp
c002f6fc:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002f702:	e8 c6 fe ff ff       	call   c002f5cd <frame_evict>
c002f707:	89 c7                	mov    %eax,%edi
        pagedir_clear_page(frame_ptr_->thread_use->pagedir, frame_ptr_->page);
c002f709:	83 c4 08             	add    $0x8,%esp
c002f70c:	ff 70 08             	pushl  0x8(%eax)
c002f70f:	8b 40 04             	mov    0x4(%eax),%eax
c002f712:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002f718:	e8 34 cc ff ff       	call   c002c351 <pagedir_clear_page>
        is_dirty= is_dirty || pagedir_is_dirty(frame_ptr_->thread_use->pagedir, frame_ptr_->page);
c002f71d:	83 c4 08             	add    $0x8,%esp
c002f720:	ff 77 08             	pushl  0x8(%edi)
c002f723:	8b 47 04             	mov    0x4(%edi),%eax
c002f726:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002f72c:	e8 0a cb ff ff       	call   c002c23b <pagedir_is_dirty>
        is_dirty = is_dirty || pagedir_is_dirty(frame_ptr_->thread_use->pagedir, frame_ptr_->frame);
c002f731:	83 c4 10             	add    $0x10,%esp
c002f734:	bd 01 00 00 00       	mov    $0x1,%ebp
c002f739:	84 c0                	test   %al,%al
c002f73b:	0f 84 a6 00 00 00    	je     c002f7e7 <get_frame+0x188>
        swap_index_t swap_idx = swap_out( frame_ptr_->frame );
c002f741:	83 ec 0c             	sub    $0xc,%esp
c002f744:	ff 37                	pushl  (%edi)
c002f746:	e8 e1 01 00 00       	call   c002f92c <swap_out>
        spt_set_swap(frame_ptr_->thread_use->spt, frame_ptr_->page, swap_idx);
c002f74b:	83 c4 0c             	add    $0xc,%esp
c002f74e:	50                   	push   %eax
c002f74f:	ff 77 08             	pushl  0x8(%edi)
c002f752:	8b 47 04             	mov    0x4(%edi),%eax
c002f755:	ff b0 18 01 00 00    	pushl  0x118(%eax)
c002f75b:	e8 39 09 00 00       	call   c0030099 <spt_set_swap>
        spt_set_dirty(frame_ptr_->thread_use->spt, frame_ptr_->page, is_dirty);
c002f760:	83 c4 0c             	add    $0xc,%esp
c002f763:	55                   	push   %ebp
c002f764:	ff 77 08             	pushl  0x8(%edi)
c002f767:	8b 47 04             	mov    0x4(%edi),%eax
c002f76a:	ff b0 18 01 00 00    	pushl  0x118(%eax)
c002f770:	e8 c7 04 00 00       	call   c002fc3c <spt_set_dirty>
        free_frame_without_lock(frame_ptr_->frame);
c002f775:	8b 2f                	mov    (%edi),%ebp
    struct frame_item *t = find_frame(frame);
c002f777:	89 2c 24             	mov    %ebp,(%esp)
c002f77a:	e8 b2 fc ff ff       	call   c002f431 <find_frame>
c002f77f:	89 c7                	mov    %eax,%edi
    if (t != NULL) {
c002f781:	83 c4 10             	add    $0x10,%esp
c002f784:	85 c0                	test   %eax,%eax
c002f786:	74 7d                	je     c002f805 <get_frame+0x1a6>
        hash_delete(&frame_table, &t->hash_elem);
c002f788:	83 ec 08             	sub    $0x8,%esp
c002f78b:	8d 40 14             	lea    0x14(%eax),%eax
c002f78e:	50                   	push   %eax
c002f78f:	8d 83 a8 1f 00 00    	lea    0x1fa8(%ebx),%eax
c002f795:	50                   	push   %eax
c002f796:	e8 51 b4 ff ff       	call   c002abec <hash_delete>
        list_remove(&t->list_elem);
c002f79b:	8d 47 0c             	lea    0xc(%edi),%eax
c002f79e:	89 04 24             	mov    %eax,(%esp)
c002f7a1:	e8 56 a0 ff ff       	call   c00297fc <list_remove>
        palloc_free_page (frame);
c002f7a6:	89 2c 24             	mov    %ebp,(%esp)
c002f7a9:	e8 f9 43 ff ff       	call   c0023ba7 <palloc_free_page>
        free(t);
c002f7ae:	89 3c 24             	mov    %edi,(%esp)
c002f7b1:	e8 46 48 ff ff       	call   c0023ffc <free>
        frame_addr = palloc_get_page (PAL_USER | flags);
c002f7b6:	89 34 24             	mov    %esi,(%esp)
c002f7b9:	e8 7e 42 ff ff       	call   c0023a3c <palloc_get_page>
c002f7be:	89 c7                	mov    %eax,%edi
    if (frame_addr == NULL) {
c002f7c0:	83 c4 10             	add    $0x10,%esp
c002f7c3:	85 c0                	test   %eax,%eax
c002f7c5:	0f 85 ca fe ff ff    	jne    c002f695 <get_frame+0x36>
        PANIC ("no frame");
c002f7cb:	8d 83 5a 5e ff ff    	lea    -0xa1a6(%ebx),%eax
c002f7d1:	50                   	push   %eax
c002f7d2:	8d 83 e4 35 ff ff    	lea    -0xca1c(%ebx),%eax
c002f7d8:	50                   	push   %eax
c002f7d9:	6a 4a                	push   $0x4a
c002f7db:	8d 83 40 5e ff ff    	lea    -0xa1c0(%ebx),%eax
c002f7e1:	50                   	push   %eax
c002f7e2:	e8 46 99 ff ff       	call   c002912d <debug_panic>
        is_dirty = is_dirty || pagedir_is_dirty(frame_ptr_->thread_use->pagedir, frame_ptr_->frame);
c002f7e7:	83 ec 08             	sub    $0x8,%esp
c002f7ea:	ff 37                	pushl  (%edi)
c002f7ec:	8b 47 04             	mov    0x4(%edi),%eax
c002f7ef:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002f7f5:	e8 41 ca ff ff       	call   c002c23b <pagedir_is_dirty>
c002f7fa:	0f b6 e8             	movzbl %al,%ebp
c002f7fd:	83 c4 10             	add    $0x10,%esp
c002f800:	e9 3c ff ff ff       	jmp    c002f741 <get_frame+0xe2>
        PANIC ("frame not exist");
c002f805:	8d 83 30 5e ff ff    	lea    -0xa1d0(%ebx),%eax
c002f80b:	50                   	push   %eax
c002f80c:	8d 83 cc 35 ff ff    	lea    -0xca34(%ebx),%eax
c002f812:	50                   	push   %eax
c002f813:	6a 7c                	push   $0x7c
c002f815:	8d 83 40 5e ff ff    	lea    -0xa1c0(%ebx),%eax
c002f81b:	50                   	push   %eax
c002f81c:	e8 0c 99 ff ff       	call   c002912d <debug_panic>

c002f821 <get_pin_info>:

bool get_pin_info(void *frame) {
c002f821:	53                   	push   %ebx
c002f822:	83 ec 14             	sub    $0x14,%esp
c002f825:	e8 19 09 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f82a:	81 c3 82 e4 00 00    	add    $0xe482,%ebx
    struct frame_item *t = find_frame(frame);
c002f830:	ff 74 24 1c          	pushl  0x1c(%esp)
c002f834:	e8 f8 fb ff ff       	call   c002f431 <find_frame>
    if (t != NULL) {
c002f839:	83 c4 10             	add    $0x10,%esp
c002f83c:	85 c0                	test   %eax,%eax
c002f83e:	74 09                	je     c002f849 <get_pin_info+0x28>
        return t->pinned;
c002f840:	0f b6 40 1c          	movzbl 0x1c(%eax),%eax
    }
    else {
        PANIC ("frame not exist");
    }
}
c002f844:	83 c4 08             	add    $0x8,%esp
c002f847:	5b                   	pop    %ebx
c002f848:	c3                   	ret    
        PANIC ("frame not exist");
c002f849:	8d 83 30 5e ff ff    	lea    -0xa1d0(%ebx),%eax
c002f84f:	50                   	push   %eax
c002f850:	8d 83 a4 35 ff ff    	lea    -0xca5c(%ebx),%eax
c002f856:	50                   	push   %eax
c002f857:	68 9e 00 00 00       	push   $0x9e
c002f85c:	8d 83 40 5e ff ff    	lea    -0xa1c0(%ebx),%eax
c002f862:	50                   	push   %eax
c002f863:	e8 c5 98 ff ff       	call   c002912d <debug_panic>

c002f868 <set_pin_info>:

bool set_pin_info(void *frame, bool value) {
c002f868:	56                   	push   %esi
c002f869:	53                   	push   %ebx
c002f86a:	83 ec 10             	sub    $0x10,%esp
c002f86d:	e8 d1 08 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f872:	81 c3 3a e4 00 00    	add    $0xe43a,%ebx
c002f878:	8b 74 24 20          	mov    0x20(%esp),%esi
    lock_acquire(&frame_lock);
c002f87c:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f882:	50                   	push   %eax
c002f883:	e8 d4 39 ff ff       	call   c002325c <lock_acquire>
    struct frame_item *t = find_frame(frame);
c002f888:	83 c4 04             	add    $0x4,%esp
c002f88b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002f88f:	e8 9d fb ff ff       	call   c002f431 <find_frame>
    if (t != NULL) {
c002f894:	83 c4 10             	add    $0x10,%esp
c002f897:	85 c0                	test   %eax,%eax
c002f899:	74 22                	je     c002f8bd <set_pin_info+0x55>
        t->pinned = value;
c002f89b:	89 f2                	mov    %esi,%edx
c002f89d:	88 50 1c             	mov    %dl,0x1c(%eax)
        lock_release(&frame_lock);
c002f8a0:	83 ec 0c             	sub    $0xc,%esp
c002f8a3:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f8a9:	50                   	push   %eax
c002f8aa:	e8 ae 3b ff ff       	call   c002345d <lock_release>
        return true;
c002f8af:	83 c4 10             	add    $0x10,%esp
c002f8b2:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    else {
        lock_release(&frame_lock);
        return false;
    }
c002f8b7:	83 c4 04             	add    $0x4,%esp
c002f8ba:	5b                   	pop    %ebx
c002f8bb:	5e                   	pop    %esi
c002f8bc:	c3                   	ret    
        lock_release(&frame_lock);
c002f8bd:	83 ec 0c             	sub    $0xc,%esp
c002f8c0:	8d 83 74 1f 00 00    	lea    0x1f74(%ebx),%eax
c002f8c6:	50                   	push   %eax
c002f8c7:	e8 91 3b ff ff       	call   c002345d <lock_release>
        return false;
c002f8cc:	83 c4 10             	add    $0x10,%esp
c002f8cf:	b8 00 00 00 00       	mov    $0x0,%eax
c002f8d4:	eb e1                	jmp    c002f8b7 <set_pin_info+0x4f>

c002f8d6 <swap_init>:

static struct lock swap_lock;
static struct bitmap *swap_map;
static struct block *swap_block;

void swap_init() {
c002f8d6:	53                   	push   %ebx
c002f8d7:	83 ec 14             	sub    $0x14,%esp
c002f8da:	e8 64 08 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f8df:	81 c3 cd e3 00 00    	add    $0xe3cd,%ebx
    size_t swap_size;
    lock_init(&swap_lock);
c002f8e5:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c002f8eb:	50                   	push   %eax
c002f8ec:	e8 bf 38 ff ff       	call   c00231b0 <lock_init>
    swap_block = block_get_role(BLOCK_SWAP);
c002f8f1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c002f8f8:	e8 30 58 ff ff       	call   c002512d <block_get_role>
c002f8fd:	89 83 d4 1f 00 00    	mov    %eax,0x1fd4(%ebx)
    swap_size = block_size(swap_block) / SECTORS_PER_PAGE;
c002f903:	89 04 24             	mov    %eax,(%esp)
c002f906:	e8 41 5a ff ff       	call   c002534c <block_size>
c002f90b:	c1 e8 03             	shr    $0x3,%eax
    swap_map = bitmap_create(swap_size);
c002f90e:	89 04 24             	mov    %eax,(%esp)
c002f911:	e8 ba a9 ff ff       	call   c002a2d0 <bitmap_create>
c002f916:	89 83 d8 1f 00 00    	mov    %eax,0x1fd8(%ebx)
    bitmap_set_all(swap_map, true);
c002f91c:	83 c4 08             	add    $0x8,%esp
c002f91f:	6a 01                	push   $0x1
c002f921:	50                   	push   %eax
c002f922:	e8 52 a9 ff ff       	call   c002a279 <bitmap_set_all>
}
c002f927:	83 c4 18             	add    $0x18,%esp
c002f92a:	5b                   	pop    %ebx
c002f92b:	c3                   	ret    

c002f92c <swap_out>:




swap_index_t swap_out(void *page) {
c002f92c:	55                   	push   %ebp
c002f92d:	57                   	push   %edi
c002f92e:	56                   	push   %esi
c002f92f:	53                   	push   %ebx
c002f930:	83 ec 28             	sub    $0x28,%esp
c002f933:	e8 0b 08 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f938:	81 c3 74 e3 00 00    	add    $0xe374,%ebx
    lock_acquire (&swap_lock);
c002f93e:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c002f944:	50                   	push   %eax
c002f945:	e8 12 39 ff ff       	call   c002325c <lock_acquire>
    size_t free_index = bitmap_scan_and_flip (swap_map, 0, 1, true);
c002f94a:	6a 01                	push   $0x1
c002f94c:	6a 01                	push   $0x1
c002f94e:	6a 00                	push   $0x0
c002f950:	ff b3 d8 1f 00 00    	pushl  0x1fd8(%ebx)
c002f956:	e8 50 ad ff ff       	call   c002a6ab <bitmap_scan_and_flip>
c002f95b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    if (free_index == BITMAP_ERROR) {
c002f95f:	83 c4 20             	add    $0x20,%esp
c002f962:	83 f8 ff             	cmp    $0xffffffff,%eax
c002f965:	74 5f                	je     c002f9c6 <swap_out+0x9a>
        PANIC ("Swap device is full");
    }
    else {
        for (size_t i = 0; i < SECTORS_PER_PAGE; ++i){
            block_write (swap_block, free_index * SECTORS_PER_PAGE + i, page + BLOCK_SECTOR_SIZE * i);
c002f967:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002f96b:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
c002f972:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002f976:	8d 6e 08             	lea    0x8(%esi),%ebp
c002f979:	83 ec 04             	sub    $0x4,%esp
c002f97c:	57                   	push   %edi
c002f97d:	56                   	push   %esi
c002f97e:	ff b3 d4 1f 00 00    	pushl  0x1fd4(%ebx)
c002f984:	e8 55 59 ff ff       	call   c00252de <block_write>
c002f989:	83 c6 01             	add    $0x1,%esi
c002f98c:	81 c7 00 02 00 00    	add    $0x200,%edi
        for (size_t i = 0; i < SECTORS_PER_PAGE; ++i){
c002f992:	83 c4 10             	add    $0x10,%esp
c002f995:	39 ee                	cmp    %ebp,%esi
c002f997:	75 e0                	jne    c002f979 <swap_out+0x4d>
        }
        bitmap_set(swap_map, free_index, false);
c002f999:	83 ec 04             	sub    $0x4,%esp
c002f99c:	6a 00                	push   $0x0
c002f99e:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002f9a2:	57                   	push   %edi
c002f9a3:	ff b3 d8 1f 00 00    	pushl  0x1fd8(%ebx)
c002f9a9:	e8 b0 a6 ff ff       	call   c002a05e <bitmap_set>
        lock_release (&swap_lock);  
c002f9ae:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c002f9b4:	89 04 24             	mov    %eax,(%esp)
c002f9b7:	e8 a1 3a ff ff       	call   c002345d <lock_release>
        return free_index;
    }
}
c002f9bc:	89 f8                	mov    %edi,%eax
c002f9be:	83 c4 2c             	add    $0x2c,%esp
c002f9c1:	5b                   	pop    %ebx
c002f9c2:	5e                   	pop    %esi
c002f9c3:	5f                   	pop    %edi
c002f9c4:	5d                   	pop    %ebp
c002f9c5:	c3                   	ret    
        PANIC ("Swap device is full");
c002f9c6:	8d 83 63 5e ff ff    	lea    -0xa19d(%ebx),%eax
c002f9cc:	50                   	push   %eax
c002f9cd:	8d 83 04 36 ff ff    	lea    -0xc9fc(%ebx),%eax
c002f9d3:	50                   	push   %eax
c002f9d4:	6a 1d                	push   $0x1d
c002f9d6:	8d 83 77 5e ff ff    	lea    -0xa189(%ebx),%eax
c002f9dc:	50                   	push   %eax
c002f9dd:	e8 4b 97 ff ff       	call   c002912d <debug_panic>

c002f9e2 <swap_in>:

void swap_in(swap_index_t swap_index, void *page) {
c002f9e2:	55                   	push   %ebp
c002f9e3:	57                   	push   %edi
c002f9e4:	56                   	push   %esi
c002f9e5:	53                   	push   %ebx
c002f9e6:	83 ec 18             	sub    $0x18,%esp
c002f9e9:	e8 55 07 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002f9ee:	81 c3 be e2 00 00    	add    $0xe2be,%ebx
    lock_acquire (&swap_lock);
c002f9f4:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c002f9fa:	50                   	push   %eax
c002f9fb:	e8 5c 38 ff ff       	call   c002325c <lock_acquire>
    if (bitmap_test (swap_map, swap_index) == 0) {
c002fa00:	83 c4 08             	add    $0x8,%esp
c002fa03:	ff 74 24 28          	pushl  0x28(%esp)
c002fa07:	ff b3 d8 1f 00 00    	pushl  0x1fd8(%ebx)
c002fa0d:	e8 03 a7 ff ff       	call   c002a115 <bitmap_test>
c002fa12:	83 c4 10             	add    $0x10,%esp
c002fa15:	84 c0                	test   %al,%al
c002fa17:	75 5c                	jne    c002fa75 <swap_in+0x93>
        
        for (size_t i = 0; i < SECTORS_PER_PAGE; i++)
            block_read (swap_block, swap_index * SECTORS_PER_PAGE + i, page + BLOCK_SECTOR_SIZE * i);
c002fa19:	8b 44 24 20          	mov    0x20(%esp),%eax
c002fa1d:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
c002fa24:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002fa28:	8d 6e 08             	lea    0x8(%esi),%ebp
c002fa2b:	83 ec 04             	sub    $0x4,%esp
c002fa2e:	57                   	push   %edi
c002fa2f:	56                   	push   %esi
c002fa30:	ff b3 d4 1f 00 00    	pushl  0x1fd4(%ebx)
c002fa36:	e8 6f 58 ff ff       	call   c00252aa <block_read>
c002fa3b:	83 c6 01             	add    $0x1,%esi
c002fa3e:	81 c7 00 02 00 00    	add    $0x200,%edi
        for (size_t i = 0; i < SECTORS_PER_PAGE; i++)
c002fa44:	83 c4 10             	add    $0x10,%esp
c002fa47:	39 ee                	cmp    %ebp,%esi
c002fa49:	75 e0                	jne    c002fa2b <swap_in+0x49>
        bitmap_set (swap_map, swap_index, true);
c002fa4b:	83 ec 04             	sub    $0x4,%esp
c002fa4e:	6a 01                	push   $0x1
c002fa50:	ff 74 24 28          	pushl  0x28(%esp)
c002fa54:	ff b3 d8 1f 00 00    	pushl  0x1fd8(%ebx)
c002fa5a:	e8 ff a5 ff ff       	call   c002a05e <bitmap_set>
        lock_release(&swap_lock);
c002fa5f:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c002fa65:	89 04 24             	mov    %eax,(%esp)
c002fa68:	e8 f0 39 ff ff       	call   c002345d <lock_release>
    }
    else {
        PANIC ("Swap block is free");
    }
}
c002fa6d:	83 c4 1c             	add    $0x1c,%esp
c002fa70:	5b                   	pop    %ebx
c002fa71:	5e                   	pop    %esi
c002fa72:	5f                   	pop    %edi
c002fa73:	5d                   	pop    %ebp
c002fa74:	c3                   	ret    
        PANIC ("Swap block is free");
c002fa75:	8d 83 87 5e ff ff    	lea    -0xa179(%ebx),%eax
c002fa7b:	50                   	push   %eax
c002fa7c:	8d 83 fc 35 ff ff    	lea    -0xca04(%ebx),%eax
c002fa82:	50                   	push   %eax
c002fa83:	6a 33                	push   $0x33
c002fa85:	8d 83 77 5e ff ff    	lea    -0xa189(%ebx),%eax
c002fa8b:	50                   	push   %eax
c002fa8c:	e8 9c 96 ff ff       	call   c002912d <debug_panic>

c002fa91 <swap_free>:


void swap_free (swap_index_t swap_index) {
c002fa91:	56                   	push   %esi
c002fa92:	53                   	push   %ebx
c002fa93:	83 ec 0c             	sub    $0xc,%esp
c002fa96:	e8 a8 06 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fa9b:	81 c3 11 e2 00 00    	add    $0xe211,%ebx
c002faa1:	8b 74 24 18          	mov    0x18(%esp),%esi

  if (bitmap_test(swap_map, swap_index) == true) {
c002faa5:	56                   	push   %esi
c002faa6:	ff b3 d8 1f 00 00    	pushl  0x1fd8(%ebx)
c002faac:	e8 64 a6 ff ff       	call   c002a115 <bitmap_test>
c002fab1:	83 c4 10             	add    $0x10,%esp
c002fab4:	84 c0                	test   %al,%al
c002fab6:	75 17                	jne    c002facf <swap_free+0x3e>
    PANIC ("Error");
  }
  bitmap_set(swap_map, swap_index, true);
c002fab8:	83 ec 04             	sub    $0x4,%esp
c002fabb:	6a 01                	push   $0x1
c002fabd:	56                   	push   %esi
c002fabe:	ff b3 d8 1f 00 00    	pushl  0x1fd8(%ebx)
c002fac4:	e8 95 a5 ff ff       	call   c002a05e <bitmap_set>
c002fac9:	83 c4 14             	add    $0x14,%esp
c002facc:	5b                   	pop    %ebx
c002facd:	5e                   	pop    %esi
c002face:	c3                   	ret    
    PANIC ("Error");
c002facf:	8d 83 47 3f ff ff    	lea    -0xc0b9(%ebx),%eax
c002fad5:	50                   	push   %eax
c002fad6:	8d 83 f0 35 ff ff    	lea    -0xca10(%ebx),%eax
c002fadc:	50                   	push   %eax
c002fadd:	6a 3b                	push   $0x3b
c002fadf:	8d 83 77 5e ff ff    	lea    -0xa189(%ebx),%eax
c002fae5:	50                   	push   %eax
c002fae6:	e8 42 96 ff ff       	call   c002912d <debug_panic>

c002faeb <spt_hash_less>:
}

static bool spt_hash_less(const struct hash_elem *x, const struct hash_elem *y, void *aux UNUSED) {
    struct page_table_item *xx = hash_entry(x, struct page_table_item, hash_elem);
    struct page_table_item *yy = hash_entry(y, struct page_table_item, hash_elem);
    return xx->key < yy->key;
c002faeb:	8b 54 24 04          	mov    0x4(%esp),%edx
c002faef:	8b 44 24 08          	mov    0x8(%esp),%eax
c002faf3:	8b 40 dc             	mov    -0x24(%eax),%eax
c002faf6:	39 42 dc             	cmp    %eax,-0x24(%edx)
c002faf9:	0f 92 c0             	setb   %al
}
c002fafc:	c3                   	ret    

c002fafd <spt_hash>:
static unsigned spt_hash(const struct hash_elem *e, void *aux UNUSED) {
c002fafd:	53                   	push   %ebx
c002fafe:	83 ec 14             	sub    $0x14,%esp
c002fb01:	e8 3d 06 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fb06:	81 c3 a6 e1 00 00    	add    $0xe1a6,%ebx
	return hash_int( (int)t->key);
c002fb0c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002fb10:	ff 70 dc             	pushl  -0x24(%eax)
c002fb13:	e8 e5 b3 ff ff       	call   c002aefd <hash_int>
}
c002fb18:	83 c4 18             	add    $0x18,%esp
c002fb1b:	5b                   	pop    %ebx
c002fb1c:	c3                   	ret    

c002fb1d <spt_hash_clear>:

static void spt_hash_clear(struct hash_elem *e, void *aux UNUSED) {
c002fb1d:	55                   	push   %ebp
c002fb1e:	57                   	push   %edi
c002fb1f:	56                   	push   %esi
c002fb20:	53                   	push   %ebx
c002fb21:	83 ec 0c             	sub    $0xc,%esp
c002fb24:	e8 1a 06 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fb29:	81 c3 83 e1 00 00    	add    $0xe183,%ebx
c002fb2f:	8b 74 24 20          	mov    0x20(%esp),%esi
    struct page_table_item *t = hash_entry(e, struct page_table_item, hash_elem);
c002fb33:	8d 7e d8             	lea    -0x28(%esi),%edi
    if(t->status == FRAME) {
c002fb36:	8b 46 d8             	mov    -0x28(%esi),%eax
c002fb39:	83 f8 01             	cmp    $0x1,%eax
c002fb3c:	74 16                	je     c002fb54 <spt_hash_clear+0x37>
	    pagedir_clear_page(thread_current()->pagedir, t->key);
	    free_frame(t->value);
        // vm_frame_free(t->value);
	}
    else if (t->status == SWAP) {
c002fb3e:	83 f8 03             	cmp    $0x3,%eax
c002fb41:	74 38                	je     c002fb7b <spt_hash_clear+0x5e>
        swap_free(t->swap_index);
    }
	free(t);
c002fb43:	83 ec 0c             	sub    $0xc,%esp
c002fb46:	57                   	push   %edi
c002fb47:	e8 b0 44 ff ff       	call   c0023ffc <free>
}
c002fb4c:	83 c4 1c             	add    $0x1c,%esp
c002fb4f:	5b                   	pop    %ebx
c002fb50:	5e                   	pop    %esi
c002fb51:	5f                   	pop    %edi
c002fb52:	5d                   	pop    %ebp
c002fb53:	c3                   	ret    
	    pagedir_clear_page(thread_current()->pagedir, t->key);
c002fb54:	8b 6e dc             	mov    -0x24(%esi),%ebp
c002fb57:	e8 6d 14 ff ff       	call   c0020fc9 <thread_current>
c002fb5c:	83 ec 08             	sub    $0x8,%esp
c002fb5f:	55                   	push   %ebp
c002fb60:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002fb66:	e8 e6 c7 ff ff       	call   c002c351 <pagedir_clear_page>
	    free_frame(t->value);
c002fb6b:	83 c4 04             	add    $0x4,%esp
c002fb6e:	ff 76 e0             	pushl  -0x20(%esi)
c002fb71:	e8 45 f9 ff ff       	call   c002f4bb <free_frame>
c002fb76:	83 c4 10             	add    $0x10,%esp
c002fb79:	eb c8                	jmp    c002fb43 <spt_hash_clear+0x26>
        swap_free(t->swap_index);
c002fb7b:	83 ec 0c             	sub    $0xc,%esp
c002fb7e:	ff 76 e8             	pushl  -0x18(%esi)
c002fb81:	e8 0b ff ff ff       	call   c002fa91 <swap_free>
c002fb86:	83 c4 10             	add    $0x10,%esp
c002fb89:	eb b8                	jmp    c002fb43 <spt_hash_clear+0x26>

c002fb8b <spt_init>:

struct s_page_table* spt_init(void) {
c002fb8b:	56                   	push   %esi
c002fb8c:	53                   	push   %ebx
c002fb8d:	83 ec 10             	sub    $0x10,%esp
c002fb90:	e8 ae 05 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fb95:	81 c3 17 e1 00 00    	add    $0xe117,%ebx
    struct s_page_table *spt = (struct s_page_table *) malloc(sizeof(struct s_page_table));
c002fb9b:	6a 18                	push   $0x18
c002fb9d:	e8 ac 42 ff ff       	call   c0023e4e <malloc>
c002fba2:	89 c6                	mov    %eax,%esi
    //printf("malloc ok");
    hash_init(&spt->page_map, spt_hash, spt_hash_less, NULL);
c002fba4:	6a 00                	push   $0x0
c002fba6:	8d 83 3f 1e ff ff    	lea    -0xe1c1(%ebx),%eax
c002fbac:	50                   	push   %eax
c002fbad:	8d 83 51 1e ff ff    	lea    -0xe1af(%ebx),%eax
c002fbb3:	50                   	push   %eax
c002fbb4:	56                   	push   %esi
c002fbb5:	e8 a8 ae ff ff       	call   c002aa62 <hash_init>
    return spt;
}
c002fbba:	89 f0                	mov    %esi,%eax
c002fbbc:	83 c4 24             	add    $0x24,%esp
c002fbbf:	5b                   	pop    %ebx
c002fbc0:	5e                   	pop    %esi
c002fbc1:	c3                   	ret    

c002fbc2 <spt_destroy>:


void spt_destroy(struct s_page_table *spt) {
c002fbc2:	56                   	push   %esi
c002fbc3:	53                   	push   %ebx
c002fbc4:	83 ec 0c             	sub    $0xc,%esp
c002fbc7:	e8 77 05 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fbcc:	81 c3 e0 e0 00 00    	add    $0xe0e0,%ebx
c002fbd2:	8b 74 24 18          	mov    0x18(%esp),%esi
    hash_destroy (&spt->page_map, spt_hash_clear);
c002fbd6:	8d 83 71 1e ff ff    	lea    -0xe18f(%ebx),%eax
c002fbdc:	50                   	push   %eax
c002fbdd:	56                   	push   %esi
c002fbde:	e8 e6 ae ff ff       	call   c002aac9 <hash_destroy>
    free(spt);
c002fbe3:	89 34 24             	mov    %esi,(%esp)
c002fbe6:	e8 11 44 ff ff       	call   c0023ffc <free>
}
c002fbeb:	83 c4 14             	add    $0x14,%esp
c002fbee:	5b                   	pop    %ebx
c002fbef:	5e                   	pop    %esi
c002fbf0:	c3                   	ret    

c002fbf1 <find_page>:

struct page_table_item * find_page(struct s_page_table *spt, void *page) {
c002fbf1:	53                   	push   %ebx
c002fbf2:	83 ec 40             	sub    $0x40,%esp
c002fbf5:	e8 49 05 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fbfa:	81 c3 b2 e0 00 00    	add    $0xe0b2,%ebx
    struct hash_elem *e;
	struct page_table_item tmp;
	tmp.key = page;
c002fc00:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002fc04:	89 44 24 0c          	mov    %eax,0xc(%esp)
	e = hash_find(&spt->page_map, &(tmp.hash_elem));
c002fc08:	8d 44 24 30          	lea    0x30(%esp),%eax
c002fc0c:	50                   	push   %eax
c002fc0d:	ff 74 24 4c          	pushl  0x4c(%esp)
c002fc11:	e8 af af ff ff       	call   c002abc5 <hash_find>

	if(e != NULL) {
		return hash_entry(e, struct page_table_item, hash_elem);
c002fc16:	8d 50 d8             	lea    -0x28(%eax),%edx
c002fc19:	85 c0                	test   %eax,%eax
c002fc1b:	0f 45 c2             	cmovne %edx,%eax
	}
	else {
		return NULL;
	}
}
c002fc1e:	83 c4 48             	add    $0x48,%esp
c002fc21:	5b                   	pop    %ebx
c002fc22:	c3                   	ret    

c002fc23 <spt_has_item>:

bool spt_has_item(struct s_page_table *spt, void *page) {
c002fc23:	83 ec 14             	sub    $0x14,%esp
    struct page_table_item *e = find_page(spt, page);
c002fc26:	ff 74 24 1c          	pushl  0x1c(%esp)
c002fc2a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002fc2e:	e8 be ff ff ff       	call   c002fbf1 <find_page>
    if (e == NULL) return false;
c002fc33:	85 c0                	test   %eax,%eax
c002fc35:	0f 95 c0             	setne  %al
    return true;
}
c002fc38:	83 c4 1c             	add    $0x1c,%esp
c002fc3b:	c3                   	ret    

c002fc3c <spt_set_dirty>:

bool spt_set_dirty(struct s_page_table *spt, void *page, bool dirty) {
c002fc3c:	56                   	push   %esi
c002fc3d:	53                   	push   %ebx
c002fc3e:	83 ec 0c             	sub    $0xc,%esp
c002fc41:	e8 15 05 00 00       	call   c003015b <__x86.get_pc_thunk.si>
c002fc46:	81 c6 66 e0 00 00    	add    $0xe066,%esi
c002fc4c:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    struct page_table_item *e = find_page(spt, page);
c002fc50:	ff 74 24 1c          	pushl  0x1c(%esp)
c002fc54:	ff 74 24 1c          	pushl  0x1c(%esp)
c002fc58:	e8 94 ff ff ff       	call   c002fbf1 <find_page>
    if (e == NULL) PANIC("page not exist when set dirty");
c002fc5d:	83 c4 10             	add    $0x10,%esp
c002fc60:	85 c0                	test   %eax,%eax
c002fc62:	74 0e                	je     c002fc72 <spt_set_dirty+0x36>
    e->dirty = e->dirty || dirty;
c002fc64:	08 58 0c             	or     %bl,0xc(%eax)
    return true;
}
c002fc67:	b8 01 00 00 00       	mov    $0x1,%eax
c002fc6c:	83 c4 04             	add    $0x4,%esp
c002fc6f:	5b                   	pop    %ebx
c002fc70:	5e                   	pop    %esi
c002fc71:	c3                   	ret    
    if (e == NULL) PANIC("page not exist when set dirty");
c002fc72:	8d 86 9a 5e ff ff    	lea    -0xa166(%esi),%eax
c002fc78:	50                   	push   %eax
c002fc79:	8d 86 1c 36 ff ff    	lea    -0xc9e4(%esi),%eax
c002fc7f:	50                   	push   %eax
c002fc80:	6a 4a                	push   $0x4a
c002fc82:	8d 86 b8 5e ff ff    	lea    -0xa148(%esi),%eax
c002fc88:	50                   	push   %eax
c002fc89:	89 f3                	mov    %esi,%ebx
c002fc8b:	e8 9d 94 ff ff       	call   c002912d <debug_panic>

c002fc90 <load_page>:

static bool load_page_from_filesys(struct page_table_item *e, void *kpage);

bool load_page(struct s_page_table * spt, uint32_t *pagedir, void *upage) {
c002fc90:	55                   	push   %ebp
c002fc91:	57                   	push   %edi
c002fc92:	56                   	push   %esi
c002fc93:	53                   	push   %ebx
c002fc94:	83 ec 14             	sub    $0x14,%esp
c002fc97:	e8 a7 04 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fc9c:	81 c3 10 e0 00 00    	add    $0xe010,%ebx
    struct page_table_item *e = find_page(spt, upage);
c002fca2:	ff 74 24 30          	pushl  0x30(%esp)
c002fca6:	ff 74 24 2c          	pushl  0x2c(%esp)
c002fcaa:	e8 42 ff ff ff       	call   c002fbf1 <find_page>
    if (e == NULL) {
c002fcaf:	83 c4 10             	add    $0x10,%esp
c002fcb2:	85 c0                	test   %eax,%eax
c002fcb4:	0f 84 45 01 00 00    	je     c002fdff <load_page+0x16f>
c002fcba:	89 c6                	mov    %eax,%esi
        // printf("load_page fault1");
        return false;
    }
    if (e->status == FRAME) {
        return true; // already in frame, so don't need to load again
c002fcbc:	bf 01 00 00 00       	mov    $0x1,%edi
    if (e->status == FRAME) {
c002fcc1:	83 38 01             	cmpl   $0x1,(%eax)
c002fcc4:	74 7d                	je     c002fd43 <load_page+0xb3>
    }

    void *frame = get_frame(upage, PAL_USER);
c002fcc6:	83 ec 08             	sub    $0x8,%esp
c002fcc9:	6a 04                	push   $0x4
c002fccb:	ff 74 24 34          	pushl  0x34(%esp)
c002fccf:	e8 8b f9 ff ff       	call   c002f65f <get_frame>
c002fcd4:	89 c5                	mov    %eax,%ebp
    // void *frame = vm_frame_allocate(PAL_USER, upage);

    if (frame == NULL) {
c002fcd6:	83 c4 10             	add    $0x10,%esp
c002fcd9:	85 c0                	test   %eax,%eax
c002fcdb:	0f 84 28 01 00 00    	je     c002fe09 <load_page+0x179>
        return false;
        
    }
    bool writable = true;

    if(e->status == ALL_ZERO) {
c002fce1:	8b 16                	mov    (%esi),%edx
c002fce3:	85 d2                	test   %edx,%edx
c002fce5:	74 66                	je     c002fd4d <load_page+0xbd>
        memset(frame, 0, PGSIZE);
    }
    else if (e->status == SWAP) {
c002fce7:	83 fa 03             	cmp    $0x3,%edx
c002fcea:	0f 84 8e 00 00 00    	je     c002fd7e <load_page+0xee>
    bool writable = true;
c002fcf0:	b8 01 00 00 00       	mov    $0x1,%eax
        swap_in(e->swap_index, frame);
    }
    else if (e->status == FILE) {
c002fcf5:	83 fa 02             	cmp    $0x2,%edx
c002fcf8:	0f 84 99 00 00 00    	je     c002fd97 <load_page+0x107>
            return false;
        }
        writable = e->writable;
    }

    if (!pagedir_set_page(pagedir, upage, frame, writable)) {
c002fcfe:	0f b6 c0             	movzbl %al,%eax
c002fd01:	50                   	push   %eax
c002fd02:	55                   	push   %ebp
c002fd03:	ff 74 24 30          	pushl  0x30(%esp)
c002fd07:	ff 74 24 30          	pushl  0x30(%esp)
c002fd0b:	e8 b8 c2 ff ff       	call   c002bfc8 <pagedir_set_page>
c002fd10:	89 c7                	mov    %eax,%edi
c002fd12:	83 c4 10             	add    $0x10,%esp
c002fd15:	84 c0                	test   %al,%al
c002fd17:	0f 84 d1 00 00 00    	je     c002fdee <load_page+0x15e>
        free_frame(frame);
        // vm_frame_free(frame);
        return false;
    }

    e->status = FRAME;
c002fd1d:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    e->value = frame;
c002fd23:	89 6e 08             	mov    %ebp,0x8(%esi)

    pagedir_set_dirty(pagedir, frame, false);
c002fd26:	83 ec 04             	sub    $0x4,%esp
c002fd29:	6a 00                	push   $0x0
c002fd2b:	55                   	push   %ebp
c002fd2c:	ff 74 24 30          	pushl  0x30(%esp)
c002fd30:	e8 c1 c6 ff ff       	call   c002c3f6 <pagedir_set_dirty>

    set_pin_info(frame, false);
c002fd35:	83 c4 08             	add    $0x8,%esp
c002fd38:	6a 00                	push   $0x0
c002fd3a:	55                   	push   %ebp
c002fd3b:	e8 28 fb ff ff       	call   c002f868 <set_pin_info>
    // vm_frame_unpin(frame);

    return true;
c002fd40:	83 c4 10             	add    $0x10,%esp
}
c002fd43:	89 f8                	mov    %edi,%eax
c002fd45:	83 c4 0c             	add    $0xc,%esp
c002fd48:	5b                   	pop    %ebx
c002fd49:	5e                   	pop    %esi
c002fd4a:	5f                   	pop    %edi
c002fd4b:	5d                   	pop    %ebp
c002fd4c:	c3                   	ret    
        memset(frame, 0, PGSIZE);
c002fd4d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c002fd53:	c7 80 fc 0f 00 00 00 	movl   $0x0,0xffc(%eax)
c002fd5a:	00 00 00 
c002fd5d:	8d 78 04             	lea    0x4(%eax),%edi
c002fd60:	83 e7 fc             	and    $0xfffffffc,%edi
c002fd63:	89 c1                	mov    %eax,%ecx
c002fd65:	29 f9                	sub    %edi,%ecx
c002fd67:	81 c1 00 10 00 00    	add    $0x1000,%ecx
c002fd6d:	c1 e9 02             	shr    $0x2,%ecx
c002fd70:	b8 00 00 00 00       	mov    $0x0,%eax
c002fd75:	f3 ab                	rep stos %eax,%es:(%edi)
    bool writable = true;
c002fd77:	b8 01 00 00 00       	mov    $0x1,%eax
c002fd7c:	eb 80                	jmp    c002fcfe <load_page+0x6e>
        swap_in(e->swap_index, frame);
c002fd7e:	83 ec 08             	sub    $0x8,%esp
c002fd81:	50                   	push   %eax
c002fd82:	ff 76 10             	pushl  0x10(%esi)
c002fd85:	e8 58 fc ff ff       	call   c002f9e2 <swap_in>
c002fd8a:	83 c4 10             	add    $0x10,%esp
    bool writable = true;
c002fd8d:	b8 01 00 00 00       	mov    $0x1,%eax
c002fd92:	e9 67 ff ff ff       	jmp    c002fcfe <load_page+0x6e>


static bool load_page_from_filesys(struct page_table_item *e, void *kpage){
    file_seek (e->file, e->file_off);
c002fd97:	83 ec 08             	sub    $0x8,%esp
c002fd9a:	ff 76 1c             	pushl  0x1c(%esi)
c002fd9d:	ff 76 18             	pushl  0x18(%esi)
c002fda0:	e8 3a e2 ff ff       	call   c002dfdf <file_seek>

    int n_read = file_read (e->file, kpage, e->read_bytes);
c002fda5:	83 c4 0c             	add    $0xc,%esp
c002fda8:	ff 76 20             	pushl  0x20(%esi)
c002fdab:	55                   	push   %ebp
c002fdac:	ff 76 18             	pushl  0x18(%esi)
c002fdaf:	e8 36 e0 ff ff       	call   c002ddea <file_read>
    if(n_read != (int)e->read_bytes)
c002fdb4:	83 c4 10             	add    $0x10,%esp
c002fdb7:	3b 46 20             	cmp    0x20(%esi),%eax
c002fdba:	74 16                	je     c002fdd2 <load_page+0x142>
            free_frame(frame);
c002fdbc:	83 ec 0c             	sub    $0xc,%esp
c002fdbf:	55                   	push   %ebp
c002fdc0:	e8 f6 f6 ff ff       	call   c002f4bb <free_frame>
            return false;
c002fdc5:	83 c4 10             	add    $0x10,%esp
c002fdc8:	bf 00 00 00 00       	mov    $0x0,%edi
c002fdcd:	e9 71 ff ff ff       	jmp    c002fd43 <load_page+0xb3>
        return false;
    memset (kpage + n_read, 0, e->zero_bytes);
c002fdd2:	01 e8                	add    %ebp,%eax
c002fdd4:	83 ec 04             	sub    $0x4,%esp
c002fdd7:	ff 76 24             	pushl  0x24(%esi)
c002fdda:	6a 00                	push   $0x0
c002fddc:	50                   	push   %eax
c002fddd:	e8 ba 88 ff ff       	call   c002869c <memset>
        writable = e->writable;
c002fde2:	0f b6 46 14          	movzbl 0x14(%esi),%eax
c002fde6:	83 c4 10             	add    $0x10,%esp
c002fde9:	e9 10 ff ff ff       	jmp    c002fcfe <load_page+0x6e>
        free_frame(frame);
c002fdee:	83 ec 0c             	sub    $0xc,%esp
c002fdf1:	55                   	push   %ebp
c002fdf2:	e8 c4 f6 ff ff       	call   c002f4bb <free_frame>
        return false;
c002fdf7:	83 c4 10             	add    $0x10,%esp
c002fdfa:	e9 44 ff ff ff       	jmp    c002fd43 <load_page+0xb3>
        return false;
c002fdff:	bf 00 00 00 00       	mov    $0x0,%edi
c002fe04:	e9 3a ff ff ff       	jmp    c002fd43 <load_page+0xb3>
        return false;
c002fe09:	bf 00 00 00 00       	mov    $0x0,%edi
c002fe0e:	e9 30 ff ff ff       	jmp    c002fd43 <load_page+0xb3>

c002fe13 <spt_unmap>:
    return true;
}

bool spt_unmap(struct s_page_table *spt, uint32_t *pagedir, void *upage, struct file *file, off_t offset, size_t bytes) {
c002fe13:	55                   	push   %ebp
c002fe14:	57                   	push   %edi
c002fe15:	56                   	push   %esi
c002fe16:	53                   	push   %ebx
c002fe17:	83 ec 14             	sub    $0x14,%esp
c002fe1a:	e8 24 03 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002fe1f:	81 c3 8d de 00 00    	add    $0xde8d,%ebx
c002fe25:	8b 7c 24 28          	mov    0x28(%esp),%edi
    struct page_table_item *e = find_page(spt, upage);
c002fe29:	ff 74 24 30          	pushl  0x30(%esp)
c002fe2d:	57                   	push   %edi
c002fe2e:	e8 be fd ff ff       	call   c002fbf1 <find_page>
    if (e == NULL) PANIC("page not exist when unmap");
c002fe33:	83 c4 10             	add    $0x10,%esp
c002fe36:	85 c0                	test   %eax,%eax
c002fe38:	74 2c                	je     c002fe66 <spt_unmap+0x53>
c002fe3a:	89 c6                	mov    %eax,%esi

    if (e->status == FRAME) {
c002fe3c:	8b 00                	mov    (%eax),%eax
c002fe3e:	83 f8 01             	cmp    $0x1,%eax
c002fe41:	74 42                	je     c002fe85 <spt_unmap+0x72>
        }
        free_frame(e->value);
        // vm_frame_free(e->value);
        pagedir_clear_page(pagedir, e->key);
    }
    else if (e->status == SWAP) {
c002fe43:	83 f8 03             	cmp    $0x3,%eax
c002fe46:	0f 84 bd 00 00 00    	je     c002ff09 <spt_unmap+0xf6>
            swap_free(e->swap_index);
        }
    }

    //printf("hash_delete loading");
    hash_delete(&spt->page_map, &e->hash_elem);
c002fe4c:	83 ec 08             	sub    $0x8,%esp
c002fe4f:	83 c6 28             	add    $0x28,%esi
c002fe52:	56                   	push   %esi
c002fe53:	57                   	push   %edi
c002fe54:	e8 93 ad ff ff       	call   c002abec <hash_delete>
    return true;
}
c002fe59:	b8 01 00 00 00       	mov    $0x1,%eax
c002fe5e:	83 c4 1c             	add    $0x1c,%esp
c002fe61:	5b                   	pop    %ebx
c002fe62:	5e                   	pop    %esi
c002fe63:	5f                   	pop    %edi
c002fe64:	5d                   	pop    %ebp
c002fe65:	c3                   	ret    
    if (e == NULL) PANIC("page not exist when unmap");
c002fe66:	8d 83 c7 5e ff ff    	lea    -0xa139(%ebx),%eax
c002fe6c:	50                   	push   %eax
c002fe6d:	8d 83 10 36 ff ff    	lea    -0xc9f0(%ebx),%eax
c002fe73:	50                   	push   %eax
c002fe74:	68 94 00 00 00       	push   $0x94
c002fe79:	8d 83 b8 5e ff ff    	lea    -0xa148(%ebx),%eax
c002fe7f:	50                   	push   %eax
c002fe80:	e8 a8 92 ff ff       	call   c002912d <debug_panic>
        set_pin_info(e->value, true);
c002fe85:	83 ec 08             	sub    $0x8,%esp
c002fe88:	6a 01                	push   $0x1
c002fe8a:	ff 76 08             	pushl  0x8(%esi)
c002fe8d:	e8 d6 f9 ff ff       	call   c002f868 <set_pin_info>
    if (e->status == FRAME) {
c002fe92:	8b 06                	mov    (%esi),%eax
c002fe94:	83 c4 10             	add    $0x10,%esp
c002fe97:	83 f8 01             	cmp    $0x1,%eax
c002fe9a:	75 a7                	jne    c002fe43 <spt_unmap+0x30>
        ifdirty = ifdirty || pagedir_is_dirty(pagedir, e->key);
c002fe9c:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
c002fea0:	74 19                	je     c002febb <spt_unmap+0xa8>
            file_write_at (file, e->key, bytes, offset);
c002fea2:	ff 74 24 30          	pushl  0x30(%esp)
c002fea6:	ff 74 24 38          	pushl  0x38(%esp)
c002feaa:	ff 76 04             	pushl  0x4(%esi)
c002fead:	ff 74 24 38          	pushl  0x38(%esp)
c002feb1:	e8 bd df ff ff       	call   c002de73 <file_write_at>
c002feb6:	83 c4 10             	add    $0x10,%esp
c002feb9:	eb 2c                	jmp    c002fee7 <spt_unmap+0xd4>
        ifdirty = ifdirty || pagedir_is_dirty(pagedir, e->key);
c002febb:	83 ec 08             	sub    $0x8,%esp
c002febe:	ff 76 04             	pushl  0x4(%esi)
c002fec1:	ff 74 24 30          	pushl  0x30(%esp)
c002fec5:	e8 71 c3 ff ff       	call   c002c23b <pagedir_is_dirty>
        ifdirty = ifdirty || pagedir_is_dirty(pagedir, e->value);
c002feca:	83 c4 10             	add    $0x10,%esp
c002fecd:	84 c0                	test   %al,%al
c002fecf:	75 d1                	jne    c002fea2 <spt_unmap+0x8f>
c002fed1:	83 ec 08             	sub    $0x8,%esp
c002fed4:	ff 76 08             	pushl  0x8(%esi)
c002fed7:	ff 74 24 30          	pushl  0x30(%esp)
c002fedb:	e8 5b c3 ff ff       	call   c002c23b <pagedir_is_dirty>
        if (ifdirty) {
c002fee0:	83 c4 10             	add    $0x10,%esp
c002fee3:	84 c0                	test   %al,%al
c002fee5:	75 bb                	jne    c002fea2 <spt_unmap+0x8f>
        free_frame(e->value);
c002fee7:	83 ec 0c             	sub    $0xc,%esp
c002feea:	ff 76 08             	pushl  0x8(%esi)
c002feed:	e8 c9 f5 ff ff       	call   c002f4bb <free_frame>
        pagedir_clear_page(pagedir, e->key);
c002fef2:	83 c4 08             	add    $0x8,%esp
c002fef5:	ff 76 04             	pushl  0x4(%esi)
c002fef8:	ff 74 24 30          	pushl  0x30(%esp)
c002fefc:	e8 50 c4 ff ff       	call   c002c351 <pagedir_clear_page>
c002ff01:	83 c4 10             	add    $0x10,%esp
c002ff04:	e9 43 ff ff ff       	jmp    c002fe4c <spt_unmap+0x39>
        ifdirty = ifdirty || pagedir_is_dirty(pagedir, e->key);
c002ff09:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
c002ff0d:	74 3c                	je     c002ff4b <spt_unmap+0x138>
            void *tmp_page = palloc_get_page(0);
c002ff0f:	83 ec 0c             	sub    $0xc,%esp
c002ff12:	6a 00                	push   $0x0
c002ff14:	e8 23 3b ff ff       	call   c0023a3c <palloc_get_page>
c002ff19:	89 c5                	mov    %eax,%ebp
            swap_in(e->swap_index, tmp_page);
c002ff1b:	83 c4 08             	add    $0x8,%esp
c002ff1e:	50                   	push   %eax
c002ff1f:	ff 76 10             	pushl  0x10(%esi)
c002ff22:	e8 bb fa ff ff       	call   c002f9e2 <swap_in>
            file_write_at (file, tmp_page, PGSIZE, offset);
c002ff27:	ff 74 24 40          	pushl  0x40(%esp)
c002ff2b:	68 00 10 00 00       	push   $0x1000
c002ff30:	55                   	push   %ebp
c002ff31:	ff 74 24 48          	pushl  0x48(%esp)
c002ff35:	e8 39 df ff ff       	call   c002de73 <file_write_at>
            palloc_free_page(tmp_page);
c002ff3a:	83 c4 14             	add    $0x14,%esp
c002ff3d:	55                   	push   %ebp
c002ff3e:	e8 64 3c ff ff       	call   c0023ba7 <palloc_free_page>
c002ff43:	83 c4 10             	add    $0x10,%esp
c002ff46:	e9 01 ff ff ff       	jmp    c002fe4c <spt_unmap+0x39>
        ifdirty = ifdirty || pagedir_is_dirty(pagedir, e->key);
c002ff4b:	83 ec 08             	sub    $0x8,%esp
c002ff4e:	ff 76 04             	pushl  0x4(%esi)
c002ff51:	ff 74 24 30          	pushl  0x30(%esp)
c002ff55:	e8 e1 c2 ff ff       	call   c002c23b <pagedir_is_dirty>
        if (ifdirty) {
c002ff5a:	83 c4 10             	add    $0x10,%esp
c002ff5d:	84 c0                	test   %al,%al
c002ff5f:	75 ae                	jne    c002ff0f <spt_unmap+0xfc>
            swap_free(e->swap_index);
c002ff61:	83 ec 0c             	sub    $0xc,%esp
c002ff64:	ff 76 10             	pushl  0x10(%esi)
c002ff67:	e8 25 fb ff ff       	call   c002fa91 <swap_free>
c002ff6c:	83 c4 10             	add    $0x10,%esp
c002ff6f:	e9 d8 fe ff ff       	jmp    c002fe4c <spt_unmap+0x39>

c002ff74 <spt_install_file>:


bool spt_install_file(struct s_page_table *spt, void *page, struct file *file, off_t offset,
                        uint32_t read_bytes, uint32_t zero_bytes, bool writable) {
c002ff74:	56                   	push   %esi
c002ff75:	53                   	push   %ebx
c002ff76:	83 ec 10             	sub    $0x10,%esp
c002ff79:	e8 c5 01 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ff7e:	81 c3 2e dd 00 00    	add    $0xdd2e,%ebx
c002ff84:	8b 74 24 34          	mov    0x34(%esp),%esi

    struct page_table_item *e = malloc(sizeof(struct page_table_item));
c002ff88:	6a 30                	push   $0x30
c002ff8a:	e8 bf 3e ff ff       	call   c0023e4e <malloc>
    e->key = page;
c002ff8f:	8b 54 24 24          	mov    0x24(%esp),%edx
c002ff93:	89 50 04             	mov    %edx,0x4(%eax)
    e->read_bytes = read_bytes;
c002ff96:	8b 54 24 30          	mov    0x30(%esp),%edx
c002ff9a:	89 50 20             	mov    %edx,0x20(%eax)
    e->zero_bytes = zero_bytes;
c002ff9d:	8b 54 24 34          	mov    0x34(%esp),%edx
c002ffa1:	89 50 24             	mov    %edx,0x24(%eax)
    e->writable = writable;
c002ffa4:	89 f1                	mov    %esi,%ecx
c002ffa6:	88 48 14             	mov    %cl,0x14(%eax)
    e->file = file;
c002ffa9:	8b 54 24 28          	mov    0x28(%esp),%edx
c002ffad:	89 50 18             	mov    %edx,0x18(%eax)
    e->file_off = offset;
c002ffb0:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c002ffb4:	89 50 1c             	mov    %edx,0x1c(%eax)
    e->status = FILE;
c002ffb7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    e->dirty = false;
c002ffbd:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
    e->value = NULL;
c002ffc1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    return hash_insert(spt, &e->hash_elem) == NULL;
c002ffc8:	83 c4 08             	add    $0x8,%esp
c002ffcb:	83 c0 28             	add    $0x28,%eax
c002ffce:	50                   	push   %eax
c002ffcf:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ffd3:	e8 2b ab ff ff       	call   c002ab03 <hash_insert>
c002ffd8:	85 c0                	test   %eax,%eax
c002ffda:	0f 94 c0             	sete   %al
}
c002ffdd:	83 c4 14             	add    $0x14,%esp
c002ffe0:	5b                   	pop    %ebx
c002ffe1:	5e                   	pop    %esi
c002ffe2:	c3                   	ret    

c002ffe3 <spt_install_frame>:

//use in process.c install_page
bool spt_install_frame(struct s_page_table *spt, void *upage, void *kpage) {
c002ffe3:	57                   	push   %edi
c002ffe4:	56                   	push   %esi
c002ffe5:	53                   	push   %ebx
c002ffe6:	e8 58 01 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c002ffeb:	81 c3 c1 dc 00 00    	add    $0xdcc1,%ebx
c002fff1:	8b 74 24 10          	mov    0x10(%esp),%esi
c002fff5:	8b 7c 24 14          	mov    0x14(%esp),%edi
    struct page_table_elem *t = find_page(spt, upage);
c002fff9:	83 ec 08             	sub    $0x8,%esp
c002fffc:	57                   	push   %edi
c002fffd:	56                   	push   %esi
c002fffe:	e8 ee fb ff ff       	call   c002fbf1 <find_page>
    if (t != NULL) {
c0030003:	83 c4 10             	add    $0x10,%esp
        return false;
c0030006:	ba 00 00 00 00       	mov    $0x0,%edx
    if (t != NULL) {
c003000b:	85 c0                	test   %eax,%eax
c003000d:	74 06                	je     c0030015 <spt_install_frame+0x32>
    e->status = FRAME;
    e->dirty = false;
    e->swap_index = -1;
    hash_insert(spt, &e->hash_elem);
    return true;
}
c003000f:	89 d0                	mov    %edx,%eax
c0030011:	5b                   	pop    %ebx
c0030012:	5e                   	pop    %esi
c0030013:	5f                   	pop    %edi
c0030014:	c3                   	ret    
    struct page_table_item *e = (struct page_table_item *) malloc(sizeof(struct page_table_item));
c0030015:	83 ec 0c             	sub    $0xc,%esp
c0030018:	6a 30                	push   $0x30
c003001a:	e8 2f 3e ff ff       	call   c0023e4e <malloc>
    e->key = upage;
c003001f:	89 78 04             	mov    %edi,0x4(%eax)
    e->value = kpage;
c0030022:	8b 54 24 28          	mov    0x28(%esp),%edx
c0030026:	89 50 08             	mov    %edx,0x8(%eax)
    e->status = FRAME;
c0030029:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    e->dirty = false;
c003002f:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
    e->swap_index = -1;
c0030033:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
    hash_insert(spt, &e->hash_elem);
c003003a:	83 c4 08             	add    $0x8,%esp
c003003d:	83 c0 28             	add    $0x28,%eax
c0030040:	50                   	push   %eax
c0030041:	56                   	push   %esi
c0030042:	e8 bc aa ff ff       	call   c002ab03 <hash_insert>
    return true;
c0030047:	83 c4 10             	add    $0x10,%esp
c003004a:	ba 01 00 00 00       	mov    $0x1,%edx
c003004f:	eb be                	jmp    c003000f <spt_install_frame+0x2c>

c0030051 <spt_install_zeropage>:

//use in exception.c page_fault
bool spt_install_zeropage(struct s_page_table *spt, void *page) {
c0030051:	53                   	push   %ebx
c0030052:	83 ec 14             	sub    $0x14,%esp
c0030055:	e8 e9 00 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c003005a:	81 c3 52 dc 00 00    	add    $0xdc52,%ebx
    struct page_table_item *e = malloc(sizeof(struct page_table_item));
c0030060:	6a 30                	push   $0x30
c0030062:	e8 e7 3d ff ff       	call   c0023e4e <malloc>
    e->key = page;
c0030067:	8b 54 24 24          	mov    0x24(%esp),%edx
c003006b:	89 50 04             	mov    %edx,0x4(%eax)
    e->status = ALL_ZERO;
c003006e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    e->dirty = false;
c0030074:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
    e->value = NULL;
c0030078:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    return hash_insert(spt, &e->hash_elem) == NULL;
c003007f:	83 c4 08             	add    $0x8,%esp
c0030082:	83 c0 28             	add    $0x28,%eax
c0030085:	50                   	push   %eax
c0030086:	ff 74 24 1c          	pushl  0x1c(%esp)
c003008a:	e8 74 aa ff ff       	call   c002ab03 <hash_insert>
c003008f:	85 c0                	test   %eax,%eax
c0030091:	0f 94 c0             	sete   %al
}
c0030094:	83 c4 18             	add    $0x18,%esp
c0030097:	5b                   	pop    %ebx
c0030098:	c3                   	ret    

c0030099 <spt_set_swap>:

bool spt_set_swap(struct s_page_table *spt, void *page, swap_index_t swap_index) {
c0030099:	53                   	push   %ebx
c003009a:	83 ec 10             	sub    $0x10,%esp
c003009d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    struct page_table_item *e = find_page(spt, page);
c00300a1:	53                   	push   %ebx
c00300a2:	ff 74 24 1c          	pushl  0x1c(%esp)
c00300a6:	e8 46 fb ff ff       	call   c002fbf1 <find_page>
    if (e == NULL)  return false;
c00300ab:	83 c4 10             	add    $0x10,%esp
c00300ae:	85 c0                	test   %eax,%eax
c00300b0:	74 1a                	je     c00300cc <spt_set_swap+0x33>
    e->status = SWAP;
c00300b2:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    e->value = page;
c00300b8:	89 58 08             	mov    %ebx,0x8(%eax)
    e->swap_index  = swap_index;
c00300bb:	8b 54 24 18          	mov    0x18(%esp),%edx
c00300bf:	89 50 10             	mov    %edx,0x10(%eax)
    return true;
c00300c2:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00300c7:	83 c4 08             	add    $0x8,%esp
c00300ca:	5b                   	pop    %ebx
c00300cb:	c3                   	ret    
    if (e == NULL)  return false;
c00300cc:	b8 00 00 00 00       	mov    $0x0,%eax
c00300d1:	eb f4                	jmp    c00300c7 <spt_set_swap+0x2e>

c00300d3 <pin_page>:


void pin_page(struct s_page_table *spt, void *page) {
c00300d3:	53                   	push   %ebx
c00300d4:	83 ec 10             	sub    $0x10,%esp
c00300d7:	e8 67 00 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c00300dc:	81 c3 d0 db 00 00    	add    $0xdbd0,%ebx
  struct page_table_item *e;
  e = find_page(spt, page);
c00300e2:	ff 74 24 1c          	pushl  0x1c(%esp)
c00300e6:	ff 74 24 1c          	pushl  0x1c(%esp)
c00300ea:	e8 02 fb ff ff       	call   c002fbf1 <find_page>
  if(e == NULL) {
c00300ef:	83 c4 10             	add    $0x10,%esp
c00300f2:	85 c0                	test   %eax,%eax
c00300f4:	74 10                	je     c0030106 <pin_page+0x33>
    return;
  }

//   ASSERT (spte->status == ON_FRAME);
  set_pin_info (e->value, true);
c00300f6:	83 ec 08             	sub    $0x8,%esp
c00300f9:	6a 01                	push   $0x1
c00300fb:	ff 70 08             	pushl  0x8(%eax)
c00300fe:	e8 65 f7 ff ff       	call   c002f868 <set_pin_info>
c0030103:	83 c4 10             	add    $0x10,%esp
}
c0030106:	83 c4 08             	add    $0x8,%esp
c0030109:	5b                   	pop    %ebx
c003010a:	c3                   	ret    

c003010b <unpin_page>:

void unpin_page(struct s_page_table *spt, void *page) {
c003010b:	53                   	push   %ebx
c003010c:	83 ec 10             	sub    $0x10,%esp
c003010f:	e8 2f 00 00 00       	call   c0030143 <__x86.get_pc_thunk.bx>
c0030114:	81 c3 98 db 00 00    	add    $0xdb98,%ebx
  struct page_table_item *e;
  e = find_page(spt, page);
c003011a:	ff 74 24 1c          	pushl  0x1c(%esp)
c003011e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0030122:	e8 ca fa ff ff       	call   c002fbf1 <find_page>
  if(e == NULL) {
c0030127:	83 c4 10             	add    $0x10,%esp
c003012a:	85 c0                	test   %eax,%eax
c003012c:	74 10                	je     c003013e <unpin_page+0x33>
    return;
  }

//   ASSERT (spte->status == ON_FRAME);
  set_pin_info (e->value, false);
c003012e:	83 ec 08             	sub    $0x8,%esp
c0030131:	6a 00                	push   $0x0
c0030133:	ff 70 08             	pushl  0x8(%eax)
c0030136:	e8 2d f7 ff ff       	call   c002f868 <set_pin_info>
c003013b:	83 c4 10             	add    $0x10,%esp
c003013e:	83 c4 08             	add    $0x8,%esp
c0030141:	5b                   	pop    %ebx
c0030142:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

c0030143 <__x86.get_pc_thunk.bx>:
c0030143:	8b 1c 24             	mov    (%esp),%ebx
c0030146:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

c0030147 <__x86.get_pc_thunk.ax>:
c0030147:	8b 04 24             	mov    (%esp),%eax
c003014a:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bp:

c003014b <__x86.get_pc_thunk.bp>:
c003014b:	8b 2c 24             	mov    (%esp),%ebp
c003014e:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.di:

c003014f <__x86.get_pc_thunk.di>:
c003014f:	8b 3c 24             	mov    (%esp),%edi
c0030152:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c0030153 <__x86.get_pc_thunk.dx>:
c0030153:	8b 14 24             	mov    (%esp),%edx
c0030156:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

c0030157 <__x86.get_pc_thunk.cx>:
c0030157:	8b 0c 24             	mov    (%esp),%ecx
c003015a:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.si:

c003015b <__x86.get_pc_thunk.si>:
c003015b:	8b 34 24             	mov    (%esp),%esi
c003015e:	c3                   	ret    
