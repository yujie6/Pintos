
kernel.o：     文件格式 elf32-i386


Disassembly of section .text:

c00200b8 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c00200b8:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c00200bd:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c00200bf:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c00200c0:	b4 88                	mov    $0x88,%ah
	int $0x15
c00200c2:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c00200c4:	66 05 00 04          	add    $0x400,%ax
c00200c8:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c00200ca:	66 3d 00 00          	cmp    $0x0,%ax
c00200ce:	01 00                	add    %eax,(%eax)
	jbe 1f
c00200d0:	76 06                	jbe    c00200d8 <start+0x20>
	mov $0x10000, %eax
c00200d2:	66 b8 00 00          	mov    $0x0,%ax
c00200d6:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c00200d8:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c00200dc:	67 66 a3 be 01       	addr16 mov %ax,0x1be
c00200e1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200e3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200e5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200e7:	75 fa                	jne    c00200e3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200e9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200eb:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ed:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200ef:	a8 02                	test   $0x2,%al
	jnz 1b
c00200f1:	75 fa                	jne    c00200ed <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200f3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200f5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200f7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200f9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200fb:	75 fa                	jne    c00200f7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200fd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c0020102:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c0020105:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c0020108:	66 b9 00 04          	mov    $0x400,%cx
c002010c:	00 00                	add    %al,(%eax)
	rep stosl
c002010e:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c0020111:	66 b8 07 00          	mov    $0x7,%ax
c0020115:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c0020117:	66 b9 11 00          	mov    $0x11,%cx
c002011b:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c002011d:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020120:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c0020127:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c0020128:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c002012b:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c0020132:	00 e2                	add    %ah,%dl
	loop 1b
c0020134:	eb b8                	jmp    c00200ee <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c0020136:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c0020138:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c002013a:	66 b8 07 00          	mov    $0x7,%ax
c002013e:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020140:	66 b9 00 40          	mov    $0x4000,%cx
c0020144:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020146:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020149:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020150:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020151:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020156:	e2 f1                	loop   c0020149 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020158:	66 b8 00 f0          	mov    $0xf000,%ax
c002015c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002015e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020161:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020162:	67 66 0f 01 15       	lgdtw  (%di)
c0020167:	b8 01 00 00 0f       	mov    $0xf000001,%eax
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002016c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002016e:	66 0d 05 00          	or     $0x5,%ax
c0020172:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020178:	ea 7f 01 02 c0 08 00 	ljmp   $0x8,$0xc002017f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002017f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020183:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020185:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020187:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020189:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002018b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002018d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020193:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020198:	e8 67 00 00 00       	call   c0020204 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002019d:	eb fe                	jmp    c002019d <start+0xe5>
	...

c00201a0 <gdt>:
	...
c00201a8:	ff                   	(bad)  
c00201a9:	ff 00                	incl   (%eax)
c00201ab:	00 00                	add    %al,(%eax)
c00201ad:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c00201b4:	00                   	.byte 0x0
c00201b5:	92                   	xchg   %eax,%edx
c00201b6:	cf                   	iret   
	...

c00201b8 <gdtdesc>:
c00201b8:	17                   	pop    %ss
c00201b9:	00                   	.byte 0x0
c00201ba:	a0                   	.byte 0xa0
c00201bb:	01 02                	add    %eax,(%edx)
c00201bd:	c0                   	.byte 0xc0

c00201be <init_ram_pages>:
c00201be:	00 00                	add    %al,(%eax)
	...

c00201c2 <run_task>:
}

/* Runs the task specified in ARGV[1]. */
// try passing argv to process_execute
static void
run_task(char **argv) {
c00201c2:	56                   	push   %esi
c00201c3:	53                   	push   %ebx
c00201c4:	83 ec 0c             	sub    $0xc,%esp
c00201c7:	e8 cb d6 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00201cc:	81 c3 34 a3 01 00    	add    $0x1a334,%ebx
    const char *task = argv[1];
c00201d2:	8b 44 24 18          	mov    0x18(%esp),%eax
c00201d6:	8b 70 04             	mov    0x4(%eax),%esi

    printf("Executing '%s':\n", task);
c00201d9:	56                   	push   %esi
c00201da:	8d 83 29 44 ff ff    	lea    -0xbbd7(%ebx),%eax
c00201e0:	50                   	push   %eax
c00201e1:	e8 a2 70 00 00       	call   c0027288 <printf>
#ifdef USERPROG
    process_wait (process_execute (task));
#else
    run_test(task);
c00201e6:	89 34 24             	mov    %esi,(%esp)
c00201e9:	e8 ed ac 00 00       	call   c002aedb <run_test>
#endif
    printf("Execution of '%s' complete.\n", task);
c00201ee:	83 c4 08             	add    $0x8,%esp
c00201f1:	56                   	push   %esi
c00201f2:	8d 83 3a 44 ff ff    	lea    -0xbbc6(%ebx),%eax
c00201f8:	50                   	push   %eax
c00201f9:	e8 8a 70 00 00       	call   c0027288 <printf>
}
c00201fe:	83 c4 14             	add    $0x14,%esp
c0020201:	5b                   	pop    %ebx
c0020202:	5e                   	pop    %esi
c0020203:	c3                   	ret    

c0020204 <pintos_init>:
pintos_init(void) {
c0020204:	55                   	push   %ebp
c0020205:	57                   	push   %edi
c0020206:	56                   	push   %esi
c0020207:	53                   	push   %ebx
c0020208:	83 ec 40             	sub    $0x40,%esp
c002020b:	e8 87 d6 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020210:	81 c3 f0 a2 01 00    	add    $0x1a2f0,%ebx
    memset(&_start_bss, 0, &_end_bss - &_start_bss);
c0020216:	c7 c2 00 a5 03 c0    	mov    $0xc003a500,%edx
c002021c:	c7 c0 42 c2 03 c0    	mov    $0xc003c242,%eax
c0020222:	29 d0                	sub    %edx,%eax
c0020224:	50                   	push   %eax
c0020225:	6a 00                	push   $0x0
c0020227:	52                   	push   %edx
c0020228:	e8 26 82 00 00       	call   c0028453 <memset>
    argc = *(uint32_t *) ptov(LOADER_ARG_CNT);
c002022d:	8b 3d 3a 7d 00 c0    	mov    0xc0007d3a,%edi
c0020233:	89 7c 24 14          	mov    %edi,0x14(%esp)
    for (i = 0; i < argc; i++) {
c0020237:	83 c4 10             	add    $0x10,%esp
c002023a:	be 00 00 00 00       	mov    $0x0,%esi
    p = ptov(LOADER_ARGS);
c002023f:	bd 3e 7d 00 c0       	mov    $0xc0007d3e,%ebp
    for (i = 0; i < argc; i++) {
c0020244:	85 ff                	test   %edi,%edi
c0020246:	0f 8e 47 05 00 00    	jle    c0020793 <pintos_init+0x58f>
        argv[i] = p;
c002024c:	89 ac b3 20 00 00 00 	mov    %ebp,0x20(%ebx,%esi,4)
        p += strnlen(p, end - p) + 1;
c0020253:	83 ec 08             	sub    $0x8,%esp
c0020256:	b8 be 7d 00 c0       	mov    $0xc0007dbe,%eax
c002025b:	29 e8                	sub    %ebp,%eax
c002025d:	50                   	push   %eax
c002025e:	55                   	push   %ebp
c002025f:	e8 96 82 00 00       	call   c00284fa <strnlen>
c0020264:	8d 6c 05 01          	lea    0x1(%ebp,%eax,1),%ebp
    for (i = 0; i < argc; i++) {
c0020268:	83 c6 01             	add    $0x1,%esi
c002026b:	83 c4 10             	add    $0x10,%esp
c002026e:	39 74 24 04          	cmp    %esi,0x4(%esp)
c0020272:	0f 84 dc 04 00 00    	je     c0020754 <pintos_init+0x550>
        if (p >= end)
c0020278:	81 fd bd 7d 00 c0    	cmp    $0xc0007dbd,%ebp
c002027e:	76 cc                	jbe    c002024c <pintos_init+0x48>
            PANIC ("command line arguments overflow");
c0020280:	8d 83 14 45 ff ff    	lea    -0xbaec(%ebx),%eax
c0020286:	50                   	push   %eax
c0020287:	8d 83 f0 33 ff ff    	lea    -0xcc10(%ebx),%eax
c002028d:	50                   	push   %eax
c002028e:	68 e5 00 00 00       	push   $0xe5
c0020293:	8d 83 57 44 ff ff    	lea    -0xbba9(%ebx),%eax
c0020299:	50                   	push   %eax
c002029a:	e8 45 8c 00 00       	call   c0028ee4 <debug_panic>
            printf(" %s", argv[i]);
c002029f:	83 ec 08             	sub    $0x8,%esp
c00202a2:	57                   	push   %edi
c00202a3:	ff 74 24 14          	pushl  0x14(%esp)
c00202a7:	e8 dc 6f 00 00       	call   c0027288 <printf>
c00202ac:	83 c4 10             	add    $0x10,%esp
c00202af:	83 c6 04             	add    $0x4,%esi
    for (i = 0; i < argc; i++)
c00202b2:	39 74 24 04          	cmp    %esi,0x4(%esp)
c00202b6:	0f 84 f4 04 00 00    	je     c00207b0 <pintos_init+0x5ac>
        if (strchr(argv[i], ' ') == NULL)
c00202bc:	8b 3e                	mov    (%esi),%edi
c00202be:	83 ec 08             	sub    $0x8,%esp
c00202c1:	6a 20                	push   $0x20
c00202c3:	57                   	push   %edi
c00202c4:	e8 3c 7f 00 00       	call   c0028205 <strchr>
c00202c9:	83 c4 10             	add    $0x10,%esp
c00202cc:	85 c0                	test   %eax,%eax
c00202ce:	74 cf                	je     c002029f <pintos_init+0x9b>
            printf(" '%s'", argv[i]);
c00202d0:	83 ec 08             	sub    $0x8,%esp
c00202d3:	57                   	push   %edi
c00202d4:	55                   	push   %ebp
c00202d5:	e8 ae 6f 00 00       	call   c0027288 <printf>
c00202da:	83 c4 10             	add    $0x10,%esp
c00202dd:	eb d0                	jmp    c00202af <pintos_init+0xab>

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage(void) {
    printf("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00202df:	83 ec 0c             	sub    $0xc,%esp
c00202e2:	8d 83 34 45 ff ff    	lea    -0xbacc(%ebx),%eax
c00202e8:	50                   	push   %eax
c00202e9:	e8 17 ab 00 00       	call   c002ae05 <puts>
           "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
            "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
    );
    shutdown_power_off();
c00202ee:	e8 8b 67 00 00       	call   c0026a7e <shutdown_power_off>
            shutdown_configure(SHUTDOWN_POWER_OFF);
c00202f3:	83 ec 0c             	sub    $0xc,%esp
c00202f6:	6a 01                	push   $0x1
c00202f8:	e8 f0 66 00 00       	call   c00269ed <shutdown_configure>
c00202fd:	83 c4 10             	add    $0x10,%esp
    for (; *argv != NULL && **argv == '-'; argv++) {
c0020300:	83 c5 04             	add    $0x4,%ebp
c0020303:	8b 45 00             	mov    0x0(%ebp),%eax
c0020306:	85 c0                	test   %eax,%eax
c0020308:	0f 84 22 01 00 00    	je     c0020430 <pintos_init+0x22c>
c002030e:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020311:	0f 85 19 01 00 00    	jne    c0020430 <pintos_init+0x22c>
        char *name = strtok_r(*argv, "=", &save_ptr);
c0020317:	83 ec 04             	sub    $0x4,%esp
c002031a:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002031e:	57                   	push   %edi
c002031f:	8d 93 50 51 ff ff    	lea    -0xaeb0(%ebx),%edx
c0020325:	52                   	push   %edx
c0020326:	50                   	push   %eax
c0020327:	e8 f3 7f 00 00       	call   c002831f <strtok_r>
c002032c:	89 c6                	mov    %eax,%esi
c002032e:	89 44 24 14          	mov    %eax,0x14(%esp)
        char *value = strtok_r(NULL, "", &save_ptr);
c0020332:	83 c4 0c             	add    $0xc,%esp
c0020335:	57                   	push   %edi
c0020336:	8d 83 62 51 ff ff    	lea    -0xae9e(%ebx),%eax
c002033c:	50                   	push   %eax
c002033d:	6a 00                	push   $0x0
c002033f:	e8 db 7f 00 00       	call   c002831f <strtok_r>
        if (!strcmp(name, "-h"))
c0020344:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020349:	8d bb 72 44 ff ff    	lea    -0xbb8e(%ebx),%edi
c002034f:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020351:	0f 97 c2             	seta   %dl
c0020354:	80 da 00             	sbb    $0x0,%dl
c0020357:	83 c4 10             	add    $0x10,%esp
c002035a:	84 d2                	test   %dl,%dl
c002035c:	74 81                	je     c00202df <pintos_init+0xdb>
        else if (!strcmp(name, "-q"))
c002035e:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020363:	8d bb 75 44 ff ff    	lea    -0xbb8b(%ebx),%edi
c0020369:	8b 74 24 04          	mov    0x4(%esp),%esi
c002036d:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002036f:	0f 97 c2             	seta   %dl
c0020372:	80 da 00             	sbb    $0x0,%dl
c0020375:	84 d2                	test   %dl,%dl
c0020377:	0f 84 76 ff ff ff    	je     c00202f3 <pintos_init+0xef>
        else if (!strcmp(name, "-r"))
c002037d:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020382:	8d bb 78 44 ff ff    	lea    -0xbb88(%ebx),%edi
c0020388:	8b 74 24 04          	mov    0x4(%esp),%esi
c002038c:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002038e:	0f 97 c2             	seta   %dl
c0020391:	80 da 00             	sbb    $0x0,%dl
c0020394:	84 d2                	test   %dl,%dl
c0020396:	74 41                	je     c00203d9 <pintos_init+0x1d5>
        else if (!strcmp(name, "-rs"))
c0020398:	b9 04 00 00 00       	mov    $0x4,%ecx
c002039d:	8d bb 7b 44 ff ff    	lea    -0xbb85(%ebx),%edi
c00203a3:	8b 74 24 04          	mov    0x4(%esp),%esi
c00203a7:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203a9:	0f 97 c2             	seta   %dl
c00203ac:	80 da 00             	sbb    $0x0,%dl
c00203af:	84 d2                	test   %dl,%dl
c00203b1:	74 38                	je     c00203eb <pintos_init+0x1e7>
        else if (!strcmp(name, "-mlfqs"))
c00203b3:	b9 07 00 00 00       	mov    $0x7,%ecx
c00203b8:	8d bb 7f 44 ff ff    	lea    -0xbb81(%ebx),%edi
c00203be:	8b 74 24 04          	mov    0x4(%esp),%esi
c00203c2:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203c4:	0f 97 c0             	seta   %al
c00203c7:	1c 00                	sbb    $0x0,%al
c00203c9:	84 c0                	test   %al,%al
c00203cb:	75 37                	jne    c0020404 <pintos_init+0x200>
            thread_mlfqs = true;
c00203cd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00203d1:	c6 00 01             	movb   $0x1,(%eax)
c00203d4:	e9 27 ff ff ff       	jmp    c0020300 <pintos_init+0xfc>
            shutdown_configure(SHUTDOWN_REBOOT);
c00203d9:	83 ec 0c             	sub    $0xc,%esp
c00203dc:	6a 02                	push   $0x2
c00203de:	e8 0a 66 00 00       	call   c00269ed <shutdown_configure>
c00203e3:	83 c4 10             	add    $0x10,%esp
c00203e6:	e9 15 ff ff ff       	jmp    c0020300 <pintos_init+0xfc>
            random_init(atoi(value));
c00203eb:	83 ec 0c             	sub    $0xc,%esp
c00203ee:	50                   	push   %eax
c00203ef:	e8 39 7a 00 00       	call   c0027e2d <atoi>
c00203f4:	89 04 24             	mov    %eax,(%esp)
c00203f7:	e8 9a 68 00 00       	call   c0026c96 <random_init>
c00203fc:	83 c4 10             	add    $0x10,%esp
c00203ff:	e9 fc fe ff ff       	jmp    c0020300 <pintos_init+0xfc>
            PANIC ("unknown option `%s' (use -h for help)", name);
c0020404:	83 ec 0c             	sub    $0xc,%esp
c0020407:	ff 74 24 10          	pushl  0x10(%esp)
c002040b:	8d 83 04 47 ff ff    	lea    -0xb8fc(%ebx),%eax
c0020411:	50                   	push   %eax
c0020412:	8d 83 e0 33 ff ff    	lea    -0xcc20(%ebx),%eax
c0020418:	50                   	push   %eax
c0020419:	68 1c 01 00 00       	push   $0x11c
c002041e:	8d 83 57 44 ff ff    	lea    -0xbba9(%ebx),%eax
c0020424:	50                   	push   %eax
c0020425:	e8 ba 8a 00 00       	call   c0028ee4 <debug_panic>
    for (; *argv != NULL && **argv == '-'; argv++) {
c002042a:	8d ab 20 00 00 00    	lea    0x20(%ebx),%ebp
    random_init(rtc_get_time());
c0020430:	e8 4b 64 00 00       	call   c0026880 <rtc_get_time>
c0020435:	83 ec 0c             	sub    $0xc,%esp
c0020438:	50                   	push   %eax
c0020439:	e8 58 68 00 00       	call   c0026c96 <random_init>
    global_load_avg = fix_int(0);
c002043e:	c7 c0 3c c2 03 c0    	mov    $0xc003c23c,%eax
c0020444:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    thread_init();
c002044a:	e8 9f 07 00 00       	call   c0020bee <thread_init>
    console_init();
c002044f:	e8 09 a9 00 00       	call   c002ad5d <console_init>
    printf("Pintos booting with %'"PRIu32" kB RAM...\n",
c0020454:	83 c4 08             	add    $0x8,%esp
           init_ram_pages * PGSIZE / 1024);
c0020457:	c7 c6 be 01 02 c0    	mov    $0xc00201be,%esi
c002045d:	8b 06                	mov    (%esi),%eax
c002045f:	c1 e0 0c             	shl    $0xc,%eax
    printf("Pintos booting with %'"PRIu32" kB RAM...\n",
c0020462:	c1 e8 0a             	shr    $0xa,%eax
c0020465:	50                   	push   %eax
c0020466:	8d 83 2c 47 ff ff    	lea    -0xb8d4(%ebx),%eax
c002046c:	50                   	push   %eax
c002046d:	e8 16 6e 00 00       	call   c0027288 <printf>
    palloc_init(user_page_limit);
c0020472:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0020479:	e8 27 32 00 00       	call   c00236a5 <palloc_init>
    malloc_init();
c002047e:	e8 a0 36 00 00       	call   c0023b23 <malloc_init>
    pd = init_page_dir = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c0020483:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c002048a:	e8 73 33 00 00       	call   c0023802 <palloc_get_page>
c002048f:	89 c1                	mov    %eax,%ecx
c0020491:	89 44 24 20          	mov    %eax,0x20(%esp)
c0020495:	c7 c0 38 c2 03 c0    	mov    $0xc003c238,%eax
c002049b:	89 08                	mov    %ecx,(%eax)
    for (page = 0; page < init_ram_pages; page++) {
c002049d:	83 c4 10             	add    $0x10,%esp
c00204a0:	83 3e 00             	cmpl   $0x0,(%esi)
c00204a3:	0f 84 6f 01 00 00    	je     c0020618 <pintos_init+0x414>
c00204a9:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
    pt = NULL;
c00204ae:	b8 00 00 00 00       	mov    $0x0,%eax
    for (page = 0; page < init_ram_pages; page++) {
c00204b3:	be 00 00 00 00       	mov    $0x0,%esi
        bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c00204b8:	c7 c1 00 30 03 c0    	mov    $0xc0033000,%ecx
c00204be:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c00204c2:	c7 c1 00 00 02 c0    	mov    $0xc0020000,%ecx
c00204c8:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c00204cc:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c00204d0:	89 f5                	mov    %esi,%ebp
c00204d2:	e9 a6 00 00 00       	jmp    c002057d <pintos_init+0x379>
    for (; *argv != NULL && **argv == '-'; argv++) {
c00204d7:	8d ab 20 00 00 00    	lea    0x20(%ebx),%ebp
c00204dd:	e9 4e ff ff ff       	jmp    c0020430 <pintos_init+0x22c>
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create(uint32_t *pt) {
    ASSERT (pg_ofs(pt) == 0);
c00204e2:	83 ec 0c             	sub    $0xc,%esp
c00204e5:	8d 83 86 44 ff ff    	lea    -0xbb7a(%ebx),%eax
c00204eb:	50                   	push   %eax
c00204ec:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00204f2:	50                   	push   %eax
c00204f3:	8d 83 d4 33 ff ff    	lea    -0xcc2c(%ebx),%eax
c00204f9:	50                   	push   %eax
c00204fa:	6a 48                	push   $0x48
c00204fc:	8d 83 ad 44 ff ff    	lea    -0xbb53(%ebx),%eax
c0020502:	50                   	push   %eax
c0020503:	e8 dc 89 00 00       	call   c0028ee4 <debug_panic>

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop(const void *vaddr) {
    ASSERT (is_kernel_vaddr(vaddr));
c0020508:	83 ec 0c             	sub    $0xc,%esp
c002050b:	8d 83 c1 44 ff ff    	lea    -0xbb3f(%ebx),%eax
c0020511:	50                   	push   %eax
c0020512:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020518:	50                   	push   %eax
c0020519:	8d 83 cc 33 ff ff    	lea    -0xcc34(%ebx),%eax
c002051f:	50                   	push   %eax
c0020520:	6a 55                	push   $0x55
c0020522:	8d 83 d8 44 ff ff    	lea    -0xbb28(%ebx),%eax
c0020528:	50                   	push   %eax
c0020529:	e8 b6 89 00 00       	call   c0028ee4 <debug_panic>
        pt[pte_idx] = pte_create_kernel(vaddr, !in_kernel_text);
c002052e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0020532:	8d 0c 88             	lea    (%eax,%ecx,4),%ecx
c0020535:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0020539:	81 7c 24 0c ff ff ff 	cmpl   $0xbfffffff,0xc(%esp)
c0020540:	bf 
c0020541:	0f 86 a7 00 00 00    	jbe    c00205ee <pintos_init+0x3ea>

    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020547:	89 e9                	mov    %ebp,%ecx
c0020549:	c1 e1 0c             	shl    $0xc,%ecx
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel(void *page, bool writable) {
    ASSERT (pg_ofs(page) == 0);
    return vtop(page) | PTE_P | (writable ? PTE_W : 0);
c002054c:	0f b6 74 24 04       	movzbl 0x4(%esp),%esi
c0020551:	83 f6 01             	xor    $0x1,%esi
c0020554:	89 f2                	mov    %esi,%edx
c0020556:	0f b6 f2             	movzbl %dl,%esi
c0020559:	01 f6                	add    %esi,%esi
c002055b:	09 f1                	or     %esi,%ecx
c002055d:	83 c9 01             	or     $0x1,%ecx
c0020560:	8b 74 24 08          	mov    0x8(%esp),%esi
c0020564:	89 0e                	mov    %ecx,(%esi)
    for (page = 0; page < init_ram_pages; page++) {
c0020566:	83 c5 01             	add    $0x1,%ebp
c0020569:	81 c7 00 10 00 00    	add    $0x1000,%edi
c002056f:	c7 c2 be 01 02 c0    	mov    $0xc00201be,%edx
c0020575:	3b 2a                	cmp    (%edx),%ebp
c0020577:	0f 83 97 00 00 00    	jae    c0020614 <pintos_init+0x410>
    return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002057d:	89 fa                	mov    %edi,%edx
c002057f:	c1 ea 0c             	shr    $0xc,%edx
c0020582:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c0020588:	89 54 24 08          	mov    %edx,0x8(%esp)
        bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c002058c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0020590:	3b 7c 24 14          	cmp    0x14(%esp),%edi
c0020594:	0f 92 c1             	setb   %cl
c0020597:	3b 7c 24 18          	cmp    0x18(%esp),%edi
c002059b:	0f 93 c2             	setae  %dl
c002059e:	21 d1                	and    %edx,%ecx
c00205a0:	88 4c 24 04          	mov    %cl,0x4(%esp)
    return (uintptr_t) va >> PDSHIFT;
c00205a4:	89 fa                	mov    %edi,%edx
c00205a6:	c1 ea 16             	shr    $0x16,%edx
        if (pd[pde_idx] == 0) {
c00205a9:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00205ad:	8d 34 91             	lea    (%ecx,%edx,4),%esi
c00205b0:	83 3e 00             	cmpl   $0x0,(%esi)
c00205b3:	0f 85 75 ff ff ff    	jne    c002052e <pintos_init+0x32a>
            pt = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c00205b9:	83 ec 0c             	sub    $0xc,%esp
c00205bc:	6a 03                	push   $0x3
c00205be:	e8 3f 32 00 00       	call   c0023802 <palloc_get_page>
    return (uintptr_t) va & PGMASK;
c00205c3:	89 c2                	mov    %eax,%edx
    ASSERT (pg_ofs(pt) == 0);
c00205c5:	83 c4 10             	add    $0x10,%esp
c00205c8:	a9 ff 0f 00 00       	test   $0xfff,%eax
c00205cd:	0f 85 0f ff ff ff    	jne    c00204e2 <pintos_init+0x2de>
    ASSERT (is_kernel_vaddr(vaddr));
c00205d3:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00205d8:	0f 86 2a ff ff ff    	jbe    c0020508 <pintos_init+0x304>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00205de:	81 c2 00 00 00 40    	add    $0x40000000,%edx
    return vtop(pt) | PTE_U | PTE_P | PTE_W;
c00205e4:	83 ca 07             	or     $0x7,%edx
c00205e7:	89 16                	mov    %edx,(%esi)
c00205e9:	e9 40 ff ff ff       	jmp    c002052e <pintos_init+0x32a>
    ASSERT (is_kernel_vaddr(vaddr));
c00205ee:	83 ec 0c             	sub    $0xc,%esp
c00205f1:	8d 83 c1 44 ff ff    	lea    -0xbb3f(%ebx),%eax
c00205f7:	50                   	push   %eax
c00205f8:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00205fe:	50                   	push   %eax
c00205ff:	8d 83 cc 33 ff ff    	lea    -0xcc34(%ebx),%eax
c0020605:	50                   	push   %eax
c0020606:	6a 55                	push   $0x55
c0020608:	8d 83 d8 44 ff ff    	lea    -0xbb28(%ebx),%eax
c002060e:	50                   	push   %eax
c002060f:	e8 d0 88 00 00       	call   c0028ee4 <debug_panic>
c0020614:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
    asm volatile ("movl %0, %%cr3" : : "r" (vtop(init_page_dir)));
c0020618:	c7 c0 38 c2 03 c0    	mov    $0xc003c238,%eax
c002061e:	8b 00                	mov    (%eax),%eax
c0020620:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020625:	76 5c                	jbe    c0020683 <pintos_init+0x47f>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020627:	05 00 00 00 40       	add    $0x40000000,%eax
c002062c:	0f 22 d8             	mov    %eax,%cr3
    intr_init();
c002062f:	e8 10 15 00 00       	call   c0021b44 <intr_init>
    timer_init();
c0020634:	e8 23 3c 00 00       	call   c002425c <timer_init>
    kbd_init();
c0020639:	e8 ab 41 00 00       	call   c00247e9 <kbd_init>
    input_init();
c002063e:	e8 d1 5c 00 00       	call   c0026314 <input_init>
    thread_start();
c0020643:	e8 7c 10 00 00       	call   c00216c4 <thread_start>
    serial_init_queue();
c0020648:	e8 4a 46 00 00       	call   c0024c97 <serial_init_queue>
    timer_calibrate();
c002064d:	e8 41 3c 00 00       	call   c0024293 <timer_calibrate>
    printf("Boot complete.\n");
c0020652:	83 ec 0c             	sub    $0xc,%esp
c0020655:	8d 83 ee 44 ff ff    	lea    -0xbb12(%ebx),%eax
c002065b:	50                   	push   %eax
c002065c:	e8 a4 a7 00 00       	call   c002ae05 <puts>
    if (*argv != NULL) {
c0020661:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020664:	83 c4 10             	add    $0x10,%esp
            if (a->name == NULL)
c0020667:	8d 83 ee 4a ff ff    	lea    -0xb512(%ebx),%eax
c002066d:	89 44 24 04          	mov    %eax,0x4(%esp)
    if (*argv != NULL) {
c0020671:	85 ff                	test   %edi,%edi
c0020673:	0f 85 94 00 00 00    	jne    c002070d <pintos_init+0x509>
    shutdown();
c0020679:	e8 99 64 00 00       	call   c0026b17 <shutdown>
    thread_exit();
c002067e:	e8 6b 0d 00 00       	call   c00213ee <thread_exit>
    ASSERT (is_kernel_vaddr(vaddr));
c0020683:	83 ec 0c             	sub    $0xc,%esp
c0020686:	8d 83 c1 44 ff ff    	lea    -0xbb3f(%ebx),%eax
c002068c:	50                   	push   %eax
c002068d:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020693:	50                   	push   %eax
c0020694:	8d 83 cc 33 ff ff    	lea    -0xcc34(%ebx),%eax
c002069a:	50                   	push   %eax
c002069b:	6a 55                	push   $0x55
c002069d:	8d 83 d8 44 ff ff    	lea    -0xbb28(%ebx),%eax
c00206a3:	50                   	push   %eax
c00206a4:	e8 3b 88 00 00       	call   c0028ee4 <debug_panic>
        for (i = 1; i < a->argc; i++)
c00206a9:	8b 56 04             	mov    0x4(%esi),%edx
c00206ac:	83 fa 01             	cmp    $0x1,%edx
c00206af:	7e 40                	jle    c00206f1 <pintos_init+0x4ed>
            if (argv[i] == NULL)
c00206b1:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c00206b5:	74 13                	je     c00206ca <pintos_init+0x4c6>
        for (i = 1; i < a->argc; i++)
c00206b7:	b8 01 00 00 00       	mov    $0x1,%eax
c00206bc:	83 c0 01             	add    $0x1,%eax
c00206bf:	39 c2                	cmp    %eax,%edx
c00206c1:	74 2e                	je     c00206f1 <pintos_init+0x4ed>
            if (argv[i] == NULL)
c00206c3:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c00206c8:	75 f2                	jne    c00206bc <pintos_init+0x4b8>
                PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c00206ca:	83 ec 08             	sub    $0x8,%esp
c00206cd:	83 ea 01             	sub    $0x1,%edx
c00206d0:	52                   	push   %edx
c00206d1:	57                   	push   %edi
c00206d2:	8d 83 78 47 ff ff    	lea    -0xb888(%ebx),%eax
c00206d8:	50                   	push   %eax
c00206d9:	8d 83 c0 33 ff ff    	lea    -0xcc40(%ebx),%eax
c00206df:	50                   	push   %eax
c00206e0:	68 62 01 00 00       	push   $0x162
c00206e5:	8d 83 57 44 ff ff    	lea    -0xbba9(%ebx),%eax
c00206eb:	50                   	push   %eax
c00206ec:	e8 f3 87 00 00       	call   c0028ee4 <debug_panic>
        a->function(argv);
c00206f1:	83 ec 0c             	sub    $0xc,%esp
c00206f4:	55                   	push   %ebp
c00206f5:	ff 56 08             	call   *0x8(%esi)
        argv += a->argc;
c00206f8:	8b 46 04             	mov    0x4(%esi),%eax
c00206fb:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
    while (*argv != NULL) {
c00206ff:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020702:	83 c4 10             	add    $0x10,%esp
c0020705:	85 ff                	test   %edi,%edi
c0020707:	0f 84 6c ff ff ff    	je     c0020679 <pintos_init+0x475>
            if (a->name == NULL)
c002070d:	8b 44 24 04          	mov    0x4(%esp),%eax
        for (a = actions;; a++)
c0020711:	8d b3 78 77 ff ff    	lea    -0x8888(%ebx),%esi
            else if (!strcmp(*argv, a->name))
c0020717:	83 ec 08             	sub    $0x8,%esp
c002071a:	50                   	push   %eax
c002071b:	57                   	push   %edi
c002071c:	e8 79 7a 00 00       	call   c002819a <strcmp>
c0020721:	83 c4 10             	add    $0x10,%esp
c0020724:	85 c0                	test   %eax,%eax
c0020726:	74 81                	je     c00206a9 <pintos_init+0x4a5>
        for (a = actions;; a++)
c0020728:	83 c6 0c             	add    $0xc,%esi
            if (a->name == NULL)
c002072b:	8b 06                	mov    (%esi),%eax
c002072d:	85 c0                	test   %eax,%eax
c002072f:	75 e6                	jne    c0020717 <pintos_init+0x513>
                PANIC ("unknown action `%s' (use -h for help)", *argv);
c0020731:	83 ec 0c             	sub    $0xc,%esp
c0020734:	57                   	push   %edi
c0020735:	8d 83 50 47 ff ff    	lea    -0xb8b0(%ebx),%eax
c002073b:	50                   	push   %eax
c002073c:	8d 83 c0 33 ff ff    	lea    -0xcc40(%ebx),%eax
c0020742:	50                   	push   %eax
c0020743:	68 5b 01 00 00       	push   $0x15b
c0020748:	8d 83 57 44 ff ff    	lea    -0xbba9(%ebx),%eax
c002074e:	50                   	push   %eax
c002074f:	e8 90 87 00 00       	call   c0028ee4 <debug_panic>
    argv[argc] = NULL;
c0020754:	8d ab 20 00 00 00    	lea    0x20(%ebx),%ebp
c002075a:	c7 44 b5 00 00 00 00 	movl   $0x0,0x0(%ebp,%esi,4)
c0020761:	00 
    printf("Kernel command line:");
c0020762:	83 ec 0c             	sub    $0xc,%esp
c0020765:	8d 83 fd 44 ff ff    	lea    -0xbb03(%ebx),%eax
c002076b:	50                   	push   %eax
c002076c:	e8 17 6b 00 00       	call   c0027288 <printf>
    for (i = 0; i < argc; i++)
c0020771:	89 ee                	mov    %ebp,%esi
c0020773:	8d 44 bd 00          	lea    0x0(%ebp,%edi,4),%eax
c0020777:	89 44 24 14          	mov    %eax,0x14(%esp)
c002077b:	83 c4 10             	add    $0x10,%esp
            printf(" '%s'", argv[i]);
c002077e:	8d ab 6c 44 ff ff    	lea    -0xbb94(%ebx),%ebp
            printf(" %s", argv[i]);
c0020784:	8d 83 bf 52 ff ff    	lea    -0xad41(%ebx),%eax
c002078a:	89 44 24 08          	mov    %eax,0x8(%esp)
c002078e:	e9 29 fb ff ff       	jmp    c00202bc <pintos_init+0xb8>
    argv[argc] = NULL;
c0020793:	c7 84 bb 20 00 00 00 	movl   $0x0,0x20(%ebx,%edi,4)
c002079a:	00 00 00 00 
    printf("Kernel command line:");
c002079e:	83 ec 0c             	sub    $0xc,%esp
c00207a1:	8d 83 fd 44 ff ff    	lea    -0xbb03(%ebx),%eax
c00207a7:	50                   	push   %eax
c00207a8:	e8 db 6a 00 00       	call   c0027288 <printf>
c00207ad:	83 c4 10             	add    $0x10,%esp
    printf("\n");
c00207b0:	83 ec 0c             	sub    $0xc,%esp
c00207b3:	6a 0a                	push   $0xa
c00207b5:	e8 bd a6 00 00       	call   c002ae77 <putchar>
    for (; *argv != NULL && **argv == '-'; argv++) {
c00207ba:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
c00207c0:	83 c4 10             	add    $0x10,%esp
c00207c3:	85 c0                	test   %eax,%eax
c00207c5:	0f 84 5f fc ff ff    	je     c002042a <pintos_init+0x226>
c00207cb:	80 38 2d             	cmpb   $0x2d,(%eax)
c00207ce:	0f 85 03 fd ff ff    	jne    c00204d7 <pintos_init+0x2d3>
c00207d4:	8d ab 20 00 00 00    	lea    0x20(%ebx),%ebp
        char *name = strtok_r(*argv, "=", &save_ptr);
c00207da:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
c00207de:	89 4c 24 08          	mov    %ecx,0x8(%esp)
            thread_mlfqs = true;
c00207e2:	c7 c1 40 c2 03 c0    	mov    $0xc003c240,%ecx
c00207e8:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c00207ec:	e9 26 fb ff ff       	jmp    c0020317 <pintos_init+0x113>

c00207f1 <thread_cmp_priority>:
bool thread_cmp_priority(const struct list_elem *a,
                         const struct list_elem *b,
                         void *aux) {
    int priority_a = list_entry(a, struct thread, elem)->priority;
    int priority_b = list_entry(b, struct thread, elem)->priority;
    return priority_a > priority_b;
c00207f1:	8b 54 24 04          	mov    0x4(%esp),%edx
c00207f5:	8b 44 24 08          	mov    0x8(%esp),%eax
c00207f9:	8b 80 1c ff ff ff    	mov    -0xe4(%eax),%eax
c00207ff:	39 82 1c ff ff ff    	cmp    %eax,-0xe4(%edx)
c0020805:	0f 9f c0             	setg   %al
}
c0020808:	c3                   	ret    

c0020809 <lock_cmp_priority>:
bool lock_cmp_priority(const struct list_elem *a,
                       const struct list_elem *b,
                       void *aux) {
    int priority_a = list_entry(a, struct lock, elem)->max_priority;
    int priority_b = list_entry(b, struct lock, elem)->max_priority;
    return priority_a > priority_b;
c0020809:	8b 54 24 04          	mov    0x4(%esp),%edx
c002080d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020811:	8b 40 08             	mov    0x8(%eax),%eax
c0020814:	39 42 08             	cmp    %eax,0x8(%edx)
c0020817:	0f 9f c0             	setg   %al
}
c002081a:	c3                   	ret    

c002081b <update_thread_recent_cpu>:
void update_thread_recent_cpu(struct thread *t, void *aux) {
c002081b:	55                   	push   %ebp
c002081c:	57                   	push   %edi
c002081d:	56                   	push   %esi
c002081e:	53                   	push   %ebx
c002081f:	83 ec 1c             	sub    $0x1c,%esp
c0020822:	e8 70 d0 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020827:	81 c3 d9 9c 01 00    	add    $0x19cd9,%ebx
c002082d:	8b 6c 24 30          	mov    0x30(%esp),%ebp

/* Returns X * Y. */
static inline fixed_point_t
fix_mul (fixed_point_t x, fixed_point_t y)
{
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0020831:	c7 c0 3c c2 03 c0    	mov    $0xc003c23c,%eax
c0020837:	8b 00                	mov    (%eax),%eax
c0020839:	99                   	cltd   
c002083a:	0f a4 c2 11          	shld   $0x11,%eax,%edx
c002083e:	c1 e0 11             	shl    $0x11,%eax
c0020841:	89 d1                	mov    %edx,%ecx
c0020843:	c1 f9 1f             	sar    $0x1f,%ecx
c0020846:	0f b7 f1             	movzwl %cx,%esi
c0020849:	bf 00 00 00 00       	mov    $0x0,%edi
c002084e:	01 c6                	add    %eax,%esi
c0020850:	11 d7                	adc    %edx,%edi
c0020852:	89 f0                	mov    %esi,%eax
c0020854:	0f ac f8 10          	shrd   $0x10,%edi,%eax

/* Returns X / Y. */
static inline fixed_point_t
fix_div (fixed_point_t x, fixed_point_t y)
{
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c0020858:	89 c1                	mov    %eax,%ecx
c002085a:	c1 f9 1f             	sar    $0x1f,%ecx
c002085d:	89 c6                	mov    %eax,%esi
c002085f:	89 cf                	mov    %ecx,%edi
c0020861:	0f a4 c7 10          	shld   $0x10,%eax,%edi
c0020865:	c1 e6 10             	shl    $0x10,%esi
    return __mk_fix (x.f + y.f);
c0020868:	05 00 00 01 00       	add    $0x10000,%eax
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c002086d:	99                   	cltd   
c002086e:	52                   	push   %edx
c002086f:	50                   	push   %eax
c0020870:	57                   	push   %edi
c0020871:	56                   	push   %esi
c0020872:	e8 37 80 00 00       	call   c00288ae <__divdi3>
c0020877:	83 c4 10             	add    $0x10,%esp
c002087a:	89 04 24             	mov    %eax,(%esp)
    t->recent_cpu = fix_add(fix_mul(t->recent_cpu, tmp), fix_int(t->nice));
c002087d:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0020880:	89 54 24 0c          	mov    %edx,0xc(%esp)
    ASSERT (n >= FIX_MIN_INT && n <= FIX_MAX_INT);
c0020884:	81 c2 ff ff 00 00    	add    $0xffff,%edx
c002088a:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
c0020890:	77 65                	ja     c00208f7 <update_thread_recent_cpu+0xdc>
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0020892:	8b 45 20             	mov    0x20(%ebp),%eax
c0020895:	89 44 24 08          	mov    %eax,0x8(%esp)
c0020899:	89 c7                	mov    %eax,%edi
c002089b:	c1 ff 1f             	sar    $0x1f,%edi
c002089e:	8b 0c 24             	mov    (%esp),%ecx
c00208a1:	89 cb                	mov    %ecx,%ebx
c00208a3:	c1 fb 1f             	sar    $0x1f,%ebx
c00208a6:	89 fe                	mov    %edi,%esi
c00208a8:	0f af 34 24          	imul   (%esp),%esi
c00208ac:	89 d9                	mov    %ebx,%ecx
c00208ae:	0f af c8             	imul   %eax,%ecx
c00208b1:	01 f1                	add    %esi,%ecx
c00208b3:	8b 04 24             	mov    (%esp),%eax
c00208b6:	f7 64 24 08          	mull   0x8(%esp)
c00208ba:	89 04 24             	mov    %eax,(%esp)
c00208bd:	89 54 24 04          	mov    %edx,0x4(%esp)
c00208c1:	01 4c 24 04          	add    %ecx,0x4(%esp)
c00208c5:	8b 74 24 04          	mov    0x4(%esp),%esi
c00208c9:	c1 fe 1f             	sar    $0x1f,%esi
c00208cc:	0f b7 ce             	movzwl %si,%ecx
c00208cf:	bb 00 00 00 00       	mov    $0x0,%ebx
c00208d4:	8b 04 24             	mov    (%esp),%eax
c00208d7:	8b 54 24 04          	mov    0x4(%esp),%edx
c00208db:	01 c8                	add    %ecx,%eax
c00208dd:	11 da                	adc    %ebx,%edx
c00208df:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return __mk_fix (n * FIX_F);
c00208e3:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c00208e7:	c1 e1 10             	shl    $0x10,%ecx
    return __mk_fix (x.f + y.f);
c00208ea:	01 c8                	add    %ecx,%eax
c00208ec:	89 45 20             	mov    %eax,0x20(%ebp)
}
c00208ef:	83 c4 1c             	add    $0x1c,%esp
c00208f2:	5b                   	pop    %ebx
c00208f3:	5e                   	pop    %esi
c00208f4:	5f                   	pop    %edi
c00208f5:	5d                   	pop    %ebp
c00208f6:	c3                   	ret    
    ASSERT (n >= FIX_MIN_INT && n <= FIX_MAX_INT);
c00208f7:	83 ec 0c             	sub    $0xc,%esp
c00208fa:	8d 83 9c 47 ff ff    	lea    -0xb864(%ebx),%eax
c0020900:	50                   	push   %eax
c0020901:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020907:	50                   	push   %eax
c0020908:	8d 83 dc 34 ff ff    	lea    -0xcb24(%ebx),%eax
c002090e:	50                   	push   %eax
c002090f:	6a 27                	push   $0x27
c0020911:	8d 83 aa 48 ff ff    	lea    -0xb756(%ebx),%eax
c0020917:	50                   	push   %eax
c0020918:	e8 c7 85 00 00       	call   c0028ee4 <debug_panic>

c002091d <alloc_frame>:
alloc_frame(struct thread *t, size_t size) {
c002091d:	53                   	push   %ebx
c002091e:	83 ec 08             	sub    $0x8,%esp
c0020921:	e8 71 cf 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020926:	81 c3 da 9b 01 00    	add    $0x19bda,%ebx
    return t != NULL && t->magic == THREAD_MAGIC;
c002092c:	85 c0                	test   %eax,%eax
c002092e:	74 0c                	je     c002093c <alloc_frame+0x1f>
c0020930:	81 b8 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%eax)
c0020937:	bf 6a cd 
c002093a:	74 52                	je     c002098e <alloc_frame+0x71>
    ASSERT(is_thread(t));
c002093c:	83 ec 0c             	sub    $0xc,%esp
c002093f:	8d 83 fa 48 ff ff    	lea    -0xb706(%ebx),%eax
c0020945:	50                   	push   %eax
c0020946:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002094c:	50                   	push   %eax
c002094d:	8d 83 b0 34 ff ff    	lea    -0xcb50(%ebx),%eax
c0020953:	50                   	push   %eax
c0020954:	68 3d 02 00 00       	push   $0x23d
c0020959:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c002095f:	50                   	push   %eax
c0020960:	e8 7f 85 00 00       	call   c0028ee4 <debug_panic>
    ASSERT(size % sizeof(uint32_t) == 0);
c0020965:	83 ec 0c             	sub    $0xc,%esp
c0020968:	8d 83 c6 48 ff ff    	lea    -0xb73a(%ebx),%eax
c002096e:	50                   	push   %eax
c002096f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020975:	50                   	push   %eax
c0020976:	8d 83 b0 34 ff ff    	lea    -0xcb50(%ebx),%eax
c002097c:	50                   	push   %eax
c002097d:	68 3e 02 00 00       	push   $0x23e
c0020982:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020988:	50                   	push   %eax
c0020989:	e8 56 85 00 00       	call   c0028ee4 <debug_panic>
c002098e:	f6 c2 03             	test   $0x3,%dl
c0020991:	75 d2                	jne    c0020965 <alloc_frame+0x48>
    t->stack -= size;
c0020993:	8b 48 18             	mov    0x18(%eax),%ecx
c0020996:	29 d1                	sub    %edx,%ecx
c0020998:	89 48 18             	mov    %ecx,0x18(%eax)
}
c002099b:	89 c8                	mov    %ecx,%eax
c002099d:	83 c4 08             	add    $0x8,%esp
c00209a0:	5b                   	pop    %ebx
c00209a1:	c3                   	ret    

c00209a2 <update_thread_priority_mlfqs>:
void update_thread_priority_mlfqs(struct thread *t, void *aux) {
c00209a2:	57                   	push   %edi
c00209a3:	56                   	push   %esi
c00209a4:	53                   	push   %ebx
c00209a5:	e8 ed ce 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00209aa:	81 c3 56 9b 01 00    	add    $0x19b56,%ebx
c00209b0:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    ASSERT(thread_mlfqs);
c00209b4:	c7 c2 40 c2 03 c0    	mov    $0xc003c240,%edx
c00209ba:	80 3a 00             	cmpb   $0x0,(%edx)
c00209bd:	74 58                	je     c0020a17 <update_thread_priority_mlfqs+0x75>
    if (t == idle_thread) {
c00209bf:	39 8b 88 01 00 00    	cmp    %ecx,0x188(%ebx)
c00209c5:	74 4c                	je     c0020a13 <update_thread_priority_mlfqs+0x71>
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c00209c7:	8b 41 20             	mov    0x20(%ecx),%eax
c00209ca:	99                   	cltd   
c00209cb:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c00209cf:	c1 e0 10             	shl    $0x10,%eax
c00209d2:	89 c6                	mov    %eax,%esi
c00209d4:	89 d7                	mov    %edx,%edi
c00209d6:	89 d3                	mov    %edx,%ebx
c00209d8:	c1 fb 1f             	sar    $0x1f,%ebx
c00209db:	81 e3 ff ff 03 00    	and    $0x3ffff,%ebx
c00209e1:	ba 00 00 00 00       	mov    $0x0,%edx
c00209e6:	01 de                	add    %ebx,%esi
c00209e8:	11 d7                	adc    %edx,%edi
c00209ea:	89 f0                	mov    %esi,%eax
c00209ec:	0f ac f8 12          	shrd   $0x12,%edi,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c00209f0:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c00209f6:	05 00 80 00 00       	add    $0x8000,%eax
c00209fb:	0f 49 d0             	cmovns %eax,%edx
c00209fe:	c1 fa 10             	sar    $0x10,%edx
    t->priority = PRI_MAX - fix_round(fix_div(t->recent_cpu, fix_int(4)))
c0020a01:	b8 3f 00 00 00       	mov    $0x3f,%eax
c0020a06:	29 d0                	sub    %edx,%eax
                  - t->nice * 2;
c0020a08:	8b 79 1c             	mov    0x1c(%ecx),%edi
c0020a0b:	8d 14 3f             	lea    (%edi,%edi,1),%edx
c0020a0e:	29 d0                	sub    %edx,%eax
c0020a10:	89 41 24             	mov    %eax,0x24(%ecx)
}
c0020a13:	5b                   	pop    %ebx
c0020a14:	5e                   	pop    %esi
c0020a15:	5f                   	pop    %edi
c0020a16:	c3                   	ret    
    ASSERT(thread_mlfqs);
c0020a17:	83 ec 0c             	sub    $0xc,%esp
c0020a1a:	8d 93 d5 63 ff ff    	lea    -0x9c2b(%ebx),%edx
c0020a20:	52                   	push   %edx
c0020a21:	8d 93 96 44 ff ff    	lea    -0xbb6a(%ebx),%edx
c0020a27:	52                   	push   %edx
c0020a28:	8d 93 28 34 ff ff    	lea    -0xcbd8(%ebx),%edx
c0020a2e:	52                   	push   %edx
c0020a2f:	68 91 01 00 00       	push   $0x191
c0020a34:	8d 93 e3 48 ff ff    	lea    -0xb71d(%ebx),%edx
c0020a3a:	52                   	push   %edx
c0020a3b:	e8 a4 84 00 00       	call   c0028ee4 <debug_panic>

c0020a40 <init_thread>:
init_thread(struct thread *t, const char *name, int priority) {
c0020a40:	55                   	push   %ebp
c0020a41:	57                   	push   %edi
c0020a42:	56                   	push   %esi
c0020a43:	53                   	push   %ebx
c0020a44:	83 ec 0c             	sub    $0xc,%esp
c0020a47:	e8 4b ce 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020a4c:	81 c3 b4 9a 01 00    	add    $0x19ab4,%ebx
    ASSERT(t != NULL);
c0020a52:	85 c0                	test   %eax,%eax
c0020a54:	0f 84 f8 00 00 00    	je     c0020b52 <init_thread+0x112>
c0020a5a:	89 c6                	mov    %eax,%esi
c0020a5c:	89 cd                	mov    %ecx,%ebp
    ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020a5e:	83 f9 3f             	cmp    $0x3f,%ecx
c0020a61:	0f 87 14 01 00 00    	ja     c0020b7b <init_thread+0x13b>
    ASSERT(name != NULL);
c0020a67:	85 d2                	test   %edx,%edx
c0020a69:	0f 84 35 01 00 00    	je     c0020ba4 <init_thread+0x164>
    memset(t, 0, sizeof *t);
c0020a6f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0020a75:	c7 80 14 01 00 00 00 	movl   $0x0,0x114(%eax)
c0020a7c:	00 00 00 
c0020a7f:	8d 78 04             	lea    0x4(%eax),%edi
c0020a82:	83 e7 fc             	and    $0xfffffffc,%edi
c0020a85:	89 c1                	mov    %eax,%ecx
c0020a87:	29 f9                	sub    %edi,%ecx
c0020a89:	81 c1 18 01 00 00    	add    $0x118,%ecx
c0020a8f:	c1 e9 02             	shr    $0x2,%ecx
c0020a92:	b8 00 00 00 00       	mov    $0x0,%eax
c0020a97:	f3 ab                	rep stos %eax,%es:(%edi)
    t->status = THREAD_BLOCKED;
c0020a99:	c7 46 04 02 00 00 00 	movl   $0x2,0x4(%esi)
    t->ticks_blocked = 0;
c0020aa0:	c7 86 e4 00 00 00 00 	movl   $0x0,0xe4(%esi)
c0020aa7:	00 00 00 
c0020aaa:	c7 86 e8 00 00 00 00 	movl   $0x0,0xe8(%esi)
c0020ab1:	00 00 00 
    strlcpy(t->name, name, sizeof t->name);
c0020ab4:	83 ec 04             	sub    $0x4,%esp
c0020ab7:	6a 10                	push   $0x10
c0020ab9:	52                   	push   %edx
c0020aba:	8d 46 08             	lea    0x8(%esi),%eax
c0020abd:	50                   	push   %eax
c0020abe:	e8 63 7a 00 00       	call   c0028526 <strlcpy>
    t->stack = (uint8_t *) t + PGSIZE;
c0020ac3:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
c0020ac9:	89 46 18             	mov    %eax,0x18(%esi)
    t->priority = priority;
c0020acc:	89 6e 24             	mov    %ebp,0x24(%esi)
    t->original_priority = priority;
c0020acf:	89 6e 28             	mov    %ebp,0x28(%esi)
    t->lock_waiting = NULL;
c0020ad2:	c7 86 04 01 00 00 00 	movl   $0x0,0x104(%esi)
c0020ad9:	00 00 00 
    list_init(&t->lock_list);
c0020adc:	8d 86 f4 00 00 00    	lea    0xf4(%esi),%eax
c0020ae2:	89 04 24             	mov    %eax,(%esp)
c0020ae5:	e8 c7 84 00 00       	call   c0028fb1 <list_init>
    list_init(&t->child_list);
c0020aea:	8d 86 cc 00 00 00    	lea    0xcc(%esi),%eax
c0020af0:	89 04 24             	mov    %eax,(%esp)
c0020af3:	e8 b9 84 00 00       	call   c0028fb1 <list_init>
    list_init(&t->file_descriptor_list);
c0020af8:	8d 46 30             	lea    0x30(%esi),%eax
c0020afb:	89 04 24             	mov    %eax,(%esp)
c0020afe:	e8 ae 84 00 00       	call   c0028fb1 <list_init>
    t->magic = THREAD_MAGIC;
c0020b03:	c7 86 14 01 00 00 4b 	movl   $0xcd6abf4b,0x114(%esi)
c0020b0a:	bf 6a cd 
    if (thread_mlfqs) {
c0020b0d:	83 c4 10             	add    $0x10,%esp
c0020b10:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c0020b16:	80 38 00             	cmpb   $0x0,(%eax)
c0020b19:	0f 85 ae 00 00 00    	jne    c0020bcd <init_thread+0x18d>
    old_level = intr_disable();
c0020b1f:	e8 ff 0f 00 00       	call   c0021b23 <intr_disable>
c0020b24:	89 c7                	mov    %eax,%edi
    list_insert_ordered(&all_list, &t->allelem, (list_less_func *) &thread_cmp_priority, NULL);
c0020b26:	6a 00                	push   $0x0
c0020b28:	8d 83 f1 62 fe ff    	lea    -0x19d0f(%ebx),%eax
c0020b2e:	50                   	push   %eax
c0020b2f:	81 c6 ec 00 00 00    	add    $0xec,%esi
c0020b35:	56                   	push   %esi
c0020b36:	8d 83 8c 01 00 00    	lea    0x18c(%ebx),%eax
c0020b3c:	50                   	push   %eax
c0020b3d:	e8 66 8f 00 00       	call   c0029aa8 <list_insert_ordered>
    intr_set_level(old_level);
c0020b42:	89 3c 24             	mov    %edi,(%esp)
c0020b45:	e8 e0 0f 00 00       	call   c0021b2a <intr_set_level>
}
c0020b4a:	83 c4 1c             	add    $0x1c,%esp
c0020b4d:	5b                   	pop    %ebx
c0020b4e:	5e                   	pop    %esi
c0020b4f:	5f                   	pop    %edi
c0020b50:	5d                   	pop    %ebp
c0020b51:	c3                   	ret    
    ASSERT(t != NULL);
c0020b52:	83 ec 0c             	sub    $0xc,%esp
c0020b55:	8d 83 17 5d ff ff    	lea    -0xa2e9(%ebx),%eax
c0020b5b:	50                   	push   %eax
c0020b5c:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020b62:	50                   	push   %eax
c0020b63:	8d 83 e4 34 ff ff    	lea    -0xcb1c(%ebx),%eax
c0020b69:	50                   	push   %eax
c0020b6a:	68 17 02 00 00       	push   $0x217
c0020b6f:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020b75:	50                   	push   %eax
c0020b76:	e8 69 83 00 00       	call   c0028ee4 <debug_panic>
    ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020b7b:	83 ec 0c             	sub    $0xc,%esp
c0020b7e:	8d 83 c4 47 ff ff    	lea    -0xb83c(%ebx),%eax
c0020b84:	50                   	push   %eax
c0020b85:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020b8b:	50                   	push   %eax
c0020b8c:	8d 83 e4 34 ff ff    	lea    -0xcb1c(%ebx),%eax
c0020b92:	50                   	push   %eax
c0020b93:	68 18 02 00 00       	push   $0x218
c0020b98:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020b9e:	50                   	push   %eax
c0020b9f:	e8 40 83 00 00       	call   c0028ee4 <debug_panic>
    ASSERT(name != NULL);
c0020ba4:	83 ec 0c             	sub    $0xc,%esp
c0020ba7:	8d 83 07 49 ff ff    	lea    -0xb6f9(%ebx),%eax
c0020bad:	50                   	push   %eax
c0020bae:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020bb4:	50                   	push   %eax
c0020bb5:	8d 83 e4 34 ff ff    	lea    -0xcb1c(%ebx),%eax
c0020bbb:	50                   	push   %eax
c0020bbc:	68 19 02 00 00       	push   $0x219
c0020bc1:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020bc7:	50                   	push   %eax
c0020bc8:	e8 17 83 00 00       	call   c0028ee4 <debug_panic>
        t->nice = 0;
c0020bcd:	c7 46 1c 00 00 00 00 	movl   $0x0,0x1c(%esi)
        t->recent_cpu = fix_int(0);
c0020bd4:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
        update_thread_priority_mlfqs(t, NULL);
c0020bdb:	83 ec 08             	sub    $0x8,%esp
c0020bde:	6a 00                	push   $0x0
c0020be0:	56                   	push   %esi
c0020be1:	e8 bc fd ff ff       	call   c00209a2 <update_thread_priority_mlfqs>
c0020be6:	83 c4 10             	add    $0x10,%esp
c0020be9:	e9 31 ff ff ff       	jmp    c0020b1f <init_thread+0xdf>

c0020bee <thread_init>:
thread_init(void) {
c0020bee:	55                   	push   %ebp
c0020bef:	57                   	push   %edi
c0020bf0:	56                   	push   %esi
c0020bf1:	53                   	push   %ebx
c0020bf2:	83 ec 0c             	sub    $0xc,%esp
c0020bf5:	e8 9d cc 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020bfa:	81 c3 06 99 01 00    	add    $0x19906,%ebx
    ASSERT(intr_get_level() == INTR_OFF);
c0020c00:	e8 cc 0e 00 00       	call   c0021ad1 <intr_get_level>
c0020c05:	85 c0                	test   %eax,%eax
c0020c07:	75 7e                	jne    c0020c87 <thread_init+0x99>
    lock_init(&tid_lock);
c0020c09:	83 ec 0c             	sub    $0xc,%esp
c0020c0c:	8d b3 60 01 00 00    	lea    0x160(%ebx),%esi
c0020c12:	56                   	push   %esi
c0020c13:	e8 5e 23 00 00       	call   c0022f76 <lock_init>
    list_init(&ready_list);
c0020c18:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c0020c1e:	89 04 24             	mov    %eax,(%esp)
c0020c21:	e8 8b 83 00 00       	call   c0028fb1 <list_init>
    list_init(&all_list);
c0020c26:	8d 83 8c 01 00 00    	lea    0x18c(%ebx),%eax
c0020c2c:	89 04 24             	mov    %eax,(%esp)
c0020c2f:	e8 7d 83 00 00       	call   c0028fb1 <list_init>
    asm ("mov %%esp, %0" : "=g" (esp));
c0020c34:	89 e0                	mov    %esp,%eax
    return (void *) ((uintptr_t) va & ~PGMASK);
c0020c36:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    initial_thread = running_thread();
c0020c3b:	89 83 84 01 00 00    	mov    %eax,0x184(%ebx)
    init_thread(initial_thread, "main", PRI_DEFAULT);
c0020c41:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020c46:	8d 93 31 49 ff ff    	lea    -0xb6cf(%ebx),%edx
c0020c4c:	e8 ef fd ff ff       	call   c0020a40 <init_thread>
    initial_thread->status = THREAD_RUNNING;
c0020c51:	8b bb 84 01 00 00    	mov    0x184(%ebx),%edi
c0020c57:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    lock_acquire(&tid_lock);
c0020c5e:	89 34 24             	mov    %esi,(%esp)
c0020c61:	e8 bc 23 00 00       	call   c0023022 <lock_acquire>
    tid = next_tid++;
c0020c66:	8b ab bc fb ff ff    	mov    -0x444(%ebx),%ebp
c0020c6c:	8d 45 01             	lea    0x1(%ebp),%eax
c0020c6f:	89 83 bc fb ff ff    	mov    %eax,-0x444(%ebx)
    lock_release(&tid_lock);
c0020c75:	89 34 24             	mov    %esi,(%esp)
c0020c78:	e8 a6 25 00 00       	call   c0023223 <lock_release>
    initial_thread->tid = allocate_tid();
c0020c7d:	89 2f                	mov    %ebp,(%edi)
}
c0020c7f:	83 c4 1c             	add    $0x1c,%esp
c0020c82:	5b                   	pop    %ebx
c0020c83:	5e                   	pop    %esi
c0020c84:	5f                   	pop    %edi
c0020c85:	5d                   	pop    %ebp
c0020c86:	c3                   	ret    
    ASSERT(intr_get_level() == INTR_OFF);
c0020c87:	83 ec 0c             	sub    $0xc,%esp
c0020c8a:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0020c90:	50                   	push   %eax
c0020c91:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020c97:	50                   	push   %eax
c0020c98:	8d 83 f0 34 ff ff    	lea    -0xcb10(%ebx),%eax
c0020c9e:	50                   	push   %eax
c0020c9f:	6a 69                	push   $0x69
c0020ca1:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020ca7:	50                   	push   %eax
c0020ca8:	e8 37 82 00 00       	call   c0028ee4 <debug_panic>

c0020cad <thread_print_stats>:
thread_print_stats(void) {
c0020cad:	53                   	push   %ebx
c0020cae:	83 ec 0c             	sub    $0xc,%esp
c0020cb1:	e8 e1 cb 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020cb6:	81 c3 4a 98 01 00    	add    $0x1984a,%ebx
    printf("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020cbc:	6a 00                	push   $0x0
c0020cbe:	6a 00                	push   $0x0
c0020cc0:	ff b3 4c 01 00 00    	pushl  0x14c(%ebx)
c0020cc6:	ff b3 48 01 00 00    	pushl  0x148(%ebx)
c0020ccc:	ff b3 54 01 00 00    	pushl  0x154(%ebx)
c0020cd2:	ff b3 50 01 00 00    	pushl  0x150(%ebx)
c0020cd8:	8d 83 f0 47 ff ff    	lea    -0xb810(%ebx),%eax
c0020cde:	50                   	push   %eax
c0020cdf:	e8 a4 65 00 00       	call   c0027288 <printf>
}
c0020ce4:	83 c4 28             	add    $0x28,%esp
c0020ce7:	5b                   	pop    %ebx
c0020ce8:	c3                   	ret    

c0020ce9 <get_cmp_priority_func>:
list_less_func *get_cmp_priority_func() {
c0020ce9:	e8 ad cb 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0020cee:	05 12 98 01 00       	add    $0x19812,%eax
    return (list_less_func *) &thread_cmp_priority;
c0020cf3:	8d 80 f1 62 fe ff    	lea    -0x19d0f(%eax),%eax
}
c0020cf9:	c3                   	ret    

c0020cfa <thread_unblock>:
thread_unblock(struct thread *t) {
c0020cfa:	57                   	push   %edi
c0020cfb:	56                   	push   %esi
c0020cfc:	53                   	push   %ebx
c0020cfd:	e8 95 cb 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020d02:	81 c3 fe 97 01 00    	add    $0x197fe,%ebx
c0020d08:	8b 74 24 10          	mov    0x10(%esp),%esi
    return t != NULL && t->magic == THREAD_MAGIC;
c0020d0c:	85 f6                	test   %esi,%esi
c0020d0e:	74 0c                	je     c0020d1c <thread_unblock+0x22>
c0020d10:	81 be 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%esi)
c0020d17:	bf 6a cd 
c0020d1a:	74 52                	je     c0020d6e <thread_unblock+0x74>
    ASSERT(is_thread(t));
c0020d1c:	83 ec 0c             	sub    $0xc,%esp
c0020d1f:	8d 83 fa 48 ff ff    	lea    -0xb706(%ebx),%eax
c0020d25:	50                   	push   %eax
c0020d26:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020d2c:	50                   	push   %eax
c0020d2d:	8d 83 84 34 ff ff    	lea    -0xcb7c(%ebx),%eax
c0020d33:	50                   	push   %eax
c0020d34:	68 12 01 00 00       	push   $0x112
c0020d39:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020d3f:	50                   	push   %eax
c0020d40:	e8 9f 81 00 00       	call   c0028ee4 <debug_panic>
    ASSERT(t->status == THREAD_BLOCKED);
c0020d45:	83 ec 0c             	sub    $0xc,%esp
c0020d48:	8d 83 36 49 ff ff    	lea    -0xb6ca(%ebx),%eax
c0020d4e:	50                   	push   %eax
c0020d4f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020d55:	50                   	push   %eax
c0020d56:	8d 83 84 34 ff ff    	lea    -0xcb7c(%ebx),%eax
c0020d5c:	50                   	push   %eax
c0020d5d:	68 15 01 00 00       	push   $0x115
c0020d62:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020d68:	50                   	push   %eax
c0020d69:	e8 76 81 00 00       	call   c0028ee4 <debug_panic>
    old_level = intr_disable();
c0020d6e:	e8 b0 0d 00 00       	call   c0021b23 <intr_disable>
c0020d73:	89 c7                	mov    %eax,%edi
    ASSERT(t->status == THREAD_BLOCKED);
c0020d75:	83 7e 04 02          	cmpl   $0x2,0x4(%esi)
c0020d79:	75 ca                	jne    c0020d45 <thread_unblock+0x4b>
    list_insert_ordered(&ready_list, &t->elem, (list_less_func *) &thread_cmp_priority, NULL);
c0020d7b:	6a 00                	push   $0x0
c0020d7d:	8d 83 f1 62 fe ff    	lea    -0x19d0f(%ebx),%eax
c0020d83:	50                   	push   %eax
c0020d84:	8d 86 08 01 00 00    	lea    0x108(%esi),%eax
c0020d8a:	50                   	push   %eax
c0020d8b:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c0020d91:	50                   	push   %eax
c0020d92:	e8 11 8d 00 00       	call   c0029aa8 <list_insert_ordered>
    t->status = THREAD_READY;
c0020d97:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
    intr_set_level(old_level);
c0020d9e:	89 3c 24             	mov    %edi,(%esp)
c0020da1:	e8 84 0d 00 00       	call   c0021b2a <intr_set_level>
}
c0020da6:	83 c4 10             	add    $0x10,%esp
c0020da9:	5b                   	pop    %ebx
c0020daa:	5e                   	pop    %esi
c0020dab:	5f                   	pop    %edi
c0020dac:	c3                   	ret    

c0020dad <thread_current>:
thread_current(void) {
c0020dad:	53                   	push   %ebx
c0020dae:	83 ec 08             	sub    $0x8,%esp
c0020db1:	e8 e1 ca 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020db6:	81 c3 4a 97 01 00    	add    $0x1974a,%ebx
    asm ("mov %%esp, %0" : "=g" (esp));
c0020dbc:	89 e0                	mov    %esp,%eax
    return t != NULL && t->magic == THREAD_MAGIC;
c0020dbe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0020dc3:	74 0c                	je     c0020dd1 <thread_current+0x24>
c0020dc5:	81 b8 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%eax)
c0020dcc:	bf 6a cd 
c0020dcf:	74 52                	je     c0020e23 <thread_current+0x76>
    ASSERT(is_thread(t));
c0020dd1:	83 ec 0c             	sub    $0xc,%esp
c0020dd4:	8d 83 fa 48 ff ff    	lea    -0xb706(%ebx),%eax
c0020dda:	50                   	push   %eax
c0020ddb:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020de1:	50                   	push   %eax
c0020de2:	8d 83 74 34 ff ff    	lea    -0xcb8c(%ebx),%eax
c0020de8:	50                   	push   %eax
c0020de9:	68 2e 01 00 00       	push   $0x12e
c0020dee:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020df4:	50                   	push   %eax
c0020df5:	e8 ea 80 00 00       	call   c0028ee4 <debug_panic>
    ASSERT(t->status == THREAD_RUNNING);
c0020dfa:	83 ec 0c             	sub    $0xc,%esp
c0020dfd:	8d 83 52 49 ff ff    	lea    -0xb6ae(%ebx),%eax
c0020e03:	50                   	push   %eax
c0020e04:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020e0a:	50                   	push   %eax
c0020e0b:	8d 83 74 34 ff ff    	lea    -0xcb8c(%ebx),%eax
c0020e11:	50                   	push   %eax
c0020e12:	68 2f 01 00 00       	push   $0x12f
c0020e17:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020e1d:	50                   	push   %eax
c0020e1e:	e8 c1 80 00 00       	call   c0028ee4 <debug_panic>
c0020e23:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0020e27:	75 d1                	jne    c0020dfa <thread_current+0x4d>
}
c0020e29:	83 c4 08             	add    $0x8,%esp
c0020e2c:	5b                   	pop    %ebx
c0020e2d:	c3                   	ret    

c0020e2e <thread_tick>:
thread_tick(void) {
c0020e2e:	53                   	push   %ebx
c0020e2f:	83 ec 08             	sub    $0x8,%esp
c0020e32:	e8 60 ca 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020e37:	81 c3 c9 96 01 00    	add    $0x196c9,%ebx
    struct thread *t = thread_current();
c0020e3d:	e8 6b ff ff ff       	call   c0020dad <thread_current>
    if (t == idle_thread)
c0020e42:	39 83 88 01 00 00    	cmp    %eax,0x188(%ebx)
c0020e48:	74 27                	je     c0020e71 <thread_tick+0x43>
        kernel_ticks++;
c0020e4a:	83 83 48 01 00 00 01 	addl   $0x1,0x148(%ebx)
c0020e51:	83 93 4c 01 00 00 00 	adcl   $0x0,0x14c(%ebx)
    if (++thread_ticks >= TIME_SLICE)
c0020e58:	8b 83 40 01 00 00    	mov    0x140(%ebx),%eax
c0020e5e:	83 c0 01             	add    $0x1,%eax
c0020e61:	89 83 40 01 00 00    	mov    %eax,0x140(%ebx)
c0020e67:	83 f8 03             	cmp    $0x3,%eax
c0020e6a:	77 15                	ja     c0020e81 <thread_tick+0x53>
}
c0020e6c:	83 c4 08             	add    $0x8,%esp
c0020e6f:	5b                   	pop    %ebx
c0020e70:	c3                   	ret    
        idle_ticks++;
c0020e71:	83 83 50 01 00 00 01 	addl   $0x1,0x150(%ebx)
c0020e78:	83 93 54 01 00 00 00 	adcl   $0x0,0x154(%ebx)
c0020e7f:	eb d7                	jmp    c0020e58 <thread_tick+0x2a>
        intr_yield_on_return();
c0020e81:	e8 55 0f 00 00       	call   c0021ddb <intr_yield_on_return>
}
c0020e86:	eb e4                	jmp    c0020e6c <thread_tick+0x3e>

c0020e88 <thread_name>:
thread_name(void) {
c0020e88:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->name;
c0020e8b:	e8 1d ff ff ff       	call   c0020dad <thread_current>
c0020e90:	83 c0 08             	add    $0x8,%eax
}
c0020e93:	83 c4 0c             	add    $0xc,%esp
c0020e96:	c3                   	ret    

c0020e97 <thread_tid>:
thread_tid(void) {
c0020e97:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->tid;
c0020e9a:	e8 0e ff ff ff       	call   c0020dad <thread_current>
c0020e9f:	8b 00                	mov    (%eax),%eax
}
c0020ea1:	83 c4 0c             	add    $0xc,%esp
c0020ea4:	c3                   	ret    

c0020ea5 <thread_foreach>:
thread_foreach(thread_action_func func, void *aux) {
c0020ea5:	55                   	push   %ebp
c0020ea6:	57                   	push   %edi
c0020ea7:	56                   	push   %esi
c0020ea8:	53                   	push   %ebx
c0020ea9:	83 ec 0c             	sub    $0xc,%esp
c0020eac:	e8 e6 c9 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020eb1:	81 c3 4f 96 01 00    	add    $0x1964f,%ebx
c0020eb7:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    ASSERT(intr_get_level() == INTR_OFF);
c0020ebb:	e8 11 0c 00 00       	call   c0021ad1 <intr_get_level>
c0020ec0:	85 c0                	test   %eax,%eax
c0020ec2:	75 48                	jne    c0020f0c <thread_foreach+0x67>
    for (e = list_begin(&all_list); e != list_end(&all_list);
c0020ec4:	83 ec 0c             	sub    $0xc,%esp
c0020ec7:	8d 83 8c 01 00 00    	lea    0x18c(%ebx),%eax
c0020ecd:	50                   	push   %eax
c0020ece:	e8 36 81 00 00       	call   c0029009 <list_begin>
c0020ed3:	89 c6                	mov    %eax,%esi
c0020ed5:	83 c4 10             	add    $0x10,%esp
c0020ed8:	8d bb 8c 01 00 00    	lea    0x18c(%ebx),%edi
c0020ede:	83 ec 0c             	sub    $0xc,%esp
c0020ee1:	57                   	push   %edi
c0020ee2:	e8 c4 81 00 00       	call   c00290ab <list_end>
c0020ee7:	83 c4 10             	add    $0x10,%esp
c0020eea:	39 f0                	cmp    %esi,%eax
c0020eec:	74 47                	je     c0020f35 <thread_foreach+0x90>
        func(t, aux);
c0020eee:	83 ec 08             	sub    $0x8,%esp
c0020ef1:	55                   	push   %ebp
        struct thread *t = list_entry(e, struct thread, allelem);
c0020ef2:	8d 86 14 ff ff ff    	lea    -0xec(%esi),%eax
        func(t, aux);
c0020ef8:	50                   	push   %eax
c0020ef9:	ff 54 24 30          	call   *0x30(%esp)
         e = list_next(e)) {
c0020efd:	89 34 24             	mov    %esi,(%esp)
c0020f00:	e8 49 81 00 00       	call   c002904e <list_next>
c0020f05:	89 c6                	mov    %eax,%esi
c0020f07:	83 c4 10             	add    $0x10,%esp
c0020f0a:	eb d2                	jmp    c0020ede <thread_foreach+0x39>
    ASSERT(intr_get_level() == INTR_OFF);
c0020f0c:	83 ec 0c             	sub    $0xc,%esp
c0020f0f:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0020f15:	50                   	push   %eax
c0020f16:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0020f1c:	50                   	push   %eax
c0020f1d:	8d 83 48 34 ff ff    	lea    -0xcbb8(%ebx),%eax
c0020f23:	50                   	push   %eax
c0020f24:	68 65 01 00 00       	push   $0x165
c0020f29:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0020f2f:	50                   	push   %eax
c0020f30:	e8 af 7f 00 00       	call   c0028ee4 <debug_panic>
}
c0020f35:	83 c4 0c             	add    $0xc,%esp
c0020f38:	5b                   	pop    %ebx
c0020f39:	5e                   	pop    %esi
c0020f3a:	5f                   	pop    %edi
c0020f3b:	5d                   	pop    %ebp
c0020f3c:	c3                   	ret    

c0020f3d <thread_get_priority>:
thread_get_priority(void) {
c0020f3d:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->priority;
c0020f40:	e8 68 fe ff ff       	call   c0020dad <thread_current>
c0020f45:	8b 40 24             	mov    0x24(%eax),%eax
}
c0020f48:	83 c4 0c             	add    $0xc,%esp
c0020f4b:	c3                   	ret    

c0020f4c <get_ready_list_size>:
int get_ready_list_size(void) {
c0020f4c:	56                   	push   %esi
c0020f4d:	53                   	push   %ebx
c0020f4e:	83 ec 10             	sub    $0x10,%esp
c0020f51:	e8 41 c9 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020f56:	81 c3 aa 95 01 00    	add    $0x195aa,%ebx
    return list_size(&ready_list) + ((thread_current() != idle_thread) ? 1 : 0);
c0020f5c:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c0020f62:	50                   	push   %eax
c0020f63:	e8 aa 86 00 00       	call   c0029612 <list_size>
c0020f68:	89 c6                	mov    %eax,%esi
c0020f6a:	e8 3e fe ff ff       	call   c0020dad <thread_current>
c0020f6f:	39 83 88 01 00 00    	cmp    %eax,0x188(%ebx)
c0020f75:	0f 95 c0             	setne  %al
c0020f78:	0f b6 c0             	movzbl %al,%eax
c0020f7b:	01 f0                	add    %esi,%eax
};
c0020f7d:	83 c4 14             	add    $0x14,%esp
c0020f80:	5b                   	pop    %ebx
c0020f81:	5e                   	pop    %esi
c0020f82:	c3                   	ret    

c0020f83 <update_all_priority>:
void update_all_priority(void) {
c0020f83:	83 ec 14             	sub    $0x14,%esp
c0020f86:	e8 10 c9 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0020f8b:	05 75 95 01 00       	add    $0x19575,%eax
    thread_foreach((thread_action_func) &update_thread_priority_mlfqs, NULL);
c0020f90:	6a 00                	push   $0x0
c0020f92:	8d 80 a2 64 fe ff    	lea    -0x19b5e(%eax),%eax
c0020f98:	50                   	push   %eax
c0020f99:	e8 07 ff ff ff       	call   c0020ea5 <thread_foreach>
}
c0020f9e:	83 c4 1c             	add    $0x1c,%esp
c0020fa1:	c3                   	ret    

c0020fa2 <update_all_recent_cpu>:
void update_all_recent_cpu(void) {
c0020fa2:	83 ec 14             	sub    $0x14,%esp
c0020fa5:	e8 f1 c8 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0020faa:	05 56 95 01 00       	add    $0x19556,%eax
    thread_foreach((thread_action_func) &update_thread_recent_cpu, NULL);
c0020faf:	6a 00                	push   $0x0
c0020fb1:	8d 80 1b 63 fe ff    	lea    -0x19ce5(%eax),%eax
c0020fb7:	50                   	push   %eax
c0020fb8:	e8 e8 fe ff ff       	call   c0020ea5 <thread_foreach>
}
c0020fbd:	83 c4 1c             	add    $0x1c,%esp
c0020fc0:	c3                   	ret    

c0020fc1 <update_cur_thread_cpu>:
void update_cur_thread_cpu(void) {
c0020fc1:	83 ec 0c             	sub    $0xc,%esp
    struct thread *cur = thread_current();
c0020fc4:	e8 e4 fd ff ff       	call   c0020dad <thread_current>
    return __mk_fix (x.f + y.f);
c0020fc9:	81 40 20 00 00 01 00 	addl   $0x10000,0x20(%eax)
}
c0020fd0:	83 c4 0c             	add    $0xc,%esp
c0020fd3:	c3                   	ret    

c0020fd4 <thread_get_nice>:
thread_get_nice(void) {
c0020fd4:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->nice;
c0020fd7:	e8 d1 fd ff ff       	call   c0020dad <thread_current>
c0020fdc:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020fdf:	83 c4 0c             	add    $0xc,%esp
c0020fe2:	c3                   	ret    

c0020fe3 <update_load_avg>:
void update_load_avg(void) {
c0020fe3:	55                   	push   %ebp
c0020fe4:	57                   	push   %edi
c0020fe5:	56                   	push   %esi
c0020fe6:	53                   	push   %ebx
c0020fe7:	83 ec 1c             	sub    $0x1c,%esp
c0020fea:	e8 a8 c8 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0020fef:	81 c3 11 95 01 00    	add    $0x19511,%ebx
    fixed_point_t a = fix_frac(get_ready_list_size(), 60);
c0020ff5:	e8 52 ff ff ff       	call   c0020f4c <get_ready_list_size>
c0020ffa:	89 c1                	mov    %eax,%ecx
    ASSERT (n / d >= FIX_MIN_INT && n / d <= FIX_MAX_INT);
c0020ffc:	ba 89 88 88 88       	mov    $0x88888889,%edx
c0021001:	f7 ea                	imul   %edx
c0021003:	01 ca                	add    %ecx,%edx
c0021005:	c1 fa 05             	sar    $0x5,%edx
c0021008:	89 c8                	mov    %ecx,%eax
c002100a:	c1 f8 1f             	sar    $0x1f,%eax
c002100d:	29 c2                	sub    %eax,%edx
c002100f:	81 c2 ff ff 00 00    	add    $0xffff,%edx
c0021015:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
c002101b:	77 77                	ja     c0021094 <update_load_avg+0xb1>
    global_load_avg = fix_add(a, b);
c002101d:	c7 c5 3c c2 03 c0    	mov    $0xc003c23c,%ebp
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0021023:	8b 45 00             	mov    0x0(%ebp),%eax
c0021026:	89 c7                	mov    %eax,%edi
c0021028:	c1 ff 1f             	sar    $0x1f,%edi
c002102b:	69 ff bb fb 00 00    	imul   $0xfbbb,%edi,%edi
c0021031:	be bb fb 00 00       	mov    $0xfbbb,%esi
c0021036:	f7 e6                	mul    %esi
c0021038:	89 04 24             	mov    %eax,(%esp)
c002103b:	89 54 24 04          	mov    %edx,0x4(%esp)
c002103f:	01 7c 24 04          	add    %edi,0x4(%esp)
c0021043:	8b 74 24 04          	mov    0x4(%esp),%esi
c0021047:	c1 fe 1f             	sar    $0x1f,%esi
c002104a:	89 f0                	mov    %esi,%eax
c002104c:	25 ff ff 00 00       	and    $0xffff,%eax
c0021051:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021055:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002105c:	00 
c002105d:	8b 04 24             	mov    (%esp),%eax
c0021060:	8b 54 24 04          	mov    0x4(%esp),%edx
c0021064:	03 44 24 08          	add    0x8(%esp),%eax
c0021068:	13 54 24 0c          	adc    0xc(%esp),%edx
c002106c:	0f ac d0 10          	shrd   $0x10,%edx,%eax
c0021070:	89 c6                	mov    %eax,%esi
    return __mk_fix ((long long) n * FIX_F / d);
c0021072:	89 c8                	mov    %ecx,%eax
c0021074:	99                   	cltd   
c0021075:	0f a4 ca 10          	shld   $0x10,%ecx,%edx
c0021079:	c1 e0 10             	shl    $0x10,%eax
c002107c:	6a 00                	push   $0x0
c002107e:	6a 3c                	push   $0x3c
c0021080:	52                   	push   %edx
c0021081:	50                   	push   %eax
c0021082:	e8 27 78 00 00       	call   c00288ae <__divdi3>
    return __mk_fix (x.f + y.f);
c0021087:	01 c6                	add    %eax,%esi
c0021089:	89 75 00             	mov    %esi,0x0(%ebp)
}
c002108c:	83 c4 2c             	add    $0x2c,%esp
c002108f:	5b                   	pop    %ebx
c0021090:	5e                   	pop    %esi
c0021091:	5f                   	pop    %edi
c0021092:	5d                   	pop    %ebp
c0021093:	c3                   	ret    
    ASSERT (n / d >= FIX_MIN_INT && n / d <= FIX_MAX_INT);
c0021094:	83 ec 0c             	sub    $0xc,%esp
c0021097:	8d 83 30 48 ff ff    	lea    -0xb7d0(%ebx),%eax
c002109d:	50                   	push   %eax
c002109e:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00210a4:	50                   	push   %eax
c00210a5:	8d 83 1c 34 ff ff    	lea    -0xcbe4(%ebx),%eax
c00210ab:	50                   	push   %eax
c00210ac:	6a 30                	push   $0x30
c00210ae:	8d 83 aa 48 ff ff    	lea    -0xb756(%ebx),%eax
c00210b4:	50                   	push   %eax
c00210b5:	e8 2a 7e 00 00       	call   c0028ee4 <debug_panic>

c00210ba <thread_get_load_avg>:
thread_get_load_avg(void) {
c00210ba:	55                   	push   %ebp
c00210bb:	57                   	push   %edi
c00210bc:	56                   	push   %esi
c00210bd:	53                   	push   %ebx
c00210be:	e8 d8 c7 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c00210c3:	05 3d 94 01 00       	add    $0x1943d,%eax
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c00210c8:	c7 c0 3c c2 03 c0    	mov    $0xc003c23c,%eax
c00210ce:	8b 38                	mov    (%eax),%edi
c00210d0:	89 fb                	mov    %edi,%ebx
c00210d2:	c1 fb 1f             	sar    $0x1f,%ebx
c00210d5:	69 f3 00 00 64 00    	imul   $0x640000,%ebx,%esi
c00210db:	b9 00 00 64 00       	mov    $0x640000,%ecx
c00210e0:	89 f8                	mov    %edi,%eax
c00210e2:	f7 e1                	mul    %ecx
c00210e4:	89 c7                	mov    %eax,%edi
c00210e6:	89 d5                	mov    %edx,%ebp
c00210e8:	01 f5                	add    %esi,%ebp
c00210ea:	89 ee                	mov    %ebp,%esi
c00210ec:	c1 fe 1f             	sar    $0x1f,%esi
c00210ef:	0f b7 c6             	movzwl %si,%eax
c00210f2:	ba 00 00 00 00       	mov    $0x0,%edx
c00210f7:	01 f8                	add    %edi,%eax
c00210f9:	11 ea                	adc    %ebp,%edx
c00210fb:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c00210ff:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c0021105:	05 00 80 00 00       	add    $0x8000,%eax
c002110a:	0f 48 c2             	cmovs  %edx,%eax
c002110d:	c1 f8 10             	sar    $0x10,%eax
}
c0021110:	5b                   	pop    %ebx
c0021111:	5e                   	pop    %esi
c0021112:	5f                   	pop    %edi
c0021113:	5d                   	pop    %ebp
c0021114:	c3                   	ret    

c0021115 <thread_get_recent_cpu>:
thread_get_recent_cpu(void) {
c0021115:	55                   	push   %ebp
c0021116:	57                   	push   %edi
c0021117:	56                   	push   %esi
c0021118:	53                   	push   %ebx
c0021119:	83 ec 0c             	sub    $0xc,%esp
    return fix_round(fix_mul(fix_int(100), thread_current()->recent_cpu));
c002111c:	e8 8c fc ff ff       	call   c0020dad <thread_current>
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0021121:	8b 78 20             	mov    0x20(%eax),%edi
c0021124:	89 fb                	mov    %edi,%ebx
c0021126:	c1 fb 1f             	sar    $0x1f,%ebx
c0021129:	69 f3 00 00 64 00    	imul   $0x640000,%ebx,%esi
c002112f:	b9 00 00 64 00       	mov    $0x640000,%ecx
c0021134:	89 f8                	mov    %edi,%eax
c0021136:	f7 e1                	mul    %ecx
c0021138:	89 c7                	mov    %eax,%edi
c002113a:	89 d5                	mov    %edx,%ebp
c002113c:	01 f5                	add    %esi,%ebp
c002113e:	89 ee                	mov    %ebp,%esi
c0021140:	c1 fe 1f             	sar    $0x1f,%esi
c0021143:	0f b7 c6             	movzwl %si,%eax
c0021146:	ba 00 00 00 00       	mov    $0x0,%edx
c002114b:	01 f8                	add    %edi,%eax
c002114d:	11 ea                	adc    %ebp,%edx
c002114f:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c0021153:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c0021159:	05 00 80 00 00       	add    $0x8000,%eax
c002115e:	0f 48 c2             	cmovs  %edx,%eax
c0021161:	c1 f8 10             	sar    $0x10,%eax
}
c0021164:	83 c4 0c             	add    $0xc,%esp
c0021167:	5b                   	pop    %ebx
c0021168:	5e                   	pop    %esi
c0021169:	5f                   	pop    %edi
c002116a:	5d                   	pop    %ebp
c002116b:	c3                   	ret    

c002116c <thread_schedule_tail>:
thread_schedule_tail(struct thread *prev) {
c002116c:	57                   	push   %edi
c002116d:	56                   	push   %esi
c002116e:	53                   	push   %ebx
c002116f:	e8 23 c7 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021174:	81 c3 8c 93 01 00    	add    $0x1938c,%ebx
c002117a:	8b 7c 24 10          	mov    0x10(%esp),%edi
    asm ("mov %%esp, %0" : "=g" (esp));
c002117e:	89 e6                	mov    %esp,%esi
c0021180:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    ASSERT(intr_get_level() == INTR_OFF);
c0021186:	e8 46 09 00 00       	call   c0021ad1 <intr_get_level>
c002118b:	85 c0                	test   %eax,%eax
c002118d:	75 1f                	jne    c00211ae <thread_schedule_tail+0x42>
    cur->status = THREAD_RUNNING;
c002118f:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    thread_ticks = 0;
c0021196:	c7 83 40 01 00 00 00 	movl   $0x0,0x140(%ebx)
c002119d:	00 00 00 
    if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) {
c00211a0:	85 ff                	test   %edi,%edi
c00211a2:	74 06                	je     c00211aa <thread_schedule_tail+0x3e>
c00211a4:	83 7f 04 03          	cmpl   $0x3,0x4(%edi)
c00211a8:	74 2d                	je     c00211d7 <thread_schedule_tail+0x6b>
}
c00211aa:	5b                   	pop    %ebx
c00211ab:	5e                   	pop    %esi
c00211ac:	5f                   	pop    %edi
c00211ad:	c3                   	ret    
    ASSERT(intr_get_level() == INTR_OFF);
c00211ae:	83 ec 0c             	sub    $0xc,%esp
c00211b1:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c00211b7:	50                   	push   %eax
c00211b8:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00211be:	50                   	push   %eax
c00211bf:	8d 83 04 34 ff ff    	lea    -0xcbfc(%ebx),%eax
c00211c5:	50                   	push   %eax
c00211c6:	68 68 02 00 00       	push   $0x268
c00211cb:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c00211d1:	50                   	push   %eax
c00211d2:	e8 0d 7d 00 00       	call   c0028ee4 <debug_panic>
    if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) {
c00211d7:	39 bb 84 01 00 00    	cmp    %edi,0x184(%ebx)
c00211dd:	74 cb                	je     c00211aa <thread_schedule_tail+0x3e>
        ASSERT(prev != cur);
c00211df:	39 f7                	cmp    %esi,%edi
c00211e1:	74 0e                	je     c00211f1 <thread_schedule_tail+0x85>
        palloc_free_page(prev);
c00211e3:	83 ec 0c             	sub    $0xc,%esp
c00211e6:	57                   	push   %edi
c00211e7:	e8 81 27 00 00       	call   c002396d <palloc_free_page>
c00211ec:	83 c4 10             	add    $0x10,%esp
}
c00211ef:	eb b9                	jmp    c00211aa <thread_schedule_tail+0x3e>
        ASSERT(prev != cur);
c00211f1:	83 ec 0c             	sub    $0xc,%esp
c00211f4:	8d 83 6e 49 ff ff    	lea    -0xb692(%ebx),%eax
c00211fa:	50                   	push   %eax
c00211fb:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021201:	50                   	push   %eax
c0021202:	8d 83 04 34 ff ff    	lea    -0xcbfc(%ebx),%eax
c0021208:	50                   	push   %eax
c0021209:	68 7b 02 00 00       	push   $0x27b
c002120e:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0021214:	50                   	push   %eax
c0021215:	e8 ca 7c 00 00       	call   c0028ee4 <debug_panic>

c002121a <schedule>:
schedule(void) {
c002121a:	57                   	push   %edi
c002121b:	56                   	push   %esi
c002121c:	53                   	push   %ebx
c002121d:	e8 75 c6 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021222:	81 c3 de 92 01 00    	add    $0x192de,%ebx
    asm ("mov %%esp, %0" : "=g" (esp));
c0021228:	89 e6                	mov    %esp,%esi
c002122a:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    if (list_empty(&ready_list))
c0021230:	83 ec 0c             	sub    $0xc,%esp
c0021233:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c0021239:	50                   	push   %eax
c002123a:	e8 16 84 00 00       	call   c0029655 <list_empty>
c002123f:	83 c4 10             	add    $0x10,%esp
c0021242:	84 c0                	test   %al,%al
c0021244:	74 56                	je     c002129c <schedule+0x82>
        return idle_thread;
c0021246:	8b bb 88 01 00 00    	mov    0x188(%ebx),%edi
    ASSERT(intr_get_level() == INTR_OFF);
c002124c:	e8 80 08 00 00       	call   c0021ad1 <intr_get_level>
c0021251:	85 c0                	test   %eax,%eax
c0021253:	75 61                	jne    c00212b6 <schedule+0x9c>
    ASSERT(cur->status != THREAD_RUNNING);
c0021255:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0021259:	0f 84 80 00 00 00    	je     c00212df <schedule+0xc5>
    return t != NULL && t->magic == THREAD_MAGIC;
c002125f:	85 ff                	test   %edi,%edi
c0021261:	74 10                	je     c0021273 <schedule+0x59>
c0021263:	81 bf 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%edi)
c002126a:	bf 6a cd 
c002126d:	0f 84 95 00 00 00    	je     c0021308 <schedule+0xee>
    ASSERT(is_thread(next));
c0021273:	83 ec 0c             	sub    $0xc,%esp
c0021276:	8d 83 98 49 ff ff    	lea    -0xb668(%ebx),%eax
c002127c:	50                   	push   %eax
c002127d:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021283:	50                   	push   %eax
c0021284:	8d 83 94 34 ff ff    	lea    -0xcb6c(%ebx),%eax
c002128a:	50                   	push   %eax
c002128b:	68 8f 02 00 00       	push   $0x28f
c0021290:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0021296:	50                   	push   %eax
c0021297:	e8 48 7c 00 00       	call   c0028ee4 <debug_panic>
        return list_entry(list_pop_front(&ready_list),
c002129c:	83 ec 0c             	sub    $0xc,%esp
c002129f:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c00212a5:	50                   	push   %eax
c00212a6:	e8 21 84 00 00       	call   c00296cc <list_pop_front>
c00212ab:	8d b8 f8 fe ff ff    	lea    -0x108(%eax),%edi
c00212b1:	83 c4 10             	add    $0x10,%esp
c00212b4:	eb 96                	jmp    c002124c <schedule+0x32>
    ASSERT(intr_get_level() == INTR_OFF);
c00212b6:	83 ec 0c             	sub    $0xc,%esp
c00212b9:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c00212bf:	50                   	push   %eax
c00212c0:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00212c6:	50                   	push   %eax
c00212c7:	8d 83 94 34 ff ff    	lea    -0xcb6c(%ebx),%eax
c00212cd:	50                   	push   %eax
c00212ce:	68 8d 02 00 00       	push   $0x28d
c00212d3:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c00212d9:	50                   	push   %eax
c00212da:	e8 05 7c 00 00       	call   c0028ee4 <debug_panic>
    ASSERT(cur->status != THREAD_RUNNING);
c00212df:	83 ec 0c             	sub    $0xc,%esp
c00212e2:	8d 83 7a 49 ff ff    	lea    -0xb686(%ebx),%eax
c00212e8:	50                   	push   %eax
c00212e9:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00212ef:	50                   	push   %eax
c00212f0:	8d 83 94 34 ff ff    	lea    -0xcb6c(%ebx),%eax
c00212f6:	50                   	push   %eax
c00212f7:	68 8e 02 00 00       	push   $0x28e
c00212fc:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0021302:	50                   	push   %eax
c0021303:	e8 dc 7b 00 00       	call   c0028ee4 <debug_panic>
    struct thread *prev = NULL;
c0021308:	b8 00 00 00 00       	mov    $0x0,%eax
    if (cur != next)
c002130d:	39 f7                	cmp    %esi,%edi
c002130f:	74 0d                	je     c002131e <schedule+0x104>
        prev = switch_threads(cur, next);
c0021311:	83 ec 08             	sub    $0x8,%esp
c0021314:	57                   	push   %edi
c0021315:	56                   	push   %esi
c0021316:	e8 35 06 00 00       	call   c0021950 <switch_threads>
c002131b:	83 c4 10             	add    $0x10,%esp
    thread_schedule_tail(prev);
c002131e:	83 ec 0c             	sub    $0xc,%esp
c0021321:	50                   	push   %eax
c0021322:	e8 45 fe ff ff       	call   c002116c <thread_schedule_tail>
}
c0021327:	83 c4 10             	add    $0x10,%esp
c002132a:	5b                   	pop    %ebx
c002132b:	5e                   	pop    %esi
c002132c:	5f                   	pop    %edi
c002132d:	c3                   	ret    

c002132e <thread_block>:
thread_block(void) {
c002132e:	53                   	push   %ebx
c002132f:	83 ec 08             	sub    $0x8,%esp
c0021332:	e8 60 c5 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021337:	81 c3 c9 91 01 00    	add    $0x191c9,%ebx
    ASSERT(!intr_context());
c002133d:	e8 87 0a 00 00       	call   c0021dc9 <intr_context>
c0021342:	84 c0                	test   %al,%al
c0021344:	75 1f                	jne    c0021365 <thread_block+0x37>
    ASSERT(intr_get_level() == INTR_OFF);
c0021346:	e8 86 07 00 00       	call   c0021ad1 <intr_get_level>
c002134b:	85 c0                	test   %eax,%eax
c002134d:	75 3f                	jne    c002138e <thread_block+0x60>
    thread_current()->status = THREAD_BLOCKED;
c002134f:	e8 59 fa ff ff       	call   c0020dad <thread_current>
c0021354:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    schedule();
c002135b:	e8 ba fe ff ff       	call   c002121a <schedule>
}
c0021360:	83 c4 08             	add    $0x8,%esp
c0021363:	5b                   	pop    %ebx
c0021364:	c3                   	ret    
    ASSERT(!intr_context());
c0021365:	83 ec 0c             	sub    $0xc,%esp
c0021368:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c002136e:	50                   	push   %eax
c002136f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021375:	50                   	push   %eax
c0021376:	8d 83 a0 34 ff ff    	lea    -0xcb60(%ebx),%eax
c002137c:	50                   	push   %eax
c002137d:	68 f1 00 00 00       	push   $0xf1
c0021382:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0021388:	50                   	push   %eax
c0021389:	e8 56 7b 00 00       	call   c0028ee4 <debug_panic>
    ASSERT(intr_get_level() == INTR_OFF);
c002138e:	83 ec 0c             	sub    $0xc,%esp
c0021391:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0021397:	50                   	push   %eax
c0021398:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002139e:	50                   	push   %eax
c002139f:	8d 83 a0 34 ff ff    	lea    -0xcb60(%ebx),%eax
c00213a5:	50                   	push   %eax
c00213a6:	68 f2 00 00 00       	push   $0xf2
c00213ab:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c00213b1:	50                   	push   %eax
c00213b2:	e8 2d 7b 00 00       	call   c0028ee4 <debug_panic>

c00213b7 <idle>:
idle(void *idle_started_ UNUSED) {
c00213b7:	53                   	push   %ebx
c00213b8:	83 ec 08             	sub    $0x8,%esp
c00213bb:	e8 d7 c4 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00213c0:	81 c3 40 91 01 00    	add    $0x19140,%ebx
    idle_thread = thread_current();
c00213c6:	e8 e2 f9 ff ff       	call   c0020dad <thread_current>
c00213cb:	89 83 88 01 00 00    	mov    %eax,0x188(%ebx)
    sema_up(idle_started);
c00213d1:	83 ec 0c             	sub    $0xc,%esp
c00213d4:	ff 74 24 1c          	pushl  0x1c(%esp)
c00213d8:	e8 42 1a 00 00       	call   c0022e1f <sema_up>
c00213dd:	83 c4 10             	add    $0x10,%esp
        intr_disable();
c00213e0:	e8 3e 07 00 00       	call   c0021b23 <intr_disable>
        thread_block();
c00213e5:	e8 44 ff ff ff       	call   c002132e <thread_block>
        asm volatile ("sti; hlt" : : : "memory");
c00213ea:	fb                   	sti    
c00213eb:	f4                   	hlt    
c00213ec:	eb f2                	jmp    c00213e0 <idle+0x29>

c00213ee <thread_exit>:
thread_exit(void) {
c00213ee:	53                   	push   %ebx
c00213ef:	83 ec 08             	sub    $0x8,%esp
c00213f2:	e8 a0 c4 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00213f7:	81 c3 09 91 01 00    	add    $0x19109,%ebx
    ASSERT(!intr_context());
c00213fd:	e8 c7 09 00 00       	call   c0021dc9 <intr_context>
c0021402:	84 c0                	test   %al,%al
c0021404:	74 29                	je     c002142f <thread_exit+0x41>
c0021406:	83 ec 0c             	sub    $0xc,%esp
c0021409:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c002140f:	50                   	push   %eax
c0021410:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021416:	50                   	push   %eax
c0021417:	8d 83 68 34 ff ff    	lea    -0xcb98(%ebx),%eax
c002141d:	50                   	push   %eax
c002141e:	68 3e 01 00 00       	push   $0x13e
c0021423:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0021429:	50                   	push   %eax
c002142a:	e8 b5 7a 00 00       	call   c0028ee4 <debug_panic>
    intr_disable();
c002142f:	e8 ef 06 00 00       	call   c0021b23 <intr_disable>
    list_remove(&thread_current()->allelem);
c0021434:	e8 74 f9 ff ff       	call   c0020dad <thread_current>
c0021439:	83 ec 0c             	sub    $0xc,%esp
c002143c:	05 ec 00 00 00       	add    $0xec,%eax
c0021441:	50                   	push   %eax
c0021442:	e8 6c 81 00 00       	call   c00295b3 <list_remove>
    thread_current()->status = THREAD_DYING;
c0021447:	e8 61 f9 ff ff       	call   c0020dad <thread_current>
c002144c:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    schedule();
c0021453:	e8 c2 fd ff ff       	call   c002121a <schedule>
    NOT_REACHED();
c0021458:	8d 83 60 48 ff ff    	lea    -0xb7a0(%ebx),%eax
c002145e:	50                   	push   %eax
c002145f:	8d 83 68 34 ff ff    	lea    -0xcb98(%ebx),%eax
c0021465:	50                   	push   %eax
c0021466:	68 4b 01 00 00       	push   $0x14b
c002146b:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0021471:	50                   	push   %eax
c0021472:	e8 6d 7a 00 00       	call   c0028ee4 <debug_panic>

c0021477 <kernel_thread>:
kernel_thread(thread_func *function, void *aux) {
c0021477:	56                   	push   %esi
c0021478:	53                   	push   %ebx
c0021479:	83 ec 04             	sub    $0x4,%esp
c002147c:	e8 16 c4 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021481:	81 c3 7f 90 01 00    	add    $0x1907f,%ebx
c0021487:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT(function != NULL);
c002148b:	85 f6                	test   %esi,%esi
c002148d:	74 13                	je     c00214a2 <kernel_thread+0x2b>
    intr_enable();       /* The scheduler runs with interrupts off. */
c002148f:	e8 46 06 00 00       	call   c0021ada <intr_enable>
    function(aux);       /* Execute the thread function. */
c0021494:	83 ec 0c             	sub    $0xc,%esp
c0021497:	ff 74 24 20          	pushl  0x20(%esp)
c002149b:	ff d6                	call   *%esi
    thread_exit();       /* If function() returns, kill the thread. */
c002149d:	e8 4c ff ff ff       	call   c00213ee <thread_exit>
    ASSERT(function != NULL);
c00214a2:	83 ec 0c             	sub    $0xc,%esp
c00214a5:	8d 83 b8 49 ff ff    	lea    -0xb648(%ebx),%eax
c00214ab:	50                   	push   %eax
c00214ac:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00214b2:	50                   	push   %eax
c00214b3:	8d 83 bc 34 ff ff    	lea    -0xcb44(%ebx),%eax
c00214b9:	50                   	push   %eax
c00214ba:	68 f4 01 00 00       	push   $0x1f4
c00214bf:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c00214c5:	50                   	push   %eax
c00214c6:	e8 19 7a 00 00       	call   c0028ee4 <debug_panic>

c00214cb <thread_yield>:
thread_yield(void) {
c00214cb:	57                   	push   %edi
c00214cc:	56                   	push   %esi
c00214cd:	53                   	push   %ebx
c00214ce:	e8 c4 c3 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00214d3:	81 c3 2d 90 01 00    	add    $0x1902d,%ebx
    struct thread *cur = thread_current();
c00214d9:	e8 cf f8 ff ff       	call   c0020dad <thread_current>
c00214de:	89 c6                	mov    %eax,%esi
    ASSERT(!intr_context()); // int from inside
c00214e0:	e8 e4 08 00 00       	call   c0021dc9 <intr_context>
c00214e5:	84 c0                	test   %al,%al
c00214e7:	75 4a                	jne    c0021533 <thread_yield+0x68>
    old_level = intr_disable(); // interrupt to schedule
c00214e9:	e8 35 06 00 00       	call   c0021b23 <intr_disable>
c00214ee:	89 c7                	mov    %eax,%edi
    if (cur != idle_thread)
c00214f0:	39 b3 88 01 00 00    	cmp    %esi,0x188(%ebx)
c00214f6:	74 1f                	je     c0021517 <thread_yield+0x4c>
        list_insert_ordered(&ready_list, &cur->elem, (list_less_func *) &thread_cmp_priority, NULL);
c00214f8:	6a 00                	push   $0x0
c00214fa:	8d 83 f1 62 fe ff    	lea    -0x19d0f(%ebx),%eax
c0021500:	50                   	push   %eax
c0021501:	8d 86 08 01 00 00    	lea    0x108(%esi),%eax
c0021507:	50                   	push   %eax
c0021508:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c002150e:	50                   	push   %eax
c002150f:	e8 94 85 00 00       	call   c0029aa8 <list_insert_ordered>
c0021514:	83 c4 10             	add    $0x10,%esp
    cur->status = THREAD_READY;
c0021517:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
    schedule();
c002151e:	e8 f7 fc ff ff       	call   c002121a <schedule>
    intr_set_level(old_level);
c0021523:	83 ec 0c             	sub    $0xc,%esp
c0021526:	57                   	push   %edi
c0021527:	e8 fe 05 00 00       	call   c0021b2a <intr_set_level>
}
c002152c:	83 c4 10             	add    $0x10,%esp
c002152f:	5b                   	pop    %ebx
c0021530:	5e                   	pop    %esi
c0021531:	5f                   	pop    %edi
c0021532:	c3                   	ret    
    ASSERT(!intr_context()); // int from inside
c0021533:	83 ec 0c             	sub    $0xc,%esp
c0021536:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c002153c:	50                   	push   %eax
c002153d:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021543:	50                   	push   %eax
c0021544:	8d 83 58 34 ff ff    	lea    -0xcba8(%ebx),%eax
c002154a:	50                   	push   %eax
c002154b:	68 55 01 00 00       	push   $0x155
c0021550:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c0021556:	50                   	push   %eax
c0021557:	e8 88 79 00 00       	call   c0028ee4 <debug_panic>

c002155c <thread_create>:
              thread_func *function, void *aux) {
c002155c:	55                   	push   %ebp
c002155d:	57                   	push   %edi
c002155e:	56                   	push   %esi
c002155f:	53                   	push   %ebx
c0021560:	83 ec 0c             	sub    $0xc,%esp
c0021563:	e8 2f c3 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021568:	81 c3 98 8f 01 00    	add    $0x18f98,%ebx
    ASSERT(function != NULL);
c002156e:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0021573:	0f 84 01 01 00 00    	je     c002167a <thread_create+0x11e>
    t = palloc_get_page(PAL_ZERO);
c0021579:	83 ec 0c             	sub    $0xc,%esp
c002157c:	6a 02                	push   $0x2
c002157e:	e8 7f 22 00 00       	call   c0023802 <palloc_get_page>
c0021583:	89 c6                	mov    %eax,%esi
    if (t == NULL)
c0021585:	83 c4 10             	add    $0x10,%esp
c0021588:	85 c0                	test   %eax,%eax
c002158a:	0f 84 2d 01 00 00    	je     c00216bd <thread_create+0x161>
    init_thread(t, name, priority);
c0021590:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0021594:	8b 54 24 20          	mov    0x20(%esp),%edx
c0021598:	e8 a3 f4 ff ff       	call   c0020a40 <init_thread>
    lock_acquire(&tid_lock);
c002159d:	83 ec 0c             	sub    $0xc,%esp
c00215a0:	8d ab 60 01 00 00    	lea    0x160(%ebx),%ebp
c00215a6:	55                   	push   %ebp
c00215a7:	e8 76 1a 00 00       	call   c0023022 <lock_acquire>
    tid = next_tid++;
c00215ac:	8b bb bc fb ff ff    	mov    -0x444(%ebx),%edi
c00215b2:	8d 47 01             	lea    0x1(%edi),%eax
c00215b5:	89 83 bc fb ff ff    	mov    %eax,-0x444(%ebx)
    lock_release(&tid_lock);
c00215bb:	89 2c 24             	mov    %ebp,(%esp)
c00215be:	e8 60 1c 00 00       	call   c0023223 <lock_release>
    tid = t->tid = allocate_tid();
c00215c3:	89 3e                	mov    %edi,(%esi)
    if (thread_current() != NULL) {
c00215c5:	e8 e3 f7 ff ff       	call   c0020dad <thread_current>
c00215ca:	89 c5                	mov    %eax,%ebp
c00215cc:	83 c4 10             	add    $0x10,%esp
c00215cf:	85 c0                	test   %eax,%eax
c00215d1:	74 33                	je     c0021606 <thread_create+0xaa>
        t->parent = parent;
c00215d3:	89 86 dc 00 00 00    	mov    %eax,0xdc(%esi)
        struct process_info *info_t = (struct process_info *) malloc(sizeof(struct process_info));
c00215d9:	83 ec 0c             	sub    $0xc,%esp
c00215dc:	6a 18                	push   $0x18
c00215de:	e8 31 26 00 00       	call   c0023c14 <malloc>
        info_t->is_waiting = false;
c00215e3:	c6 00 00             	movb   $0x0,(%eax)
        info_t->has_exited = false;
c00215e6:	c6 40 01 00          	movb   $0x0,0x1(%eax)
        info_t->tid = tid;
c00215ea:	89 78 04             	mov    %edi,0x4(%eax)
        info_t->thread_ = t;
c00215ed:	89 70 14             	mov    %esi,0x14(%eax)
        list_push_back(&parent->child_list, &info_t->elem);
c00215f0:	83 c4 08             	add    $0x8,%esp
c00215f3:	83 c0 0c             	add    $0xc,%eax
c00215f6:	50                   	push   %eax
c00215f7:	81 c5 cc 00 00 00    	add    $0xcc,%ebp
c00215fd:	55                   	push   %ebp
c00215fe:	e8 93 7f 00 00       	call   c0029596 <list_push_back>
c0021603:	83 c4 10             	add    $0x10,%esp
    kf = alloc_frame(t, sizeof *kf);
c0021606:	ba 0c 00 00 00       	mov    $0xc,%edx
c002160b:	89 f0                	mov    %esi,%eax
c002160d:	e8 0b f3 ff ff       	call   c002091d <alloc_frame>
    kf->eip = NULL;
c0021612:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    kf->function = function;
c0021618:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c002161c:	89 48 04             	mov    %ecx,0x4(%eax)
    kf->aux = aux;
c002161f:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0021623:	89 50 08             	mov    %edx,0x8(%eax)
    ef = alloc_frame(t, sizeof *ef);
c0021626:	ba 04 00 00 00       	mov    $0x4,%edx
c002162b:	89 f0                	mov    %esi,%eax
c002162d:	e8 eb f2 ff ff       	call   c002091d <alloc_frame>
    ef->eip = (void (*)(void)) kernel_thread;
c0021632:	8d 93 77 6f fe ff    	lea    -0x19089(%ebx),%edx
c0021638:	89 10                	mov    %edx,(%eax)
    sf = alloc_frame(t, sizeof *sf);
c002163a:	ba 1c 00 00 00       	mov    $0x1c,%edx
c002163f:	89 f0                	mov    %esi,%eax
c0021641:	e8 d7 f2 ff ff       	call   c002091d <alloc_frame>
    sf->eip = switch_entry;
c0021646:	c7 c2 6d 19 02 c0    	mov    $0xc002196d,%edx
c002164c:	89 50 10             	mov    %edx,0x10(%eax)
    sf->ebp = 0;
c002164f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    thread_unblock(t);
c0021656:	83 ec 0c             	sub    $0xc,%esp
c0021659:	56                   	push   %esi
c002165a:	e8 9b f6 ff ff       	call   c0020cfa <thread_unblock>
    if (thread_current()->priority < priority) {
c002165f:	e8 49 f7 ff ff       	call   c0020dad <thread_current>
c0021664:	83 c4 10             	add    $0x10,%esp
c0021667:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002166b:	39 48 24             	cmp    %ecx,0x24(%eax)
c002166e:	7c 33                	jl     c00216a3 <thread_create+0x147>
}
c0021670:	89 f8                	mov    %edi,%eax
c0021672:	83 c4 0c             	add    $0xc,%esp
c0021675:	5b                   	pop    %ebx
c0021676:	5e                   	pop    %esi
c0021677:	5f                   	pop    %edi
c0021678:	5d                   	pop    %ebp
c0021679:	c3                   	ret    
    ASSERT(function != NULL);
c002167a:	83 ec 0c             	sub    $0xc,%esp
c002167d:	8d 83 b8 49 ff ff    	lea    -0xb648(%ebx),%eax
c0021683:	50                   	push   %eax
c0021684:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002168a:	50                   	push   %eax
c002168b:	8d 83 cc 34 ff ff    	lea    -0xcb34(%ebx),%eax
c0021691:	50                   	push   %eax
c0021692:	68 ba 00 00 00       	push   $0xba
c0021697:	8d 83 e3 48 ff ff    	lea    -0xb71d(%ebx),%eax
c002169d:	50                   	push   %eax
c002169e:	e8 41 78 00 00       	call   c0028ee4 <debug_panic>
        enum intr_level old_level = intr_disable();
c00216a3:	e8 7b 04 00 00       	call   c0021b23 <intr_disable>
c00216a8:	89 c6                	mov    %eax,%esi
        thread_yield();
c00216aa:	e8 1c fe ff ff       	call   c00214cb <thread_yield>
        intr_set_level(old_level);
c00216af:	83 ec 0c             	sub    $0xc,%esp
c00216b2:	56                   	push   %esi
c00216b3:	e8 72 04 00 00       	call   c0021b2a <intr_set_level>
c00216b8:	83 c4 10             	add    $0x10,%esp
c00216bb:	eb b3                	jmp    c0021670 <thread_create+0x114>
        return TID_ERROR;
c00216bd:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c00216c2:	eb ac                	jmp    c0021670 <thread_create+0x114>

c00216c4 <thread_start>:
thread_start(void) {
c00216c4:	56                   	push   %esi
c00216c5:	53                   	push   %ebx
c00216c6:	83 ec 2c             	sub    $0x2c,%esp
c00216c9:	e8 c9 c1 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00216ce:	81 c3 32 8e 01 00    	add    $0x18e32,%ebx
    sema_init(&idle_started, 0);
c00216d4:	6a 00                	push   $0x0
c00216d6:	8d 74 24 18          	lea    0x18(%esp),%esi
c00216da:	56                   	push   %esi
c00216db:	e8 c0 15 00 00       	call   c0022ca0 <sema_init>
    thread_create("idle", PRI_MIN, idle, &idle_started);
c00216e0:	56                   	push   %esi
c00216e1:	8d 83 b7 6e fe ff    	lea    -0x19149(%ebx),%eax
c00216e7:	50                   	push   %eax
c00216e8:	6a 00                	push   $0x0
c00216ea:	8d 83 c9 49 ff ff    	lea    -0xb637(%ebx),%eax
c00216f0:	50                   	push   %eax
c00216f1:	e8 66 fe ff ff       	call   c002155c <thread_create>
    intr_enable();
c00216f6:	83 c4 20             	add    $0x20,%esp
c00216f9:	e8 dc 03 00 00       	call   c0021ada <intr_enable>
    sema_down(&idle_started);
c00216fe:	83 ec 0c             	sub    $0xc,%esp
c0021701:	56                   	push   %esi
c0021702:	e8 ed 15 00 00       	call   c0022cf4 <sema_down>
}
c0021707:	83 c4 34             	add    $0x34,%esp
c002170a:	5b                   	pop    %ebx
c002170b:	5e                   	pop    %esi
c002170c:	c3                   	ret    

c002170d <thread_set_priority>:
thread_set_priority(int new_priority) {
c002170d:	55                   	push   %ebp
c002170e:	57                   	push   %edi
c002170f:	56                   	push   %esi
c0021710:	53                   	push   %ebx
c0021711:	83 ec 0c             	sub    $0xc,%esp
c0021714:	e8 7e c1 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021719:	81 c3 e7 8d 01 00    	add    $0x18de7,%ebx
    struct thread *cur = thread_current();
c002171f:	e8 89 f6 ff ff       	call   c0020dad <thread_current>
c0021724:	89 c6                	mov    %eax,%esi
    if (thread_mlfqs) {
c0021726:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002172c:	80 38 00             	cmpb   $0x0,(%eax)
c002172f:	75 4d                	jne    c002177e <thread_set_priority+0x71>
    enum intr_level old_level = intr_disable();
c0021731:	e8 ed 03 00 00       	call   c0021b23 <intr_disable>
c0021736:	89 c7                	mov    %eax,%edi
    int old_priority = cur->priority;
c0021738:	8b 6e 24             	mov    0x24(%esi),%ebp
    cur->original_priority = new_priority;
c002173b:	8b 44 24 20          	mov    0x20(%esp),%eax
c002173f:	89 46 28             	mov    %eax,0x28(%esi)
    if (list_empty(&cur->lock_list) || new_priority > old_priority) {
c0021742:	83 ec 0c             	sub    $0xc,%esp
c0021745:	8d 86 f4 00 00 00    	lea    0xf4(%esi),%eax
c002174b:	50                   	push   %eax
c002174c:	e8 04 7f 00 00       	call   c0029655 <list_empty>
c0021751:	83 c4 10             	add    $0x10,%esp
c0021754:	3b 6c 24 20          	cmp    0x20(%esp),%ebp
c0021758:	7c 04                	jl     c002175e <thread_set_priority+0x51>
c002175a:	84 c0                	test   %al,%al
c002175c:	74 0c                	je     c002176a <thread_set_priority+0x5d>
        cur->priority = new_priority;
c002175e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0021762:	89 46 24             	mov    %eax,0x24(%esi)
        thread_yield();
c0021765:	e8 61 fd ff ff       	call   c00214cb <thread_yield>
    intr_set_level(old_level);
c002176a:	83 ec 0c             	sub    $0xc,%esp
c002176d:	57                   	push   %edi
c002176e:	e8 b7 03 00 00       	call   c0021b2a <intr_set_level>
c0021773:	83 c4 10             	add    $0x10,%esp
}
c0021776:	83 c4 0c             	add    $0xc,%esp
c0021779:	5b                   	pop    %ebx
c002177a:	5e                   	pop    %esi
c002177b:	5f                   	pop    %edi
c002177c:	5d                   	pop    %ebp
c002177d:	c3                   	ret    
        printf("\n\n !!!mlfqs should not set priority\n\n\n");
c002177e:	83 ec 0c             	sub    $0xc,%esp
c0021781:	8d 83 84 48 ff ff    	lea    -0xb77c(%ebx),%eax
c0021787:	50                   	push   %eax
c0021788:	e8 78 96 00 00       	call   c002ae05 <puts>
        return;
c002178d:	83 c4 10             	add    $0x10,%esp
c0021790:	eb e4                	jmp    c0021776 <thread_set_priority+0x69>

c0021792 <thread_set_nice>:
thread_set_nice(int new_nice) {
c0021792:	56                   	push   %esi
c0021793:	53                   	push   %ebx
c0021794:	83 ec 04             	sub    $0x4,%esp
c0021797:	e8 fb c0 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002179c:	81 c3 64 8d 01 00    	add    $0x18d64,%ebx
    struct thread *cur = thread_current();
c00217a2:	e8 06 f6 ff ff       	call   c0020dad <thread_current>
    cur->nice = new_nice;
c00217a7:	8b 54 24 10          	mov    0x10(%esp),%edx
c00217ab:	89 50 1c             	mov    %edx,0x1c(%eax)
    update_thread_priority_mlfqs(cur, NULL);
c00217ae:	83 ec 08             	sub    $0x8,%esp
c00217b1:	6a 00                	push   $0x0
c00217b3:	50                   	push   %eax
c00217b4:	e8 e9 f1 ff ff       	call   c00209a2 <update_thread_priority_mlfqs>
    enum intr_level old_level = intr_disable();
c00217b9:	e8 65 03 00 00       	call   c0021b23 <intr_disable>
c00217be:	89 c6                	mov    %eax,%esi
    thread_yield();
c00217c0:	e8 06 fd ff ff       	call   c00214cb <thread_yield>
    intr_set_level(old_level);
c00217c5:	89 34 24             	mov    %esi,(%esp)
c00217c8:	e8 5d 03 00 00       	call   c0021b2a <intr_set_level>
}
c00217cd:	83 c4 14             	add    $0x14,%esp
c00217d0:	5b                   	pop    %ebx
c00217d1:	5e                   	pop    %esi
c00217d2:	c3                   	ret    

c00217d3 <thread_update_priority>:


void
thread_update_priority(struct thread *t) {
c00217d3:	55                   	push   %ebp
c00217d4:	57                   	push   %edi
c00217d5:	56                   	push   %esi
c00217d6:	53                   	push   %ebx
c00217d7:	83 ec 1c             	sub    $0x1c,%esp
c00217da:	e8 b8 c0 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00217df:	81 c3 21 8d 01 00    	add    $0x18d21,%ebx
c00217e5:	8b 74 24 30          	mov    0x30(%esp),%esi
    enum intr_level old_level = intr_disable();
c00217e9:	e8 35 03 00 00       	call   c0021b23 <intr_disable>
c00217ee:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int max_priority = t->original_priority;
c00217f2:	8b 7e 28             	mov    0x28(%esi),%edi
    int lock_priority;

    if (!list_empty(&t->lock_list)) {
c00217f5:	8d ae f4 00 00 00    	lea    0xf4(%esi),%ebp
c00217fb:	83 ec 0c             	sub    $0xc,%esp
c00217fe:	55                   	push   %ebp
c00217ff:	e8 51 7e 00 00       	call   c0029655 <list_empty>
c0021804:	83 c4 10             	add    $0x10,%esp
c0021807:	84 c0                	test   %al,%al
c0021809:	74 17                	je     c0021822 <thread_update_priority+0x4f>
        lock_priority = list_entry (list_front(&t->lock_list), struct lock, elem)->max_priority;
        if (lock_priority > max_priority)
            max_priority = lock_priority;
    }

    t->priority = max_priority;
c002180b:	89 7e 24             	mov    %edi,0x24(%esi)
    intr_set_level(old_level);
c002180e:	83 ec 0c             	sub    $0xc,%esp
c0021811:	ff 74 24 18          	pushl  0x18(%esp)
c0021815:	e8 10 03 00 00       	call   c0021b2a <intr_set_level>
}
c002181a:	83 c4 2c             	add    $0x2c,%esp
c002181d:	5b                   	pop    %ebx
c002181e:	5e                   	pop    %esi
c002181f:	5f                   	pop    %edi
c0021820:	5d                   	pop    %ebp
c0021821:	c3                   	ret    
        list_sort(&t->lock_list, lock_cmp_priority, NULL);
c0021822:	83 ec 04             	sub    $0x4,%esp
c0021825:	6a 00                	push   $0x0
c0021827:	8d 83 09 63 fe ff    	lea    -0x19cf7(%ebx),%eax
c002182d:	50                   	push   %eax
c002182e:	55                   	push   %ebp
c002182f:	e8 87 7f 00 00       	call   c00297bb <list_sort>
        lock_priority = list_entry (list_front(&t->lock_list), struct lock, elem)->max_priority;
c0021834:	89 2c 24             	mov    %ebp,(%esp)
c0021837:	e8 3d 7e 00 00       	call   c0029679 <list_front>
        if (lock_priority > max_priority)
c002183c:	8b 40 08             	mov    0x8(%eax),%eax
c002183f:	83 c4 10             	add    $0x10,%esp
c0021842:	39 c7                	cmp    %eax,%edi
c0021844:	0f 4c f8             	cmovl  %eax,%edi
c0021847:	eb c2                	jmp    c002180b <thread_update_priority+0x38>

c0021849 <thread_donate_priority>:


/* Donate current priority to thread t. */
void
thread_donate_priority(struct thread *t) {
c0021849:	57                   	push   %edi
c002184a:	56                   	push   %esi
c002184b:	53                   	push   %ebx
c002184c:	e8 46 c0 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021851:	81 c3 af 8c 01 00    	add    $0x18caf,%ebx
c0021857:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c002185b:	e8 c3 02 00 00       	call   c0021b23 <intr_disable>
c0021860:	89 c7                	mov    %eax,%edi
    thread_update_priority(t);
c0021862:	83 ec 0c             	sub    $0xc,%esp
c0021865:	56                   	push   %esi
c0021866:	e8 68 ff ff ff       	call   c00217d3 <thread_update_priority>

    if (t->status == THREAD_READY) {
c002186b:	83 c4 10             	add    $0x10,%esp
c002186e:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
c0021872:	74 10                	je     c0021884 <thread_donate_priority+0x3b>
        list_remove(&t->elem);
        list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
    }
    intr_set_level(old_level);
c0021874:	83 ec 0c             	sub    $0xc,%esp
c0021877:	57                   	push   %edi
c0021878:	e8 ad 02 00 00       	call   c0021b2a <intr_set_level>
}
c002187d:	83 c4 10             	add    $0x10,%esp
c0021880:	5b                   	pop    %ebx
c0021881:	5e                   	pop    %esi
c0021882:	5f                   	pop    %edi
c0021883:	c3                   	ret    
        list_remove(&t->elem);
c0021884:	81 c6 08 01 00 00    	add    $0x108,%esi
c002188a:	83 ec 0c             	sub    $0xc,%esp
c002188d:	56                   	push   %esi
c002188e:	e8 20 7d 00 00       	call   c00295b3 <list_remove>
        list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
c0021893:	6a 00                	push   $0x0
c0021895:	8d 83 f1 62 fe ff    	lea    -0x19d0f(%ebx),%eax
c002189b:	50                   	push   %eax
c002189c:	56                   	push   %esi
c002189d:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c00218a3:	50                   	push   %eax
c00218a4:	e8 ff 81 00 00       	call   c0029aa8 <list_insert_ordered>
c00218a9:	83 c4 20             	add    $0x20,%esp
c00218ac:	eb c6                	jmp    c0021874 <thread_donate_priority+0x2b>

c00218ae <thread_remove_lock>:

void thread_remove_lock(struct lock *lock) {
c00218ae:	56                   	push   %esi
c00218af:	53                   	push   %ebx
c00218b0:	83 ec 04             	sub    $0x4,%esp
c00218b3:	e8 df bf 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00218b8:	81 c3 48 8c 01 00    	add    $0x18c48,%ebx
    enum intr_level old_level = intr_disable();
c00218be:	e8 60 02 00 00       	call   c0021b23 <intr_disable>
c00218c3:	89 c6                	mov    %eax,%esi
    list_remove(&lock->elem);
c00218c5:	83 ec 0c             	sub    $0xc,%esp
c00218c8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00218cc:	83 c0 18             	add    $0x18,%eax
c00218cf:	50                   	push   %eax
c00218d0:	e8 de 7c 00 00       	call   c00295b3 <list_remove>
    thread_update_priority(thread_current());
c00218d5:	e8 d3 f4 ff ff       	call   c0020dad <thread_current>
c00218da:	89 04 24             	mov    %eax,(%esp)
c00218dd:	e8 f1 fe ff ff       	call   c00217d3 <thread_update_priority>
    intr_set_level(old_level);
c00218e2:	89 34 24             	mov    %esi,(%esp)
c00218e5:	e8 40 02 00 00       	call   c0021b2a <intr_set_level>
}
c00218ea:	83 c4 14             	add    $0x14,%esp
c00218ed:	5b                   	pop    %ebx
c00218ee:	5e                   	pop    %esi
c00218ef:	c3                   	ret    

c00218f0 <thread_hold_the_lock>:

void thread_hold_the_lock(struct lock *lock) {
c00218f0:	57                   	push   %edi
c00218f1:	56                   	push   %esi
c00218f2:	53                   	push   %ebx
c00218f3:	e8 9f bf 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00218f8:	81 c3 08 8c 01 00    	add    $0x18c08,%ebx
c00218fe:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0021902:	e8 1c 02 00 00       	call   c0021b23 <intr_disable>
c0021907:	89 c7                	mov    %eax,%edi
    list_insert_ordered(&thread_current()->lock_list, &lock->elem, lock_cmp_priority, NULL);
c0021909:	e8 9f f4 ff ff       	call   c0020dad <thread_current>
c002190e:	6a 00                	push   $0x0
c0021910:	8d 93 09 63 fe ff    	lea    -0x19cf7(%ebx),%edx
c0021916:	52                   	push   %edx
c0021917:	8d 56 18             	lea    0x18(%esi),%edx
c002191a:	52                   	push   %edx
c002191b:	05 f4 00 00 00       	add    $0xf4,%eax
c0021920:	50                   	push   %eax
c0021921:	e8 82 81 00 00       	call   c0029aa8 <list_insert_ordered>

    if (lock->max_priority > thread_current()->priority) {
c0021926:	8b 76 20             	mov    0x20(%esi),%esi
c0021929:	e8 7f f4 ff ff       	call   c0020dad <thread_current>
c002192e:	83 c4 10             	add    $0x10,%esp
c0021931:	3b 70 24             	cmp    0x24(%eax),%esi
c0021934:	7f 10                	jg     c0021946 <thread_hold_the_lock+0x56>
        thread_current()->priority = lock->max_priority;
        thread_yield();
    }

    intr_set_level(old_level);
c0021936:	83 ec 0c             	sub    $0xc,%esp
c0021939:	57                   	push   %edi
c002193a:	e8 eb 01 00 00       	call   c0021b2a <intr_set_level>
}
c002193f:	83 c4 10             	add    $0x10,%esp
c0021942:	5b                   	pop    %ebx
c0021943:	5e                   	pop    %esi
c0021944:	5f                   	pop    %edi
c0021945:	c3                   	ret    
        thread_current()->priority = lock->max_priority;
c0021946:	89 70 24             	mov    %esi,0x24(%eax)
        thread_yield();
c0021949:	e8 7d fb ff ff       	call   c00214cb <thread_yield>
c002194e:	eb e6                	jmp    c0021936 <thread_hold_the_lock+0x46>

c0021950 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021950:	53                   	push   %ebx
	pushl %ebp
c0021951:	55                   	push   %ebp
	pushl %esi
c0021952:	56                   	push   %esi
	pushl %edi
c0021953:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021954:	8b 15 c0 a0 03 c0    	mov    0xc003a0c0,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c002195a:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c002195e:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021961:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021965:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021968:	5f                   	pop    %edi
	popl %esi
c0021969:	5e                   	pop    %esi
	popl %ebp
c002196a:	5d                   	pop    %ebp
	popl %ebx
c002196b:	5b                   	pop    %ebx
        ret
c002196c:	c3                   	ret    

c002196d <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c002196d:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021970:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021971:	e8 f6 f7 ff ff       	call   c002116c <thread_schedule_tail>
	addl $4, %esp
c0021976:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021979:	c3                   	ret    

c002197a <make_gate>:
   trap gate).  The difference is that entering an interrupt gate
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate(void (*function)(void), int dpl, int type) {
c002197a:	53                   	push   %ebx
c002197b:	83 ec 08             	sub    $0x8,%esp
c002197e:	e8 14 bf 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021983:	81 c3 7d 8b 01 00    	add    $0x18b7d,%ebx
    uint32_t e0, e1;

    ASSERT (function != NULL);
c0021989:	85 c0                	test   %eax,%eax
c002198b:	74 2c                	je     c00219b9 <make_gate+0x3f>
    ASSERT (dpl >= 0 && dpl <= 3);
c002198d:	83 fa 03             	cmp    $0x3,%edx
c0021990:	77 50                	ja     c00219e2 <make_gate+0x68>
    ASSERT (type >= 0 && type <= 15);
c0021992:	83 f9 0f             	cmp    $0xf,%ecx
c0021995:	77 74                	ja     c0021a0b <make_gate+0x91>

    e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
          | (SEL_KCSEG << 16));              /* Target code segment. */

    e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021997:	89 c3                	mov    %eax,%ebx
c0021999:	66 bb 00 00          	mov    $0x0,%bx
          | (1 << 15)                        /* Present. */
          | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
          | (0 << 12)                        /* System. */
          | ((uint32_t) type << 8));         /* Gate type. */
c002199d:	c1 e1 08             	shl    $0x8,%ecx
c00219a0:	09 cb                	or     %ecx,%ebx
          | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c00219a2:	c1 e2 0d             	shl    $0xd,%edx
          | ((uint32_t) type << 8));         /* Gate type. */
c00219a5:	09 d3                	or     %edx,%ebx
    e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00219a7:	89 da                	mov    %ebx,%edx
c00219a9:	80 ce 80             	or     $0x80,%dh
    e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c00219ac:	0f b7 c0             	movzwl %ax,%eax
c00219af:	0d 00 00 08 00       	or     $0x80000,%eax

    return e0 | ((uint64_t) e1 << 32);
}
c00219b4:	83 c4 08             	add    $0x8,%esp
c00219b7:	5b                   	pop    %ebx
c00219b8:	c3                   	ret    
    ASSERT (function != NULL);
c00219b9:	83 ec 0c             	sub    $0xc,%esp
c00219bc:	8d 83 b8 49 ff ff    	lea    -0xb648(%ebx),%eax
c00219c2:	50                   	push   %eax
c00219c3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00219c9:	50                   	push   %eax
c00219ca:	8d 83 78 35 ff ff    	lea    -0xca88(%ebx),%eax
c00219d0:	50                   	push   %eax
c00219d1:	68 1d 01 00 00       	push   $0x11d
c00219d6:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c00219dc:	50                   	push   %eax
c00219dd:	e8 02 75 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (dpl >= 0 && dpl <= 3);
c00219e2:	83 ec 0c             	sub    $0xc,%esp
c00219e5:	8d 83 e8 49 ff ff    	lea    -0xb618(%ebx),%eax
c00219eb:	50                   	push   %eax
c00219ec:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00219f2:	50                   	push   %eax
c00219f3:	8d 83 78 35 ff ff    	lea    -0xca88(%ebx),%eax
c00219f9:	50                   	push   %eax
c00219fa:	68 1e 01 00 00       	push   $0x11e
c00219ff:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021a05:	50                   	push   %eax
c0021a06:	e8 d9 74 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (type >= 0 && type <= 15);
c0021a0b:	83 ec 0c             	sub    $0xc,%esp
c0021a0e:	8d 83 fd 49 ff ff    	lea    -0xb603(%ebx),%eax
c0021a14:	50                   	push   %eax
c0021a15:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021a1b:	50                   	push   %eax
c0021a1c:	8d 83 78 35 ff ff    	lea    -0xca88(%ebx),%eax
c0021a22:	50                   	push   %eax
c0021a23:	68 1f 01 00 00       	push   $0x11f
c0021a28:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021a2e:	50                   	push   %eax
c0021a2f:	e8 b0 74 00 00       	call   c0028ee4 <debug_panic>

c0021a34 <register_handler>:
                 intr_handler_func *handler, const char *name) {
c0021a34:	56                   	push   %esi
c0021a35:	53                   	push   %ebx
c0021a36:	83 ec 04             	sub    $0x4,%esp
c0021a39:	e8 59 be 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021a3e:	81 c3 c2 8a 01 00    	add    $0x18ac2,%ebx
    ASSERT (intr_handlers[vec_no] == NULL);
c0021a44:	0f b6 f0             	movzbl %al,%esi
c0021a47:	83 bc b3 e0 09 00 00 	cmpl   $0x0,0x9e0(%ebx,%esi,4)
c0021a4e:	00 
c0021a4f:	75 42                	jne    c0021a93 <register_handler+0x5f>
    if (level == INTR_ON)
c0021a51:	83 f9 01             	cmp    $0x1,%ecx
c0021a54:	74 66                	je     c0021abc <register_handler+0x88>
        idt[vec_no] = make_intr_gate(intr_stubs[vec_no], dpl);
c0021a56:	c7 c0 c4 a0 03 c0    	mov    $0xc003a0c4,%eax

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate(void (*function)(void), int dpl) {
    return make_gate(function, dpl, 14);
c0021a5c:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021a5f:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021a64:	e8 11 ff ff ff       	call   c002197a <make_gate>
c0021a69:	89 84 f3 e0 0d 00 00 	mov    %eax,0xde0(%ebx,%esi,8)
c0021a70:	89 94 f3 e4 0d 00 00 	mov    %edx,0xde4(%ebx,%esi,8)
    intr_handlers[vec_no] = handler;
c0021a77:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021a7b:	89 84 b3 e0 09 00 00 	mov    %eax,0x9e0(%ebx,%esi,4)
    intr_names[vec_no] = name;
c0021a82:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021a86:	89 84 b3 e0 05 00 00 	mov    %eax,0x5e0(%ebx,%esi,4)
}
c0021a8d:	83 c4 04             	add    $0x4,%esp
c0021a90:	5b                   	pop    %ebx
c0021a91:	5e                   	pop    %esi
c0021a92:	c3                   	ret    
    ASSERT (intr_handlers[vec_no] == NULL);
c0021a93:	83 ec 0c             	sub    $0xc,%esp
c0021a96:	8d 83 15 4a ff ff    	lea    -0xb5eb(%ebx),%eax
c0021a9c:	50                   	push   %eax
c0021a9d:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021aa3:	50                   	push   %eax
c0021aa4:	8d 83 50 35 ff ff    	lea    -0xcab0(%ebx),%eax
c0021aaa:	50                   	push   %eax
c0021aab:	68 a2 00 00 00       	push   $0xa2
c0021ab0:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021ab6:	50                   	push   %eax
c0021ab7:	e8 28 74 00 00       	call   c0028ee4 <debug_panic>
        idt[vec_no] = make_trap_gate(intr_stubs[vec_no], dpl);
c0021abc:	c7 c0 c4 a0 03 c0    	mov    $0xc003a0c4,%eax

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate(void (*function)(void), int dpl) {
    return make_gate(function, dpl, 15);
c0021ac2:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021ac5:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021aca:	e8 ab fe ff ff       	call   c002197a <make_gate>
c0021acf:	eb 98                	jmp    c0021a69 <register_handler+0x35>

c0021ad1 <intr_get_level>:
    asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021ad1:	9c                   	pushf  
c0021ad2:	58                   	pop    %eax
    return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021ad3:	c1 e8 09             	shr    $0x9,%eax
c0021ad6:	83 e0 01             	and    $0x1,%eax
}
c0021ad9:	c3                   	ret    

c0021ada <intr_enable>:
intr_enable(void) {
c0021ada:	53                   	push   %ebx
c0021adb:	83 ec 08             	sub    $0x8,%esp
c0021ade:	e8 b4 bd 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021ae3:	81 c3 1d 8a 01 00    	add    $0x18a1d,%ebx
    enum intr_level old_level = intr_get_level();
c0021ae9:	e8 e3 ff ff ff       	call   c0021ad1 <intr_get_level>
    ASSERT (!intr_context());
c0021aee:	80 bb c1 01 00 00 00 	cmpb   $0x0,0x1c1(%ebx)
c0021af5:	75 06                	jne    c0021afd <intr_enable+0x23>
    asm volatile ("sti");
c0021af7:	fb                   	sti    
}
c0021af8:	83 c4 08             	add    $0x8,%esp
c0021afb:	5b                   	pop    %ebx
c0021afc:	c3                   	ret    
    ASSERT (!intr_context());
c0021afd:	83 ec 0c             	sub    $0xc,%esp
c0021b00:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c0021b06:	50                   	push   %eax
c0021b07:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021b0d:	50                   	push   %eax
c0021b0e:	8d 83 84 35 ff ff    	lea    -0xca7c(%ebx),%eax
c0021b14:	50                   	push   %eax
c0021b15:	6a 5e                	push   $0x5e
c0021b17:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021b1d:	50                   	push   %eax
c0021b1e:	e8 c1 73 00 00       	call   c0028ee4 <debug_panic>

c0021b23 <intr_disable>:
    enum intr_level old_level = intr_get_level();
c0021b23:	e8 a9 ff ff ff       	call   c0021ad1 <intr_get_level>
    asm volatile ("cli" : : : "memory"); // clear interrupt
c0021b28:	fa                   	cli    
}
c0021b29:	c3                   	ret    

c0021b2a <intr_set_level>:
intr_set_level(enum intr_level level) {
c0021b2a:	83 ec 0c             	sub    $0xc,%esp
    return level == INTR_ON ? intr_enable() : intr_disable();
c0021b2d:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021b32:	74 09                	je     c0021b3d <intr_set_level+0x13>
c0021b34:	e8 ea ff ff ff       	call   c0021b23 <intr_disable>
}
c0021b39:	83 c4 0c             	add    $0xc,%esp
c0021b3c:	c3                   	ret    
    return level == INTR_ON ? intr_enable() : intr_disable();
c0021b3d:	e8 98 ff ff ff       	call   c0021ada <intr_enable>
c0021b42:	eb f5                	jmp    c0021b39 <intr_set_level+0xf>

c0021b44 <intr_init>:
intr_init(void) {
c0021b44:	55                   	push   %ebp
c0021b45:	57                   	push   %edi
c0021b46:	56                   	push   %esi
c0021b47:	53                   	push   %ebx
c0021b48:	83 ec 2c             	sub    $0x2c,%esp
c0021b4b:	e8 4f bd 00 00       	call   c002d89f <__x86.get_pc_thunk.bp>
c0021b50:	81 c5 b0 89 01 00    	add    $0x189b0,%ebp

/* Writes byte DATA to PORT. */
static inline void
outb(uint16_t port, uint8_t data) {
    /* See [IA32-v2b] "OUT". */
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021b56:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0021b5b:	e6 21                	out    %al,$0x21
c0021b5d:	e6 a1                	out    %al,$0xa1
c0021b5f:	b9 11 00 00 00       	mov    $0x11,%ecx
c0021b64:	89 c8                	mov    %ecx,%eax
c0021b66:	e6 20                	out    %al,$0x20
c0021b68:	b8 20 00 00 00       	mov    $0x20,%eax
c0021b6d:	e6 21                	out    %al,$0x21
c0021b6f:	b8 04 00 00 00       	mov    $0x4,%eax
c0021b74:	e6 21                	out    %al,$0x21
c0021b76:	ba 01 00 00 00       	mov    $0x1,%edx
c0021b7b:	89 d0                	mov    %edx,%eax
c0021b7d:	e6 21                	out    %al,$0x21
c0021b7f:	89 c8                	mov    %ecx,%eax
c0021b81:	e6 a0                	out    %al,$0xa0
c0021b83:	b8 28 00 00 00       	mov    $0x28,%eax
c0021b88:	e6 a1                	out    %al,$0xa1
c0021b8a:	b8 02 00 00 00       	mov    $0x2,%eax
c0021b8f:	e6 a1                	out    %al,$0xa1
c0021b91:	89 d0                	mov    %edx,%eax
c0021b93:	e6 a1                	out    %al,$0xa1
c0021b95:	b8 00 00 00 00       	mov    $0x0,%eax
c0021b9a:	e6 21                	out    %al,$0x21
c0021b9c:	e6 a1                	out    %al,$0xa1
c0021b9e:	c7 c3 c4 a0 03 c0    	mov    $0xc003a0c4,%ebx
c0021ba4:	8d 85 e0 0d 00 00    	lea    0xde0(%ebp),%eax
c0021baa:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0021bae:	8d bb 00 04 00 00    	lea    0x400(%ebx),%edi
c0021bb4:	89 c6                	mov    %eax,%esi
    return make_gate(function, dpl, 14);
c0021bb6:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021bbb:	ba 00 00 00 00       	mov    $0x0,%edx
c0021bc0:	8b 03                	mov    (%ebx),%eax
c0021bc2:	e8 b3 fd ff ff       	call   c002197a <make_gate>
        idt[i] = make_intr_gate(intr_stubs[i], 0);
c0021bc7:	89 06                	mov    %eax,(%esi)
c0021bc9:	89 56 04             	mov    %edx,0x4(%esi)
c0021bcc:	83 c3 04             	add    $0x4,%ebx
c0021bcf:	83 c6 08             	add    $0x8,%esi
    for (i = 0; i < INTR_CNT; i++)
c0021bd2:	39 fb                	cmp    %edi,%ebx
c0021bd4:	75 e0                	jne    c0021bb6 <intr_init+0x72>

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand(uint16_t limit, void *base) {
    return limit | ((uint64_t) (uint32_t) base << 16);
c0021bd6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0021bda:	ba 00 00 00 00       	mov    $0x0,%edx
c0021bdf:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021be3:	c1 e0 10             	shl    $0x10,%eax
c0021be6:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021beb:	89 44 24 18          	mov    %eax,0x18(%esp)
c0021bef:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021bf3:	0f 01 5c 24 18       	lidtl  0x18(%esp)
    for (i = 0; i < INTR_CNT; i++)
c0021bf8:	8d 85 e0 05 00 00    	lea    0x5e0(%ebp),%eax
c0021bfe:	8d 8d e0 09 00 00    	lea    0x9e0(%ebp),%ecx
        intr_names[i] = "unknown";
c0021c04:	8d 95 33 4a ff ff    	lea    -0xb5cd(%ebp),%edx
c0021c0a:	89 10                	mov    %edx,(%eax)
c0021c0c:	83 c0 04             	add    $0x4,%eax
    for (i = 0; i < INTR_CNT; i++)
c0021c0f:	39 c1                	cmp    %eax,%ecx
c0021c11:	75 f7                	jne    c0021c0a <intr_init+0xc6>
    intr_names[0] = "#DE Divide Error";
c0021c13:	8d 85 3b 4a ff ff    	lea    -0xb5c5(%ebp),%eax
c0021c19:	89 85 e0 05 00 00    	mov    %eax,0x5e0(%ebp)
    intr_names[1] = "#DB Debug Exception";
c0021c1f:	8d 85 4c 4a ff ff    	lea    -0xb5b4(%ebp),%eax
c0021c25:	89 85 e4 05 00 00    	mov    %eax,0x5e4(%ebp)
    intr_names[2] = "NMI Interrupt";
c0021c2b:	8d 85 60 4a ff ff    	lea    -0xb5a0(%ebp),%eax
c0021c31:	89 85 e8 05 00 00    	mov    %eax,0x5e8(%ebp)
    intr_names[3] = "#BP Breakpoint Exception";
c0021c37:	8d 85 6e 4a ff ff    	lea    -0xb592(%ebp),%eax
c0021c3d:	89 85 ec 05 00 00    	mov    %eax,0x5ec(%ebp)
    intr_names[4] = "#OF Overflow Exception";
c0021c43:	8d 85 87 4a ff ff    	lea    -0xb579(%ebp),%eax
c0021c49:	89 85 f0 05 00 00    	mov    %eax,0x5f0(%ebp)
    intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021c4f:	8d 85 c4 4b ff ff    	lea    -0xb43c(%ebp),%eax
c0021c55:	89 85 f4 05 00 00    	mov    %eax,0x5f4(%ebp)
    intr_names[6] = "#UD Invalid Opcode Exception";
c0021c5b:	8d 85 9e 4a ff ff    	lea    -0xb562(%ebp),%eax
c0021c61:	89 85 f8 05 00 00    	mov    %eax,0x5f8(%ebp)
    intr_names[7] = "#NM Device Not Available Exception";
c0021c67:	8d 85 e8 4b ff ff    	lea    -0xb418(%ebp),%eax
c0021c6d:	89 85 fc 05 00 00    	mov    %eax,0x5fc(%ebp)
    intr_names[8] = "#DF Double Fault Exception";
c0021c73:	8d 85 bb 4a ff ff    	lea    -0xb545(%ebp),%eax
c0021c79:	89 85 00 06 00 00    	mov    %eax,0x600(%ebp)
    intr_names[9] = "Coprocessor Segment Overrun";
c0021c7f:	8d 85 d6 4a ff ff    	lea    -0xb52a(%ebp),%eax
c0021c85:	89 85 04 06 00 00    	mov    %eax,0x604(%ebp)
    intr_names[10] = "#TS Invalid TSS Exception";
c0021c8b:	8d 85 f2 4a ff ff    	lea    -0xb50e(%ebp),%eax
c0021c91:	89 85 08 06 00 00    	mov    %eax,0x608(%ebp)
    intr_names[11] = "#NP Segment Not Present";
c0021c97:	8d 85 0c 4b ff ff    	lea    -0xb4f4(%ebp),%eax
c0021c9d:	89 85 0c 06 00 00    	mov    %eax,0x60c(%ebp)
    intr_names[12] = "#SS Stack Fault Exception";
c0021ca3:	8d 85 24 4b ff ff    	lea    -0xb4dc(%ebp),%eax
c0021ca9:	89 85 10 06 00 00    	mov    %eax,0x610(%ebp)
    intr_names[13] = "#GP General Protection Exception";
c0021caf:	8d 85 0c 4c ff ff    	lea    -0xb3f4(%ebp),%eax
c0021cb5:	89 85 14 06 00 00    	mov    %eax,0x614(%ebp)
    intr_names[14] = "#PF Page-Fault Exception";
c0021cbb:	8d 85 3e 4b ff ff    	lea    -0xb4c2(%ebp),%eax
c0021cc1:	89 85 18 06 00 00    	mov    %eax,0x618(%ebp)
    intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021cc7:	8d 85 30 4c ff ff    	lea    -0xb3d0(%ebp),%eax
c0021ccd:	89 85 20 06 00 00    	mov    %eax,0x620(%ebp)
    intr_names[17] = "#AC Alignment Check Exception";
c0021cd3:	8d 85 57 4b ff ff    	lea    -0xb4a9(%ebp),%eax
c0021cd9:	89 85 24 06 00 00    	mov    %eax,0x624(%ebp)
    intr_names[18] = "#MC Machine-Check Exception";
c0021cdf:	8d 85 75 4b ff ff    	lea    -0xb48b(%ebp),%eax
c0021ce5:	89 85 28 06 00 00    	mov    %eax,0x628(%ebp)
    intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021ceb:	8d 85 54 4c ff ff    	lea    -0xb3ac(%ebp),%eax
c0021cf1:	89 85 2c 06 00 00    	mov    %eax,0x62c(%ebp)
}
c0021cf7:	83 c4 2c             	add    $0x2c,%esp
c0021cfa:	5b                   	pop    %ebx
c0021cfb:	5e                   	pop    %esi
c0021cfc:	5f                   	pop    %edi
c0021cfd:	5d                   	pop    %ebp
c0021cfe:	c3                   	ret    

c0021cff <intr_register_ext>:
                  const char *name) {
c0021cff:	53                   	push   %ebx
c0021d00:	83 ec 08             	sub    $0x8,%esp
c0021d03:	e8 8f bb 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021d08:	81 c3 f8 87 01 00    	add    $0x187f8,%ebx
c0021d0e:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021d12:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021d15:	80 fa 0f             	cmp    $0xf,%dl
c0021d18:	77 22                	ja     c0021d3c <intr_register_ext+0x3d>
    register_handler(vec_no, 0, INTR_OFF, handler, name);
c0021d1a:	0f b6 c0             	movzbl %al,%eax
c0021d1d:	83 ec 08             	sub    $0x8,%esp
c0021d20:	ff 74 24 20          	pushl  0x20(%esp)
c0021d24:	ff 74 24 20          	pushl  0x20(%esp)
c0021d28:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021d2d:	ba 00 00 00 00       	mov    $0x0,%edx
c0021d32:	e8 fd fc ff ff       	call   c0021a34 <register_handler>
}
c0021d37:	83 c4 18             	add    $0x18,%esp
c0021d3a:	5b                   	pop    %ebx
c0021d3b:	c3                   	ret    
    ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021d3c:	83 ec 0c             	sub    $0xc,%esp
c0021d3f:	8d 83 78 4c ff ff    	lea    -0xb388(%ebx),%eax
c0021d45:	50                   	push   %eax
c0021d46:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021d4c:	50                   	push   %eax
c0021d4d:	8d 83 64 35 ff ff    	lea    -0xca9c(%ebx),%eax
c0021d53:	50                   	push   %eax
c0021d54:	68 b1 00 00 00       	push   $0xb1
c0021d59:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021d5f:	50                   	push   %eax
c0021d60:	e8 7f 71 00 00       	call   c0028ee4 <debug_panic>

c0021d65 <intr_register_int>:
                  intr_handler_func *handler, const char *name) {
c0021d65:	53                   	push   %ebx
c0021d66:	83 ec 08             	sub    $0x8,%esp
c0021d69:	e8 29 bb 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021d6e:	81 c3 92 87 01 00    	add    $0x18792,%ebx
c0021d74:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021d78:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021d7b:	80 fa 0f             	cmp    $0xf,%dl
c0021d7e:	76 20                	jbe    c0021da0 <intr_register_int+0x3b>
    register_handler(vec_no, dpl, level, handler, name);
c0021d80:	0f b6 c0             	movzbl %al,%eax
c0021d83:	83 ec 08             	sub    $0x8,%esp
c0021d86:	ff 74 24 28          	pushl  0x28(%esp)
c0021d8a:	ff 74 24 28          	pushl  0x28(%esp)
c0021d8e:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0021d92:	8b 54 24 24          	mov    0x24(%esp),%edx
c0021d96:	e8 99 fc ff ff       	call   c0021a34 <register_handler>
}
c0021d9b:	83 c4 18             	add    $0x18,%esp
c0021d9e:	5b                   	pop    %ebx
c0021d9f:	c3                   	ret    
    ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021da0:	83 ec 0c             	sub    $0xc,%esp
c0021da3:	8d 83 9c 4c ff ff    	lea    -0xb364(%ebx),%eax
c0021da9:	50                   	push   %eax
c0021daa:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021db0:	50                   	push   %eax
c0021db1:	8d 83 3c 35 ff ff    	lea    -0xcac4(%ebx),%eax
c0021db7:	50                   	push   %eax
c0021db8:	68 c5 00 00 00       	push   $0xc5
c0021dbd:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021dc3:	50                   	push   %eax
c0021dc4:	e8 1b 71 00 00       	call   c0028ee4 <debug_panic>

c0021dc9 <intr_context>:
intr_context(void) {
c0021dc9:	e8 cd ba 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0021dce:	05 32 87 01 00       	add    $0x18732,%eax
    return in_external_intr;
c0021dd3:	0f b6 80 c1 01 00 00 	movzbl 0x1c1(%eax),%eax
}
c0021dda:	c3                   	ret    

c0021ddb <intr_yield_on_return>:
intr_yield_on_return(void) {
c0021ddb:	53                   	push   %ebx
c0021ddc:	83 ec 08             	sub    $0x8,%esp
c0021ddf:	e8 b3 ba 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021de4:	81 c3 1c 87 01 00    	add    $0x1871c,%ebx
    ASSERT (intr_context());
c0021dea:	80 bb c1 01 00 00 00 	cmpb   $0x0,0x1c1(%ebx)
c0021df1:	74 0c                	je     c0021dff <intr_yield_on_return+0x24>
    yield_on_return = true;
c0021df3:	c6 83 c0 01 00 00 01 	movb   $0x1,0x1c0(%ebx)
}
c0021dfa:	83 c4 08             	add    $0x8,%esp
c0021dfd:	5b                   	pop    %ebx
c0021dfe:	c3                   	ret    
    ASSERT (intr_context());
c0021dff:	83 ec 0c             	sub    $0xc,%esp
c0021e02:	8d 93 a9 49 ff ff    	lea    -0xb657(%ebx),%edx
c0021e08:	52                   	push   %edx
c0021e09:	8d 93 96 44 ff ff    	lea    -0xbb6a(%ebx),%edx
c0021e0f:	52                   	push   %edx
c0021e10:	8d 93 24 35 ff ff    	lea    -0xcadc(%ebx),%edx
c0021e16:	52                   	push   %edx
c0021e17:	68 d6 00 00 00       	push   $0xd6
c0021e1c:	8d 93 ce 49 ff ff    	lea    -0xb632(%ebx),%edx
c0021e22:	52                   	push   %edx
c0021e23:	e8 bc 70 00 00       	call   c0028ee4 <debug_panic>

c0021e28 <intr_handler>:
/* Handler for all interrupts, faults, and exceptions.  This
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler(struct intr_frame *frame) {
c0021e28:	55                   	push   %ebp
c0021e29:	57                   	push   %edi
c0021e2a:	56                   	push   %esi
c0021e2b:	53                   	push   %ebx
c0021e2c:	83 ec 0c             	sub    $0xc,%esp
c0021e2f:	e8 63 ba 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021e34:	81 c3 cc 86 01 00    	add    $0x186cc,%ebx
c0021e3a:	8b 7c 24 20          	mov    0x20(%esp),%edi

    /* External interrupts are special.
       We only handle one at a time (so interrupts must be off)
       and they need to be acknowledged on the PIC (see below).
       An external interrupt handler cannot sleep. */
    external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021e3e:	8b 47 30             	mov    0x30(%edi),%eax
c0021e41:	8d 70 e0             	lea    -0x20(%eax),%esi
    if (external) {
c0021e44:	83 fe 0f             	cmp    $0xf,%esi
c0021e47:	76 2c                	jbe    c0021e75 <intr_handler+0x4d>
        in_external_intr = true;
        yield_on_return = false;
    }

    /* Invoke the interrupt's handler. */
    handler = intr_handlers[frame->vec_no];
c0021e49:	8b 57 30             	mov    0x30(%edi),%edx
c0021e4c:	8b 84 93 e0 09 00 00 	mov    0x9e0(%ebx,%edx,4),%eax
    if (handler != NULL)
c0021e53:	85 c0                	test   %eax,%eax
c0021e55:	0f 84 8e 00 00 00    	je     c0021ee9 <intr_handler+0xc1>
        handler(frame);
c0021e5b:	83 ec 0c             	sub    $0xc,%esp
c0021e5e:	57                   	push   %edi
c0021e5f:	ff d0                	call   *%eax
c0021e61:	83 c4 10             	add    $0x10,%esp
           condition.  Ignore it. */
    } else
        unexpected_interrupt(frame);

    /* Complete the processing of an external interrupt. */
    if (external) {
c0021e64:	83 fe 0f             	cmp    $0xf,%esi
c0021e67:	0f 86 c2 00 00 00    	jbe    c0021f2f <intr_handler+0x107>
        pic_end_of_interrupt(frame->vec_no);

        if (yield_on_return)
            thread_yield();
    }
}
c0021e6d:	83 c4 0c             	add    $0xc,%esp
c0021e70:	5b                   	pop    %ebx
c0021e71:	5e                   	pop    %esi
c0021e72:	5f                   	pop    %edi
c0021e73:	5d                   	pop    %ebp
c0021e74:	c3                   	ret    
        ASSERT (intr_get_level() == INTR_OFF);
c0021e75:	e8 57 fc ff ff       	call   c0021ad1 <intr_get_level>
c0021e7a:	85 c0                	test   %eax,%eax
c0021e7c:	75 19                	jne    c0021e97 <intr_handler+0x6f>
        ASSERT (!intr_context());
c0021e7e:	80 bb c1 01 00 00 00 	cmpb   $0x0,0x1c1(%ebx)
c0021e85:	75 39                	jne    c0021ec0 <intr_handler+0x98>
        in_external_intr = true;
c0021e87:	c6 83 c1 01 00 00 01 	movb   $0x1,0x1c1(%ebx)
        yield_on_return = false;
c0021e8e:	c6 83 c0 01 00 00 00 	movb   $0x0,0x1c0(%ebx)
c0021e95:	eb b2                	jmp    c0021e49 <intr_handler+0x21>
        ASSERT (intr_get_level() == INTR_OFF);
c0021e97:	83 ec 0c             	sub    $0xc,%esp
c0021e9a:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0021ea0:	50                   	push   %eax
c0021ea1:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021ea7:	50                   	push   %eax
c0021ea8:	8d 83 14 35 ff ff    	lea    -0xcaec(%ebx),%eax
c0021eae:	50                   	push   %eax
c0021eaf:	68 53 01 00 00       	push   $0x153
c0021eb4:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021eba:	50                   	push   %eax
c0021ebb:	e8 24 70 00 00       	call   c0028ee4 <debug_panic>
        ASSERT (!intr_context());
c0021ec0:	83 ec 0c             	sub    $0xc,%esp
c0021ec3:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c0021ec9:	50                   	push   %eax
c0021eca:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021ed0:	50                   	push   %eax
c0021ed1:	8d 83 14 35 ff ff    	lea    -0xcaec(%ebx),%eax
c0021ed7:	50                   	push   %eax
c0021ed8:	68 54 01 00 00       	push   $0x154
c0021edd:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021ee3:	50                   	push   %eax
c0021ee4:	e8 fb 6f 00 00       	call   c0028ee4 <debug_panic>
    else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f) {
c0021ee9:	89 d0                	mov    %edx,%eax
c0021eeb:	83 e0 f7             	and    $0xfffffff7,%eax
c0021eee:	83 f8 27             	cmp    $0x27,%eax
c0021ef1:	0f 84 6d ff ff ff    	je     c0021e64 <intr_handler+0x3c>
/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt(const struct intr_frame *f) {
    /* Count the number so far. */
    unsigned int n = ++unexpected_cnt[f->vec_no];
c0021ef7:	8d ab e0 01 00 00    	lea    0x1e0(%ebx),%ebp
c0021efd:	8b 4c 95 00          	mov    0x0(%ebp,%edx,4),%ecx
c0021f01:	8d 41 01             	lea    0x1(%ecx),%eax
c0021f04:	89 44 95 00          	mov    %eax,0x0(%ebp,%edx,4)
    /* If the number is a power of 2, print a message.  This rate
       limiting means that we get information about an uncommon
       unexpected interrupt the first time and fairly often after
       that, but one that occurs many times will not overwhelm the
       console. */
    if ((n & (n - 1)) == 0)
c0021f08:	85 c1                	test   %eax,%ecx
c0021f0a:	0f 85 54 ff ff ff    	jne    c0021e64 <intr_handler+0x3c>
        printf("Unexpected interrupt %#04x (%s)\n",
c0021f10:	83 ec 04             	sub    $0x4,%esp
c0021f13:	ff b4 93 e0 05 00 00 	pushl  0x5e0(%ebx,%edx,4)
c0021f1a:	52                   	push   %edx
c0021f1b:	8d 83 bc 4c ff ff    	lea    -0xb344(%ebx),%eax
c0021f21:	50                   	push   %eax
c0021f22:	e8 61 53 00 00       	call   c0027288 <printf>
c0021f27:	83 c4 10             	add    $0x10,%esp
c0021f2a:	e9 35 ff ff ff       	jmp    c0021e64 <intr_handler+0x3c>
        ASSERT (intr_get_level() == INTR_OFF);
c0021f2f:	e8 9d fb ff ff       	call   c0021ad1 <intr_get_level>
c0021f34:	85 c0                	test   %eax,%eax
c0021f36:	75 40                	jne    c0021f78 <intr_handler+0x150>
        ASSERT (intr_context());
c0021f38:	80 bb c1 01 00 00 00 	cmpb   $0x0,0x1c1(%ebx)
c0021f3f:	74 60                	je     c0021fa1 <intr_handler+0x179>
        in_external_intr = false;
c0021f41:	c6 83 c1 01 00 00 00 	movb   $0x0,0x1c1(%ebx)
        pic_end_of_interrupt(frame->vec_no);
c0021f48:	8b 57 30             	mov    0x30(%edi),%edx
    ASSERT (irq >= 0x20 && irq < 0x30);
c0021f4b:	8d 42 e0             	lea    -0x20(%edx),%eax
c0021f4e:	83 f8 0f             	cmp    $0xf,%eax
c0021f51:	77 77                	ja     c0021fca <intr_handler+0x1a2>
c0021f53:	b8 20 00 00 00       	mov    $0x20,%eax
c0021f58:	e6 20                	out    %al,$0x20
    if (irq >= 0x28)
c0021f5a:	83 fa 27             	cmp    $0x27,%edx
c0021f5d:	7e 02                	jle    c0021f61 <intr_handler+0x139>
c0021f5f:	e6 a0                	out    %al,$0xa0
        if (yield_on_return)
c0021f61:	80 bb c0 01 00 00 00 	cmpb   $0x0,0x1c0(%ebx)
c0021f68:	0f 84 ff fe ff ff    	je     c0021e6d <intr_handler+0x45>
            thread_yield();
c0021f6e:	e8 58 f5 ff ff       	call   c00214cb <thread_yield>
}
c0021f73:	e9 f5 fe ff ff       	jmp    c0021e6d <intr_handler+0x45>
        ASSERT (intr_get_level() == INTR_OFF);
c0021f78:	83 ec 0c             	sub    $0xc,%esp
c0021f7b:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0021f81:	50                   	push   %eax
c0021f82:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021f88:	50                   	push   %eax
c0021f89:	8d 83 14 35 ff ff    	lea    -0xcaec(%ebx),%eax
c0021f8f:	50                   	push   %eax
c0021f90:	68 67 01 00 00       	push   $0x167
c0021f95:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021f9b:	50                   	push   %eax
c0021f9c:	e8 43 6f 00 00       	call   c0028ee4 <debug_panic>
        ASSERT (intr_context());
c0021fa1:	83 ec 0c             	sub    $0xc,%esp
c0021fa4:	8d 83 a9 49 ff ff    	lea    -0xb657(%ebx),%eax
c0021faa:	50                   	push   %eax
c0021fab:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021fb1:	50                   	push   %eax
c0021fb2:	8d 83 14 35 ff ff    	lea    -0xcaec(%ebx),%eax
c0021fb8:	50                   	push   %eax
c0021fb9:	68 68 01 00 00       	push   $0x168
c0021fbe:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021fc4:	50                   	push   %eax
c0021fc5:	e8 1a 6f 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (irq >= 0x20 && irq < 0x30);
c0021fca:	83 ec 0c             	sub    $0xc,%esp
c0021fcd:	8d 83 91 4b ff ff    	lea    -0xb46f(%ebx),%eax
c0021fd3:	50                   	push   %eax
c0021fd4:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0021fda:	50                   	push   %eax
c0021fdb:	8d 83 fc 34 ff ff    	lea    -0xcb04(%ebx),%eax
c0021fe1:	50                   	push   %eax
c0021fe2:	68 ff 00 00 00       	push   $0xff
c0021fe7:	8d 83 ce 49 ff ff    	lea    -0xb632(%ebx),%eax
c0021fed:	50                   	push   %eax
c0021fee:	e8 f1 6e 00 00       	call   c0028ee4 <debug_panic>

c0021ff3 <intr_dump_frame>:
               f->vec_no, intr_names[f->vec_no]);
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame(const struct intr_frame *f) {
c0021ff3:	57                   	push   %edi
c0021ff4:	56                   	push   %esi
c0021ff5:	53                   	push   %ebx
c0021ff6:	e8 9c b8 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0021ffb:	81 c3 05 85 01 00    	add    $0x18505,%ebx
c0022001:	8b 74 24 10          	mov    0x10(%esp),%esi
    /* Store current value of CR2 into `cr2'.
       CR2 is the linear address of the last page fault.
       See [IA32-v2a] "MOV--Move to/from Control Registers" and
       [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
       (#PF)". */
    asm ("movl %%cr2, %0" : "=r" (cr2));
c0022005:	0f 20 d7             	mov    %cr2,%edi

    printf("Interrupt %#04x (%s) at eip=%p\n",
           f->vec_no, intr_names[f->vec_no], f->eip);
c0022008:	8b 46 30             	mov    0x30(%esi),%eax
    printf("Interrupt %#04x (%s) at eip=%p\n",
c002200b:	ff 76 3c             	pushl  0x3c(%esi)
c002200e:	ff b4 83 e0 05 00 00 	pushl  0x5e0(%ebx,%eax,4)
c0022015:	50                   	push   %eax
c0022016:	8d 83 e0 4c ff ff    	lea    -0xb320(%ebx),%eax
c002201c:	50                   	push   %eax
c002201d:	e8 66 52 00 00       	call   c0027288 <printf>
    printf(" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0022022:	83 c4 0c             	add    $0xc,%esp
c0022025:	ff 76 34             	pushl  0x34(%esi)
c0022028:	57                   	push   %edi
c0022029:	8d 83 ab 4b ff ff    	lea    -0xb455(%ebx),%eax
c002202f:	50                   	push   %eax
c0022030:	e8 53 52 00 00       	call   c0027288 <printf>
    printf(" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0022035:	83 c4 04             	add    $0x4,%esp
c0022038:	ff 76 14             	pushl  0x14(%esi)
c002203b:	ff 76 18             	pushl  0x18(%esi)
c002203e:	ff 76 10             	pushl  0x10(%esi)
c0022041:	ff 76 1c             	pushl  0x1c(%esi)
c0022044:	8d 83 00 4d ff ff    	lea    -0xb300(%ebx),%eax
c002204a:	50                   	push   %eax
c002204b:	e8 38 52 00 00       	call   c0027288 <printf>
           f->eax, f->ebx, f->ecx, f->edx);
    printf(" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0022050:	83 c4 14             	add    $0x14,%esp
c0022053:	ff 76 08             	pushl  0x8(%esi)
c0022056:	ff 76 48             	pushl  0x48(%esi)
c0022059:	ff 36                	pushl  (%esi)
c002205b:	ff 76 04             	pushl  0x4(%esi)
c002205e:	8d 83 28 4d ff ff    	lea    -0xb2d8(%ebx),%eax
c0022064:	50                   	push   %eax
c0022065:	e8 1e 52 00 00       	call   c0027288 <printf>
           f->esi, f->edi, (uint32_t) f->esp, f->ebp);
    printf(" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c002206a:	83 c4 14             	add    $0x14,%esp
c002206d:	0f b7 46 4c          	movzwl 0x4c(%esi),%eax
c0022071:	50                   	push   %eax
c0022072:	0f b7 46 28          	movzwl 0x28(%esi),%eax
c0022076:	50                   	push   %eax
c0022077:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
c002207b:	50                   	push   %eax
c002207c:	0f b7 46 40          	movzwl 0x40(%esi),%eax
c0022080:	50                   	push   %eax
c0022081:	8d 83 50 4d ff ff    	lea    -0xb2b0(%ebx),%eax
c0022087:	50                   	push   %eax
c0022088:	e8 fb 51 00 00       	call   c0027288 <printf>
           f->cs, f->ds, f->es, f->ss);
}
c002208d:	83 c4 20             	add    $0x20,%esp
c0022090:	5b                   	pop    %ebx
c0022091:	5e                   	pop    %esi
c0022092:	5f                   	pop    %edi
c0022093:	c3                   	ret    

c0022094 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name(uint8_t vec) {
c0022094:	e8 02 b8 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0022099:	05 67 84 01 00       	add    $0x18467,%eax
    return intr_names[vec];
c002209e:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c00220a3:	8b 84 90 e0 05 00 00 	mov    0x5e0(%eax,%edx,4),%eax
}
c00220aa:	c3                   	ret    

c00220ab <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c00220ab:	1e                   	push   %ds
	pushl %es
c00220ac:	06                   	push   %es
	pushl %fs
c00220ad:	0f a0                	push   %fs
	pushl %gs
c00220af:	0f a8                	push   %gs
	pushal
c00220b1:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c00220b2:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c00220b3:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c00220b8:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c00220ba:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c00220bc:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c00220c0:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c00220c1:	e8 62 fd ff ff       	call   c0021e28 <intr_handler>
	addl $4, %esp
c00220c6:	83 c4 04             	add    $0x4,%esp

c00220c9 <intr_exit>:
        	EBX = Pop();
        	EDX = Pop();
        	ECX = Pop();
        	EAX = Pop();
        */
	popal
c00220c9:	61                   	popa   
	popl %gs
c00220ca:	0f a9                	pop    %gs
	popl %fs
c00220cc:	0f a1                	pop    %fs
	popl %es
c00220ce:	07                   	pop    %es
	popl %ds
c00220cf:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c00220d0:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c00220d3:	cf                   	iret   

c00220d4 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c00220d4:	55                   	push   %ebp
c00220d5:	6a 00                	push   $0x0
c00220d7:	6a 00                	push   $0x0
c00220d9:	eb d0                	jmp    c00220ab <intr_entry>

c00220db <intr01_stub>:
c00220db:	55                   	push   %ebp
c00220dc:	6a 00                	push   $0x0
c00220de:	6a 01                	push   $0x1
c00220e0:	eb c9                	jmp    c00220ab <intr_entry>

c00220e2 <intr02_stub>:
c00220e2:	55                   	push   %ebp
c00220e3:	6a 00                	push   $0x0
c00220e5:	6a 02                	push   $0x2
c00220e7:	eb c2                	jmp    c00220ab <intr_entry>

c00220e9 <intr03_stub>:
c00220e9:	55                   	push   %ebp
c00220ea:	6a 00                	push   $0x0
c00220ec:	6a 03                	push   $0x3
c00220ee:	eb bb                	jmp    c00220ab <intr_entry>

c00220f0 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c00220f0:	55                   	push   %ebp
c00220f1:	6a 00                	push   $0x0
c00220f3:	6a 04                	push   $0x4
c00220f5:	eb b4                	jmp    c00220ab <intr_entry>

c00220f7 <intr05_stub>:
c00220f7:	55                   	push   %ebp
c00220f8:	6a 00                	push   $0x0
c00220fa:	6a 05                	push   $0x5
c00220fc:	eb ad                	jmp    c00220ab <intr_entry>

c00220fe <intr06_stub>:
c00220fe:	55                   	push   %ebp
c00220ff:	6a 00                	push   $0x0
c0022101:	6a 06                	push   $0x6
c0022103:	eb a6                	jmp    c00220ab <intr_entry>

c0022105 <intr07_stub>:
c0022105:	55                   	push   %ebp
c0022106:	6a 00                	push   $0x0
c0022108:	6a 07                	push   $0x7
c002210a:	eb 9f                	jmp    c00220ab <intr_entry>

c002210c <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c002210c:	ff 34 24             	pushl  (%esp)
c002210f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022113:	6a 08                	push   $0x8
c0022115:	eb 94                	jmp    c00220ab <intr_entry>

c0022117 <intr09_stub>:
c0022117:	55                   	push   %ebp
c0022118:	6a 00                	push   $0x0
c002211a:	6a 09                	push   $0x9
c002211c:	eb 8d                	jmp    c00220ab <intr_entry>

c002211e <intr0a_stub>:
c002211e:	ff 34 24             	pushl  (%esp)
c0022121:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022125:	6a 0a                	push   $0xa
c0022127:	eb 82                	jmp    c00220ab <intr_entry>

c0022129 <intr0b_stub>:
c0022129:	ff 34 24             	pushl  (%esp)
c002212c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022130:	6a 0b                	push   $0xb
c0022132:	e9 74 ff ff ff       	jmp    c00220ab <intr_entry>

c0022137 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0022137:	55                   	push   %ebp
c0022138:	6a 00                	push   $0x0
c002213a:	6a 0c                	push   $0xc
c002213c:	e9 6a ff ff ff       	jmp    c00220ab <intr_entry>

c0022141 <intr0d_stub>:
c0022141:	ff 34 24             	pushl  (%esp)
c0022144:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022148:	6a 0d                	push   $0xd
c002214a:	e9 5c ff ff ff       	jmp    c00220ab <intr_entry>

c002214f <intr0e_stub>:
c002214f:	ff 34 24             	pushl  (%esp)
c0022152:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022156:	6a 0e                	push   $0xe
c0022158:	e9 4e ff ff ff       	jmp    c00220ab <intr_entry>

c002215d <intr0f_stub>:
c002215d:	55                   	push   %ebp
c002215e:	6a 00                	push   $0x0
c0022160:	6a 0f                	push   $0xf
c0022162:	e9 44 ff ff ff       	jmp    c00220ab <intr_entry>

c0022167 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0022167:	55                   	push   %ebp
c0022168:	6a 00                	push   $0x0
c002216a:	6a 10                	push   $0x10
c002216c:	e9 3a ff ff ff       	jmp    c00220ab <intr_entry>

c0022171 <intr11_stub>:
c0022171:	ff 34 24             	pushl  (%esp)
c0022174:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022178:	6a 11                	push   $0x11
c002217a:	e9 2c ff ff ff       	jmp    c00220ab <intr_entry>

c002217f <intr12_stub>:
c002217f:	55                   	push   %ebp
c0022180:	6a 00                	push   $0x0
c0022182:	6a 12                	push   $0x12
c0022184:	e9 22 ff ff ff       	jmp    c00220ab <intr_entry>

c0022189 <intr13_stub>:
c0022189:	55                   	push   %ebp
c002218a:	6a 00                	push   $0x0
c002218c:	6a 13                	push   $0x13
c002218e:	e9 18 ff ff ff       	jmp    c00220ab <intr_entry>

c0022193 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0022193:	55                   	push   %ebp
c0022194:	6a 00                	push   $0x0
c0022196:	6a 14                	push   $0x14
c0022198:	e9 0e ff ff ff       	jmp    c00220ab <intr_entry>

c002219d <intr15_stub>:
c002219d:	55                   	push   %ebp
c002219e:	6a 00                	push   $0x0
c00221a0:	6a 15                	push   $0x15
c00221a2:	e9 04 ff ff ff       	jmp    c00220ab <intr_entry>

c00221a7 <intr16_stub>:
c00221a7:	55                   	push   %ebp
c00221a8:	6a 00                	push   $0x0
c00221aa:	6a 16                	push   $0x16
c00221ac:	e9 fa fe ff ff       	jmp    c00220ab <intr_entry>

c00221b1 <intr17_stub>:
c00221b1:	55                   	push   %ebp
c00221b2:	6a 00                	push   $0x0
c00221b4:	6a 17                	push   $0x17
c00221b6:	e9 f0 fe ff ff       	jmp    c00220ab <intr_entry>

c00221bb <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c00221bb:	ff 34 24             	pushl  (%esp)
c00221be:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00221c2:	6a 18                	push   $0x18
c00221c4:	e9 e2 fe ff ff       	jmp    c00220ab <intr_entry>

c00221c9 <intr19_stub>:
c00221c9:	55                   	push   %ebp
c00221ca:	6a 00                	push   $0x0
c00221cc:	6a 19                	push   $0x19
c00221ce:	e9 d8 fe ff ff       	jmp    c00220ab <intr_entry>

c00221d3 <intr1a_stub>:
c00221d3:	ff 34 24             	pushl  (%esp)
c00221d6:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00221da:	6a 1a                	push   $0x1a
c00221dc:	e9 ca fe ff ff       	jmp    c00220ab <intr_entry>

c00221e1 <intr1b_stub>:
c00221e1:	ff 34 24             	pushl  (%esp)
c00221e4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00221e8:	6a 1b                	push   $0x1b
c00221ea:	e9 bc fe ff ff       	jmp    c00220ab <intr_entry>

c00221ef <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c00221ef:	55                   	push   %ebp
c00221f0:	6a 00                	push   $0x0
c00221f2:	6a 1c                	push   $0x1c
c00221f4:	e9 b2 fe ff ff       	jmp    c00220ab <intr_entry>

c00221f9 <intr1d_stub>:
c00221f9:	ff 34 24             	pushl  (%esp)
c00221fc:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022200:	6a 1d                	push   $0x1d
c0022202:	e9 a4 fe ff ff       	jmp    c00220ab <intr_entry>

c0022207 <intr1e_stub>:
c0022207:	ff 34 24             	pushl  (%esp)
c002220a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002220e:	6a 1e                	push   $0x1e
c0022210:	e9 96 fe ff ff       	jmp    c00220ab <intr_entry>

c0022215 <intr1f_stub>:
c0022215:	55                   	push   %ebp
c0022216:	6a 00                	push   $0x0
c0022218:	6a 1f                	push   $0x1f
c002221a:	e9 8c fe ff ff       	jmp    c00220ab <intr_entry>

c002221f <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c002221f:	55                   	push   %ebp
c0022220:	6a 00                	push   $0x0
c0022222:	6a 20                	push   $0x20
c0022224:	e9 82 fe ff ff       	jmp    c00220ab <intr_entry>

c0022229 <intr21_stub>:
c0022229:	55                   	push   %ebp
c002222a:	6a 00                	push   $0x0
c002222c:	6a 21                	push   $0x21
c002222e:	e9 78 fe ff ff       	jmp    c00220ab <intr_entry>

c0022233 <intr22_stub>:
c0022233:	55                   	push   %ebp
c0022234:	6a 00                	push   $0x0
c0022236:	6a 22                	push   $0x22
c0022238:	e9 6e fe ff ff       	jmp    c00220ab <intr_entry>

c002223d <intr23_stub>:
c002223d:	55                   	push   %ebp
c002223e:	6a 00                	push   $0x0
c0022240:	6a 23                	push   $0x23
c0022242:	e9 64 fe ff ff       	jmp    c00220ab <intr_entry>

c0022247 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0022247:	55                   	push   %ebp
c0022248:	6a 00                	push   $0x0
c002224a:	6a 24                	push   $0x24
c002224c:	e9 5a fe ff ff       	jmp    c00220ab <intr_entry>

c0022251 <intr25_stub>:
c0022251:	55                   	push   %ebp
c0022252:	6a 00                	push   $0x0
c0022254:	6a 25                	push   $0x25
c0022256:	e9 50 fe ff ff       	jmp    c00220ab <intr_entry>

c002225b <intr26_stub>:
c002225b:	55                   	push   %ebp
c002225c:	6a 00                	push   $0x0
c002225e:	6a 26                	push   $0x26
c0022260:	e9 46 fe ff ff       	jmp    c00220ab <intr_entry>

c0022265 <intr27_stub>:
c0022265:	55                   	push   %ebp
c0022266:	6a 00                	push   $0x0
c0022268:	6a 27                	push   $0x27
c002226a:	e9 3c fe ff ff       	jmp    c00220ab <intr_entry>

c002226f <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c002226f:	55                   	push   %ebp
c0022270:	6a 00                	push   $0x0
c0022272:	6a 28                	push   $0x28
c0022274:	e9 32 fe ff ff       	jmp    c00220ab <intr_entry>

c0022279 <intr29_stub>:
c0022279:	55                   	push   %ebp
c002227a:	6a 00                	push   $0x0
c002227c:	6a 29                	push   $0x29
c002227e:	e9 28 fe ff ff       	jmp    c00220ab <intr_entry>

c0022283 <intr2a_stub>:
c0022283:	55                   	push   %ebp
c0022284:	6a 00                	push   $0x0
c0022286:	6a 2a                	push   $0x2a
c0022288:	e9 1e fe ff ff       	jmp    c00220ab <intr_entry>

c002228d <intr2b_stub>:
c002228d:	55                   	push   %ebp
c002228e:	6a 00                	push   $0x0
c0022290:	6a 2b                	push   $0x2b
c0022292:	e9 14 fe ff ff       	jmp    c00220ab <intr_entry>

c0022297 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0022297:	55                   	push   %ebp
c0022298:	6a 00                	push   $0x0
c002229a:	6a 2c                	push   $0x2c
c002229c:	e9 0a fe ff ff       	jmp    c00220ab <intr_entry>

c00222a1 <intr2d_stub>:
c00222a1:	55                   	push   %ebp
c00222a2:	6a 00                	push   $0x0
c00222a4:	6a 2d                	push   $0x2d
c00222a6:	e9 00 fe ff ff       	jmp    c00220ab <intr_entry>

c00222ab <intr2e_stub>:
c00222ab:	55                   	push   %ebp
c00222ac:	6a 00                	push   $0x0
c00222ae:	6a 2e                	push   $0x2e
c00222b0:	e9 f6 fd ff ff       	jmp    c00220ab <intr_entry>

c00222b5 <intr2f_stub>:
c00222b5:	55                   	push   %ebp
c00222b6:	6a 00                	push   $0x0
c00222b8:	6a 2f                	push   $0x2f
c00222ba:	e9 ec fd ff ff       	jmp    c00220ab <intr_entry>

c00222bf <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00222bf:	55                   	push   %ebp
c00222c0:	6a 00                	push   $0x0
c00222c2:	6a 30                	push   $0x30
c00222c4:	e9 e2 fd ff ff       	jmp    c00220ab <intr_entry>

c00222c9 <intr31_stub>:
c00222c9:	55                   	push   %ebp
c00222ca:	6a 00                	push   $0x0
c00222cc:	6a 31                	push   $0x31
c00222ce:	e9 d8 fd ff ff       	jmp    c00220ab <intr_entry>

c00222d3 <intr32_stub>:
c00222d3:	55                   	push   %ebp
c00222d4:	6a 00                	push   $0x0
c00222d6:	6a 32                	push   $0x32
c00222d8:	e9 ce fd ff ff       	jmp    c00220ab <intr_entry>

c00222dd <intr33_stub>:
c00222dd:	55                   	push   %ebp
c00222de:	6a 00                	push   $0x0
c00222e0:	6a 33                	push   $0x33
c00222e2:	e9 c4 fd ff ff       	jmp    c00220ab <intr_entry>

c00222e7 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c00222e7:	55                   	push   %ebp
c00222e8:	6a 00                	push   $0x0
c00222ea:	6a 34                	push   $0x34
c00222ec:	e9 ba fd ff ff       	jmp    c00220ab <intr_entry>

c00222f1 <intr35_stub>:
c00222f1:	55                   	push   %ebp
c00222f2:	6a 00                	push   $0x0
c00222f4:	6a 35                	push   $0x35
c00222f6:	e9 b0 fd ff ff       	jmp    c00220ab <intr_entry>

c00222fb <intr36_stub>:
c00222fb:	55                   	push   %ebp
c00222fc:	6a 00                	push   $0x0
c00222fe:	6a 36                	push   $0x36
c0022300:	e9 a6 fd ff ff       	jmp    c00220ab <intr_entry>

c0022305 <intr37_stub>:
c0022305:	55                   	push   %ebp
c0022306:	6a 00                	push   $0x0
c0022308:	6a 37                	push   $0x37
c002230a:	e9 9c fd ff ff       	jmp    c00220ab <intr_entry>

c002230f <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c002230f:	55                   	push   %ebp
c0022310:	6a 00                	push   $0x0
c0022312:	6a 38                	push   $0x38
c0022314:	e9 92 fd ff ff       	jmp    c00220ab <intr_entry>

c0022319 <intr39_stub>:
c0022319:	55                   	push   %ebp
c002231a:	6a 00                	push   $0x0
c002231c:	6a 39                	push   $0x39
c002231e:	e9 88 fd ff ff       	jmp    c00220ab <intr_entry>

c0022323 <intr3a_stub>:
c0022323:	55                   	push   %ebp
c0022324:	6a 00                	push   $0x0
c0022326:	6a 3a                	push   $0x3a
c0022328:	e9 7e fd ff ff       	jmp    c00220ab <intr_entry>

c002232d <intr3b_stub>:
c002232d:	55                   	push   %ebp
c002232e:	6a 00                	push   $0x0
c0022330:	6a 3b                	push   $0x3b
c0022332:	e9 74 fd ff ff       	jmp    c00220ab <intr_entry>

c0022337 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0022337:	55                   	push   %ebp
c0022338:	6a 00                	push   $0x0
c002233a:	6a 3c                	push   $0x3c
c002233c:	e9 6a fd ff ff       	jmp    c00220ab <intr_entry>

c0022341 <intr3d_stub>:
c0022341:	55                   	push   %ebp
c0022342:	6a 00                	push   $0x0
c0022344:	6a 3d                	push   $0x3d
c0022346:	e9 60 fd ff ff       	jmp    c00220ab <intr_entry>

c002234b <intr3e_stub>:
c002234b:	55                   	push   %ebp
c002234c:	6a 00                	push   $0x0
c002234e:	6a 3e                	push   $0x3e
c0022350:	e9 56 fd ff ff       	jmp    c00220ab <intr_entry>

c0022355 <intr3f_stub>:
c0022355:	55                   	push   %ebp
c0022356:	6a 00                	push   $0x0
c0022358:	6a 3f                	push   $0x3f
c002235a:	e9 4c fd ff ff       	jmp    c00220ab <intr_entry>

c002235f <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c002235f:	55                   	push   %ebp
c0022360:	6a 00                	push   $0x0
c0022362:	6a 40                	push   $0x40
c0022364:	e9 42 fd ff ff       	jmp    c00220ab <intr_entry>

c0022369 <intr41_stub>:
c0022369:	55                   	push   %ebp
c002236a:	6a 00                	push   $0x0
c002236c:	6a 41                	push   $0x41
c002236e:	e9 38 fd ff ff       	jmp    c00220ab <intr_entry>

c0022373 <intr42_stub>:
c0022373:	55                   	push   %ebp
c0022374:	6a 00                	push   $0x0
c0022376:	6a 42                	push   $0x42
c0022378:	e9 2e fd ff ff       	jmp    c00220ab <intr_entry>

c002237d <intr43_stub>:
c002237d:	55                   	push   %ebp
c002237e:	6a 00                	push   $0x0
c0022380:	6a 43                	push   $0x43
c0022382:	e9 24 fd ff ff       	jmp    c00220ab <intr_entry>

c0022387 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0022387:	55                   	push   %ebp
c0022388:	6a 00                	push   $0x0
c002238a:	6a 44                	push   $0x44
c002238c:	e9 1a fd ff ff       	jmp    c00220ab <intr_entry>

c0022391 <intr45_stub>:
c0022391:	55                   	push   %ebp
c0022392:	6a 00                	push   $0x0
c0022394:	6a 45                	push   $0x45
c0022396:	e9 10 fd ff ff       	jmp    c00220ab <intr_entry>

c002239b <intr46_stub>:
c002239b:	55                   	push   %ebp
c002239c:	6a 00                	push   $0x0
c002239e:	6a 46                	push   $0x46
c00223a0:	e9 06 fd ff ff       	jmp    c00220ab <intr_entry>

c00223a5 <intr47_stub>:
c00223a5:	55                   	push   %ebp
c00223a6:	6a 00                	push   $0x0
c00223a8:	6a 47                	push   $0x47
c00223aa:	e9 fc fc ff ff       	jmp    c00220ab <intr_entry>

c00223af <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c00223af:	55                   	push   %ebp
c00223b0:	6a 00                	push   $0x0
c00223b2:	6a 48                	push   $0x48
c00223b4:	e9 f2 fc ff ff       	jmp    c00220ab <intr_entry>

c00223b9 <intr49_stub>:
c00223b9:	55                   	push   %ebp
c00223ba:	6a 00                	push   $0x0
c00223bc:	6a 49                	push   $0x49
c00223be:	e9 e8 fc ff ff       	jmp    c00220ab <intr_entry>

c00223c3 <intr4a_stub>:
c00223c3:	55                   	push   %ebp
c00223c4:	6a 00                	push   $0x0
c00223c6:	6a 4a                	push   $0x4a
c00223c8:	e9 de fc ff ff       	jmp    c00220ab <intr_entry>

c00223cd <intr4b_stub>:
c00223cd:	55                   	push   %ebp
c00223ce:	6a 00                	push   $0x0
c00223d0:	6a 4b                	push   $0x4b
c00223d2:	e9 d4 fc ff ff       	jmp    c00220ab <intr_entry>

c00223d7 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c00223d7:	55                   	push   %ebp
c00223d8:	6a 00                	push   $0x0
c00223da:	6a 4c                	push   $0x4c
c00223dc:	e9 ca fc ff ff       	jmp    c00220ab <intr_entry>

c00223e1 <intr4d_stub>:
c00223e1:	55                   	push   %ebp
c00223e2:	6a 00                	push   $0x0
c00223e4:	6a 4d                	push   $0x4d
c00223e6:	e9 c0 fc ff ff       	jmp    c00220ab <intr_entry>

c00223eb <intr4e_stub>:
c00223eb:	55                   	push   %ebp
c00223ec:	6a 00                	push   $0x0
c00223ee:	6a 4e                	push   $0x4e
c00223f0:	e9 b6 fc ff ff       	jmp    c00220ab <intr_entry>

c00223f5 <intr4f_stub>:
c00223f5:	55                   	push   %ebp
c00223f6:	6a 00                	push   $0x0
c00223f8:	6a 4f                	push   $0x4f
c00223fa:	e9 ac fc ff ff       	jmp    c00220ab <intr_entry>

c00223ff <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c00223ff:	55                   	push   %ebp
c0022400:	6a 00                	push   $0x0
c0022402:	6a 50                	push   $0x50
c0022404:	e9 a2 fc ff ff       	jmp    c00220ab <intr_entry>

c0022409 <intr51_stub>:
c0022409:	55                   	push   %ebp
c002240a:	6a 00                	push   $0x0
c002240c:	6a 51                	push   $0x51
c002240e:	e9 98 fc ff ff       	jmp    c00220ab <intr_entry>

c0022413 <intr52_stub>:
c0022413:	55                   	push   %ebp
c0022414:	6a 00                	push   $0x0
c0022416:	6a 52                	push   $0x52
c0022418:	e9 8e fc ff ff       	jmp    c00220ab <intr_entry>

c002241d <intr53_stub>:
c002241d:	55                   	push   %ebp
c002241e:	6a 00                	push   $0x0
c0022420:	6a 53                	push   $0x53
c0022422:	e9 84 fc ff ff       	jmp    c00220ab <intr_entry>

c0022427 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0022427:	55                   	push   %ebp
c0022428:	6a 00                	push   $0x0
c002242a:	6a 54                	push   $0x54
c002242c:	e9 7a fc ff ff       	jmp    c00220ab <intr_entry>

c0022431 <intr55_stub>:
c0022431:	55                   	push   %ebp
c0022432:	6a 00                	push   $0x0
c0022434:	6a 55                	push   $0x55
c0022436:	e9 70 fc ff ff       	jmp    c00220ab <intr_entry>

c002243b <intr56_stub>:
c002243b:	55                   	push   %ebp
c002243c:	6a 00                	push   $0x0
c002243e:	6a 56                	push   $0x56
c0022440:	e9 66 fc ff ff       	jmp    c00220ab <intr_entry>

c0022445 <intr57_stub>:
c0022445:	55                   	push   %ebp
c0022446:	6a 00                	push   $0x0
c0022448:	6a 57                	push   $0x57
c002244a:	e9 5c fc ff ff       	jmp    c00220ab <intr_entry>

c002244f <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c002244f:	55                   	push   %ebp
c0022450:	6a 00                	push   $0x0
c0022452:	6a 58                	push   $0x58
c0022454:	e9 52 fc ff ff       	jmp    c00220ab <intr_entry>

c0022459 <intr59_stub>:
c0022459:	55                   	push   %ebp
c002245a:	6a 00                	push   $0x0
c002245c:	6a 59                	push   $0x59
c002245e:	e9 48 fc ff ff       	jmp    c00220ab <intr_entry>

c0022463 <intr5a_stub>:
c0022463:	55                   	push   %ebp
c0022464:	6a 00                	push   $0x0
c0022466:	6a 5a                	push   $0x5a
c0022468:	e9 3e fc ff ff       	jmp    c00220ab <intr_entry>

c002246d <intr5b_stub>:
c002246d:	55                   	push   %ebp
c002246e:	6a 00                	push   $0x0
c0022470:	6a 5b                	push   $0x5b
c0022472:	e9 34 fc ff ff       	jmp    c00220ab <intr_entry>

c0022477 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0022477:	55                   	push   %ebp
c0022478:	6a 00                	push   $0x0
c002247a:	6a 5c                	push   $0x5c
c002247c:	e9 2a fc ff ff       	jmp    c00220ab <intr_entry>

c0022481 <intr5d_stub>:
c0022481:	55                   	push   %ebp
c0022482:	6a 00                	push   $0x0
c0022484:	6a 5d                	push   $0x5d
c0022486:	e9 20 fc ff ff       	jmp    c00220ab <intr_entry>

c002248b <intr5e_stub>:
c002248b:	55                   	push   %ebp
c002248c:	6a 00                	push   $0x0
c002248e:	6a 5e                	push   $0x5e
c0022490:	e9 16 fc ff ff       	jmp    c00220ab <intr_entry>

c0022495 <intr5f_stub>:
c0022495:	55                   	push   %ebp
c0022496:	6a 00                	push   $0x0
c0022498:	6a 5f                	push   $0x5f
c002249a:	e9 0c fc ff ff       	jmp    c00220ab <intr_entry>

c002249f <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c002249f:	55                   	push   %ebp
c00224a0:	6a 00                	push   $0x0
c00224a2:	6a 60                	push   $0x60
c00224a4:	e9 02 fc ff ff       	jmp    c00220ab <intr_entry>

c00224a9 <intr61_stub>:
c00224a9:	55                   	push   %ebp
c00224aa:	6a 00                	push   $0x0
c00224ac:	6a 61                	push   $0x61
c00224ae:	e9 f8 fb ff ff       	jmp    c00220ab <intr_entry>

c00224b3 <intr62_stub>:
c00224b3:	55                   	push   %ebp
c00224b4:	6a 00                	push   $0x0
c00224b6:	6a 62                	push   $0x62
c00224b8:	e9 ee fb ff ff       	jmp    c00220ab <intr_entry>

c00224bd <intr63_stub>:
c00224bd:	55                   	push   %ebp
c00224be:	6a 00                	push   $0x0
c00224c0:	6a 63                	push   $0x63
c00224c2:	e9 e4 fb ff ff       	jmp    c00220ab <intr_entry>

c00224c7 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c00224c7:	55                   	push   %ebp
c00224c8:	6a 00                	push   $0x0
c00224ca:	6a 64                	push   $0x64
c00224cc:	e9 da fb ff ff       	jmp    c00220ab <intr_entry>

c00224d1 <intr65_stub>:
c00224d1:	55                   	push   %ebp
c00224d2:	6a 00                	push   $0x0
c00224d4:	6a 65                	push   $0x65
c00224d6:	e9 d0 fb ff ff       	jmp    c00220ab <intr_entry>

c00224db <intr66_stub>:
c00224db:	55                   	push   %ebp
c00224dc:	6a 00                	push   $0x0
c00224de:	6a 66                	push   $0x66
c00224e0:	e9 c6 fb ff ff       	jmp    c00220ab <intr_entry>

c00224e5 <intr67_stub>:
c00224e5:	55                   	push   %ebp
c00224e6:	6a 00                	push   $0x0
c00224e8:	6a 67                	push   $0x67
c00224ea:	e9 bc fb ff ff       	jmp    c00220ab <intr_entry>

c00224ef <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c00224ef:	55                   	push   %ebp
c00224f0:	6a 00                	push   $0x0
c00224f2:	6a 68                	push   $0x68
c00224f4:	e9 b2 fb ff ff       	jmp    c00220ab <intr_entry>

c00224f9 <intr69_stub>:
c00224f9:	55                   	push   %ebp
c00224fa:	6a 00                	push   $0x0
c00224fc:	6a 69                	push   $0x69
c00224fe:	e9 a8 fb ff ff       	jmp    c00220ab <intr_entry>

c0022503 <intr6a_stub>:
c0022503:	55                   	push   %ebp
c0022504:	6a 00                	push   $0x0
c0022506:	6a 6a                	push   $0x6a
c0022508:	e9 9e fb ff ff       	jmp    c00220ab <intr_entry>

c002250d <intr6b_stub>:
c002250d:	55                   	push   %ebp
c002250e:	6a 00                	push   $0x0
c0022510:	6a 6b                	push   $0x6b
c0022512:	e9 94 fb ff ff       	jmp    c00220ab <intr_entry>

c0022517 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022517:	55                   	push   %ebp
c0022518:	6a 00                	push   $0x0
c002251a:	6a 6c                	push   $0x6c
c002251c:	e9 8a fb ff ff       	jmp    c00220ab <intr_entry>

c0022521 <intr6d_stub>:
c0022521:	55                   	push   %ebp
c0022522:	6a 00                	push   $0x0
c0022524:	6a 6d                	push   $0x6d
c0022526:	e9 80 fb ff ff       	jmp    c00220ab <intr_entry>

c002252b <intr6e_stub>:
c002252b:	55                   	push   %ebp
c002252c:	6a 00                	push   $0x0
c002252e:	6a 6e                	push   $0x6e
c0022530:	e9 76 fb ff ff       	jmp    c00220ab <intr_entry>

c0022535 <intr6f_stub>:
c0022535:	55                   	push   %ebp
c0022536:	6a 00                	push   $0x0
c0022538:	6a 6f                	push   $0x6f
c002253a:	e9 6c fb ff ff       	jmp    c00220ab <intr_entry>

c002253f <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c002253f:	55                   	push   %ebp
c0022540:	6a 00                	push   $0x0
c0022542:	6a 70                	push   $0x70
c0022544:	e9 62 fb ff ff       	jmp    c00220ab <intr_entry>

c0022549 <intr71_stub>:
c0022549:	55                   	push   %ebp
c002254a:	6a 00                	push   $0x0
c002254c:	6a 71                	push   $0x71
c002254e:	e9 58 fb ff ff       	jmp    c00220ab <intr_entry>

c0022553 <intr72_stub>:
c0022553:	55                   	push   %ebp
c0022554:	6a 00                	push   $0x0
c0022556:	6a 72                	push   $0x72
c0022558:	e9 4e fb ff ff       	jmp    c00220ab <intr_entry>

c002255d <intr73_stub>:
c002255d:	55                   	push   %ebp
c002255e:	6a 00                	push   $0x0
c0022560:	6a 73                	push   $0x73
c0022562:	e9 44 fb ff ff       	jmp    c00220ab <intr_entry>

c0022567 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0022567:	55                   	push   %ebp
c0022568:	6a 00                	push   $0x0
c002256a:	6a 74                	push   $0x74
c002256c:	e9 3a fb ff ff       	jmp    c00220ab <intr_entry>

c0022571 <intr75_stub>:
c0022571:	55                   	push   %ebp
c0022572:	6a 00                	push   $0x0
c0022574:	6a 75                	push   $0x75
c0022576:	e9 30 fb ff ff       	jmp    c00220ab <intr_entry>

c002257b <intr76_stub>:
c002257b:	55                   	push   %ebp
c002257c:	6a 00                	push   $0x0
c002257e:	6a 76                	push   $0x76
c0022580:	e9 26 fb ff ff       	jmp    c00220ab <intr_entry>

c0022585 <intr77_stub>:
c0022585:	55                   	push   %ebp
c0022586:	6a 00                	push   $0x0
c0022588:	6a 77                	push   $0x77
c002258a:	e9 1c fb ff ff       	jmp    c00220ab <intr_entry>

c002258f <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c002258f:	55                   	push   %ebp
c0022590:	6a 00                	push   $0x0
c0022592:	6a 78                	push   $0x78
c0022594:	e9 12 fb ff ff       	jmp    c00220ab <intr_entry>

c0022599 <intr79_stub>:
c0022599:	55                   	push   %ebp
c002259a:	6a 00                	push   $0x0
c002259c:	6a 79                	push   $0x79
c002259e:	e9 08 fb ff ff       	jmp    c00220ab <intr_entry>

c00225a3 <intr7a_stub>:
c00225a3:	55                   	push   %ebp
c00225a4:	6a 00                	push   $0x0
c00225a6:	6a 7a                	push   $0x7a
c00225a8:	e9 fe fa ff ff       	jmp    c00220ab <intr_entry>

c00225ad <intr7b_stub>:
c00225ad:	55                   	push   %ebp
c00225ae:	6a 00                	push   $0x0
c00225b0:	6a 7b                	push   $0x7b
c00225b2:	e9 f4 fa ff ff       	jmp    c00220ab <intr_entry>

c00225b7 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00225b7:	55                   	push   %ebp
c00225b8:	6a 00                	push   $0x0
c00225ba:	6a 7c                	push   $0x7c
c00225bc:	e9 ea fa ff ff       	jmp    c00220ab <intr_entry>

c00225c1 <intr7d_stub>:
c00225c1:	55                   	push   %ebp
c00225c2:	6a 00                	push   $0x0
c00225c4:	6a 7d                	push   $0x7d
c00225c6:	e9 e0 fa ff ff       	jmp    c00220ab <intr_entry>

c00225cb <intr7e_stub>:
c00225cb:	55                   	push   %ebp
c00225cc:	6a 00                	push   $0x0
c00225ce:	6a 7e                	push   $0x7e
c00225d0:	e9 d6 fa ff ff       	jmp    c00220ab <intr_entry>

c00225d5 <intr7f_stub>:
c00225d5:	55                   	push   %ebp
c00225d6:	6a 00                	push   $0x0
c00225d8:	6a 7f                	push   $0x7f
c00225da:	e9 cc fa ff ff       	jmp    c00220ab <intr_entry>

c00225df <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c00225df:	55                   	push   %ebp
c00225e0:	6a 00                	push   $0x0
c00225e2:	68 80 00 00 00       	push   $0x80
c00225e7:	e9 bf fa ff ff       	jmp    c00220ab <intr_entry>

c00225ec <intr81_stub>:
c00225ec:	55                   	push   %ebp
c00225ed:	6a 00                	push   $0x0
c00225ef:	68 81 00 00 00       	push   $0x81
c00225f4:	e9 b2 fa ff ff       	jmp    c00220ab <intr_entry>

c00225f9 <intr82_stub>:
c00225f9:	55                   	push   %ebp
c00225fa:	6a 00                	push   $0x0
c00225fc:	68 82 00 00 00       	push   $0x82
c0022601:	e9 a5 fa ff ff       	jmp    c00220ab <intr_entry>

c0022606 <intr83_stub>:
c0022606:	55                   	push   %ebp
c0022607:	6a 00                	push   $0x0
c0022609:	68 83 00 00 00       	push   $0x83
c002260e:	e9 98 fa ff ff       	jmp    c00220ab <intr_entry>

c0022613 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022613:	55                   	push   %ebp
c0022614:	6a 00                	push   $0x0
c0022616:	68 84 00 00 00       	push   $0x84
c002261b:	e9 8b fa ff ff       	jmp    c00220ab <intr_entry>

c0022620 <intr85_stub>:
c0022620:	55                   	push   %ebp
c0022621:	6a 00                	push   $0x0
c0022623:	68 85 00 00 00       	push   $0x85
c0022628:	e9 7e fa ff ff       	jmp    c00220ab <intr_entry>

c002262d <intr86_stub>:
c002262d:	55                   	push   %ebp
c002262e:	6a 00                	push   $0x0
c0022630:	68 86 00 00 00       	push   $0x86
c0022635:	e9 71 fa ff ff       	jmp    c00220ab <intr_entry>

c002263a <intr87_stub>:
c002263a:	55                   	push   %ebp
c002263b:	6a 00                	push   $0x0
c002263d:	68 87 00 00 00       	push   $0x87
c0022642:	e9 64 fa ff ff       	jmp    c00220ab <intr_entry>

c0022647 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022647:	55                   	push   %ebp
c0022648:	6a 00                	push   $0x0
c002264a:	68 88 00 00 00       	push   $0x88
c002264f:	e9 57 fa ff ff       	jmp    c00220ab <intr_entry>

c0022654 <intr89_stub>:
c0022654:	55                   	push   %ebp
c0022655:	6a 00                	push   $0x0
c0022657:	68 89 00 00 00       	push   $0x89
c002265c:	e9 4a fa ff ff       	jmp    c00220ab <intr_entry>

c0022661 <intr8a_stub>:
c0022661:	55                   	push   %ebp
c0022662:	6a 00                	push   $0x0
c0022664:	68 8a 00 00 00       	push   $0x8a
c0022669:	e9 3d fa ff ff       	jmp    c00220ab <intr_entry>

c002266e <intr8b_stub>:
c002266e:	55                   	push   %ebp
c002266f:	6a 00                	push   $0x0
c0022671:	68 8b 00 00 00       	push   $0x8b
c0022676:	e9 30 fa ff ff       	jmp    c00220ab <intr_entry>

c002267b <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c002267b:	55                   	push   %ebp
c002267c:	6a 00                	push   $0x0
c002267e:	68 8c 00 00 00       	push   $0x8c
c0022683:	e9 23 fa ff ff       	jmp    c00220ab <intr_entry>

c0022688 <intr8d_stub>:
c0022688:	55                   	push   %ebp
c0022689:	6a 00                	push   $0x0
c002268b:	68 8d 00 00 00       	push   $0x8d
c0022690:	e9 16 fa ff ff       	jmp    c00220ab <intr_entry>

c0022695 <intr8e_stub>:
c0022695:	55                   	push   %ebp
c0022696:	6a 00                	push   $0x0
c0022698:	68 8e 00 00 00       	push   $0x8e
c002269d:	e9 09 fa ff ff       	jmp    c00220ab <intr_entry>

c00226a2 <intr8f_stub>:
c00226a2:	55                   	push   %ebp
c00226a3:	6a 00                	push   $0x0
c00226a5:	68 8f 00 00 00       	push   $0x8f
c00226aa:	e9 fc f9 ff ff       	jmp    c00220ab <intr_entry>

c00226af <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00226af:	55                   	push   %ebp
c00226b0:	6a 00                	push   $0x0
c00226b2:	68 90 00 00 00       	push   $0x90
c00226b7:	e9 ef f9 ff ff       	jmp    c00220ab <intr_entry>

c00226bc <intr91_stub>:
c00226bc:	55                   	push   %ebp
c00226bd:	6a 00                	push   $0x0
c00226bf:	68 91 00 00 00       	push   $0x91
c00226c4:	e9 e2 f9 ff ff       	jmp    c00220ab <intr_entry>

c00226c9 <intr92_stub>:
c00226c9:	55                   	push   %ebp
c00226ca:	6a 00                	push   $0x0
c00226cc:	68 92 00 00 00       	push   $0x92
c00226d1:	e9 d5 f9 ff ff       	jmp    c00220ab <intr_entry>

c00226d6 <intr93_stub>:
c00226d6:	55                   	push   %ebp
c00226d7:	6a 00                	push   $0x0
c00226d9:	68 93 00 00 00       	push   $0x93
c00226de:	e9 c8 f9 ff ff       	jmp    c00220ab <intr_entry>

c00226e3 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c00226e3:	55                   	push   %ebp
c00226e4:	6a 00                	push   $0x0
c00226e6:	68 94 00 00 00       	push   $0x94
c00226eb:	e9 bb f9 ff ff       	jmp    c00220ab <intr_entry>

c00226f0 <intr95_stub>:
c00226f0:	55                   	push   %ebp
c00226f1:	6a 00                	push   $0x0
c00226f3:	68 95 00 00 00       	push   $0x95
c00226f8:	e9 ae f9 ff ff       	jmp    c00220ab <intr_entry>

c00226fd <intr96_stub>:
c00226fd:	55                   	push   %ebp
c00226fe:	6a 00                	push   $0x0
c0022700:	68 96 00 00 00       	push   $0x96
c0022705:	e9 a1 f9 ff ff       	jmp    c00220ab <intr_entry>

c002270a <intr97_stub>:
c002270a:	55                   	push   %ebp
c002270b:	6a 00                	push   $0x0
c002270d:	68 97 00 00 00       	push   $0x97
c0022712:	e9 94 f9 ff ff       	jmp    c00220ab <intr_entry>

c0022717 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022717:	55                   	push   %ebp
c0022718:	6a 00                	push   $0x0
c002271a:	68 98 00 00 00       	push   $0x98
c002271f:	e9 87 f9 ff ff       	jmp    c00220ab <intr_entry>

c0022724 <intr99_stub>:
c0022724:	55                   	push   %ebp
c0022725:	6a 00                	push   $0x0
c0022727:	68 99 00 00 00       	push   $0x99
c002272c:	e9 7a f9 ff ff       	jmp    c00220ab <intr_entry>

c0022731 <intr9a_stub>:
c0022731:	55                   	push   %ebp
c0022732:	6a 00                	push   $0x0
c0022734:	68 9a 00 00 00       	push   $0x9a
c0022739:	e9 6d f9 ff ff       	jmp    c00220ab <intr_entry>

c002273e <intr9b_stub>:
c002273e:	55                   	push   %ebp
c002273f:	6a 00                	push   $0x0
c0022741:	68 9b 00 00 00       	push   $0x9b
c0022746:	e9 60 f9 ff ff       	jmp    c00220ab <intr_entry>

c002274b <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c002274b:	55                   	push   %ebp
c002274c:	6a 00                	push   $0x0
c002274e:	68 9c 00 00 00       	push   $0x9c
c0022753:	e9 53 f9 ff ff       	jmp    c00220ab <intr_entry>

c0022758 <intr9d_stub>:
c0022758:	55                   	push   %ebp
c0022759:	6a 00                	push   $0x0
c002275b:	68 9d 00 00 00       	push   $0x9d
c0022760:	e9 46 f9 ff ff       	jmp    c00220ab <intr_entry>

c0022765 <intr9e_stub>:
c0022765:	55                   	push   %ebp
c0022766:	6a 00                	push   $0x0
c0022768:	68 9e 00 00 00       	push   $0x9e
c002276d:	e9 39 f9 ff ff       	jmp    c00220ab <intr_entry>

c0022772 <intr9f_stub>:
c0022772:	55                   	push   %ebp
c0022773:	6a 00                	push   $0x0
c0022775:	68 9f 00 00 00       	push   $0x9f
c002277a:	e9 2c f9 ff ff       	jmp    c00220ab <intr_entry>

c002277f <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c002277f:	55                   	push   %ebp
c0022780:	6a 00                	push   $0x0
c0022782:	68 a0 00 00 00       	push   $0xa0
c0022787:	e9 1f f9 ff ff       	jmp    c00220ab <intr_entry>

c002278c <intra1_stub>:
c002278c:	55                   	push   %ebp
c002278d:	6a 00                	push   $0x0
c002278f:	68 a1 00 00 00       	push   $0xa1
c0022794:	e9 12 f9 ff ff       	jmp    c00220ab <intr_entry>

c0022799 <intra2_stub>:
c0022799:	55                   	push   %ebp
c002279a:	6a 00                	push   $0x0
c002279c:	68 a2 00 00 00       	push   $0xa2
c00227a1:	e9 05 f9 ff ff       	jmp    c00220ab <intr_entry>

c00227a6 <intra3_stub>:
c00227a6:	55                   	push   %ebp
c00227a7:	6a 00                	push   $0x0
c00227a9:	68 a3 00 00 00       	push   $0xa3
c00227ae:	e9 f8 f8 ff ff       	jmp    c00220ab <intr_entry>

c00227b3 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c00227b3:	55                   	push   %ebp
c00227b4:	6a 00                	push   $0x0
c00227b6:	68 a4 00 00 00       	push   $0xa4
c00227bb:	e9 eb f8 ff ff       	jmp    c00220ab <intr_entry>

c00227c0 <intra5_stub>:
c00227c0:	55                   	push   %ebp
c00227c1:	6a 00                	push   $0x0
c00227c3:	68 a5 00 00 00       	push   $0xa5
c00227c8:	e9 de f8 ff ff       	jmp    c00220ab <intr_entry>

c00227cd <intra6_stub>:
c00227cd:	55                   	push   %ebp
c00227ce:	6a 00                	push   $0x0
c00227d0:	68 a6 00 00 00       	push   $0xa6
c00227d5:	e9 d1 f8 ff ff       	jmp    c00220ab <intr_entry>

c00227da <intra7_stub>:
c00227da:	55                   	push   %ebp
c00227db:	6a 00                	push   $0x0
c00227dd:	68 a7 00 00 00       	push   $0xa7
c00227e2:	e9 c4 f8 ff ff       	jmp    c00220ab <intr_entry>

c00227e7 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c00227e7:	55                   	push   %ebp
c00227e8:	6a 00                	push   $0x0
c00227ea:	68 a8 00 00 00       	push   $0xa8
c00227ef:	e9 b7 f8 ff ff       	jmp    c00220ab <intr_entry>

c00227f4 <intra9_stub>:
c00227f4:	55                   	push   %ebp
c00227f5:	6a 00                	push   $0x0
c00227f7:	68 a9 00 00 00       	push   $0xa9
c00227fc:	e9 aa f8 ff ff       	jmp    c00220ab <intr_entry>

c0022801 <intraa_stub>:
c0022801:	55                   	push   %ebp
c0022802:	6a 00                	push   $0x0
c0022804:	68 aa 00 00 00       	push   $0xaa
c0022809:	e9 9d f8 ff ff       	jmp    c00220ab <intr_entry>

c002280e <intrab_stub>:
c002280e:	55                   	push   %ebp
c002280f:	6a 00                	push   $0x0
c0022811:	68 ab 00 00 00       	push   $0xab
c0022816:	e9 90 f8 ff ff       	jmp    c00220ab <intr_entry>

c002281b <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c002281b:	55                   	push   %ebp
c002281c:	6a 00                	push   $0x0
c002281e:	68 ac 00 00 00       	push   $0xac
c0022823:	e9 83 f8 ff ff       	jmp    c00220ab <intr_entry>

c0022828 <intrad_stub>:
c0022828:	55                   	push   %ebp
c0022829:	6a 00                	push   $0x0
c002282b:	68 ad 00 00 00       	push   $0xad
c0022830:	e9 76 f8 ff ff       	jmp    c00220ab <intr_entry>

c0022835 <intrae_stub>:
c0022835:	55                   	push   %ebp
c0022836:	6a 00                	push   $0x0
c0022838:	68 ae 00 00 00       	push   $0xae
c002283d:	e9 69 f8 ff ff       	jmp    c00220ab <intr_entry>

c0022842 <intraf_stub>:
c0022842:	55                   	push   %ebp
c0022843:	6a 00                	push   $0x0
c0022845:	68 af 00 00 00       	push   $0xaf
c002284a:	e9 5c f8 ff ff       	jmp    c00220ab <intr_entry>

c002284f <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c002284f:	55                   	push   %ebp
c0022850:	6a 00                	push   $0x0
c0022852:	68 b0 00 00 00       	push   $0xb0
c0022857:	e9 4f f8 ff ff       	jmp    c00220ab <intr_entry>

c002285c <intrb1_stub>:
c002285c:	55                   	push   %ebp
c002285d:	6a 00                	push   $0x0
c002285f:	68 b1 00 00 00       	push   $0xb1
c0022864:	e9 42 f8 ff ff       	jmp    c00220ab <intr_entry>

c0022869 <intrb2_stub>:
c0022869:	55                   	push   %ebp
c002286a:	6a 00                	push   $0x0
c002286c:	68 b2 00 00 00       	push   $0xb2
c0022871:	e9 35 f8 ff ff       	jmp    c00220ab <intr_entry>

c0022876 <intrb3_stub>:
c0022876:	55                   	push   %ebp
c0022877:	6a 00                	push   $0x0
c0022879:	68 b3 00 00 00       	push   $0xb3
c002287e:	e9 28 f8 ff ff       	jmp    c00220ab <intr_entry>

c0022883 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022883:	55                   	push   %ebp
c0022884:	6a 00                	push   $0x0
c0022886:	68 b4 00 00 00       	push   $0xb4
c002288b:	e9 1b f8 ff ff       	jmp    c00220ab <intr_entry>

c0022890 <intrb5_stub>:
c0022890:	55                   	push   %ebp
c0022891:	6a 00                	push   $0x0
c0022893:	68 b5 00 00 00       	push   $0xb5
c0022898:	e9 0e f8 ff ff       	jmp    c00220ab <intr_entry>

c002289d <intrb6_stub>:
c002289d:	55                   	push   %ebp
c002289e:	6a 00                	push   $0x0
c00228a0:	68 b6 00 00 00       	push   $0xb6
c00228a5:	e9 01 f8 ff ff       	jmp    c00220ab <intr_entry>

c00228aa <intrb7_stub>:
c00228aa:	55                   	push   %ebp
c00228ab:	6a 00                	push   $0x0
c00228ad:	68 b7 00 00 00       	push   $0xb7
c00228b2:	e9 f4 f7 ff ff       	jmp    c00220ab <intr_entry>

c00228b7 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c00228b7:	55                   	push   %ebp
c00228b8:	6a 00                	push   $0x0
c00228ba:	68 b8 00 00 00       	push   $0xb8
c00228bf:	e9 e7 f7 ff ff       	jmp    c00220ab <intr_entry>

c00228c4 <intrb9_stub>:
c00228c4:	55                   	push   %ebp
c00228c5:	6a 00                	push   $0x0
c00228c7:	68 b9 00 00 00       	push   $0xb9
c00228cc:	e9 da f7 ff ff       	jmp    c00220ab <intr_entry>

c00228d1 <intrba_stub>:
c00228d1:	55                   	push   %ebp
c00228d2:	6a 00                	push   $0x0
c00228d4:	68 ba 00 00 00       	push   $0xba
c00228d9:	e9 cd f7 ff ff       	jmp    c00220ab <intr_entry>

c00228de <intrbb_stub>:
c00228de:	55                   	push   %ebp
c00228df:	6a 00                	push   $0x0
c00228e1:	68 bb 00 00 00       	push   $0xbb
c00228e6:	e9 c0 f7 ff ff       	jmp    c00220ab <intr_entry>

c00228eb <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c00228eb:	55                   	push   %ebp
c00228ec:	6a 00                	push   $0x0
c00228ee:	68 bc 00 00 00       	push   $0xbc
c00228f3:	e9 b3 f7 ff ff       	jmp    c00220ab <intr_entry>

c00228f8 <intrbd_stub>:
c00228f8:	55                   	push   %ebp
c00228f9:	6a 00                	push   $0x0
c00228fb:	68 bd 00 00 00       	push   $0xbd
c0022900:	e9 a6 f7 ff ff       	jmp    c00220ab <intr_entry>

c0022905 <intrbe_stub>:
c0022905:	55                   	push   %ebp
c0022906:	6a 00                	push   $0x0
c0022908:	68 be 00 00 00       	push   $0xbe
c002290d:	e9 99 f7 ff ff       	jmp    c00220ab <intr_entry>

c0022912 <intrbf_stub>:
c0022912:	55                   	push   %ebp
c0022913:	6a 00                	push   $0x0
c0022915:	68 bf 00 00 00       	push   $0xbf
c002291a:	e9 8c f7 ff ff       	jmp    c00220ab <intr_entry>

c002291f <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c002291f:	55                   	push   %ebp
c0022920:	6a 00                	push   $0x0
c0022922:	68 c0 00 00 00       	push   $0xc0
c0022927:	e9 7f f7 ff ff       	jmp    c00220ab <intr_entry>

c002292c <intrc1_stub>:
c002292c:	55                   	push   %ebp
c002292d:	6a 00                	push   $0x0
c002292f:	68 c1 00 00 00       	push   $0xc1
c0022934:	e9 72 f7 ff ff       	jmp    c00220ab <intr_entry>

c0022939 <intrc2_stub>:
c0022939:	55                   	push   %ebp
c002293a:	6a 00                	push   $0x0
c002293c:	68 c2 00 00 00       	push   $0xc2
c0022941:	e9 65 f7 ff ff       	jmp    c00220ab <intr_entry>

c0022946 <intrc3_stub>:
c0022946:	55                   	push   %ebp
c0022947:	6a 00                	push   $0x0
c0022949:	68 c3 00 00 00       	push   $0xc3
c002294e:	e9 58 f7 ff ff       	jmp    c00220ab <intr_entry>

c0022953 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022953:	55                   	push   %ebp
c0022954:	6a 00                	push   $0x0
c0022956:	68 c4 00 00 00       	push   $0xc4
c002295b:	e9 4b f7 ff ff       	jmp    c00220ab <intr_entry>

c0022960 <intrc5_stub>:
c0022960:	55                   	push   %ebp
c0022961:	6a 00                	push   $0x0
c0022963:	68 c5 00 00 00       	push   $0xc5
c0022968:	e9 3e f7 ff ff       	jmp    c00220ab <intr_entry>

c002296d <intrc6_stub>:
c002296d:	55                   	push   %ebp
c002296e:	6a 00                	push   $0x0
c0022970:	68 c6 00 00 00       	push   $0xc6
c0022975:	e9 31 f7 ff ff       	jmp    c00220ab <intr_entry>

c002297a <intrc7_stub>:
c002297a:	55                   	push   %ebp
c002297b:	6a 00                	push   $0x0
c002297d:	68 c7 00 00 00       	push   $0xc7
c0022982:	e9 24 f7 ff ff       	jmp    c00220ab <intr_entry>

c0022987 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022987:	55                   	push   %ebp
c0022988:	6a 00                	push   $0x0
c002298a:	68 c8 00 00 00       	push   $0xc8
c002298f:	e9 17 f7 ff ff       	jmp    c00220ab <intr_entry>

c0022994 <intrc9_stub>:
c0022994:	55                   	push   %ebp
c0022995:	6a 00                	push   $0x0
c0022997:	68 c9 00 00 00       	push   $0xc9
c002299c:	e9 0a f7 ff ff       	jmp    c00220ab <intr_entry>

c00229a1 <intrca_stub>:
c00229a1:	55                   	push   %ebp
c00229a2:	6a 00                	push   $0x0
c00229a4:	68 ca 00 00 00       	push   $0xca
c00229a9:	e9 fd f6 ff ff       	jmp    c00220ab <intr_entry>

c00229ae <intrcb_stub>:
c00229ae:	55                   	push   %ebp
c00229af:	6a 00                	push   $0x0
c00229b1:	68 cb 00 00 00       	push   $0xcb
c00229b6:	e9 f0 f6 ff ff       	jmp    c00220ab <intr_entry>

c00229bb <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c00229bb:	55                   	push   %ebp
c00229bc:	6a 00                	push   $0x0
c00229be:	68 cc 00 00 00       	push   $0xcc
c00229c3:	e9 e3 f6 ff ff       	jmp    c00220ab <intr_entry>

c00229c8 <intrcd_stub>:
c00229c8:	55                   	push   %ebp
c00229c9:	6a 00                	push   $0x0
c00229cb:	68 cd 00 00 00       	push   $0xcd
c00229d0:	e9 d6 f6 ff ff       	jmp    c00220ab <intr_entry>

c00229d5 <intrce_stub>:
c00229d5:	55                   	push   %ebp
c00229d6:	6a 00                	push   $0x0
c00229d8:	68 ce 00 00 00       	push   $0xce
c00229dd:	e9 c9 f6 ff ff       	jmp    c00220ab <intr_entry>

c00229e2 <intrcf_stub>:
c00229e2:	55                   	push   %ebp
c00229e3:	6a 00                	push   $0x0
c00229e5:	68 cf 00 00 00       	push   $0xcf
c00229ea:	e9 bc f6 ff ff       	jmp    c00220ab <intr_entry>

c00229ef <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c00229ef:	55                   	push   %ebp
c00229f0:	6a 00                	push   $0x0
c00229f2:	68 d0 00 00 00       	push   $0xd0
c00229f7:	e9 af f6 ff ff       	jmp    c00220ab <intr_entry>

c00229fc <intrd1_stub>:
c00229fc:	55                   	push   %ebp
c00229fd:	6a 00                	push   $0x0
c00229ff:	68 d1 00 00 00       	push   $0xd1
c0022a04:	e9 a2 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a09 <intrd2_stub>:
c0022a09:	55                   	push   %ebp
c0022a0a:	6a 00                	push   $0x0
c0022a0c:	68 d2 00 00 00       	push   $0xd2
c0022a11:	e9 95 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a16 <intrd3_stub>:
c0022a16:	55                   	push   %ebp
c0022a17:	6a 00                	push   $0x0
c0022a19:	68 d3 00 00 00       	push   $0xd3
c0022a1e:	e9 88 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a23 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022a23:	55                   	push   %ebp
c0022a24:	6a 00                	push   $0x0
c0022a26:	68 d4 00 00 00       	push   $0xd4
c0022a2b:	e9 7b f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a30 <intrd5_stub>:
c0022a30:	55                   	push   %ebp
c0022a31:	6a 00                	push   $0x0
c0022a33:	68 d5 00 00 00       	push   $0xd5
c0022a38:	e9 6e f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a3d <intrd6_stub>:
c0022a3d:	55                   	push   %ebp
c0022a3e:	6a 00                	push   $0x0
c0022a40:	68 d6 00 00 00       	push   $0xd6
c0022a45:	e9 61 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a4a <intrd7_stub>:
c0022a4a:	55                   	push   %ebp
c0022a4b:	6a 00                	push   $0x0
c0022a4d:	68 d7 00 00 00       	push   $0xd7
c0022a52:	e9 54 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a57 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022a57:	55                   	push   %ebp
c0022a58:	6a 00                	push   $0x0
c0022a5a:	68 d8 00 00 00       	push   $0xd8
c0022a5f:	e9 47 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a64 <intrd9_stub>:
c0022a64:	55                   	push   %ebp
c0022a65:	6a 00                	push   $0x0
c0022a67:	68 d9 00 00 00       	push   $0xd9
c0022a6c:	e9 3a f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a71 <intrda_stub>:
c0022a71:	55                   	push   %ebp
c0022a72:	6a 00                	push   $0x0
c0022a74:	68 da 00 00 00       	push   $0xda
c0022a79:	e9 2d f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a7e <intrdb_stub>:
c0022a7e:	55                   	push   %ebp
c0022a7f:	6a 00                	push   $0x0
c0022a81:	68 db 00 00 00       	push   $0xdb
c0022a86:	e9 20 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a8b <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022a8b:	55                   	push   %ebp
c0022a8c:	6a 00                	push   $0x0
c0022a8e:	68 dc 00 00 00       	push   $0xdc
c0022a93:	e9 13 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022a98 <intrdd_stub>:
c0022a98:	55                   	push   %ebp
c0022a99:	6a 00                	push   $0x0
c0022a9b:	68 dd 00 00 00       	push   $0xdd
c0022aa0:	e9 06 f6 ff ff       	jmp    c00220ab <intr_entry>

c0022aa5 <intrde_stub>:
c0022aa5:	55                   	push   %ebp
c0022aa6:	6a 00                	push   $0x0
c0022aa8:	68 de 00 00 00       	push   $0xde
c0022aad:	e9 f9 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022ab2 <intrdf_stub>:
c0022ab2:	55                   	push   %ebp
c0022ab3:	6a 00                	push   $0x0
c0022ab5:	68 df 00 00 00       	push   $0xdf
c0022aba:	e9 ec f5 ff ff       	jmp    c00220ab <intr_entry>

c0022abf <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022abf:	55                   	push   %ebp
c0022ac0:	6a 00                	push   $0x0
c0022ac2:	68 e0 00 00 00       	push   $0xe0
c0022ac7:	e9 df f5 ff ff       	jmp    c00220ab <intr_entry>

c0022acc <intre1_stub>:
c0022acc:	55                   	push   %ebp
c0022acd:	6a 00                	push   $0x0
c0022acf:	68 e1 00 00 00       	push   $0xe1
c0022ad4:	e9 d2 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022ad9 <intre2_stub>:
c0022ad9:	55                   	push   %ebp
c0022ada:	6a 00                	push   $0x0
c0022adc:	68 e2 00 00 00       	push   $0xe2
c0022ae1:	e9 c5 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022ae6 <intre3_stub>:
c0022ae6:	55                   	push   %ebp
c0022ae7:	6a 00                	push   $0x0
c0022ae9:	68 e3 00 00 00       	push   $0xe3
c0022aee:	e9 b8 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022af3 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022af3:	55                   	push   %ebp
c0022af4:	6a 00                	push   $0x0
c0022af6:	68 e4 00 00 00       	push   $0xe4
c0022afb:	e9 ab f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b00 <intre5_stub>:
c0022b00:	55                   	push   %ebp
c0022b01:	6a 00                	push   $0x0
c0022b03:	68 e5 00 00 00       	push   $0xe5
c0022b08:	e9 9e f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b0d <intre6_stub>:
c0022b0d:	55                   	push   %ebp
c0022b0e:	6a 00                	push   $0x0
c0022b10:	68 e6 00 00 00       	push   $0xe6
c0022b15:	e9 91 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b1a <intre7_stub>:
c0022b1a:	55                   	push   %ebp
c0022b1b:	6a 00                	push   $0x0
c0022b1d:	68 e7 00 00 00       	push   $0xe7
c0022b22:	e9 84 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b27 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022b27:	55                   	push   %ebp
c0022b28:	6a 00                	push   $0x0
c0022b2a:	68 e8 00 00 00       	push   $0xe8
c0022b2f:	e9 77 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b34 <intre9_stub>:
c0022b34:	55                   	push   %ebp
c0022b35:	6a 00                	push   $0x0
c0022b37:	68 e9 00 00 00       	push   $0xe9
c0022b3c:	e9 6a f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b41 <intrea_stub>:
c0022b41:	55                   	push   %ebp
c0022b42:	6a 00                	push   $0x0
c0022b44:	68 ea 00 00 00       	push   $0xea
c0022b49:	e9 5d f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b4e <intreb_stub>:
c0022b4e:	55                   	push   %ebp
c0022b4f:	6a 00                	push   $0x0
c0022b51:	68 eb 00 00 00       	push   $0xeb
c0022b56:	e9 50 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b5b <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022b5b:	55                   	push   %ebp
c0022b5c:	6a 00                	push   $0x0
c0022b5e:	68 ec 00 00 00       	push   $0xec
c0022b63:	e9 43 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b68 <intred_stub>:
c0022b68:	55                   	push   %ebp
c0022b69:	6a 00                	push   $0x0
c0022b6b:	68 ed 00 00 00       	push   $0xed
c0022b70:	e9 36 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b75 <intree_stub>:
c0022b75:	55                   	push   %ebp
c0022b76:	6a 00                	push   $0x0
c0022b78:	68 ee 00 00 00       	push   $0xee
c0022b7d:	e9 29 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b82 <intref_stub>:
c0022b82:	55                   	push   %ebp
c0022b83:	6a 00                	push   $0x0
c0022b85:	68 ef 00 00 00       	push   $0xef
c0022b8a:	e9 1c f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b8f <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022b8f:	55                   	push   %ebp
c0022b90:	6a 00                	push   $0x0
c0022b92:	68 f0 00 00 00       	push   $0xf0
c0022b97:	e9 0f f5 ff ff       	jmp    c00220ab <intr_entry>

c0022b9c <intrf1_stub>:
c0022b9c:	55                   	push   %ebp
c0022b9d:	6a 00                	push   $0x0
c0022b9f:	68 f1 00 00 00       	push   $0xf1
c0022ba4:	e9 02 f5 ff ff       	jmp    c00220ab <intr_entry>

c0022ba9 <intrf2_stub>:
c0022ba9:	55                   	push   %ebp
c0022baa:	6a 00                	push   $0x0
c0022bac:	68 f2 00 00 00       	push   $0xf2
c0022bb1:	e9 f5 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022bb6 <intrf3_stub>:
c0022bb6:	55                   	push   %ebp
c0022bb7:	6a 00                	push   $0x0
c0022bb9:	68 f3 00 00 00       	push   $0xf3
c0022bbe:	e9 e8 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022bc3 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022bc3:	55                   	push   %ebp
c0022bc4:	6a 00                	push   $0x0
c0022bc6:	68 f4 00 00 00       	push   $0xf4
c0022bcb:	e9 db f4 ff ff       	jmp    c00220ab <intr_entry>

c0022bd0 <intrf5_stub>:
c0022bd0:	55                   	push   %ebp
c0022bd1:	6a 00                	push   $0x0
c0022bd3:	68 f5 00 00 00       	push   $0xf5
c0022bd8:	e9 ce f4 ff ff       	jmp    c00220ab <intr_entry>

c0022bdd <intrf6_stub>:
c0022bdd:	55                   	push   %ebp
c0022bde:	6a 00                	push   $0x0
c0022be0:	68 f6 00 00 00       	push   $0xf6
c0022be5:	e9 c1 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022bea <intrf7_stub>:
c0022bea:	55                   	push   %ebp
c0022beb:	6a 00                	push   $0x0
c0022bed:	68 f7 00 00 00       	push   $0xf7
c0022bf2:	e9 b4 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022bf7 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022bf7:	55                   	push   %ebp
c0022bf8:	6a 00                	push   $0x0
c0022bfa:	68 f8 00 00 00       	push   $0xf8
c0022bff:	e9 a7 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c04 <intrf9_stub>:
c0022c04:	55                   	push   %ebp
c0022c05:	6a 00                	push   $0x0
c0022c07:	68 f9 00 00 00       	push   $0xf9
c0022c0c:	e9 9a f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c11 <intrfa_stub>:
c0022c11:	55                   	push   %ebp
c0022c12:	6a 00                	push   $0x0
c0022c14:	68 fa 00 00 00       	push   $0xfa
c0022c19:	e9 8d f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c1e <intrfb_stub>:
c0022c1e:	55                   	push   %ebp
c0022c1f:	6a 00                	push   $0x0
c0022c21:	68 fb 00 00 00       	push   $0xfb
c0022c26:	e9 80 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c2b <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022c2b:	55                   	push   %ebp
c0022c2c:	6a 00                	push   $0x0
c0022c2e:	68 fc 00 00 00       	push   $0xfc
c0022c33:	e9 73 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c38 <intrfd_stub>:
c0022c38:	55                   	push   %ebp
c0022c39:	6a 00                	push   $0x0
c0022c3b:	68 fd 00 00 00       	push   $0xfd
c0022c40:	e9 66 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c45 <intrfe_stub>:
c0022c45:	55                   	push   %ebp
c0022c46:	6a 00                	push   $0x0
c0022c48:	68 fe 00 00 00       	push   $0xfe
c0022c4d:	e9 59 f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c52 <intrff_stub>:
c0022c52:	55                   	push   %ebp
c0022c53:	6a 00                	push   $0x0
c0022c55:	68 ff 00 00 00       	push   $0xff
c0022c5a:	e9 4c f4 ff ff       	jmp    c00220ab <intr_entry>

c0022c5f <sema_cmp_priority>:
    lock_acquire(lock);
}

bool sema_cmp_priority(const struct list_elem *a,
                       const struct list_elem *b,
                       void *aux) {
c0022c5f:	56                   	push   %esi
c0022c60:	53                   	push   %ebx
c0022c61:	83 ec 10             	sub    $0x10,%esp
c0022c64:	e8 2e ac 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022c69:	81 c3 97 78 01 00    	add    $0x17897,%ebx
    struct semaphore_elem *sema_a = list_entry(a, struct semaphore_elem, elem);
    struct semaphore_elem *sema_b = list_entry(b, struct semaphore_elem, elem);
    int priority_a = list_entry(list_front(&sema_a->semaphore.waiters), struct thread, elem)->priority;
c0022c6f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0022c73:	83 c0 0c             	add    $0xc,%eax
c0022c76:	50                   	push   %eax
c0022c77:	e8 fd 69 00 00       	call   c0029679 <list_front>
c0022c7c:	8b b0 1c ff ff ff    	mov    -0xe4(%eax),%esi
    int priority_b = list_entry(list_front(&sema_b->semaphore.waiters), struct thread, elem)->priority;
c0022c82:	8b 44 24 24          	mov    0x24(%esp),%eax
c0022c86:	83 c0 0c             	add    $0xc,%eax
c0022c89:	89 04 24             	mov    %eax,(%esp)
c0022c8c:	e8 e8 69 00 00       	call   c0029679 <list_front>
    return priority_a > priority_b;
c0022c91:	3b b0 1c ff ff ff    	cmp    -0xe4(%eax),%esi
c0022c97:	0f 9f c0             	setg   %al
}
c0022c9a:	83 c4 14             	add    $0x14,%esp
c0022c9d:	5b                   	pop    %ebx
c0022c9e:	5e                   	pop    %esi
c0022c9f:	c3                   	ret    

c0022ca0 <sema_init>:
sema_init(struct semaphore *sema, unsigned value) {
c0022ca0:	53                   	push   %ebx
c0022ca1:	83 ec 08             	sub    $0x8,%esp
c0022ca4:	e8 ee ab 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022ca9:	81 c3 57 78 01 00    	add    $0x17857,%ebx
c0022caf:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (sema != NULL);
c0022cb3:	85 c0                	test   %eax,%eax
c0022cb5:	74 17                	je     c0022cce <sema_init+0x2e>
    sema->value = value;
c0022cb7:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022cbb:	89 10                	mov    %edx,(%eax)
    list_init(&sema->waiters);
c0022cbd:	83 ec 0c             	sub    $0xc,%esp
c0022cc0:	83 c0 04             	add    $0x4,%eax
c0022cc3:	50                   	push   %eax
c0022cc4:	e8 e8 62 00 00       	call   c0028fb1 <list_init>
}
c0022cc9:	83 c4 18             	add    $0x18,%esp
c0022ccc:	5b                   	pop    %ebx
c0022ccd:	c3                   	ret    
    ASSERT (sema != NULL);
c0022cce:	83 ec 0c             	sub    $0xc,%esp
c0022cd1:	8d 83 76 4d ff ff    	lea    -0xb28a(%ebx),%eax
c0022cd7:	50                   	push   %eax
c0022cd8:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0022cde:	50                   	push   %eax
c0022cdf:	8d 83 44 36 ff ff    	lea    -0xc9bc(%ebx),%eax
c0022ce5:	50                   	push   %eax
c0022ce6:	6a 2e                	push   $0x2e
c0022ce8:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0022cee:	50                   	push   %eax
c0022cef:	e8 f0 61 00 00       	call   c0028ee4 <debug_panic>

c0022cf4 <sema_down>:
sema_down(struct semaphore *sema) {
c0022cf4:	55                   	push   %ebp
c0022cf5:	57                   	push   %edi
c0022cf6:	56                   	push   %esi
c0022cf7:	53                   	push   %ebx
c0022cf8:	83 ec 1c             	sub    $0x1c,%esp
c0022cfb:	e8 97 ab 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022d00:	81 c3 00 78 01 00    	add    $0x17800,%ebx
c0022d06:	8b 7c 24 30          	mov    0x30(%esp),%edi
    ASSERT (sema != NULL);
c0022d0a:	85 ff                	test   %edi,%edi
c0022d0c:	74 5d                	je     c0022d6b <sema_down+0x77>
    ASSERT (!intr_context());
c0022d0e:	e8 b6 f0 ff ff       	call   c0021dc9 <intr_context>
c0022d13:	84 c0                	test   %al,%al
c0022d15:	75 7a                	jne    c0022d91 <sema_down+0x9d>
    old_level = intr_disable();
c0022d17:	e8 07 ee ff ff       	call   c0021b23 <intr_disable>
c0022d1c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    while (sema->value == 0) {
c0022d20:	8b 07                	mov    (%edi),%eax
c0022d22:	85 c0                	test   %eax,%eax
c0022d24:	75 2c                	jne    c0022d52 <sema_down+0x5e>
        list_insert_ordered(&sema->waiters, &thread_current()->elem, get_cmp_priority_func(), NULL);
c0022d26:	8d 6f 04             	lea    0x4(%edi),%ebp
c0022d29:	e8 bb df ff ff       	call   c0020ce9 <get_cmp_priority_func>
c0022d2e:	89 c6                	mov    %eax,%esi
c0022d30:	e8 78 e0 ff ff       	call   c0020dad <thread_current>
c0022d35:	6a 00                	push   $0x0
c0022d37:	56                   	push   %esi
c0022d38:	05 08 01 00 00       	add    $0x108,%eax
c0022d3d:	50                   	push   %eax
c0022d3e:	55                   	push   %ebp
c0022d3f:	e8 64 6d 00 00       	call   c0029aa8 <list_insert_ordered>
        thread_block();
c0022d44:	e8 e5 e5 ff ff       	call   c002132e <thread_block>
    while (sema->value == 0) {
c0022d49:	8b 07                	mov    (%edi),%eax
c0022d4b:	83 c4 10             	add    $0x10,%esp
c0022d4e:	85 c0                	test   %eax,%eax
c0022d50:	74 d7                	je     c0022d29 <sema_down+0x35>
    sema->value--;
c0022d52:	83 e8 01             	sub    $0x1,%eax
c0022d55:	89 07                	mov    %eax,(%edi)
    intr_set_level(old_level);
c0022d57:	83 ec 0c             	sub    $0xc,%esp
c0022d5a:	ff 74 24 18          	pushl  0x18(%esp)
c0022d5e:	e8 c7 ed ff ff       	call   c0021b2a <intr_set_level>
}
c0022d63:	83 c4 2c             	add    $0x2c,%esp
c0022d66:	5b                   	pop    %ebx
c0022d67:	5e                   	pop    %esi
c0022d68:	5f                   	pop    %edi
c0022d69:	5d                   	pop    %ebp
c0022d6a:	c3                   	ret    
    ASSERT (sema != NULL);
c0022d6b:	83 ec 0c             	sub    $0xc,%esp
c0022d6e:	8d 83 76 4d ff ff    	lea    -0xb28a(%ebx),%eax
c0022d74:	50                   	push   %eax
c0022d75:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0022d7b:	50                   	push   %eax
c0022d7c:	8d 83 38 36 ff ff    	lea    -0xc9c8(%ebx),%eax
c0022d82:	50                   	push   %eax
c0022d83:	6a 3f                	push   $0x3f
c0022d85:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0022d8b:	50                   	push   %eax
c0022d8c:	e8 53 61 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (!intr_context());
c0022d91:	83 ec 0c             	sub    $0xc,%esp
c0022d94:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c0022d9a:	50                   	push   %eax
c0022d9b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0022da1:	50                   	push   %eax
c0022da2:	8d 83 38 36 ff ff    	lea    -0xc9c8(%ebx),%eax
c0022da8:	50                   	push   %eax
c0022da9:	6a 40                	push   $0x40
c0022dab:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0022db1:	50                   	push   %eax
c0022db2:	e8 2d 61 00 00       	call   c0028ee4 <debug_panic>

c0022db7 <sema_try_down>:
sema_try_down(struct semaphore *sema) {
c0022db7:	57                   	push   %edi
c0022db8:	56                   	push   %esi
c0022db9:	53                   	push   %ebx
c0022dba:	e8 d8 aa 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022dbf:	81 c3 41 77 01 00    	add    $0x17741,%ebx
c0022dc5:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (sema != NULL);
c0022dc9:	85 f6                	test   %esi,%esi
c0022dcb:	74 2c                	je     c0022df9 <sema_try_down+0x42>
    old_level = intr_disable();
c0022dcd:	e8 51 ed ff ff       	call   c0021b23 <intr_disable>
    if (sema->value > 0) {
c0022dd2:	8b 16                	mov    (%esi),%edx
        success = false;
c0022dd4:	bf 00 00 00 00       	mov    $0x0,%edi
    if (sema->value > 0) {
c0022dd9:	85 d2                	test   %edx,%edx
c0022ddb:	74 0a                	je     c0022de7 <sema_try_down+0x30>
        sema->value--;
c0022ddd:	83 ea 01             	sub    $0x1,%edx
c0022de0:	89 16                	mov    %edx,(%esi)
        success = true;
c0022de2:	bf 01 00 00 00       	mov    $0x1,%edi
    intr_set_level(old_level);
c0022de7:	83 ec 0c             	sub    $0xc,%esp
c0022dea:	50                   	push   %eax
c0022deb:	e8 3a ed ff ff       	call   c0021b2a <intr_set_level>
    return success;
c0022df0:	83 c4 10             	add    $0x10,%esp
}
c0022df3:	89 f8                	mov    %edi,%eax
c0022df5:	5b                   	pop    %ebx
c0022df6:	5e                   	pop    %esi
c0022df7:	5f                   	pop    %edi
c0022df8:	c3                   	ret    
    ASSERT (sema != NULL);
c0022df9:	83 ec 0c             	sub    $0xc,%esp
c0022dfc:	8d 83 76 4d ff ff    	lea    -0xb28a(%ebx),%eax
c0022e02:	50                   	push   %eax
c0022e03:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0022e09:	50                   	push   %eax
c0022e0a:	8d 83 28 36 ff ff    	lea    -0xc9d8(%ebx),%eax
c0022e10:	50                   	push   %eax
c0022e11:	6a 55                	push   $0x55
c0022e13:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0022e19:	50                   	push   %eax
c0022e1a:	e8 c5 60 00 00       	call   c0028ee4 <debug_panic>

c0022e1f <sema_up>:
sema_up(struct semaphore *sema) {
c0022e1f:	57                   	push   %edi
c0022e20:	56                   	push   %esi
c0022e21:	53                   	push   %ebx
c0022e22:	e8 70 aa 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022e27:	81 c3 d9 76 01 00    	add    $0x176d9,%ebx
c0022e2d:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (sema != NULL);
c0022e31:	85 f6                	test   %esi,%esi
c0022e33:	74 32                	je     c0022e67 <sema_up+0x48>
    old_level = intr_disable();
c0022e35:	e8 e9 ec ff ff       	call   c0021b23 <intr_disable>
c0022e3a:	89 c7                	mov    %eax,%edi
    sema->value++;
c0022e3c:	83 06 01             	addl   $0x1,(%esi)
    if (!list_empty(&sema->waiters)) {
c0022e3f:	83 c6 04             	add    $0x4,%esi
c0022e42:	83 ec 0c             	sub    $0xc,%esp
c0022e45:	56                   	push   %esi
c0022e46:	e8 0a 68 00 00       	call   c0029655 <list_empty>
c0022e4b:	83 c4 10             	add    $0x10,%esp
c0022e4e:	84 c0                	test   %al,%al
c0022e50:	74 3b                	je     c0022e8d <sema_up+0x6e>
    thread_yield();
c0022e52:	e8 74 e6 ff ff       	call   c00214cb <thread_yield>
    intr_set_level(old_level);
c0022e57:	83 ec 0c             	sub    $0xc,%esp
c0022e5a:	57                   	push   %edi
c0022e5b:	e8 ca ec ff ff       	call   c0021b2a <intr_set_level>
}
c0022e60:	83 c4 10             	add    $0x10,%esp
c0022e63:	5b                   	pop    %ebx
c0022e64:	5e                   	pop    %esi
c0022e65:	5f                   	pop    %edi
c0022e66:	c3                   	ret    
    ASSERT (sema != NULL);
c0022e67:	83 ec 0c             	sub    $0xc,%esp
c0022e6a:	8d 83 76 4d ff ff    	lea    -0xb28a(%ebx),%eax
c0022e70:	50                   	push   %eax
c0022e71:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0022e77:	50                   	push   %eax
c0022e78:	8d 83 20 36 ff ff    	lea    -0xc9e0(%ebx),%eax
c0022e7e:	50                   	push   %eax
c0022e7f:	6a 6d                	push   $0x6d
c0022e81:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0022e87:	50                   	push   %eax
c0022e88:	e8 57 60 00 00       	call   c0028ee4 <debug_panic>
        list_sort(&sema->waiters, get_cmp_priority_func(), NULL);
c0022e8d:	e8 57 de ff ff       	call   c0020ce9 <get_cmp_priority_func>
c0022e92:	83 ec 04             	sub    $0x4,%esp
c0022e95:	6a 00                	push   $0x0
c0022e97:	50                   	push   %eax
c0022e98:	56                   	push   %esi
c0022e99:	e8 1d 69 00 00       	call   c00297bb <list_sort>
        thread_unblock(list_entry (list_pop_front(&sema->waiters),
c0022e9e:	89 34 24             	mov    %esi,(%esp)
c0022ea1:	e8 26 68 00 00       	call   c00296cc <list_pop_front>
c0022ea6:	2d 08 01 00 00       	sub    $0x108,%eax
c0022eab:	89 04 24             	mov    %eax,(%esp)
c0022eae:	e8 47 de ff ff       	call   c0020cfa <thread_unblock>
c0022eb3:	83 c4 10             	add    $0x10,%esp
c0022eb6:	eb 9a                	jmp    c0022e52 <sema_up+0x33>

c0022eb8 <sema_test_helper>:
sema_test_helper(void *sema_) {
c0022eb8:	57                   	push   %edi
c0022eb9:	56                   	push   %esi
c0022eba:	53                   	push   %ebx
c0022ebb:	8b 74 24 10          	mov    0x10(%esp),%esi
c0022ebf:	bb 0a 00 00 00       	mov    $0xa,%ebx
        sema_up(&sema[1]);
c0022ec4:	8d 7e 14             	lea    0x14(%esi),%edi
        sema_down(&sema[0]);
c0022ec7:	83 ec 0c             	sub    $0xc,%esp
c0022eca:	56                   	push   %esi
c0022ecb:	e8 24 fe ff ff       	call   c0022cf4 <sema_down>
        sema_up(&sema[1]);
c0022ed0:	89 3c 24             	mov    %edi,(%esp)
c0022ed3:	e8 47 ff ff ff       	call   c0022e1f <sema_up>
    for (i = 0; i < 10; i++) {
c0022ed8:	83 c4 10             	add    $0x10,%esp
c0022edb:	83 eb 01             	sub    $0x1,%ebx
c0022ede:	75 e7                	jne    c0022ec7 <sema_test_helper+0xf>
}
c0022ee0:	5b                   	pop    %ebx
c0022ee1:	5e                   	pop    %esi
c0022ee2:	5f                   	pop    %edi
c0022ee3:	c3                   	ret    

c0022ee4 <sema_self_test>:
sema_self_test(void) {
c0022ee4:	55                   	push   %ebp
c0022ee5:	57                   	push   %edi
c0022ee6:	56                   	push   %esi
c0022ee7:	53                   	push   %ebx
c0022ee8:	83 ec 48             	sub    $0x48,%esp
c0022eeb:	e8 a7 a9 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022ef0:	81 c3 10 76 01 00    	add    $0x17610,%ebx
    printf("Testing semaphores...");
c0022ef6:	8d 83 99 4d ff ff    	lea    -0xb267(%ebx),%eax
c0022efc:	50                   	push   %eax
c0022efd:	e8 86 43 00 00       	call   c0027288 <printf>
    sema_init(&sema[0], 0);
c0022f02:	83 c4 08             	add    $0x8,%esp
c0022f05:	6a 00                	push   $0x0
c0022f07:	8d 74 24 14          	lea    0x14(%esp),%esi
c0022f0b:	56                   	push   %esi
c0022f0c:	e8 8f fd ff ff       	call   c0022ca0 <sema_init>
    sema_init(&sema[1], 0);
c0022f11:	83 c4 08             	add    $0x8,%esp
c0022f14:	6a 00                	push   $0x0
c0022f16:	8d 44 24 28          	lea    0x28(%esp),%eax
c0022f1a:	50                   	push   %eax
c0022f1b:	e8 80 fd ff ff       	call   c0022ca0 <sema_init>
    thread_create("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022f20:	56                   	push   %esi
c0022f21:	8d 83 b8 89 fe ff    	lea    -0x17648(%ebx),%eax
c0022f27:	50                   	push   %eax
c0022f28:	6a 1f                	push   $0x1f
c0022f2a:	8d 83 af 4d ff ff    	lea    -0xb251(%ebx),%eax
c0022f30:	50                   	push   %eax
c0022f31:	e8 26 e6 ff ff       	call   c002155c <thread_create>
c0022f36:	83 c4 20             	add    $0x20,%esp
c0022f39:	be 0a 00 00 00       	mov    $0xa,%esi
        sema_up(&sema[0]);
c0022f3e:	8d 6c 24 08          	lea    0x8(%esp),%ebp
        sema_down(&sema[1]);
c0022f42:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
        sema_up(&sema[0]);
c0022f46:	83 ec 0c             	sub    $0xc,%esp
c0022f49:	55                   	push   %ebp
c0022f4a:	e8 d0 fe ff ff       	call   c0022e1f <sema_up>
        sema_down(&sema[1]);
c0022f4f:	89 3c 24             	mov    %edi,(%esp)
c0022f52:	e8 9d fd ff ff       	call   c0022cf4 <sema_down>
    for (i = 0; i < 10; i++) {
c0022f57:	83 c4 10             	add    $0x10,%esp
c0022f5a:	83 ee 01             	sub    $0x1,%esi
c0022f5d:	75 e7                	jne    c0022f46 <sema_self_test+0x62>
    printf("done.\n");
c0022f5f:	83 ec 0c             	sub    $0xc,%esp
c0022f62:	8d 83 b9 4d ff ff    	lea    -0xb247(%ebx),%eax
c0022f68:	50                   	push   %eax
c0022f69:	e8 97 7e 00 00       	call   c002ae05 <puts>
}
c0022f6e:	83 c4 4c             	add    $0x4c,%esp
c0022f71:	5b                   	pop    %ebx
c0022f72:	5e                   	pop    %esi
c0022f73:	5f                   	pop    %edi
c0022f74:	5d                   	pop    %ebp
c0022f75:	c3                   	ret    

c0022f76 <lock_init>:
lock_init(struct lock *lock) {
c0022f76:	53                   	push   %ebx
c0022f77:	83 ec 08             	sub    $0x8,%esp
c0022f7a:	e8 18 a9 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022f7f:	81 c3 81 75 01 00    	add    $0x17581,%ebx
c0022f85:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (lock != NULL);
c0022f89:	85 c0                	test   %eax,%eax
c0022f8b:	74 19                	je     c0022fa6 <lock_init+0x30>
    lock->holder = NULL;
c0022f8d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    sema_init(&lock->semaphore, 1);
c0022f93:	83 ec 08             	sub    $0x8,%esp
c0022f96:	6a 01                	push   $0x1
c0022f98:	83 c0 04             	add    $0x4,%eax
c0022f9b:	50                   	push   %eax
c0022f9c:	e8 ff fc ff ff       	call   c0022ca0 <sema_init>
}
c0022fa1:	83 c4 18             	add    $0x18,%esp
c0022fa4:	5b                   	pop    %ebx
c0022fa5:	c3                   	ret    
    ASSERT (lock != NULL);
c0022fa6:	83 ec 0c             	sub    $0xc,%esp
c0022fa9:	8d 83 bf 4d ff ff    	lea    -0xb241(%ebx),%eax
c0022faf:	50                   	push   %eax
c0022fb0:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0022fb6:	50                   	push   %eax
c0022fb7:	8d 83 14 36 ff ff    	lea    -0xc9ec(%ebx),%eax
c0022fbd:	50                   	push   %eax
c0022fbe:	68 b3 00 00 00       	push   $0xb3
c0022fc3:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0022fc9:	50                   	push   %eax
c0022fca:	e8 15 5f 00 00       	call   c0028ee4 <debug_panic>

c0022fcf <lock_held_by_current_thread>:
lock_held_by_current_thread(const struct lock *lock) {
c0022fcf:	56                   	push   %esi
c0022fd0:	53                   	push   %ebx
c0022fd1:	83 ec 04             	sub    $0x4,%esp
c0022fd4:	e8 be a8 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0022fd9:	81 c3 27 75 01 00    	add    $0x17527,%ebx
c0022fdf:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (lock != NULL);
c0022fe3:	85 c0                	test   %eax,%eax
c0022fe5:	74 12                	je     c0022ff9 <lock_held_by_current_thread+0x2a>
    return lock->holder == thread_current();
c0022fe7:	8b 30                	mov    (%eax),%esi
c0022fe9:	e8 bf dd ff ff       	call   c0020dad <thread_current>
c0022fee:	39 c6                	cmp    %eax,%esi
c0022ff0:	0f 94 c0             	sete   %al
}
c0022ff3:	83 c4 04             	add    $0x4,%esp
c0022ff6:	5b                   	pop    %ebx
c0022ff7:	5e                   	pop    %esi
c0022ff8:	c3                   	ret    
    ASSERT (lock != NULL);
c0022ff9:	83 ec 0c             	sub    $0xc,%esp
c0022ffc:	8d 83 bf 4d ff ff    	lea    -0xb241(%ebx),%eax
c0023002:	50                   	push   %eax
c0023003:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023009:	50                   	push   %eax
c002300a:	8d 83 c4 35 ff ff    	lea    -0xca3c(%ebx),%eax
c0023010:	50                   	push   %eax
c0023011:	68 0d 01 00 00       	push   $0x10d
c0023016:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c002301c:	50                   	push   %eax
c002301d:	e8 c2 5e 00 00       	call   c0028ee4 <debug_panic>

c0023022 <lock_acquire>:
lock_acquire(struct lock *lock) {
c0023022:	55                   	push   %ebp
c0023023:	57                   	push   %edi
c0023024:	56                   	push   %esi
c0023025:	53                   	push   %ebx
c0023026:	83 ec 0c             	sub    $0xc,%esp
c0023029:	e8 69 a8 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002302e:	81 c3 d2 74 01 00    	add    $0x174d2,%ebx
c0023034:	8b 7c 24 20          	mov    0x20(%esp),%edi
    struct thread *current_thread = thread_current();
c0023038:	e8 70 dd ff ff       	call   c0020dad <thread_current>
    ASSERT (lock != NULL);
c002303d:	85 ff                	test   %edi,%edi
c002303f:	0f 84 a6 00 00 00    	je     c00230eb <lock_acquire+0xc9>
c0023045:	89 c5                	mov    %eax,%ebp
    ASSERT (!intr_context());
c0023047:	e8 7d ed ff ff       	call   c0021dc9 <intr_context>
c002304c:	84 c0                	test   %al,%al
c002304e:	0f 85 c0 00 00 00    	jne    c0023114 <lock_acquire+0xf2>
    ASSERT (!lock_held_by_current_thread(lock));
c0023054:	83 ec 0c             	sub    $0xc,%esp
c0023057:	57                   	push   %edi
c0023058:	e8 72 ff ff ff       	call   c0022fcf <lock_held_by_current_thread>
c002305d:	83 c4 10             	add    $0x10,%esp
c0023060:	84 c0                	test   %al,%al
c0023062:	0f 85 d5 00 00 00    	jne    c002313d <lock_acquire+0x11b>
    if (lock->holder != NULL && !thread_mlfqs) {
c0023068:	83 3f 00             	cmpl   $0x0,(%edi)
c002306b:	74 3f                	je     c00230ac <lock_acquire+0x8a>
c002306d:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c0023073:	80 38 00             	cmpb   $0x0,(%eax)
c0023076:	75 34                	jne    c00230ac <lock_acquire+0x8a>
        current_thread->lock_waiting = lock;
c0023078:	89 bd 04 01 00 00    	mov    %edi,0x104(%ebp)
        while (l && current_thread->priority > l->max_priority) {
c002307e:	8b 45 24             	mov    0x24(%ebp),%eax
c0023081:	3b 47 20             	cmp    0x20(%edi),%eax
c0023084:	7e 26                	jle    c00230ac <lock_acquire+0x8a>
        l = lock;
c0023086:	89 fe                	mov    %edi,%esi
            l->max_priority = current_thread->priority;
c0023088:	89 46 20             	mov    %eax,0x20(%esi)
            thread_donate_priority(l->holder);
c002308b:	83 ec 0c             	sub    $0xc,%esp
c002308e:	ff 36                	pushl  (%esi)
c0023090:	e8 b4 e7 ff ff       	call   c0021849 <thread_donate_priority>
            l = l->holder->lock_waiting;
c0023095:	8b 06                	mov    (%esi),%eax
c0023097:	8b b0 04 01 00 00    	mov    0x104(%eax),%esi
        while (l && current_thread->priority > l->max_priority) {
c002309d:	83 c4 10             	add    $0x10,%esp
c00230a0:	85 f6                	test   %esi,%esi
c00230a2:	74 08                	je     c00230ac <lock_acquire+0x8a>
c00230a4:	8b 45 24             	mov    0x24(%ebp),%eax
c00230a7:	3b 46 20             	cmp    0x20(%esi),%eax
c00230aa:	7f dc                	jg     c0023088 <lock_acquire+0x66>
    sema_down(&lock->semaphore);
c00230ac:	83 ec 0c             	sub    $0xc,%esp
c00230af:	8d 47 04             	lea    0x4(%edi),%eax
c00230b2:	50                   	push   %eax
c00230b3:	e8 3c fc ff ff       	call   c0022cf4 <sema_down>
    enum intr_level old_level = intr_disable();
c00230b8:	e8 66 ea ff ff       	call   c0021b23 <intr_disable>
c00230bd:	89 c5                	mov    %eax,%ebp
    current_thread = thread_current();
c00230bf:	e8 e9 dc ff ff       	call   c0020dad <thread_current>
c00230c4:	89 c6                	mov    %eax,%esi
    if (!thread_mlfqs) {
c00230c6:	83 c4 10             	add    $0x10,%esp
c00230c9:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c00230cf:	80 38 00             	cmpb   $0x0,(%eax)
c00230d2:	0f 84 8e 00 00 00    	je     c0023166 <lock_acquire+0x144>
    lock->holder = current_thread;
c00230d8:	89 37                	mov    %esi,(%edi)
    intr_set_level(old_level);
c00230da:	83 ec 0c             	sub    $0xc,%esp
c00230dd:	55                   	push   %ebp
c00230de:	e8 47 ea ff ff       	call   c0021b2a <intr_set_level>
}
c00230e3:	83 c4 1c             	add    $0x1c,%esp
c00230e6:	5b                   	pop    %ebx
c00230e7:	5e                   	pop    %esi
c00230e8:	5f                   	pop    %edi
c00230e9:	5d                   	pop    %ebp
c00230ea:	c3                   	ret    
    ASSERT (lock != NULL);
c00230eb:	83 ec 0c             	sub    $0xc,%esp
c00230ee:	8d 83 bf 4d ff ff    	lea    -0xb241(%ebx),%eax
c00230f4:	50                   	push   %eax
c00230f5:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00230fb:	50                   	push   %eax
c00230fc:	8d 83 04 36 ff ff    	lea    -0xc9fc(%ebx),%eax
c0023102:	50                   	push   %eax
c0023103:	68 c6 00 00 00       	push   $0xc6
c0023108:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c002310e:	50                   	push   %eax
c002310f:	e8 d0 5d 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (!intr_context());
c0023114:	83 ec 0c             	sub    $0xc,%esp
c0023117:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c002311d:	50                   	push   %eax
c002311e:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023124:	50                   	push   %eax
c0023125:	8d 83 04 36 ff ff    	lea    -0xc9fc(%ebx),%eax
c002312b:	50                   	push   %eax
c002312c:	68 c7 00 00 00       	push   $0xc7
c0023131:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0023137:	50                   	push   %eax
c0023138:	e8 a7 5d 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (!lock_held_by_current_thread(lock));
c002313d:	83 ec 0c             	sub    $0xc,%esp
c0023140:	8d 83 dc 4d ff ff    	lea    -0xb224(%ebx),%eax
c0023146:	50                   	push   %eax
c0023147:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002314d:	50                   	push   %eax
c002314e:	8d 83 04 36 ff ff    	lea    -0xc9fc(%ebx),%eax
c0023154:	50                   	push   %eax
c0023155:	68 c8 00 00 00       	push   $0xc8
c002315a:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0023160:	50                   	push   %eax
c0023161:	e8 7e 5d 00 00       	call   c0028ee4 <debug_panic>
        current_thread->lock_waiting = NULL;
c0023166:	c7 86 04 01 00 00 00 	movl   $0x0,0x104(%esi)
c002316d:	00 00 00 
        lock->max_priority = current_thread->priority;
c0023170:	8b 46 24             	mov    0x24(%esi),%eax
c0023173:	89 47 20             	mov    %eax,0x20(%edi)
        thread_hold_the_lock(lock);
c0023176:	83 ec 0c             	sub    $0xc,%esp
c0023179:	57                   	push   %edi
c002317a:	e8 71 e7 ff ff       	call   c00218f0 <thread_hold_the_lock>
c002317f:	83 c4 10             	add    $0x10,%esp
c0023182:	e9 51 ff ff ff       	jmp    c00230d8 <lock_acquire+0xb6>

c0023187 <lock_try_acquire>:
lock_try_acquire(struct lock *lock) {
c0023187:	57                   	push   %edi
c0023188:	56                   	push   %esi
c0023189:	53                   	push   %ebx
c002318a:	e8 08 a7 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002318f:	81 c3 71 73 01 00    	add    $0x17371,%ebx
c0023195:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (lock != NULL);
c0023199:	85 f6                	test   %esi,%esi
c002319b:	74 2b                	je     c00231c8 <lock_try_acquire+0x41>
    ASSERT (!lock_held_by_current_thread(lock));
c002319d:	83 ec 0c             	sub    $0xc,%esp
c00231a0:	56                   	push   %esi
c00231a1:	e8 29 fe ff ff       	call   c0022fcf <lock_held_by_current_thread>
c00231a6:	83 c4 10             	add    $0x10,%esp
c00231a9:	84 c0                	test   %al,%al
c00231ab:	75 44                	jne    c00231f1 <lock_try_acquire+0x6a>
    success = sema_try_down(&lock->semaphore);
c00231ad:	83 ec 0c             	sub    $0xc,%esp
c00231b0:	8d 46 04             	lea    0x4(%esi),%eax
c00231b3:	50                   	push   %eax
c00231b4:	e8 fe fb ff ff       	call   c0022db7 <sema_try_down>
c00231b9:	89 c7                	mov    %eax,%edi
    if (success)
c00231bb:	83 c4 10             	add    $0x10,%esp
c00231be:	84 c0                	test   %al,%al
c00231c0:	75 58                	jne    c002321a <lock_try_acquire+0x93>
}
c00231c2:	89 f8                	mov    %edi,%eax
c00231c4:	5b                   	pop    %ebx
c00231c5:	5e                   	pop    %esi
c00231c6:	5f                   	pop    %edi
c00231c7:	c3                   	ret    
    ASSERT (lock != NULL);
c00231c8:	83 ec 0c             	sub    $0xc,%esp
c00231cb:	8d 83 bf 4d ff ff    	lea    -0xb241(%ebx),%eax
c00231d1:	50                   	push   %eax
c00231d2:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00231d8:	50                   	push   %eax
c00231d9:	8d 83 f0 35 ff ff    	lea    -0xca10(%ebx),%eax
c00231df:	50                   	push   %eax
c00231e0:	68 ee 00 00 00       	push   $0xee
c00231e5:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c00231eb:	50                   	push   %eax
c00231ec:	e8 f3 5c 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (!lock_held_by_current_thread(lock));
c00231f1:	83 ec 0c             	sub    $0xc,%esp
c00231f4:	8d 83 dc 4d ff ff    	lea    -0xb224(%ebx),%eax
c00231fa:	50                   	push   %eax
c00231fb:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023201:	50                   	push   %eax
c0023202:	8d 83 f0 35 ff ff    	lea    -0xca10(%ebx),%eax
c0023208:	50                   	push   %eax
c0023209:	68 ef 00 00 00       	push   $0xef
c002320e:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0023214:	50                   	push   %eax
c0023215:	e8 ca 5c 00 00       	call   c0028ee4 <debug_panic>
        lock->holder = thread_current();
c002321a:	e8 8e db ff ff       	call   c0020dad <thread_current>
c002321f:	89 06                	mov    %eax,(%esi)
    return success;
c0023221:	eb 9f                	jmp    c00231c2 <lock_try_acquire+0x3b>

c0023223 <lock_release>:
lock_release(struct lock *lock) {
c0023223:	56                   	push   %esi
c0023224:	53                   	push   %ebx
c0023225:	83 ec 04             	sub    $0x4,%esp
c0023228:	e8 6a a6 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002322d:	81 c3 d3 72 01 00    	add    $0x172d3,%ebx
c0023233:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (lock != NULL);
c0023237:	85 f6                	test   %esi,%esi
c0023239:	74 33                	je     c002326e <lock_release+0x4b>
    ASSERT (lock_held_by_current_thread(lock));
c002323b:	83 ec 0c             	sub    $0xc,%esp
c002323e:	56                   	push   %esi
c002323f:	e8 8b fd ff ff       	call   c0022fcf <lock_held_by_current_thread>
c0023244:	83 c4 10             	add    $0x10,%esp
c0023247:	84 c0                	test   %al,%al
c0023249:	74 4c                	je     c0023297 <lock_release+0x74>
    lock->holder = NULL;
c002324b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    if (!thread_mlfqs)
c0023251:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c0023257:	80 38 00             	cmpb   $0x0,(%eax)
c002325a:	74 64                	je     c00232c0 <lock_release+0x9d>
    sema_up(&lock->semaphore);
c002325c:	83 ec 0c             	sub    $0xc,%esp
c002325f:	83 c6 04             	add    $0x4,%esi
c0023262:	56                   	push   %esi
c0023263:	e8 b7 fb ff ff       	call   c0022e1f <sema_up>
}
c0023268:	83 c4 14             	add    $0x14,%esp
c002326b:	5b                   	pop    %ebx
c002326c:	5e                   	pop    %esi
c002326d:	c3                   	ret    
    ASSERT (lock != NULL);
c002326e:	83 ec 0c             	sub    $0xc,%esp
c0023271:	8d 83 bf 4d ff ff    	lea    -0xb241(%ebx),%eax
c0023277:	50                   	push   %eax
c0023278:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002327e:	50                   	push   %eax
c002327f:	8d 83 e0 35 ff ff    	lea    -0xca20(%ebx),%eax
c0023285:	50                   	push   %eax
c0023286:	68 fe 00 00 00       	push   $0xfe
c002328b:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0023291:	50                   	push   %eax
c0023292:	e8 4d 5c 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c0023297:	83 ec 0c             	sub    $0xc,%esp
c002329a:	8d 83 00 4e ff ff    	lea    -0xb200(%ebx),%eax
c00232a0:	50                   	push   %eax
c00232a1:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00232a7:	50                   	push   %eax
c00232a8:	8d 83 e0 35 ff ff    	lea    -0xca20(%ebx),%eax
c00232ae:	50                   	push   %eax
c00232af:	68 ff 00 00 00       	push   $0xff
c00232b4:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c00232ba:	50                   	push   %eax
c00232bb:	e8 24 5c 00 00       	call   c0028ee4 <debug_panic>
        thread_remove_lock(lock);
c00232c0:	83 ec 0c             	sub    $0xc,%esp
c00232c3:	56                   	push   %esi
c00232c4:	e8 e5 e5 ff ff       	call   c00218ae <thread_remove_lock>
c00232c9:	83 c4 10             	add    $0x10,%esp
c00232cc:	eb 8e                	jmp    c002325c <lock_release+0x39>

c00232ce <cond_init>:
cond_init(struct condition *cond) {
c00232ce:	53                   	push   %ebx
c00232cf:	83 ec 08             	sub    $0x8,%esp
c00232d2:	e8 c0 a5 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00232d7:	81 c3 29 72 01 00    	add    $0x17229,%ebx
c00232dd:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (cond != NULL);
c00232e1:	85 c0                	test   %eax,%eax
c00232e3:	74 0e                	je     c00232f3 <cond_init+0x25>
    list_init(&cond->waiters);
c00232e5:	83 ec 0c             	sub    $0xc,%esp
c00232e8:	50                   	push   %eax
c00232e9:	e8 c3 5c 00 00       	call   c0028fb1 <list_init>
}
c00232ee:	83 c4 18             	add    $0x18,%esp
c00232f1:	5b                   	pop    %ebx
c00232f2:	c3                   	ret    
    ASSERT (cond != NULL);
c00232f3:	83 ec 0c             	sub    $0xc,%esp
c00232f6:	8d 83 cc 4d ff ff    	lea    -0xb234(%ebx),%eax
c00232fc:	50                   	push   %eax
c00232fd:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023303:	50                   	push   %eax
c0023304:	8d 83 b8 35 ff ff    	lea    -0xca48(%ebx),%eax
c002330a:	50                   	push   %eax
c002330b:	68 1d 01 00 00       	push   $0x11d
c0023310:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0023316:	50                   	push   %eax
c0023317:	e8 c8 5b 00 00       	call   c0028ee4 <debug_panic>

c002331c <cond_wait>:
cond_wait(struct condition *cond, struct lock *lock) {
c002331c:	55                   	push   %ebp
c002331d:	57                   	push   %edi
c002331e:	56                   	push   %esi
c002331f:	53                   	push   %ebx
c0023320:	83 ec 2c             	sub    $0x2c,%esp
c0023323:	e8 7b a5 00 00       	call   c002d8a3 <__x86.get_pc_thunk.di>
c0023328:	81 c7 d8 71 01 00    	add    $0x171d8,%edi
c002332e:	8b 74 24 44          	mov    0x44(%esp),%esi
    ASSERT (cond != NULL);
c0023332:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c0023337:	74 6d                	je     c00233a6 <cond_wait+0x8a>
    ASSERT (lock != NULL);
c0023339:	85 f6                	test   %esi,%esi
c002333b:	0f 84 90 00 00 00    	je     c00233d1 <cond_wait+0xb5>
    ASSERT (!intr_context());
c0023341:	89 fb                	mov    %edi,%ebx
c0023343:	e8 81 ea ff ff       	call   c0021dc9 <intr_context>
c0023348:	84 c0                	test   %al,%al
c002334a:	0f 85 ac 00 00 00    	jne    c00233fc <cond_wait+0xe0>
    ASSERT (lock_held_by_current_thread(lock));
c0023350:	83 ec 0c             	sub    $0xc,%esp
c0023353:	56                   	push   %esi
c0023354:	e8 76 fc ff ff       	call   c0022fcf <lock_held_by_current_thread>
c0023359:	83 c4 10             	add    $0x10,%esp
c002335c:	84 c0                	test   %al,%al
c002335e:	0f 84 c1 00 00 00    	je     c0023425 <cond_wait+0x109>
    sema_init(&waiter.semaphore, 0);
c0023364:	83 ec 08             	sub    $0x8,%esp
c0023367:	6a 00                	push   $0x0
c0023369:	8d 5c 24 10          	lea    0x10(%esp),%ebx
c002336d:	8d 6c 24 18          	lea    0x18(%esp),%ebp
c0023371:	55                   	push   %ebp
c0023372:	e8 29 f9 ff ff       	call   c0022ca0 <sema_init>
    list_push_back(&cond->waiters, &waiter.elem);
c0023377:	83 c4 08             	add    $0x8,%esp
c002337a:	53                   	push   %ebx
c002337b:	ff 74 24 4c          	pushl  0x4c(%esp)
c002337f:	89 fb                	mov    %edi,%ebx
c0023381:	e8 10 62 00 00       	call   c0029596 <list_push_back>
    lock_release(lock);
c0023386:	89 34 24             	mov    %esi,(%esp)
c0023389:	e8 95 fe ff ff       	call   c0023223 <lock_release>
    sema_down(&waiter.semaphore);
c002338e:	89 2c 24             	mov    %ebp,(%esp)
c0023391:	e8 5e f9 ff ff       	call   c0022cf4 <sema_down>
    lock_acquire(lock);
c0023396:	89 34 24             	mov    %esi,(%esp)
c0023399:	e8 84 fc ff ff       	call   c0023022 <lock_acquire>
}
c002339e:	83 c4 3c             	add    $0x3c,%esp
c00233a1:	5b                   	pop    %ebx
c00233a2:	5e                   	pop    %esi
c00233a3:	5f                   	pop    %edi
c00233a4:	5d                   	pop    %ebp
c00233a5:	c3                   	ret    
    ASSERT (cond != NULL);
c00233a6:	83 ec 0c             	sub    $0xc,%esp
c00233a9:	8d 87 cc 4d ff ff    	lea    -0xb234(%edi),%eax
c00233af:	50                   	push   %eax
c00233b0:	8d 87 96 44 ff ff    	lea    -0xbb6a(%edi),%eax
c00233b6:	50                   	push   %eax
c00233b7:	8d 87 ac 35 ff ff    	lea    -0xca54(%edi),%eax
c00233bd:	50                   	push   %eax
c00233be:	68 3a 01 00 00       	push   $0x13a
c00233c3:	8d 87 83 4d ff ff    	lea    -0xb27d(%edi),%eax
c00233c9:	50                   	push   %eax
c00233ca:	89 fb                	mov    %edi,%ebx
c00233cc:	e8 13 5b 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (lock != NULL);
c00233d1:	83 ec 0c             	sub    $0xc,%esp
c00233d4:	8d 87 bf 4d ff ff    	lea    -0xb241(%edi),%eax
c00233da:	50                   	push   %eax
c00233db:	8d 87 96 44 ff ff    	lea    -0xbb6a(%edi),%eax
c00233e1:	50                   	push   %eax
c00233e2:	8d 87 ac 35 ff ff    	lea    -0xca54(%edi),%eax
c00233e8:	50                   	push   %eax
c00233e9:	68 3b 01 00 00       	push   $0x13b
c00233ee:	8d 87 83 4d ff ff    	lea    -0xb27d(%edi),%eax
c00233f4:	50                   	push   %eax
c00233f5:	89 fb                	mov    %edi,%ebx
c00233f7:	e8 e8 5a 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (!intr_context());
c00233fc:	83 ec 0c             	sub    $0xc,%esp
c00233ff:	8d 87 a8 49 ff ff    	lea    -0xb658(%edi),%eax
c0023405:	50                   	push   %eax
c0023406:	8d 87 96 44 ff ff    	lea    -0xbb6a(%edi),%eax
c002340c:	50                   	push   %eax
c002340d:	8d 87 ac 35 ff ff    	lea    -0xca54(%edi),%eax
c0023413:	50                   	push   %eax
c0023414:	68 3c 01 00 00       	push   $0x13c
c0023419:	8d 87 83 4d ff ff    	lea    -0xb27d(%edi),%eax
c002341f:	50                   	push   %eax
c0023420:	e8 bf 5a 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c0023425:	83 ec 0c             	sub    $0xc,%esp
c0023428:	8d 87 00 4e ff ff    	lea    -0xb200(%edi),%eax
c002342e:	50                   	push   %eax
c002342f:	8d 87 96 44 ff ff    	lea    -0xbb6a(%edi),%eax
c0023435:	50                   	push   %eax
c0023436:	8d 87 ac 35 ff ff    	lea    -0xca54(%edi),%eax
c002343c:	50                   	push   %eax
c002343d:	68 3d 01 00 00       	push   $0x13d
c0023442:	8d 87 83 4d ff ff    	lea    -0xb27d(%edi),%eax
c0023448:	50                   	push   %eax
c0023449:	e8 96 5a 00 00       	call   c0028ee4 <debug_panic>

c002344e <cond_signal>:

   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal(struct condition *cond, struct lock *lock UNUSED) {
c002344e:	57                   	push   %edi
c002344f:	56                   	push   %esi
c0023450:	53                   	push   %ebx
c0023451:	e8 41 a4 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023456:	81 c3 aa 70 01 00    	add    $0x170aa,%ebx
c002345c:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023460:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (cond != NULL);
c0023464:	85 f6                	test   %esi,%esi
c0023466:	74 4e                	je     c00234b6 <cond_signal+0x68>
    ASSERT (lock != NULL);
c0023468:	85 ff                	test   %edi,%edi
c002346a:	74 73                	je     c00234df <cond_signal+0x91>
    ASSERT (!intr_context());
c002346c:	e8 58 e9 ff ff       	call   c0021dc9 <intr_context>
c0023471:	84 c0                	test   %al,%al
c0023473:	0f 85 8f 00 00 00    	jne    c0023508 <cond_signal+0xba>
    ASSERT (lock_held_by_current_thread(lock));
c0023479:	83 ec 0c             	sub    $0xc,%esp
c002347c:	57                   	push   %edi
c002347d:	e8 4d fb ff ff       	call   c0022fcf <lock_held_by_current_thread>
c0023482:	83 c4 10             	add    $0x10,%esp
c0023485:	84 c0                	test   %al,%al
c0023487:	0f 84 a4 00 00 00    	je     c0023531 <cond_signal+0xe3>
    list_sort(&cond->waiters, sema_cmp_priority, NULL);
c002348d:	83 ec 04             	sub    $0x4,%esp
c0023490:	6a 00                	push   $0x0
c0023492:	8d 83 5f 87 fe ff    	lea    -0x178a1(%ebx),%eax
c0023498:	50                   	push   %eax
c0023499:	56                   	push   %esi
c002349a:	e8 1c 63 00 00       	call   c00297bb <list_sort>
    // put the one with least sema value at front
    if (!list_empty(&cond->waiters))
c002349f:	89 34 24             	mov    %esi,(%esp)
c00234a2:	e8 ae 61 00 00       	call   c0029655 <list_empty>
c00234a7:	83 c4 10             	add    $0x10,%esp
c00234aa:	84 c0                	test   %al,%al
c00234ac:	0f 84 a8 00 00 00    	je     c002355a <cond_signal+0x10c>
        sema_up(&list_entry (list_pop_front(&cond->waiters),
                             struct semaphore_elem, elem)->semaphore);
}
c00234b2:	5b                   	pop    %ebx
c00234b3:	5e                   	pop    %esi
c00234b4:	5f                   	pop    %edi
c00234b5:	c3                   	ret    
    ASSERT (cond != NULL);
c00234b6:	83 ec 0c             	sub    $0xc,%esp
c00234b9:	8d 83 cc 4d ff ff    	lea    -0xb234(%ebx),%eax
c00234bf:	50                   	push   %eax
c00234c0:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00234c6:	50                   	push   %eax
c00234c7:	8d 83 a0 35 ff ff    	lea    -0xca60(%ebx),%eax
c00234cd:	50                   	push   %eax
c00234ce:	68 59 01 00 00       	push   $0x159
c00234d3:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c00234d9:	50                   	push   %eax
c00234da:	e8 05 5a 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (lock != NULL);
c00234df:	83 ec 0c             	sub    $0xc,%esp
c00234e2:	8d 83 bf 4d ff ff    	lea    -0xb241(%ebx),%eax
c00234e8:	50                   	push   %eax
c00234e9:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00234ef:	50                   	push   %eax
c00234f0:	8d 83 a0 35 ff ff    	lea    -0xca60(%ebx),%eax
c00234f6:	50                   	push   %eax
c00234f7:	68 5a 01 00 00       	push   $0x15a
c00234fc:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0023502:	50                   	push   %eax
c0023503:	e8 dc 59 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (!intr_context());
c0023508:	83 ec 0c             	sub    $0xc,%esp
c002350b:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c0023511:	50                   	push   %eax
c0023512:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023518:	50                   	push   %eax
c0023519:	8d 83 a0 35 ff ff    	lea    -0xca60(%ebx),%eax
c002351f:	50                   	push   %eax
c0023520:	68 5b 01 00 00       	push   $0x15b
c0023525:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c002352b:	50                   	push   %eax
c002352c:	e8 b3 59 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c0023531:	83 ec 0c             	sub    $0xc,%esp
c0023534:	8d 83 00 4e ff ff    	lea    -0xb200(%ebx),%eax
c002353a:	50                   	push   %eax
c002353b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023541:	50                   	push   %eax
c0023542:	8d 83 a0 35 ff ff    	lea    -0xca60(%ebx),%eax
c0023548:	50                   	push   %eax
c0023549:	68 5c 01 00 00       	push   $0x15c
c002354e:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c0023554:	50                   	push   %eax
c0023555:	e8 8a 59 00 00       	call   c0028ee4 <debug_panic>
        sema_up(&list_entry (list_pop_front(&cond->waiters),
c002355a:	83 ec 0c             	sub    $0xc,%esp
c002355d:	56                   	push   %esi
c002355e:	e8 69 61 00 00       	call   c00296cc <list_pop_front>
c0023563:	83 c0 08             	add    $0x8,%eax
c0023566:	89 04 24             	mov    %eax,(%esp)
c0023569:	e8 b1 f8 ff ff       	call   c0022e1f <sema_up>
c002356e:	83 c4 10             	add    $0x10,%esp
}
c0023571:	e9 3c ff ff ff       	jmp    c00234b2 <cond_signal+0x64>

c0023576 <cond_broadcast>:

   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast(struct condition *cond, struct lock *lock) {
c0023576:	57                   	push   %edi
c0023577:	56                   	push   %esi
c0023578:	53                   	push   %ebx
c0023579:	e8 19 a3 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002357e:	81 c3 82 6f 01 00    	add    $0x16f82,%ebx
c0023584:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023588:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (cond != NULL);
c002358c:	85 f6                	test   %esi,%esi
c002358e:	74 23                	je     c00235b3 <cond_broadcast+0x3d>
    ASSERT (lock != NULL);
c0023590:	85 ff                	test   %edi,%edi
c0023592:	74 48                	je     c00235dc <cond_broadcast+0x66>

    while (!list_empty(&cond->waiters))
c0023594:	83 ec 0c             	sub    $0xc,%esp
c0023597:	56                   	push   %esi
c0023598:	e8 b8 60 00 00       	call   c0029655 <list_empty>
c002359d:	83 c4 10             	add    $0x10,%esp
c00235a0:	84 c0                	test   %al,%al
c00235a2:	75 61                	jne    c0023605 <cond_broadcast+0x8f>
        cond_signal(cond, lock);
c00235a4:	83 ec 08             	sub    $0x8,%esp
c00235a7:	57                   	push   %edi
c00235a8:	56                   	push   %esi
c00235a9:	e8 a0 fe ff ff       	call   c002344e <cond_signal>
c00235ae:	83 c4 10             	add    $0x10,%esp
c00235b1:	eb e1                	jmp    c0023594 <cond_broadcast+0x1e>
    ASSERT (cond != NULL);
c00235b3:	83 ec 0c             	sub    $0xc,%esp
c00235b6:	8d 83 cc 4d ff ff    	lea    -0xb234(%ebx),%eax
c00235bc:	50                   	push   %eax
c00235bd:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00235c3:	50                   	push   %eax
c00235c4:	8d 83 90 35 ff ff    	lea    -0xca70(%ebx),%eax
c00235ca:	50                   	push   %eax
c00235cb:	68 6c 01 00 00       	push   $0x16c
c00235d0:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c00235d6:	50                   	push   %eax
c00235d7:	e8 08 59 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (lock != NULL);
c00235dc:	83 ec 0c             	sub    $0xc,%esp
c00235df:	8d 83 bf 4d ff ff    	lea    -0xb241(%ebx),%eax
c00235e5:	50                   	push   %eax
c00235e6:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00235ec:	50                   	push   %eax
c00235ed:	8d 83 90 35 ff ff    	lea    -0xca70(%ebx),%eax
c00235f3:	50                   	push   %eax
c00235f4:	68 6d 01 00 00       	push   $0x16d
c00235f9:	8d 83 83 4d ff ff    	lea    -0xb27d(%ebx),%eax
c00235ff:	50                   	push   %eax
c0023600:	e8 df 58 00 00       	call   c0028ee4 <debug_panic>
}
c0023605:	5b                   	pop    %ebx
c0023606:	5e                   	pop    %esi
c0023607:	5f                   	pop    %edi
c0023608:	c3                   	ret    

c0023609 <init_pool>:
}

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool(struct pool *p, void *base, size_t page_cnt, const char *name) {
c0023609:	55                   	push   %ebp
c002360a:	57                   	push   %edi
c002360b:	56                   	push   %esi
c002360c:	53                   	push   %ebx
c002360d:	83 ec 28             	sub    $0x28,%esp
c0023610:	e8 82 a2 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023615:	81 c3 eb 6e 01 00    	add    $0x16eeb,%ebx
c002361b:	89 c5                	mov    %eax,%ebp
c002361d:	89 54 24 18          	mov    %edx,0x18(%esp)
c0023621:	89 cf                	mov    %ecx,%edi
    /* We'll put the pool's used_map at its base.
       Calculate the space needed for the bitmap
       and subtract it from the pool's size. */
    size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size(page_cnt), PGSIZE); // page_id = size / pgsize
c0023623:	51                   	push   %ecx
c0023624:	e8 63 67 00 00       	call   c0029d8c <bitmap_buf_size>
c0023629:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
c002362f:	89 f0                	mov    %esi,%eax
c0023631:	c1 e8 0c             	shr    $0xc,%eax
    if (bm_pages > page_cnt)
c0023634:	83 c4 10             	add    $0x10,%esp
c0023637:	39 c7                	cmp    %eax,%edi
c0023639:	72 44                	jb     c002367f <init_pool+0x76>
        PANIC ("Not enough memory in %s for bitmap.", name);
    page_cnt -= bm_pages;
c002363b:	29 c7                	sub    %eax,%edi

    printf("%zu pages available in %s.\n", page_cnt, name);
c002363d:	83 ec 04             	sub    $0x4,%esp
c0023640:	ff 74 24 34          	pushl  0x34(%esp)
c0023644:	57                   	push   %edi
c0023645:	8d 83 8e 4e ff ff    	lea    -0xb172(%ebx),%eax
c002364b:	50                   	push   %eax
c002364c:	e8 37 3c 00 00       	call   c0027288 <printf>

    /* Initialize the pool. */
    lock_init(&p->lock);
c0023651:	89 2c 24             	mov    %ebp,(%esp)
c0023654:	e8 1d f9 ff ff       	call   c0022f76 <lock_init>
    p->used_map = bitmap_create_in_buf(page_cnt, base, bm_pages * PGSIZE);
c0023659:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c002365f:	83 c4 0c             	add    $0xc,%esp
c0023662:	56                   	push   %esi
c0023663:	ff 74 24 14          	pushl  0x14(%esp)
c0023667:	57                   	push   %edi
c0023668:	e8 88 6a 00 00       	call   c002a0f5 <bitmap_create_in_buf>
c002366d:	89 45 24             	mov    %eax,0x24(%ebp)
    p->base = base + bm_pages * PGSIZE;
c0023670:	03 74 24 1c          	add    0x1c(%esp),%esi
c0023674:	89 75 28             	mov    %esi,0x28(%ebp)
}
c0023677:	83 c4 2c             	add    $0x2c,%esp
c002367a:	5b                   	pop    %ebx
c002367b:	5e                   	pop    %esi
c002367c:	5f                   	pop    %edi
c002367d:	5d                   	pop    %ebp
c002367e:	c3                   	ret    
        PANIC ("Not enough memory in %s for bitmap.", name);
c002367f:	83 ec 0c             	sub    $0xc,%esp
c0023682:	ff 74 24 3c          	pushl  0x3c(%esp)
c0023686:	8d 83 24 4e ff ff    	lea    -0xb1dc(%ebx),%eax
c002368c:	50                   	push   %eax
c002368d:	8d 83 7c 36 ff ff    	lea    -0xc984(%ebx),%eax
c0023693:	50                   	push   %eax
c0023694:	68 98 00 00 00       	push   $0x98
c0023699:	8d 83 77 4e ff ff    	lea    -0xb189(%ebx),%eax
c002369f:	50                   	push   %eax
c00236a0:	e8 3f 58 00 00       	call   c0028ee4 <debug_panic>

c00236a5 <palloc_init>:
palloc_init(size_t user_page_limit) {
c00236a5:	57                   	push   %edi
c00236a6:	56                   	push   %esi
c00236a7:	53                   	push   %ebx
c00236a8:	e8 ea a1 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00236ad:	81 c3 53 6e 01 00    	add    $0x16e53,%ebx
c00236b3:	8b 54 24 10          	mov    0x10(%esp),%edx
    uint8_t *free_end = ptov(init_ram_pages * PGSIZE); // num * 4KB
c00236b7:	c7 c0 be 01 02 c0    	mov    $0xc00201be,%eax
c00236bd:	8b 00                	mov    (%eax),%eax
c00236bf:	c1 e0 0c             	shl    $0xc,%eax
    ASSERT ((void *) paddr < PHYS_BASE);
c00236c2:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00236c7:	77 5e                	ja     c0023727 <palloc_init+0x82>
    size_t free_pages = (free_end - free_start) / PGSIZE;
c00236c9:	8d b0 ff 0f f0 ff    	lea    -0xff001(%eax),%esi
c00236cf:	2d 00 00 10 00       	sub    $0x100000,%eax
c00236d4:	0f 49 f0             	cmovns %eax,%esi
c00236d7:	c1 fe 0c             	sar    $0xc,%esi
    size_t user_pages = free_pages / 2;
c00236da:	89 f7                	mov    %esi,%edi
c00236dc:	d1 ef                	shr    %edi
    if (user_pages > user_page_limit)
c00236de:	39 d7                	cmp    %edx,%edi
c00236e0:	0f 47 fa             	cmova  %edx,%edi
    kernel_pages = free_pages - user_pages;
c00236e3:	29 fe                	sub    %edi,%esi
    init_pool(&kernel_pool, free_start, kernel_pages, "kernel pool");
c00236e5:	83 ec 0c             	sub    $0xc,%esp
c00236e8:	8d 83 c5 4e ff ff    	lea    -0xb13b(%ebx),%eax
c00236ee:	50                   	push   %eax
c00236ef:	89 f1                	mov    %esi,%ecx
c00236f1:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c00236f6:	8d 83 20 16 00 00    	lea    0x1620(%ebx),%eax
c00236fc:	e8 08 ff ff ff       	call   c0023609 <init_pool>
    init_pool(&user_pool, free_start + kernel_pages * PGSIZE,
c0023701:	c1 e6 0c             	shl    $0xc,%esi
c0023704:	8d 96 00 00 10 c0    	lea    -0x3ff00000(%esi),%edx
c002370a:	8d 83 d1 4e ff ff    	lea    -0xb12f(%ebx),%eax
c0023710:	89 04 24             	mov    %eax,(%esp)
c0023713:	89 f9                	mov    %edi,%ecx
c0023715:	8d 83 e0 15 00 00    	lea    0x15e0(%ebx),%eax
c002371b:	e8 e9 fe ff ff       	call   c0023609 <init_pool>
}
c0023720:	83 c4 10             	add    $0x10,%esp
c0023723:	5b                   	pop    %ebx
c0023724:	5e                   	pop    %esi
c0023725:	5f                   	pop    %edi
c0023726:	c3                   	ret    
c0023727:	83 ec 0c             	sub    $0xc,%esp
c002372a:	8d 83 aa 4e ff ff    	lea    -0xb156(%ebx),%eax
c0023730:	50                   	push   %eax
c0023731:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023737:	50                   	push   %eax
c0023738:	8d 83 88 36 ff ff    	lea    -0xc978(%ebx),%eax
c002373e:	50                   	push   %eax
c002373f:	6a 4c                	push   $0x4c
c0023741:	8d 83 d8 44 ff ff    	lea    -0xbb28(%ebx),%eax
c0023747:	50                   	push   %eax
c0023748:	e8 97 57 00 00       	call   c0028ee4 <debug_panic>

c002374d <palloc_get_multiple>:
palloc_get_multiple(enum palloc_flags flags, size_t page_cnt) {
c002374d:	55                   	push   %ebp
c002374e:	57                   	push   %edi
c002374f:	56                   	push   %esi
c0023750:	53                   	push   %ebx
c0023751:	83 ec 0c             	sub    $0xc,%esp
c0023754:	e8 3e a1 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023759:	81 c3 a7 6d 01 00    	add    $0x16da7,%ebx
c002375f:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023763:	8b 44 24 20          	mov    0x20(%esp),%eax
c0023767:	83 e0 04             	and    $0x4,%eax
c002376a:	8d b3 e0 15 00 00    	lea    0x15e0(%ebx),%esi
c0023770:	8d 83 20 16 00 00    	lea    0x1620(%ebx),%eax
c0023776:	0f 44 f0             	cmove  %eax,%esi
    if (page_cnt == 0)
c0023779:	85 ed                	test   %ebp,%ebp
c002377b:	74 7e                	je     c00237fb <palloc_get_multiple+0xae>
    lock_acquire(&pool->lock);
c002377d:	83 ec 0c             	sub    $0xc,%esp
c0023780:	56                   	push   %esi
c0023781:	e8 9c f8 ff ff       	call   c0023022 <lock_acquire>
    page_idx = bitmap_scan_and_flip(pool->used_map, 0, page_cnt, false);
c0023786:	6a 00                	push   $0x0
c0023788:	55                   	push   %ebp
c0023789:	6a 00                	push   $0x0
c002378b:	ff 76 24             	pushl  0x24(%esi)
c002378e:	e8 cf 6c 00 00       	call   c002a462 <bitmap_scan_and_flip>
c0023793:	89 c7                	mov    %eax,%edi
    lock_release(&pool->lock);
c0023795:	83 c4 14             	add    $0x14,%esp
c0023798:	56                   	push   %esi
c0023799:	e8 85 fa ff ff       	call   c0023223 <lock_release>
    if (page_idx != BITMAP_ERROR)
c002379e:	83 c4 10             	add    $0x10,%esp
c00237a1:	83 ff ff             	cmp    $0xffffffff,%edi
c00237a4:	74 23                	je     c00237c9 <palloc_get_multiple+0x7c>
        pages = pool->base + PGSIZE * page_idx;
c00237a6:	c1 e7 0c             	shl    $0xc,%edi
    if (pages != NULL) {
c00237a9:	03 7e 28             	add    0x28(%esi),%edi
c00237ac:	74 1b                	je     c00237c9 <palloc_get_multiple+0x7c>
        if (flags & PAL_ZERO)
c00237ae:	f6 44 24 20 02       	testb  $0x2,0x20(%esp)
c00237b3:	74 20                	je     c00237d5 <palloc_get_multiple+0x88>
            memset(pages, 0, PGSIZE * page_cnt);
c00237b5:	c1 e5 0c             	shl    $0xc,%ebp
c00237b8:	83 ec 04             	sub    $0x4,%esp
c00237bb:	55                   	push   %ebp
c00237bc:	6a 00                	push   $0x0
c00237be:	57                   	push   %edi
c00237bf:	e8 8f 4c 00 00       	call   c0028453 <memset>
c00237c4:	83 c4 10             	add    $0x10,%esp
c00237c7:	eb 0c                	jmp    c00237d5 <palloc_get_multiple+0x88>
        if (flags & PAL_ASSERT)
c00237c9:	f6 44 24 20 01       	testb  $0x1,0x20(%esp)
c00237ce:	75 0f                	jne    c00237df <palloc_get_multiple+0x92>
c00237d0:	bf 00 00 00 00       	mov    $0x0,%edi
}
c00237d5:	89 f8                	mov    %edi,%eax
c00237d7:	83 c4 0c             	add    $0xc,%esp
c00237da:	5b                   	pop    %ebx
c00237db:	5e                   	pop    %esi
c00237dc:	5f                   	pop    %edi
c00237dd:	5d                   	pop    %ebp
c00237de:	c3                   	ret    
            PANIC ("palloc_get: out of pages");
c00237df:	8d 83 db 4e ff ff    	lea    -0xb125(%ebx),%eax
c00237e5:	50                   	push   %eax
c00237e6:	8d 83 68 36 ff ff    	lea    -0xc998(%ebx),%eax
c00237ec:	50                   	push   %eax
c00237ed:	6a 5c                	push   $0x5c
c00237ef:	8d 83 77 4e ff ff    	lea    -0xb189(%ebx),%eax
c00237f5:	50                   	push   %eax
c00237f6:	e8 e9 56 00 00       	call   c0028ee4 <debug_panic>
        return NULL;
c00237fb:	bf 00 00 00 00       	mov    $0x0,%edi
c0023800:	eb d3                	jmp    c00237d5 <palloc_get_multiple+0x88>

c0023802 <palloc_get_page>:
palloc_get_page(enum palloc_flags flags) {
c0023802:	83 ec 14             	sub    $0x14,%esp
    return palloc_get_multiple(flags, 1);
c0023805:	6a 01                	push   $0x1
c0023807:	ff 74 24 1c          	pushl  0x1c(%esp)
c002380b:	e8 3d ff ff ff       	call   c002374d <palloc_get_multiple>
}
c0023810:	83 c4 1c             	add    $0x1c,%esp
c0023813:	c3                   	ret    

c0023814 <palloc_free_multiple>:
palloc_free_multiple(void *pages, size_t page_cnt) {
c0023814:	55                   	push   %ebp
c0023815:	57                   	push   %edi
c0023816:	56                   	push   %esi
c0023817:	53                   	push   %ebx
c0023818:	83 ec 0c             	sub    $0xc,%esp
c002381b:	e8 77 a0 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023820:	81 c3 e0 6c 01 00    	add    $0x16ce0,%ebx
c0023826:	8b 74 24 20          	mov    0x20(%esp),%esi
    ASSERT (pg_ofs(pages) == 0);
c002382a:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c0023830:	0f 85 9d 00 00 00    	jne    c00238d3 <palloc_free_multiple+0xbf>
    if (pages == NULL || page_cnt == 0)
c0023836:	85 f6                	test   %esi,%esi
c0023838:	0f 84 8d 00 00 00    	je     c00238cb <palloc_free_multiple+0xb7>
c002383e:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0023843:	0f 84 82 00 00 00    	je     c00238cb <palloc_free_multiple+0xb7>
    return (uintptr_t) va >> PGBITS;
c0023849:	89 f7                	mov    %esi,%edi
c002384b:	c1 ef 0c             	shr    $0xc,%edi
c002384e:	8b 83 48 16 00 00    	mov    0x1648(%ebx),%eax
c0023854:	c1 e8 0c             	shr    $0xc,%eax
c0023857:	89 c5                	mov    %eax,%ebp
   false otherwise. */
static bool
page_from_pool(const struct pool *pool, void *page) {
    size_t page_no = pg_no(page);
    size_t start_page = pg_no(pool->base);
    size_t end_page = start_page + bitmap_size(pool->used_map);
c0023859:	83 ec 0c             	sub    $0xc,%esp
c002385c:	ff b3 44 16 00 00    	pushl  0x1644(%ebx)
c0023862:	e8 6b 65 00 00       	call   c0029dd2 <bitmap_size>
c0023867:	89 ea                	mov    %ebp,%edx
c0023869:	01 e8                	add    %ebp,%eax

    return page_no >= start_page && page_no < end_page;
c002386b:	83 c4 10             	add    $0x10,%esp
    if (page_from_pool(&kernel_pool, pages))
c002386e:	39 c7                	cmp    %eax,%edi
c0023870:	0f 83 83 00 00 00    	jae    c00238f9 <palloc_free_multiple+0xe5>
        pool = &kernel_pool;
c0023876:	8d ab 20 16 00 00    	lea    0x1620(%ebx),%ebp
    if (page_from_pool(&kernel_pool, pages))
c002387c:	39 d7                	cmp    %edx,%edi
c002387e:	72 79                	jb     c00238f9 <palloc_free_multiple+0xe5>
c0023880:	8b 45 28             	mov    0x28(%ebp),%eax
c0023883:	c1 e8 0c             	shr    $0xc,%eax
    page_idx = pg_no(pages) - pg_no(pool->base);
c0023886:	29 c7                	sub    %eax,%edi
    memset(pages, 0xcc, PGSIZE * page_cnt);
c0023888:	83 ec 04             	sub    $0x4,%esp
c002388b:	8b 44 24 28          	mov    0x28(%esp),%eax
c002388f:	c1 e0 0c             	shl    $0xc,%eax
c0023892:	50                   	push   %eax
c0023893:	68 cc 00 00 00       	push   $0xcc
c0023898:	56                   	push   %esi
c0023899:	e8 b5 4b 00 00       	call   c0028453 <memset>
    ASSERT (bitmap_all(pool->used_map, page_idx, page_cnt));
c002389e:	83 c4 0c             	add    $0xc,%esp
c00238a1:	ff 74 24 28          	pushl  0x28(%esp)
c00238a5:	57                   	push   %edi
c00238a6:	ff 75 24             	pushl  0x24(%ebp)
c00238a9:	e8 c7 6a 00 00       	call   c002a375 <bitmap_all>
c00238ae:	83 c4 10             	add    $0x10,%esp
c00238b1:	84 c0                	test   %al,%al
c00238b3:	0f 84 8b 00 00 00    	je     c0023944 <palloc_free_multiple+0x130>
    bitmap_set_multiple(pool->used_map, page_idx, page_cnt, false);
c00238b9:	6a 00                	push   $0x0
c00238bb:	ff 74 24 28          	pushl  0x28(%esp)
c00238bf:	57                   	push   %edi
c00238c0:	ff 75 24             	pushl  0x24(%ebp)
c00238c3:	e8 8f 66 00 00       	call   c0029f57 <bitmap_set_multiple>
c00238c8:	83 c4 10             	add    $0x10,%esp
}
c00238cb:	83 c4 0c             	add    $0xc,%esp
c00238ce:	5b                   	pop    %ebx
c00238cf:	5e                   	pop    %esi
c00238d0:	5f                   	pop    %edi
c00238d1:	5d                   	pop    %ebp
c00238d2:	c3                   	ret    
    ASSERT (pg_ofs(pages) == 0);
c00238d3:	83 ec 0c             	sub    $0xc,%esp
c00238d6:	8d 83 f4 4e ff ff    	lea    -0xb10c(%ebx),%eax
c00238dc:	50                   	push   %eax
c00238dd:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00238e3:	50                   	push   %eax
c00238e4:	8d 83 50 36 ff ff    	lea    -0xc9b0(%ebx),%eax
c00238ea:	50                   	push   %eax
c00238eb:	6a 74                	push   $0x74
c00238ed:	8d 83 77 4e ff ff    	lea    -0xb189(%ebx),%eax
c00238f3:	50                   	push   %eax
c00238f4:	e8 eb 55 00 00       	call   c0028ee4 <debug_panic>
c00238f9:	8b ab 08 16 00 00    	mov    0x1608(%ebx),%ebp
c00238ff:	c1 ed 0c             	shr    $0xc,%ebp
    size_t end_page = start_page + bitmap_size(pool->used_map);
c0023902:	83 ec 0c             	sub    $0xc,%esp
c0023905:	ff b3 04 16 00 00    	pushl  0x1604(%ebx)
c002390b:	e8 c2 64 00 00       	call   c0029dd2 <bitmap_size>
c0023910:	01 e8                	add    %ebp,%eax
    return page_no >= start_page && page_no < end_page;
c0023912:	83 c4 10             	add    $0x10,%esp
    else if (page_from_pool(&user_pool, pages))
c0023915:	39 c7                	cmp    %eax,%edi
c0023917:	73 0f                	jae    c0023928 <palloc_free_multiple+0x114>
c0023919:	39 ef                	cmp    %ebp,%edi
c002391b:	72 0b                	jb     c0023928 <palloc_free_multiple+0x114>
        pool = &user_pool;
c002391d:	8d ab e0 15 00 00    	lea    0x15e0(%ebx),%ebp
c0023923:	e9 58 ff ff ff       	jmp    c0023880 <palloc_free_multiple+0x6c>
        NOT_REACHED ();
c0023928:	8d 83 60 48 ff ff    	lea    -0xb7a0(%ebx),%eax
c002392e:	50                   	push   %eax
c002392f:	8d 83 50 36 ff ff    	lea    -0xc9b0(%ebx),%eax
c0023935:	50                   	push   %eax
c0023936:	6a 7d                	push   $0x7d
c0023938:	8d 83 77 4e ff ff    	lea    -0xb189(%ebx),%eax
c002393e:	50                   	push   %eax
c002393f:	e8 a0 55 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (bitmap_all(pool->used_map, page_idx, page_cnt));
c0023944:	83 ec 0c             	sub    $0xc,%esp
c0023947:	8d 83 48 4e ff ff    	lea    -0xb1b8(%ebx),%eax
c002394d:	50                   	push   %eax
c002394e:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023954:	50                   	push   %eax
c0023955:	8d 83 50 36 ff ff    	lea    -0xc9b0(%ebx),%eax
c002395b:	50                   	push   %eax
c002395c:	68 85 00 00 00       	push   $0x85
c0023961:	8d 83 77 4e ff ff    	lea    -0xb189(%ebx),%eax
c0023967:	50                   	push   %eax
c0023968:	e8 77 55 00 00       	call   c0028ee4 <debug_panic>

c002396d <palloc_free_page>:
palloc_free_page(void *page) {
c002396d:	83 ec 14             	sub    $0x14,%esp
    palloc_free_multiple(page, 1);
c0023970:	6a 01                	push   $0x1
c0023972:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023976:	e8 99 fe ff ff       	call   c0023814 <palloc_free_multiple>
}
c002397b:	83 c4 1c             	add    $0x1c,%esp
c002397e:	c3                   	ret    

c002397f <arena_to_block>:
    return a;
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block(struct arena *a, size_t idx) {
c002397f:	53                   	push   %ebx
c0023980:	83 ec 08             	sub    $0x8,%esp
c0023983:	e8 0f 9f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023988:	81 c3 78 6b 01 00    	add    $0x16b78,%ebx
    ASSERT (a != NULL);
c002398e:	85 c0                	test   %eax,%eax
c0023990:	74 1c                	je     c00239ae <arena_to_block+0x2f>
    ASSERT (a->magic == ARENA_MAGIC);
c0023992:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c0023998:	75 3d                	jne    c00239d7 <arena_to_block+0x58>
    ASSERT (idx < a->desc->blocks_per_arena);
c002399a:	8b 48 04             	mov    0x4(%eax),%ecx
c002399d:	39 51 04             	cmp    %edx,0x4(%ecx)
c00239a0:	76 5e                	jbe    c0023a00 <arena_to_block+0x81>
    return (struct block *) ((uint8_t *) a
                             + sizeof *a
                             + idx * a->desc->block_size);
c00239a2:	0f af 11             	imul   (%ecx),%edx
    return (struct block *) ((uint8_t *) a
c00239a5:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c00239a9:	83 c4 08             	add    $0x8,%esp
c00239ac:	5b                   	pop    %ebx
c00239ad:	c3                   	ret    
    ASSERT (a != NULL);
c00239ae:	83 ec 0c             	sub    $0xc,%esp
c00239b1:	8d 83 79 4d ff ff    	lea    -0xb287(%ebx),%eax
c00239b7:	50                   	push   %eax
c00239b8:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00239be:	50                   	push   %eax
c00239bf:	8d 83 a8 36 ff ff    	lea    -0xc958(%ebx),%eax
c00239c5:	50                   	push   %eax
c00239c6:	68 07 01 00 00       	push   $0x107
c00239cb:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c00239d1:	50                   	push   %eax
c00239d2:	e8 0d 55 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (a->magic == ARENA_MAGIC);
c00239d7:	83 ec 0c             	sub    $0xc,%esp
c00239da:	8d 83 1e 4f ff ff    	lea    -0xb0e2(%ebx),%eax
c00239e0:	50                   	push   %eax
c00239e1:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00239e7:	50                   	push   %eax
c00239e8:	8d 83 a8 36 ff ff    	lea    -0xc958(%ebx),%eax
c00239ee:	50                   	push   %eax
c00239ef:	68 08 01 00 00       	push   $0x108
c00239f4:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c00239fa:	50                   	push   %eax
c00239fb:	e8 e4 54 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (idx < a->desc->blocks_per_arena);
c0023a00:	83 ec 0c             	sub    $0xc,%esp
c0023a03:	8d 83 38 4f ff ff    	lea    -0xb0c8(%ebx),%eax
c0023a09:	50                   	push   %eax
c0023a0a:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023a10:	50                   	push   %eax
c0023a11:	8d 83 a8 36 ff ff    	lea    -0xc958(%ebx),%eax
c0023a17:	50                   	push   %eax
c0023a18:	68 09 01 00 00       	push   $0x109
c0023a1d:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c0023a23:	50                   	push   %eax
c0023a24:	e8 bb 54 00 00       	call   c0028ee4 <debug_panic>

c0023a29 <block_to_arena>:
block_to_arena(struct block *b) {
c0023a29:	56                   	push   %esi
c0023a2a:	53                   	push   %ebx
c0023a2b:	83 ec 04             	sub    $0x4,%esp
c0023a2e:	e8 64 9e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023a33:	81 c3 cd 6a 01 00    	add    $0x16acd,%ebx
    ASSERT (a != NULL);
c0023a39:	89 c1                	mov    %eax,%ecx
c0023a3b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0023a41:	74 2e                	je     c0023a71 <block_to_arena+0x48>
    ASSERT (a->magic == ARENA_MAGIC);
c0023a43:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023a49:	75 4f                	jne    c0023a9a <block_to_arena+0x71>
    ASSERT (a->desc == NULL
c0023a4b:	8b 71 04             	mov    0x4(%ecx),%esi
c0023a4e:	85 f6                	test   %esi,%esi
c0023a50:	0f 84 96 00 00 00    	je     c0023aec <block_to_arena+0xc3>
    return (uintptr_t) va & PGMASK;
c0023a56:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023a5b:	83 e8 0c             	sub    $0xc,%eax
c0023a5e:	ba 00 00 00 00       	mov    $0x0,%edx
c0023a63:	f7 36                	divl   (%esi)
c0023a65:	85 d2                	test   %edx,%edx
c0023a67:	75 5a                	jne    c0023ac3 <block_to_arena+0x9a>
}
c0023a69:	89 c8                	mov    %ecx,%eax
c0023a6b:	83 c4 04             	add    $0x4,%esp
c0023a6e:	5b                   	pop    %ebx
c0023a6f:	5e                   	pop    %esi
c0023a70:	c3                   	ret    
    ASSERT (a != NULL);
c0023a71:	83 ec 0c             	sub    $0xc,%esp
c0023a74:	8d 83 79 4d ff ff    	lea    -0xb287(%ebx),%eax
c0023a7a:	50                   	push   %eax
c0023a7b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023a81:	50                   	push   %eax
c0023a82:	8d 83 98 36 ff ff    	lea    -0xc968(%ebx),%eax
c0023a88:	50                   	push   %eax
c0023a89:	68 f9 00 00 00       	push   $0xf9
c0023a8e:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c0023a94:	50                   	push   %eax
c0023a95:	e8 4a 54 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (a->magic == ARENA_MAGIC);
c0023a9a:	83 ec 0c             	sub    $0xc,%esp
c0023a9d:	8d 83 1e 4f ff ff    	lea    -0xb0e2(%ebx),%eax
c0023aa3:	50                   	push   %eax
c0023aa4:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023aaa:	50                   	push   %eax
c0023aab:	8d 83 98 36 ff ff    	lea    -0xc968(%ebx),%eax
c0023ab1:	50                   	push   %eax
c0023ab2:	68 fa 00 00 00       	push   $0xfa
c0023ab7:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c0023abd:	50                   	push   %eax
c0023abe:	e8 21 54 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (a->desc == NULL
c0023ac3:	83 ec 0c             	sub    $0xc,%esp
c0023ac6:	8d 83 58 4f ff ff    	lea    -0xb0a8(%ebx),%eax
c0023acc:	50                   	push   %eax
c0023acd:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023ad3:	50                   	push   %eax
c0023ad4:	8d 83 98 36 ff ff    	lea    -0xc968(%ebx),%eax
c0023ada:	50                   	push   %eax
c0023adb:	68 fe 00 00 00       	push   $0xfe
c0023ae0:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c0023ae6:	50                   	push   %eax
c0023ae7:	e8 f8 53 00 00       	call   c0028ee4 <debug_panic>
c0023aec:	25 ff 0f 00 00       	and    $0xfff,%eax
    ASSERT (a->desc != NULL || pg_ofs(b) == sizeof *a);
c0023af1:	83 f8 0c             	cmp    $0xc,%eax
c0023af4:	0f 84 6f ff ff ff    	je     c0023a69 <block_to_arena+0x40>
c0023afa:	83 ec 0c             	sub    $0xc,%esp
c0023afd:	8d 83 a0 4f ff ff    	lea    -0xb060(%ebx),%eax
c0023b03:	50                   	push   %eax
c0023b04:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023b0a:	50                   	push   %eax
c0023b0b:	8d 83 98 36 ff ff    	lea    -0xc968(%ebx),%eax
c0023b11:	50                   	push   %eax
c0023b12:	68 ff 00 00 00       	push   $0xff
c0023b17:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c0023b1d:	50                   	push   %eax
c0023b1e:	e8 c1 53 00 00       	call   c0028ee4 <debug_panic>

c0023b23 <malloc_init>:
malloc_init(void) {
c0023b23:	55                   	push   %ebp
c0023b24:	57                   	push   %edi
c0023b25:	56                   	push   %esi
c0023b26:	53                   	push   %ebx
c0023b27:	83 ec 0c             	sub    $0xc,%esp
c0023b2a:	e8 68 9d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023b2f:	81 c3 d1 69 01 00    	add    $0x169d1,%ebx
        struct desc *d = &descs[desc_cnt++];
c0023b35:	8b b3 60 16 00 00    	mov    0x1660(%ebx),%esi
c0023b3b:	8d 46 01             	lea    0x1(%esi),%eax
c0023b3e:	89 83 60 16 00 00    	mov    %eax,0x1660(%ebx)
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023b44:	83 f8 0a             	cmp    $0xa,%eax
c0023b47:	0f 87 a1 00 00 00    	ja     c0023bee <malloc_init+0xcb>
        d->block_size = block_size;
c0023b4d:	8d bb 80 16 00 00    	lea    0x1680(%ebx),%edi
c0023b53:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023b56:	c7 84 33 80 16 00 00 	movl   $0x10,0x1680(%ebx,%esi,1)
c0023b5d:	10 00 00 00 
        d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c0023b61:	c7 84 33 84 16 00 00 	movl   $0xff,0x1684(%ebx,%esi,1)
c0023b68:	ff 00 00 00 
        list_init(&d->free_list);
c0023b6c:	83 ec 0c             	sub    $0xc,%esp
c0023b6f:	8d 44 37 08          	lea    0x8(%edi,%esi,1),%eax
c0023b73:	50                   	push   %eax
c0023b74:	e8 38 54 00 00       	call   c0028fb1 <list_init>
        lock_init(&d->lock);
c0023b79:	8d 44 37 18          	lea    0x18(%edi,%esi,1),%eax
c0023b7d:	89 04 24             	mov    %eax,(%esp)
c0023b80:	e8 f1 f3 ff ff       	call   c0022f76 <lock_init>
c0023b85:	83 c4 10             	add    $0x10,%esp
    for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2) {
c0023b88:	bf 20 00 00 00       	mov    $0x20,%edi
        d->block_size = block_size;
c0023b8d:	8d ab 80 16 00 00    	lea    0x1680(%ebx),%ebp
        struct desc *d = &descs[desc_cnt++];
c0023b93:	8b b3 60 16 00 00    	mov    0x1660(%ebx),%esi
c0023b99:	8d 46 01             	lea    0x1(%esi),%eax
c0023b9c:	89 83 60 16 00 00    	mov    %eax,0x1660(%ebx)
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023ba2:	83 f8 0a             	cmp    $0xa,%eax
c0023ba5:	77 47                	ja     c0023bee <malloc_init+0xcb>
        d->block_size = block_size;
c0023ba7:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023baa:	89 3c 2e             	mov    %edi,(%esi,%ebp,1)
        d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c0023bad:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023bb2:	ba 00 00 00 00       	mov    $0x0,%edx
c0023bb7:	f7 f7                	div    %edi
c0023bb9:	89 84 33 84 16 00 00 	mov    %eax,0x1684(%ebx,%esi,1)
        list_init(&d->free_list);
c0023bc0:	83 ec 0c             	sub    $0xc,%esp
c0023bc3:	8d 44 2e 08          	lea    0x8(%esi,%ebp,1),%eax
c0023bc7:	50                   	push   %eax
c0023bc8:	e8 e4 53 00 00       	call   c0028fb1 <list_init>
        lock_init(&d->lock);
c0023bcd:	8d 44 2e 18          	lea    0x18(%esi,%ebp,1),%eax
c0023bd1:	89 04 24             	mov    %eax,(%esp)
c0023bd4:	e8 9d f3 ff ff       	call   c0022f76 <lock_init>
    for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2) {
c0023bd9:	01 ff                	add    %edi,%edi
c0023bdb:	83 c4 10             	add    $0x10,%esp
c0023bde:	81 ff ff 07 00 00    	cmp    $0x7ff,%edi
c0023be4:	76 ad                	jbe    c0023b93 <malloc_init+0x70>
}
c0023be6:	83 c4 0c             	add    $0xc,%esp
c0023be9:	5b                   	pop    %ebx
c0023bea:	5e                   	pop    %esi
c0023beb:	5f                   	pop    %edi
c0023bec:	5d                   	pop    %ebp
c0023bed:	c3                   	ret    
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023bee:	83 ec 0c             	sub    $0xc,%esp
c0023bf1:	8d 83 cc 4f ff ff    	lea    -0xb034(%ebx),%eax
c0023bf7:	50                   	push   %eax
c0023bf8:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023bfe:	50                   	push   %eax
c0023bff:	8d 83 b8 36 ff ff    	lea    -0xc948(%ebx),%eax
c0023c05:	50                   	push   %eax
c0023c06:	6a 4b                	push   $0x4b
c0023c08:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c0023c0e:	50                   	push   %eax
c0023c0f:	e8 d0 52 00 00       	call   c0028ee4 <debug_panic>

c0023c14 <malloc>:
malloc(size_t size) {
c0023c14:	55                   	push   %ebp
c0023c15:	57                   	push   %edi
c0023c16:	56                   	push   %esi
c0023c17:	53                   	push   %ebx
c0023c18:	83 ec 1c             	sub    $0x1c,%esp
c0023c1b:	e8 77 9c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023c20:	81 c3 e0 68 01 00    	add    $0x168e0,%ebx
c0023c26:	8b 44 24 30          	mov    0x30(%esp),%eax
    if (size == 0)
c0023c2a:	85 c0                	test   %eax,%eax
c0023c2c:	0f 84 2d 01 00 00    	je     c0023d5f <malloc+0x14b>
    for (d = descs; d < descs + desc_cnt; d++)
c0023c32:	6b 93 60 16 00 00 3c 	imul   $0x3c,0x1660(%ebx),%edx
c0023c39:	8d 8b 80 16 00 00    	lea    0x1680(%ebx),%ecx
c0023c3f:	01 ca                	add    %ecx,%edx
c0023c41:	39 ca                	cmp    %ecx,%edx
c0023c43:	0f 86 c5 00 00 00    	jbe    c0023d0e <malloc+0xfa>
        if (d->block_size >= size)
c0023c49:	3b 83 80 16 00 00    	cmp    0x1680(%ebx),%eax
c0023c4f:	0f 86 11 01 00 00    	jbe    c0023d66 <malloc+0x152>
    for (d = descs; d < descs + desc_cnt; d++)
c0023c55:	89 ce                	mov    %ecx,%esi
c0023c57:	83 c6 3c             	add    $0x3c,%esi
c0023c5a:	39 d6                	cmp    %edx,%esi
c0023c5c:	0f 83 b2 00 00 00    	jae    c0023d14 <malloc+0x100>
        if (d->block_size >= size)
c0023c62:	39 06                	cmp    %eax,(%esi)
c0023c64:	72 f1                	jb     c0023c57 <malloc+0x43>
    lock_acquire(&d->lock);
c0023c66:	8d 46 18             	lea    0x18(%esi),%eax
c0023c69:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023c6d:	83 ec 0c             	sub    $0xc,%esp
c0023c70:	50                   	push   %eax
c0023c71:	e8 ac f3 ff ff       	call   c0023022 <lock_acquire>
    if (list_empty(&d->free_list)) {
c0023c76:	8d 46 08             	lea    0x8(%esi),%eax
c0023c79:	89 44 24 18          	mov    %eax,0x18(%esp)
c0023c7d:	89 04 24             	mov    %eax,(%esp)
c0023c80:	e8 d0 59 00 00       	call   c0029655 <list_empty>
c0023c85:	83 c4 10             	add    $0x10,%esp
c0023c88:	84 c0                	test   %al,%al
c0023c8a:	74 52                	je     c0023cde <malloc+0xca>
        a = palloc_get_page(0);
c0023c8c:	83 ec 0c             	sub    $0xc,%esp
c0023c8f:	6a 00                	push   $0x0
c0023c91:	e8 6c fb ff ff       	call   c0023802 <palloc_get_page>
c0023c96:	89 c5                	mov    %eax,%ebp
        if (a == NULL) {
c0023c98:	83 c4 10             	add    $0x10,%esp
c0023c9b:	85 c0                	test   %eax,%eax
c0023c9d:	0f 84 ab 00 00 00    	je     c0023d4e <malloc+0x13a>
        a->magic = ARENA_MAGIC;
c0023ca3:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
        a->desc = d;
c0023ca9:	89 70 04             	mov    %esi,0x4(%eax)
        a->free_cnt = d->blocks_per_arena;
c0023cac:	8b 46 04             	mov    0x4(%esi),%eax
c0023caf:	89 45 08             	mov    %eax,0x8(%ebp)
        for (i = 0; i < d->blocks_per_arena; i++) {
c0023cb2:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0023cb6:	74 26                	je     c0023cde <malloc+0xca>
c0023cb8:	bf 00 00 00 00       	mov    $0x0,%edi
            struct block *b = arena_to_block(a, i);
c0023cbd:	89 fa                	mov    %edi,%edx
c0023cbf:	89 e8                	mov    %ebp,%eax
c0023cc1:	e8 b9 fc ff ff       	call   c002397f <arena_to_block>
            list_push_back(&d->free_list, &b->free_elem);
c0023cc6:	83 ec 08             	sub    $0x8,%esp
c0023cc9:	50                   	push   %eax
c0023cca:	ff 74 24 14          	pushl  0x14(%esp)
c0023cce:	e8 c3 58 00 00       	call   c0029596 <list_push_back>
        for (i = 0; i < d->blocks_per_arena; i++) {
c0023cd3:	83 c7 01             	add    $0x1,%edi
c0023cd6:	83 c4 10             	add    $0x10,%esp
c0023cd9:	39 7e 04             	cmp    %edi,0x4(%esi)
c0023cdc:	77 df                	ja     c0023cbd <malloc+0xa9>
    b = list_entry (list_pop_front(&d->free_list), struct block, free_elem);
c0023cde:	83 ec 0c             	sub    $0xc,%esp
c0023ce1:	ff 74 24 14          	pushl  0x14(%esp)
c0023ce5:	e8 e2 59 00 00       	call   c00296cc <list_pop_front>
c0023cea:	89 c5                	mov    %eax,%ebp
    a = block_to_arena(b);
c0023cec:	e8 38 fd ff ff       	call   c0023a29 <block_to_arena>
    a->free_cnt--;
c0023cf1:	83 68 08 01          	subl   $0x1,0x8(%eax)
    lock_release(&d->lock);
c0023cf5:	83 c4 04             	add    $0x4,%esp
c0023cf8:	ff 74 24 18          	pushl  0x18(%esp)
c0023cfc:	e8 22 f5 ff ff       	call   c0023223 <lock_release>
    return b;
c0023d01:	83 c4 10             	add    $0x10,%esp
}
c0023d04:	89 e8                	mov    %ebp,%eax
c0023d06:	83 c4 1c             	add    $0x1c,%esp
c0023d09:	5b                   	pop    %ebx
c0023d0a:	5e                   	pop    %esi
c0023d0b:	5f                   	pop    %edi
c0023d0c:	5d                   	pop    %ebp
c0023d0d:	c3                   	ret    
    for (d = descs; d < descs + desc_cnt; d++)
c0023d0e:	8d b3 80 16 00 00    	lea    0x1680(%ebx),%esi
    if (d == descs + desc_cnt) {
c0023d14:	39 f2                	cmp    %esi,%edx
c0023d16:	0f 85 4a ff ff ff    	jne    c0023c66 <malloc+0x52>
        size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023d1c:	8d b0 0b 10 00 00    	lea    0x100b(%eax),%esi
c0023d22:	c1 ee 0c             	shr    $0xc,%esi
        a = palloc_get_multiple(0, page_cnt);
c0023d25:	83 ec 08             	sub    $0x8,%esp
c0023d28:	56                   	push   %esi
c0023d29:	6a 00                	push   $0x0
c0023d2b:	e8 1d fa ff ff       	call   c002374d <palloc_get_multiple>
c0023d30:	89 c5                	mov    %eax,%ebp
        if (a == NULL)
c0023d32:	83 c4 10             	add    $0x10,%esp
c0023d35:	85 c0                	test   %eax,%eax
c0023d37:	74 cb                	je     c0023d04 <malloc+0xf0>
        a->magic = ARENA_MAGIC;
c0023d39:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
        a->desc = NULL;
c0023d3f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        a->free_cnt = page_cnt;
c0023d46:	89 70 08             	mov    %esi,0x8(%eax)
        return a + 1;
c0023d49:	83 c5 0c             	add    $0xc,%ebp
c0023d4c:	eb b6                	jmp    c0023d04 <malloc+0xf0>
            lock_release(&d->lock);
c0023d4e:	83 ec 0c             	sub    $0xc,%esp
c0023d51:	ff 74 24 18          	pushl  0x18(%esp)
c0023d55:	e8 c9 f4 ff ff       	call   c0023223 <lock_release>
            return NULL;
c0023d5a:	83 c4 10             	add    $0x10,%esp
c0023d5d:	eb a5                	jmp    c0023d04 <malloc+0xf0>
        return NULL;
c0023d5f:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023d64:	eb 9e                	jmp    c0023d04 <malloc+0xf0>
    for (d = descs; d < descs + desc_cnt; d++)
c0023d66:	8d b3 80 16 00 00    	lea    0x1680(%ebx),%esi
    if (d == descs + desc_cnt) {
c0023d6c:	e9 f5 fe ff ff       	jmp    c0023c66 <malloc+0x52>

c0023d71 <calloc>:
calloc(size_t a, size_t b) {
c0023d71:	57                   	push   %edi
c0023d72:	56                   	push   %esi
c0023d73:	53                   	push   %ebx
c0023d74:	e8 1e 9b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023d79:	81 c3 87 67 01 00    	add    $0x16787,%ebx
c0023d7f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023d83:	8b 54 24 14          	mov    0x14(%esp),%edx
    size = a * b;
c0023d87:	89 c6                	mov    %eax,%esi
c0023d89:	0f af f2             	imul   %edx,%esi
    if (size < a || size < b)
c0023d8c:	39 f0                	cmp    %esi,%eax
c0023d8e:	77 2b                	ja     c0023dbb <calloc+0x4a>
c0023d90:	39 f2                	cmp    %esi,%edx
c0023d92:	77 27                	ja     c0023dbb <calloc+0x4a>
    p = malloc(size);
c0023d94:	83 ec 0c             	sub    $0xc,%esp
c0023d97:	56                   	push   %esi
c0023d98:	e8 77 fe ff ff       	call   c0023c14 <malloc>
c0023d9d:	89 c7                	mov    %eax,%edi
    if (p != NULL)
c0023d9f:	83 c4 10             	add    $0x10,%esp
c0023da2:	85 c0                	test   %eax,%eax
c0023da4:	74 0f                	je     c0023db5 <calloc+0x44>
        memset(p, 0, size);
c0023da6:	83 ec 04             	sub    $0x4,%esp
c0023da9:	56                   	push   %esi
c0023daa:	6a 00                	push   $0x0
c0023dac:	50                   	push   %eax
c0023dad:	e8 a1 46 00 00       	call   c0028453 <memset>
c0023db2:	83 c4 10             	add    $0x10,%esp
}
c0023db5:	89 f8                	mov    %edi,%eax
c0023db7:	5b                   	pop    %ebx
c0023db8:	5e                   	pop    %esi
c0023db9:	5f                   	pop    %edi
c0023dba:	c3                   	ret    
        return NULL;
c0023dbb:	bf 00 00 00 00       	mov    $0x0,%edi
c0023dc0:	eb f3                	jmp    c0023db5 <calloc+0x44>

c0023dc2 <free>:
free(void *p) {
c0023dc2:	55                   	push   %ebp
c0023dc3:	57                   	push   %edi
c0023dc4:	56                   	push   %esi
c0023dc5:	53                   	push   %ebx
c0023dc6:	83 ec 1c             	sub    $0x1c,%esp
c0023dc9:	e8 c9 9a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023dce:	81 c3 32 67 01 00    	add    $0x16732,%ebx
c0023dd4:	8b 74 24 30          	mov    0x30(%esp),%esi
    if (p != NULL) {
c0023dd8:	85 f6                	test   %esi,%esi
c0023dda:	0f 84 96 00 00 00    	je     c0023e76 <free+0xb4>
        struct arena *a = block_to_arena(b);
c0023de0:	89 f0                	mov    %esi,%eax
c0023de2:	e8 42 fc ff ff       	call   c0023a29 <block_to_arena>
c0023de7:	89 c5                	mov    %eax,%ebp
        struct desc *d = a->desc;
c0023de9:	8b 78 04             	mov    0x4(%eax),%edi
        if (d != NULL) {
c0023dec:	85 ff                	test   %edi,%edi
c0023dee:	0f 84 b3 00 00 00    	je     c0023ea7 <free+0xe5>
            memset(b, 0xcc, d->block_size);
c0023df4:	83 ec 04             	sub    $0x4,%esp
c0023df7:	ff 37                	pushl  (%edi)
c0023df9:	68 cc 00 00 00       	push   $0xcc
c0023dfe:	56                   	push   %esi
c0023dff:	e8 4f 46 00 00       	call   c0028453 <memset>
            lock_acquire(&d->lock);
c0023e04:	8d 47 18             	lea    0x18(%edi),%eax
c0023e07:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0023e0b:	89 04 24             	mov    %eax,(%esp)
c0023e0e:	e8 0f f2 ff ff       	call   c0023022 <lock_acquire>
            list_push_front(&d->free_list, &b->free_elem);
c0023e13:	83 c4 08             	add    $0x8,%esp
c0023e16:	56                   	push   %esi
c0023e17:	8d 47 08             	lea    0x8(%edi),%eax
c0023e1a:	50                   	push   %eax
c0023e1b:	e8 59 57 00 00       	call   c0029579 <list_push_front>
            if (++a->free_cnt >= d->blocks_per_arena) {
c0023e20:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e23:	83 c0 01             	add    $0x1,%eax
c0023e26:	89 45 08             	mov    %eax,0x8(%ebp)
c0023e29:	8b 57 04             	mov    0x4(%edi),%edx
c0023e2c:	83 c4 10             	add    $0x10,%esp
c0023e2f:	39 d0                	cmp    %edx,%eax
c0023e31:	72 34                	jb     c0023e67 <free+0xa5>
                ASSERT (a->free_cnt == d->blocks_per_arena);
c0023e33:	75 49                	jne    c0023e7e <free+0xbc>
                for (i = 0; i < d->blocks_per_arena; i++) {
c0023e35:	be 00 00 00 00       	mov    $0x0,%esi
c0023e3a:	85 d2                	test   %edx,%edx
c0023e3c:	74 1d                	je     c0023e5b <free+0x99>
                    struct block *b = arena_to_block(a, i);
c0023e3e:	89 f2                	mov    %esi,%edx
c0023e40:	89 e8                	mov    %ebp,%eax
c0023e42:	e8 38 fb ff ff       	call   c002397f <arena_to_block>
                    list_remove(&b->free_elem);
c0023e47:	83 ec 0c             	sub    $0xc,%esp
c0023e4a:	50                   	push   %eax
c0023e4b:	e8 63 57 00 00       	call   c00295b3 <list_remove>
                for (i = 0; i < d->blocks_per_arena; i++) {
c0023e50:	83 c6 01             	add    $0x1,%esi
c0023e53:	83 c4 10             	add    $0x10,%esp
c0023e56:	39 77 04             	cmp    %esi,0x4(%edi)
c0023e59:	77 e3                	ja     c0023e3e <free+0x7c>
                palloc_free_page(a);
c0023e5b:	83 ec 0c             	sub    $0xc,%esp
c0023e5e:	55                   	push   %ebp
c0023e5f:	e8 09 fb ff ff       	call   c002396d <palloc_free_page>
c0023e64:	83 c4 10             	add    $0x10,%esp
            lock_release(&d->lock);
c0023e67:	83 ec 0c             	sub    $0xc,%esp
c0023e6a:	ff 74 24 18          	pushl  0x18(%esp)
c0023e6e:	e8 b0 f3 ff ff       	call   c0023223 <lock_release>
c0023e73:	83 c4 10             	add    $0x10,%esp
}
c0023e76:	83 c4 1c             	add    $0x1c,%esp
c0023e79:	5b                   	pop    %ebx
c0023e7a:	5e                   	pop    %esi
c0023e7b:	5f                   	pop    %edi
c0023e7c:	5d                   	pop    %ebp
c0023e7d:	c3                   	ret    
                ASSERT (a->free_cnt == d->blocks_per_arena);
c0023e7e:	83 ec 0c             	sub    $0xc,%esp
c0023e81:	8d 83 f8 4f ff ff    	lea    -0xb008(%ebx),%eax
c0023e87:	50                   	push   %eax
c0023e88:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023e8e:	50                   	push   %eax
c0023e8f:	8d 83 90 36 ff ff    	lea    -0xc970(%ebx),%eax
c0023e95:	50                   	push   %eax
c0023e96:	68 e2 00 00 00       	push   $0xe2
c0023e9b:	8d 83 07 4f ff ff    	lea    -0xb0f9(%ebx),%eax
c0023ea1:	50                   	push   %eax
c0023ea2:	e8 3d 50 00 00       	call   c0028ee4 <debug_panic>
            palloc_free_multiple(a, a->free_cnt);
c0023ea7:	83 ec 08             	sub    $0x8,%esp
c0023eaa:	ff 70 08             	pushl  0x8(%eax)
c0023ead:	50                   	push   %eax
c0023eae:	e8 61 f9 ff ff       	call   c0023814 <palloc_free_multiple>
            return;
c0023eb3:	83 c4 10             	add    $0x10,%esp
c0023eb6:	eb be                	jmp    c0023e76 <free+0xb4>

c0023eb8 <realloc>:
realloc(void *old_block, size_t new_size) {
c0023eb8:	55                   	push   %ebp
c0023eb9:	57                   	push   %edi
c0023eba:	56                   	push   %esi
c0023ebb:	53                   	push   %ebx
c0023ebc:	83 ec 0c             	sub    $0xc,%esp
c0023ebf:	e8 d3 99 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023ec4:	81 c3 3c 66 01 00    	add    $0x1663c,%ebx
c0023eca:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0023ece:	8b 74 24 24          	mov    0x24(%esp),%esi
    if (new_size == 0) {
c0023ed2:	85 f6                	test   %esi,%esi
c0023ed4:	74 43                	je     c0023f19 <realloc+0x61>
        void *new_block = malloc(new_size);
c0023ed6:	83 ec 0c             	sub    $0xc,%esp
c0023ed9:	56                   	push   %esi
c0023eda:	e8 35 fd ff ff       	call   c0023c14 <malloc>
c0023edf:	89 c5                	mov    %eax,%ebp
        if (old_block != NULL && new_block != NULL) {
c0023ee1:	83 c4 10             	add    $0x10,%esp
c0023ee4:	85 ff                	test   %edi,%edi
c0023ee6:	74 42                	je     c0023f2a <realloc+0x72>
c0023ee8:	85 c0                	test   %eax,%eax
c0023eea:	74 3e                	je     c0023f2a <realloc+0x72>
    struct arena *a = block_to_arena(b);
c0023eec:	89 f8                	mov    %edi,%eax
c0023eee:	e8 36 fb ff ff       	call   c0023a29 <block_to_arena>
    struct desc *d = a->desc;
c0023ef3:	8b 50 04             	mov    0x4(%eax),%edx
    return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c0023ef6:	85 d2                	test   %edx,%edx
c0023ef8:	74 3a                	je     c0023f34 <realloc+0x7c>
c0023efa:	8b 02                	mov    (%edx),%eax
            size_t min_size = new_size < old_size ? new_size : old_size;
c0023efc:	39 c6                	cmp    %eax,%esi
c0023efe:	0f 47 f0             	cmova  %eax,%esi
            memcpy(new_block, old_block, min_size);
c0023f01:	83 ec 04             	sub    $0x4,%esp
c0023f04:	56                   	push   %esi
c0023f05:	57                   	push   %edi
c0023f06:	55                   	push   %ebp
c0023f07:	e8 c7 41 00 00       	call   c00280d3 <memcpy>
            free(old_block);
c0023f0c:	89 3c 24             	mov    %edi,(%esp)
c0023f0f:	e8 ae fe ff ff       	call   c0023dc2 <free>
c0023f14:	83 c4 10             	add    $0x10,%esp
c0023f17:	eb 11                	jmp    c0023f2a <realloc+0x72>
        free(old_block);
c0023f19:	83 ec 0c             	sub    $0xc,%esp
c0023f1c:	57                   	push   %edi
c0023f1d:	e8 a0 fe ff ff       	call   c0023dc2 <free>
        return NULL;
c0023f22:	83 c4 10             	add    $0x10,%esp
c0023f25:	bd 00 00 00 00       	mov    $0x0,%ebp
}
c0023f2a:	89 e8                	mov    %ebp,%eax
c0023f2c:	83 c4 0c             	add    $0xc,%esp
c0023f2f:	5b                   	pop    %ebx
c0023f30:	5e                   	pop    %esi
c0023f31:	5f                   	pop    %edi
c0023f32:	5d                   	pop    %ebp
c0023f33:	c3                   	ret    
    return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c0023f34:	8b 40 08             	mov    0x8(%eax),%eax
c0023f37:	c1 e0 0c             	shl    $0xc,%eax
c0023f3a:	89 fa                	mov    %edi,%edx
c0023f3c:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0023f42:	29 d0                	sub    %edx,%eax
c0023f44:	eb b6                	jmp    c0023efc <realloc+0x44>

c0023f46 <pit_configure_channel>:

     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel(int channel, int mode, int frequency) {
c0023f46:	55                   	push   %ebp
c0023f47:	57                   	push   %edi
c0023f48:	56                   	push   %esi
c0023f49:	53                   	push   %ebx
c0023f4a:	83 ec 0c             	sub    $0xc,%esp
c0023f4d:	e8 45 99 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0023f52:	81 c3 ae 65 01 00    	add    $0x165ae,%ebx
c0023f58:	8b 74 24 20          	mov    0x20(%esp),%esi
c0023f5c:	8b 6c 24 24          	mov    0x24(%esp),%ebp
c0023f60:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    uint16_t count;
    enum intr_level old_level;

    ASSERT (channel == 0 || channel == 2);
c0023f64:	f7 c6 fd ff ff ff    	test   $0xfffffffd,%esi
c0023f6a:	75 69                	jne    c0023fd5 <pit_configure_channel+0x8f>
    ASSERT (mode == 2 || mode == 3);
c0023f6c:	8d 45 fe             	lea    -0x2(%ebp),%eax
c0023f6f:	83 f8 01             	cmp    $0x1,%eax
c0023f72:	0f 87 83 00 00 00    	ja     c0023ffb <pit_configure_channel+0xb5>
    if (frequency < 19) {
        /* Frequency is too low: the quotient would overflow the
           16-bit counter.  Force it to 0, which the PIT treats as
           65536, the highest possible count.  This yields a 18.2
           Hz timer, approximately. */
        count = 0;
c0023f78:	bf 00 00 00 00       	mov    $0x0,%edi
    if (frequency < 19) {
c0023f7d:	83 f9 12             	cmp    $0x12,%ecx
c0023f80:	7e 20                	jle    c0023fa2 <pit_configure_channel+0x5c>
        /* Frequency is too high: the quotient would underflow to
           0, which the PIT would interpret as 65536.  A count of 1
           is illegal in mode 2, so we force it to 2, which yields
           a 596.590 kHz timer, approximately.  (This timer rate is
           probably too fast to be useful anyhow.) */
        count = 2;
c0023f82:	bf 02 00 00 00       	mov    $0x2,%edi
    } else if (frequency > PIT_HZ) {
c0023f87:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c0023f8d:	7f 13                	jg     c0023fa2 <pit_configure_channel+0x5c>
    } else
        count = (PIT_HZ + frequency / 2) / frequency;
c0023f8f:	89 c8                	mov    %ecx,%eax
c0023f91:	c1 e8 1f             	shr    $0x1f,%eax
c0023f94:	01 c8                	add    %ecx,%eax
c0023f96:	d1 f8                	sar    %eax
c0023f98:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023f9d:	99                   	cltd   
c0023f9e:	f7 f9                	idiv   %ecx
c0023fa0:	89 c7                	mov    %eax,%edi

    /* Configure the PIT mode and load its counters. */
    old_level = intr_disable();
c0023fa2:	e8 7c db ff ff       	call   c0021b23 <intr_disable>
c0023fa7:	89 c1                	mov    %eax,%ecx
    outb(PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023fa9:	89 f0                	mov    %esi,%eax
c0023fab:	c1 e0 06             	shl    $0x6,%eax
c0023fae:	01 ed                	add    %ebp,%ebp
c0023fb0:	09 e8                	or     %ebp,%eax
c0023fb2:	83 c8 30             	or     $0x30,%eax
c0023fb5:	e6 43                	out    %al,$0x43
    outb(PIT_PORT_COUNTER (channel), count);
c0023fb7:	8d 56 40             	lea    0x40(%esi),%edx
c0023fba:	89 f8                	mov    %edi,%eax
c0023fbc:	ee                   	out    %al,(%dx)
    outb(PIT_PORT_COUNTER (channel), count >> 8);
c0023fbd:	89 f8                	mov    %edi,%eax
c0023fbf:	66 c1 e8 08          	shr    $0x8,%ax
c0023fc3:	ee                   	out    %al,(%dx)
    intr_set_level(old_level);
c0023fc4:	83 ec 0c             	sub    $0xc,%esp
c0023fc7:	51                   	push   %ecx
c0023fc8:	e8 5d db ff ff       	call   c0021b2a <intr_set_level>
}
c0023fcd:	83 c4 1c             	add    $0x1c,%esp
c0023fd0:	5b                   	pop    %ebx
c0023fd1:	5e                   	pop    %esi
c0023fd2:	5f                   	pop    %edi
c0023fd3:	5d                   	pop    %ebp
c0023fd4:	c3                   	ret    
    ASSERT (channel == 0 || channel == 2);
c0023fd5:	83 ec 0c             	sub    $0xc,%esp
c0023fd8:	8d 83 1b 50 ff ff    	lea    -0xafe5(%ebx),%eax
c0023fde:	50                   	push   %eax
c0023fdf:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0023fe5:	50                   	push   %eax
c0023fe6:	8d 83 c4 36 ff ff    	lea    -0xc93c(%ebx),%eax
c0023fec:	50                   	push   %eax
c0023fed:	6a 32                	push   $0x32
c0023fef:	8d 83 38 50 ff ff    	lea    -0xafc8(%ebx),%eax
c0023ff5:	50                   	push   %eax
c0023ff6:	e8 e9 4e 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (mode == 2 || mode == 3);
c0023ffb:	83 ec 0c             	sub    $0xc,%esp
c0023ffe:	8d 83 4c 50 ff ff    	lea    -0xafb4(%ebx),%eax
c0024004:	50                   	push   %eax
c0024005:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002400b:	50                   	push   %eax
c002400c:	8d 83 c4 36 ff ff    	lea    -0xc93c(%ebx),%eax
c0024012:	50                   	push   %eax
c0024013:	6a 33                	push   $0x33
c0024015:	8d 83 38 50 ff ff    	lea    -0xafc8(%ebx),%eax
c002401b:	50                   	push   %eax
c002401c:	e8 c3 4e 00 00       	call   c0028ee4 <debug_panic>

c0024021 <busy_wait>:
   Marked NO_INLINE because code alignment can significantly
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait(int64_t loops) {
c0024021:	56                   	push   %esi
c0024022:	53                   	push   %ebx
    while (loops-- > 0)
c0024023:	89 c1                	mov    %eax,%ecx
c0024025:	89 d3                	mov    %edx,%ebx
c0024027:	83 c1 ff             	add    $0xffffffff,%ecx
c002402a:	83 d3 ff             	adc    $0xffffffff,%ebx
c002402d:	be 00 00 00 00       	mov    $0x0,%esi
c0024032:	39 c6                	cmp    %eax,%esi
c0024034:	19 d6                	sbb    %edx,%esi
c0024036:	7d 0f                	jge    c0024047 <busy_wait+0x26>
c0024038:	83 c1 ff             	add    $0xffffffff,%ecx
c002403b:	83 d3 ff             	adc    $0xffffffff,%ebx
c002403e:	89 d8                	mov    %ebx,%eax
c0024040:	21 c8                	and    %ecx,%eax
c0024042:	83 f8 ff             	cmp    $0xffffffff,%eax
c0024045:	75 f1                	jne    c0024038 <busy_wait+0x17>
            barrier ();
}
c0024047:	5b                   	pop    %ebx
c0024048:	5e                   	pop    %esi
c0024049:	c3                   	ret    

c002404a <too_many_loops>:
too_many_loops(unsigned loops) {
c002404a:	55                   	push   %ebp
c002404b:	57                   	push   %edi
c002404c:	56                   	push   %esi
c002404d:	53                   	push   %ebx
c002404e:	83 ec 0c             	sub    $0xc,%esp
c0024051:	e8 41 98 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024056:	81 c3 aa 64 01 00    	add    $0x164aa,%ebx
c002405c:	89 44 24 04          	mov    %eax,0x4(%esp)
    int64_t start = ticks;
c0024060:	8b ab e0 18 00 00    	mov    0x18e0(%ebx),%ebp
c0024066:	8b 8b e4 18 00 00    	mov    0x18e4(%ebx),%ecx
    while (ticks == start)
c002406c:	8b bb e0 18 00 00    	mov    0x18e0(%ebx),%edi
c0024072:	8b b3 e4 18 00 00    	mov    0x18e4(%ebx),%esi
c0024078:	89 f8                	mov    %edi,%eax
c002407a:	31 e8                	xor    %ebp,%eax
c002407c:	89 f2                	mov    %esi,%edx
c002407e:	31 ca                	xor    %ecx,%edx
c0024080:	09 c2                	or     %eax,%edx
c0024082:	74 e8                	je     c002406c <too_many_loops+0x22>
    busy_wait(loops);
c0024084:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024088:	ba 00 00 00 00       	mov    $0x0,%edx
c002408d:	e8 8f ff ff ff       	call   c0024021 <busy_wait>
    return start != ticks;
c0024092:	33 bb e0 18 00 00    	xor    0x18e0(%ebx),%edi
c0024098:	33 b3 e4 18 00 00    	xor    0x18e4(%ebx),%esi
c002409e:	09 f7                	or     %esi,%edi
c00240a0:	0f 95 c0             	setne  %al
}
c00240a3:	83 c4 0c             	add    $0xc,%esp
c00240a6:	5b                   	pop    %ebx
c00240a7:	5e                   	pop    %esi
c00240a8:	5f                   	pop    %edi
c00240a9:	5d                   	pop    %ebp
c00240aa:	c3                   	ret    

c00240ab <timer_interrupt>:
timer_interrupt(struct intr_frame *args UNUSED) {
c00240ab:	56                   	push   %esi
c00240ac:	53                   	push   %ebx
c00240ad:	83 ec 04             	sub    $0x4,%esp
c00240b0:	e8 e2 97 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00240b5:	81 c3 4b 64 01 00    	add    $0x1644b,%ebx
    ticks++;
c00240bb:	83 83 e0 18 00 00 01 	addl   $0x1,0x18e0(%ebx)
c00240c2:	83 93 e4 18 00 00 00 	adcl   $0x0,0x18e4(%ebx)
    if (thread_mlfqs) {
c00240c9:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c00240cf:	80 38 00             	cmpb   $0x0,(%eax)
c00240d2:	75 2b                	jne    c00240ff <timer_interrupt+0x54>
    enum intr_level old_level = intr_disable();
c00240d4:	e8 4a da ff ff       	call   c0021b23 <intr_disable>
c00240d9:	89 c6                	mov    %eax,%esi
    thread_foreach(thread_blocked_check, NULL);
c00240db:	83 ec 08             	sub    $0x8,%esp
c00240de:	6a 00                	push   $0x0
c00240e0:	8d 83 fb 9c fe ff    	lea    -0x16305(%ebx),%eax
c00240e6:	50                   	push   %eax
c00240e7:	e8 b9 cd ff ff       	call   c0020ea5 <thread_foreach>
    intr_set_level(old_level);
c00240ec:	89 34 24             	mov    %esi,(%esp)
c00240ef:	e8 36 da ff ff       	call   c0021b2a <intr_set_level>
    thread_tick();
c00240f4:	e8 35 cd ff ff       	call   c0020e2e <thread_tick>
}
c00240f9:	83 c4 14             	add    $0x14,%esp
c00240fc:	5b                   	pop    %ebx
c00240fd:	5e                   	pop    %esi
c00240fe:	c3                   	ret    
        update_cur_thread_cpu();
c00240ff:	e8 bd ce ff ff       	call   c0020fc1 <update_cur_thread_cpu>
        if (ticks % TIMER_FREQ == 0) {
c0024104:	6a 00                	push   $0x0
c0024106:	6a 64                	push   $0x64
c0024108:	ff b3 e4 18 00 00    	pushl  0x18e4(%ebx)
c002410e:	ff b3 e0 18 00 00    	pushl  0x18e0(%ebx)
c0024114:	e8 b1 47 00 00       	call   c00288ca <__moddi3>
c0024119:	83 c4 10             	add    $0x10,%esp
c002411c:	09 c2                	or     %eax,%edx
c002411e:	74 10                	je     c0024130 <timer_interrupt+0x85>
        if (ticks % 4) {
c0024120:	f6 83 e0 18 00 00 03 	testb  $0x3,0x18e0(%ebx)
c0024127:	74 ab                	je     c00240d4 <timer_interrupt+0x29>
            update_all_priority();
c0024129:	e8 55 ce ff ff       	call   c0020f83 <update_all_priority>
c002412e:	eb a4                	jmp    c00240d4 <timer_interrupt+0x29>
            update_load_avg();
c0024130:	e8 ae ce ff ff       	call   c0020fe3 <update_load_avg>
            update_all_recent_cpu();
c0024135:	e8 68 ce ff ff       	call   c0020fa2 <update_all_recent_cpu>
c002413a:	eb e4                	jmp    c0024120 <timer_interrupt+0x75>

c002413c <real_time_delay>:
    }
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay(int64_t num, int32_t denom) {
c002413c:	55                   	push   %ebp
c002413d:	57                   	push   %edi
c002413e:	56                   	push   %esi
c002413f:	53                   	push   %ebx
c0024140:	83 ec 0c             	sub    $0xc,%esp
c0024143:	e8 5b 97 00 00       	call   c002d8a3 <__x86.get_pc_thunk.di>
c0024148:	81 c7 b8 63 01 00    	add    $0x163b8,%edi
c002414e:	89 c5                	mov    %eax,%ebp
c0024150:	89 d3                	mov    %edx,%ebx
    /* Scale the numerator and denominator down by 1000 to avoid
       the possibility of overflow. */
    ASSERT (denom % 1000 == 0);
c0024152:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0024157:	89 c8                	mov    %ecx,%eax
c0024159:	f7 ea                	imul   %edx
c002415b:	c1 fa 06             	sar    $0x6,%edx
c002415e:	89 c8                	mov    %ecx,%eax
c0024160:	c1 f8 1f             	sar    $0x1f,%eax
c0024163:	29 c2                	sub    %eax,%edx
c0024165:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
c002416b:	39 d1                	cmp    %edx,%ecx
c002416d:	75 61                	jne    c00241d0 <real_time_delay+0x94>
c002416f:	89 ce                	mov    %ecx,%esi
    busy_wait(loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000));
c0024171:	8b 87 d8 18 00 00    	mov    0x18d8(%edi),%eax
c0024177:	0f af d8             	imul   %eax,%ebx
c002417a:	f7 e5                	mul    %ebp
c002417c:	01 da                	add    %ebx,%edx
c002417e:	6a 00                	push   $0x0
c0024180:	68 e8 03 00 00       	push   $0x3e8
c0024185:	52                   	push   %edx
c0024186:	50                   	push   %eax
c0024187:	89 fb                	mov    %edi,%ebx
c0024189:	e8 20 47 00 00       	call   c00288ae <__divdi3>
c002418e:	83 c4 10             	add    $0x10,%esp
c0024191:	6b ea 64             	imul   $0x64,%edx,%ebp
c0024194:	b9 64 00 00 00       	mov    $0x64,%ecx
c0024199:	f7 e1                	mul    %ecx
c002419b:	89 c1                	mov    %eax,%ecx
c002419d:	89 d3                	mov    %edx,%ebx
c002419f:	01 eb                	add    %ebp,%ebx
c00241a1:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00241a6:	89 f0                	mov    %esi,%eax
c00241a8:	f7 ea                	imul   %edx
c00241aa:	c1 fa 06             	sar    $0x6,%edx
c00241ad:	c1 fe 1f             	sar    $0x1f,%esi
c00241b0:	29 f2                	sub    %esi,%edx
c00241b2:	89 d0                	mov    %edx,%eax
c00241b4:	99                   	cltd   
c00241b5:	52                   	push   %edx
c00241b6:	50                   	push   %eax
c00241b7:	53                   	push   %ebx
c00241b8:	51                   	push   %ecx
c00241b9:	89 fb                	mov    %edi,%ebx
c00241bb:	e8 ee 46 00 00       	call   c00288ae <__divdi3>
c00241c0:	83 c4 10             	add    $0x10,%esp
c00241c3:	e8 59 fe ff ff       	call   c0024021 <busy_wait>
}
c00241c8:	83 c4 0c             	add    $0xc,%esp
c00241cb:	5b                   	pop    %ebx
c00241cc:	5e                   	pop    %esi
c00241cd:	5f                   	pop    %edi
c00241ce:	5d                   	pop    %ebp
c00241cf:	c3                   	ret    
    ASSERT (denom % 1000 == 0);
c00241d0:	83 ec 0c             	sub    $0xc,%esp
c00241d3:	8d 87 63 50 ff ff    	lea    -0xaf9d(%edi),%eax
c00241d9:	50                   	push   %eax
c00241da:	8d 87 96 44 ff ff    	lea    -0xbb6a(%edi),%eax
c00241e0:	50                   	push   %eax
c00241e1:	8d 87 dc 36 ff ff    	lea    -0xc924(%edi),%eax
c00241e7:	50                   	push   %eax
c00241e8:	68 08 01 00 00       	push   $0x108
c00241ed:	8d 87 75 50 ff ff    	lea    -0xaf8b(%edi),%eax
c00241f3:	50                   	push   %eax
c00241f4:	89 fb                	mov    %edi,%ebx
c00241f6:	e8 e9 4c 00 00       	call   c0028ee4 <debug_panic>

c00241fb <thread_blocked_check>:
void thread_blocked_check(struct thread *t, void *aux UNUSED) {
c00241fb:	56                   	push   %esi
c00241fc:	53                   	push   %ebx
c00241fd:	83 ec 04             	sub    $0x4,%esp
c0024200:	e8 a2 96 00 00       	call   c002d8a7 <__x86.get_pc_thunk.dx>
c0024205:	81 c2 fb 62 01 00    	add    $0x162fb,%edx
c002420b:	8b 44 24 10          	mov    0x10(%esp),%eax
    if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c002420f:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
c0024213:	74 06                	je     c002421b <thread_blocked_check+0x20>
}
c0024215:	83 c4 04             	add    $0x4,%esp
c0024218:	5b                   	pop    %ebx
c0024219:	5e                   	pop    %esi
c002421a:	c3                   	ret    
    if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c002421b:	8b 88 e4 00 00 00    	mov    0xe4(%eax),%ecx
c0024221:	8b 98 e8 00 00 00    	mov    0xe8(%eax),%ebx
c0024227:	be 00 00 00 00       	mov    $0x0,%esi
c002422c:	39 ce                	cmp    %ecx,%esi
c002422e:	19 de                	sbb    %ebx,%esi
c0024230:	7d e3                	jge    c0024215 <thread_blocked_check+0x1a>
        t->ticks_blocked--;
c0024232:	83 c1 ff             	add    $0xffffffff,%ecx
c0024235:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024238:	89 de                	mov    %ebx,%esi
c002423a:	89 88 e4 00 00 00    	mov    %ecx,0xe4(%eax)
c0024240:	89 b0 e8 00 00 00    	mov    %esi,0xe8(%eax)
        if (t->ticks_blocked == 0) {
c0024246:	89 f3                	mov    %esi,%ebx
c0024248:	09 cb                	or     %ecx,%ebx
c002424a:	75 c9                	jne    c0024215 <thread_blocked_check+0x1a>
            thread_unblock(t);
c002424c:	83 ec 0c             	sub    $0xc,%esp
c002424f:	50                   	push   %eax
c0024250:	89 d3                	mov    %edx,%ebx
c0024252:	e8 a3 ca ff ff       	call   c0020cfa <thread_unblock>
c0024257:	83 c4 10             	add    $0x10,%esp
}
c002425a:	eb b9                	jmp    c0024215 <thread_blocked_check+0x1a>

c002425c <timer_init>:
timer_init(void) {
c002425c:	53                   	push   %ebx
c002425d:	83 ec 0c             	sub    $0xc,%esp
c0024260:	e8 32 96 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024265:	81 c3 9b 62 01 00    	add    $0x1629b,%ebx
    pit_configure_channel(0, 2, TIMER_FREQ);
c002426b:	6a 64                	push   $0x64
c002426d:	6a 02                	push   $0x2
c002426f:	6a 00                	push   $0x0
c0024271:	e8 d0 fc ff ff       	call   c0023f46 <pit_configure_channel>
    intr_register_ext(0x20, timer_interrupt, "8254 Timer");
c0024276:	83 c4 0c             	add    $0xc,%esp
c0024279:	8d 83 8b 50 ff ff    	lea    -0xaf75(%ebx),%eax
c002427f:	50                   	push   %eax
c0024280:	8d 83 ab 9b fe ff    	lea    -0x16455(%ebx),%eax
c0024286:	50                   	push   %eax
c0024287:	6a 20                	push   $0x20
c0024289:	e8 71 da ff ff       	call   c0021cff <intr_register_ext>
}
c002428e:	83 c4 18             	add    $0x18,%esp
c0024291:	5b                   	pop    %ebx
c0024292:	c3                   	ret    

c0024293 <timer_calibrate>:
timer_calibrate(void) {
c0024293:	55                   	push   %ebp
c0024294:	57                   	push   %edi
c0024295:	56                   	push   %esi
c0024296:	53                   	push   %ebx
c0024297:	83 ec 0c             	sub    $0xc,%esp
c002429a:	e8 f8 95 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002429f:	81 c3 61 62 01 00    	add    $0x16261,%ebx
    ASSERT (intr_get_level() == INTR_ON);
c00242a5:	e8 27 d8 ff ff       	call   c0021ad1 <intr_get_level>
c00242aa:	83 f8 01             	cmp    $0x1,%eax
c00242ad:	75 60                	jne    c002430f <timer_calibrate+0x7c>
    printf("Calibrating timer...  ");
c00242af:	83 ec 0c             	sub    $0xc,%esp
c00242b2:	8d 83 b2 50 ff ff    	lea    -0xaf4e(%ebx),%eax
c00242b8:	50                   	push   %eax
c00242b9:	e8 ca 2f 00 00       	call   c0027288 <printf>
    loops_per_tick = 1u << 10;
c00242be:	c7 83 d8 18 00 00 00 	movl   $0x400,0x18d8(%ebx)
c00242c5:	04 00 00 
    while (!too_many_loops(loops_per_tick << 1)) {
c00242c8:	83 c4 10             	add    $0x10,%esp
c00242cb:	8b bb d8 18 00 00    	mov    0x18d8(%ebx),%edi
c00242d1:	8d 34 3f             	lea    (%edi,%edi,1),%esi
c00242d4:	89 f0                	mov    %esi,%eax
c00242d6:	e8 6f fd ff ff       	call   c002404a <too_many_loops>
c00242db:	84 c0                	test   %al,%al
c00242dd:	75 56                	jne    c0024335 <timer_calibrate+0xa2>
        loops_per_tick <<= 1;
c00242df:	89 b3 d8 18 00 00    	mov    %esi,0x18d8(%ebx)
        ASSERT (loops_per_tick != 0);
c00242e5:	85 f6                	test   %esi,%esi
c00242e7:	75 e2                	jne    c00242cb <timer_calibrate+0x38>
c00242e9:	83 ec 0c             	sub    $0xc,%esp
c00242ec:	8d 83 c9 50 ff ff    	lea    -0xaf37(%ebx),%eax
c00242f2:	50                   	push   %eax
c00242f3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00242f9:	50                   	push   %eax
c00242fa:	8d 83 08 37 ff ff    	lea    -0xc8f8(%ebx),%eax
c0024300:	50                   	push   %eax
c0024301:	6a 3c                	push   $0x3c
c0024303:	8d 83 75 50 ff ff    	lea    -0xaf8b(%ebx),%eax
c0024309:	50                   	push   %eax
c002430a:	e8 d5 4b 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (intr_get_level() == INTR_ON);
c002430f:	83 ec 0c             	sub    $0xc,%esp
c0024312:	8d 83 96 50 ff ff    	lea    -0xaf6a(%ebx),%eax
c0024318:	50                   	push   %eax
c0024319:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002431f:	50                   	push   %eax
c0024320:	8d 83 08 37 ff ff    	lea    -0xc8f8(%ebx),%eax
c0024326:	50                   	push   %eax
c0024327:	6a 34                	push   $0x34
c0024329:	8d 83 75 50 ff ff    	lea    -0xaf8b(%ebx),%eax
c002432f:	50                   	push   %eax
c0024330:	e8 af 4b 00 00       	call   c0028ee4 <debug_panic>
    for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024335:	89 fe                	mov    %edi,%esi
c0024337:	d1 ee                	shr    %esi
c0024339:	89 fd                	mov    %edi,%ebp
c002433b:	c1 ed 0a             	shr    $0xa,%ebp
c002433e:	39 f5                	cmp    %esi,%ebp
c0024340:	75 2a                	jne    c002436c <timer_calibrate+0xd9>
    printf("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0024342:	83 ec 04             	sub    $0x4,%esp
c0024345:	b8 64 00 00 00       	mov    $0x64,%eax
c002434a:	f7 a3 d8 18 00 00    	mull   0x18d8(%ebx)
c0024350:	52                   	push   %edx
c0024351:	50                   	push   %eax
c0024352:	8d 83 dd 50 ff ff    	lea    -0xaf23(%ebx),%eax
c0024358:	50                   	push   %eax
c0024359:	e8 2a 2f 00 00       	call   c0027288 <printf>
}
c002435e:	83 c4 1c             	add    $0x1c,%esp
c0024361:	5b                   	pop    %ebx
c0024362:	5e                   	pop    %esi
c0024363:	5f                   	pop    %edi
c0024364:	5d                   	pop    %ebp
c0024365:	c3                   	ret    
    for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024366:	d1 ee                	shr    %esi
c0024368:	39 f5                	cmp    %esi,%ebp
c002436a:	74 d6                	je     c0024342 <timer_calibrate+0xaf>
        if (!too_many_loops(high_bit | test_bit))
c002436c:	89 f8                	mov    %edi,%eax
c002436e:	09 f0                	or     %esi,%eax
c0024370:	e8 d5 fc ff ff       	call   c002404a <too_many_loops>
c0024375:	84 c0                	test   %al,%al
c0024377:	75 ed                	jne    c0024366 <timer_calibrate+0xd3>
            loops_per_tick |= test_bit;
c0024379:	09 b3 d8 18 00 00    	or     %esi,0x18d8(%ebx)
c002437f:	eb e5                	jmp    c0024366 <timer_calibrate+0xd3>

c0024381 <timer_ticks>:
timer_ticks(void) {
c0024381:	57                   	push   %edi
c0024382:	56                   	push   %esi
c0024383:	53                   	push   %ebx
c0024384:	e8 0e 95 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024389:	81 c3 77 61 01 00    	add    $0x16177,%ebx
    enum intr_level old_level = intr_disable(); // ensure this process is not interrupted
c002438f:	e8 8f d7 ff ff       	call   c0021b23 <intr_disable>
    int64_t t = ticks;
c0024394:	8b b3 e0 18 00 00    	mov    0x18e0(%ebx),%esi
c002439a:	8b bb e4 18 00 00    	mov    0x18e4(%ebx),%edi
    intr_set_level(old_level);
c00243a0:	83 ec 0c             	sub    $0xc,%esp
c00243a3:	50                   	push   %eax
c00243a4:	e8 81 d7 ff ff       	call   c0021b2a <intr_set_level>
    return t;
c00243a9:	83 c4 10             	add    $0x10,%esp
}
c00243ac:	89 f0                	mov    %esi,%eax
c00243ae:	89 fa                	mov    %edi,%edx
c00243b0:	5b                   	pop    %ebx
c00243b1:	5e                   	pop    %esi
c00243b2:	5f                   	pop    %edi
c00243b3:	c3                   	ret    

c00243b4 <timer_elapsed>:
timer_elapsed(int64_t then) {
c00243b4:	57                   	push   %edi
c00243b5:	56                   	push   %esi
c00243b6:	83 ec 04             	sub    $0x4,%esp
c00243b9:	8b 74 24 10          	mov    0x10(%esp),%esi
c00243bd:	8b 7c 24 14          	mov    0x14(%esp),%edi
    return timer_ticks() - then;
c00243c1:	e8 bb ff ff ff       	call   c0024381 <timer_ticks>
c00243c6:	29 f0                	sub    %esi,%eax
c00243c8:	19 fa                	sbb    %edi,%edx
}
c00243ca:	83 c4 04             	add    $0x4,%esp
c00243cd:	5e                   	pop    %esi
c00243ce:	5f                   	pop    %edi
c00243cf:	c3                   	ret    

c00243d0 <timer_sleep>:
timer_sleep(int64_t ticks) {
c00243d0:	55                   	push   %ebp
c00243d1:	57                   	push   %edi
c00243d2:	56                   	push   %esi
c00243d3:	53                   	push   %ebx
c00243d4:	83 ec 0c             	sub    $0xc,%esp
c00243d7:	e8 bb 94 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00243dc:	81 c3 24 61 01 00    	add    $0x16124,%ebx
c00243e2:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00243e6:	8b 74 24 24          	mov    0x24(%esp),%esi
    if (ticks <= 0) {
c00243ea:	b8 00 00 00 00       	mov    $0x0,%eax
c00243ef:	39 f8                	cmp    %edi,%eax
c00243f1:	19 f0                	sbb    %esi,%eax
c00243f3:	7d 38                	jge    c002442d <timer_sleep+0x5d>
    int64_t start = timer_ticks();
c00243f5:	e8 87 ff ff ff       	call   c0024381 <timer_ticks>
    ASSERT (intr_get_level() == INTR_ON);
c00243fa:	e8 d2 d6 ff ff       	call   c0021ad1 <intr_get_level>
c00243ff:	83 f8 01             	cmp    $0x1,%eax
c0024402:	75 31                	jne    c0024435 <timer_sleep+0x65>
    enum intr_level old_level = intr_disable();
c0024404:	e8 1a d7 ff ff       	call   c0021b23 <intr_disable>
c0024409:	89 c5                	mov    %eax,%ebp
    struct thread *cur = thread_current();
c002440b:	e8 9d c9 ff ff       	call   c0020dad <thread_current>
    cur->ticks_blocked = ticks;
c0024410:	89 b8 e4 00 00 00    	mov    %edi,0xe4(%eax)
c0024416:	89 b0 e8 00 00 00    	mov    %esi,0xe8(%eax)
    thread_block();
c002441c:	e8 0d cf ff ff       	call   c002132e <thread_block>
    intr_set_level(old_level);
c0024421:	83 ec 0c             	sub    $0xc,%esp
c0024424:	55                   	push   %ebp
c0024425:	e8 00 d7 ff ff       	call   c0021b2a <intr_set_level>
c002442a:	83 c4 10             	add    $0x10,%esp
}
c002442d:	83 c4 0c             	add    $0xc,%esp
c0024430:	5b                   	pop    %ebx
c0024431:	5e                   	pop    %esi
c0024432:	5f                   	pop    %edi
c0024433:	5d                   	pop    %ebp
c0024434:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c0024435:	83 ec 0c             	sub    $0xc,%esp
c0024438:	8d 83 96 50 ff ff    	lea    -0xaf6a(%ebx),%eax
c002443e:	50                   	push   %eax
c002443f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024445:	50                   	push   %eax
c0024446:	8d 83 fc 36 ff ff    	lea    -0xc904(%ebx),%eax
c002444c:	50                   	push   %eax
c002444d:	6a 62                	push   $0x62
c002444f:	8d 83 75 50 ff ff    	lea    -0xaf8b(%ebx),%eax
c0024455:	50                   	push   %eax
c0024456:	e8 89 4a 00 00       	call   c0028ee4 <debug_panic>

c002445b <real_time_sleep>:
real_time_sleep(int64_t num, int32_t denom) {
c002445b:	55                   	push   %ebp
c002445c:	57                   	push   %edi
c002445d:	56                   	push   %esi
c002445e:	53                   	push   %ebx
c002445f:	83 ec 1c             	sub    $0x1c,%esp
c0024462:	e8 30 94 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024467:	81 c3 99 60 01 00    	add    $0x16099,%ebx
c002446d:	89 c6                	mov    %eax,%esi
c002446f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0024473:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0024477:	89 cd                	mov    %ecx,%ebp
    int64_t ticks = num * TIMER_FREQ / denom;
c0024479:	6b ca 64             	imul   $0x64,%edx,%ecx
c002447c:	b8 64 00 00 00       	mov    $0x64,%eax
c0024481:	f7 e6                	mul    %esi
c0024483:	01 ca                	add    %ecx,%edx
c0024485:	89 ef                	mov    %ebp,%edi
c0024487:	c1 ff 1f             	sar    $0x1f,%edi
c002448a:	57                   	push   %edi
c002448b:	55                   	push   %ebp
c002448c:	52                   	push   %edx
c002448d:	50                   	push   %eax
c002448e:	e8 1b 44 00 00       	call   c00288ae <__divdi3>
c0024493:	83 c4 10             	add    $0x10,%esp
c0024496:	89 c6                	mov    %eax,%esi
c0024498:	89 d7                	mov    %edx,%edi
    ASSERT (intr_get_level() == INTR_ON);
c002449a:	e8 32 d6 ff ff       	call   c0021ad1 <intr_get_level>
c002449f:	83 f8 01             	cmp    $0x1,%eax
c00244a2:	75 20                	jne    c00244c4 <real_time_sleep+0x69>
    if (ticks > 0) {
c00244a4:	b8 00 00 00 00       	mov    $0x0,%eax
c00244a9:	39 f0                	cmp    %esi,%eax
c00244ab:	19 f8                	sbb    %edi,%eax
c00244ad:	7d 3e                	jge    c00244ed <real_time_sleep+0x92>
        timer_sleep(ticks);
c00244af:	83 ec 08             	sub    $0x8,%esp
c00244b2:	57                   	push   %edi
c00244b3:	56                   	push   %esi
c00244b4:	e8 17 ff ff ff       	call   c00243d0 <timer_sleep>
c00244b9:	83 c4 10             	add    $0x10,%esp
}
c00244bc:	83 c4 1c             	add    $0x1c,%esp
c00244bf:	5b                   	pop    %ebx
c00244c0:	5e                   	pop    %esi
c00244c1:	5f                   	pop    %edi
c00244c2:	5d                   	pop    %ebp
c00244c3:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c00244c4:	83 ec 0c             	sub    $0xc,%esp
c00244c7:	8d 83 96 50 ff ff    	lea    -0xaf6a(%ebx),%eax
c00244cd:	50                   	push   %eax
c00244ce:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00244d4:	50                   	push   %eax
c00244d5:	8d 83 ec 36 ff ff    	lea    -0xc914(%ebx),%eax
c00244db:	50                   	push   %eax
c00244dc:	68 f6 00 00 00       	push   $0xf6
c00244e1:	8d 83 75 50 ff ff    	lea    -0xaf8b(%ebx),%eax
c00244e7:	50                   	push   %eax
c00244e8:	e8 f7 49 00 00       	call   c0028ee4 <debug_panic>
        real_time_delay(num, denom);
c00244ed:	89 e9                	mov    %ebp,%ecx
c00244ef:	8b 44 24 08          	mov    0x8(%esp),%eax
c00244f3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00244f7:	e8 40 fc ff ff       	call   c002413c <real_time_delay>
}
c00244fc:	eb be                	jmp    c00244bc <real_time_sleep+0x61>

c00244fe <timer_msleep>:
timer_msleep(int64_t ms) {
c00244fe:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(ms, 1000);
c0024501:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024506:	8b 44 24 10          	mov    0x10(%esp),%eax
c002450a:	8b 54 24 14          	mov    0x14(%esp),%edx
c002450e:	e8 48 ff ff ff       	call   c002445b <real_time_sleep>
}
c0024513:	83 c4 0c             	add    $0xc,%esp
c0024516:	c3                   	ret    

c0024517 <timer_usleep>:
timer_usleep(int64_t us) {
c0024517:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(us, 1000 * 1000);
c002451a:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c002451f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024523:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024527:	e8 2f ff ff ff       	call   c002445b <real_time_sleep>
}
c002452c:	83 c4 0c             	add    $0xc,%esp
c002452f:	c3                   	ret    

c0024530 <timer_nsleep>:
timer_nsleep(int64_t ns) {
c0024530:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(ns, 1000 * 1000 * 1000);
c0024533:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024538:	8b 44 24 10          	mov    0x10(%esp),%eax
c002453c:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024540:	e8 16 ff ff ff       	call   c002445b <real_time_sleep>
}
c0024545:	83 c4 0c             	add    $0xc,%esp
c0024548:	c3                   	ret    

c0024549 <timer_mdelay>:
timer_mdelay(int64_t ms) {
c0024549:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(ms, 1000);
c002454c:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024551:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024555:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024559:	e8 de fb ff ff       	call   c002413c <real_time_delay>
}
c002455e:	83 c4 0c             	add    $0xc,%esp
c0024561:	c3                   	ret    

c0024562 <timer_udelay>:
timer_udelay(int64_t us) {
c0024562:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(us, 1000 * 1000);
c0024565:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c002456a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002456e:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024572:	e8 c5 fb ff ff       	call   c002413c <real_time_delay>
}
c0024577:	83 c4 0c             	add    $0xc,%esp
c002457a:	c3                   	ret    

c002457b <timer_ndelay>:
timer_ndelay(int64_t ns) {
c002457b:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(ns, 1000 * 1000 * 1000);
c002457e:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024583:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024587:	8b 54 24 14          	mov    0x14(%esp),%edx
c002458b:	e8 ac fb ff ff       	call   c002413c <real_time_delay>
}
c0024590:	83 c4 0c             	add    $0xc,%esp
c0024593:	c3                   	ret    

c0024594 <timer_print_stats>:
timer_print_stats(void) {
c0024594:	53                   	push   %ebx
c0024595:	83 ec 08             	sub    $0x8,%esp
c0024598:	e8 fa 92 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002459d:	81 c3 63 5f 01 00    	add    $0x15f63,%ebx
    printf("Timer: %"PRId64" ticks\n", timer_ticks());
c00245a3:	e8 d9 fd ff ff       	call   c0024381 <timer_ticks>
c00245a8:	83 ec 04             	sub    $0x4,%esp
c00245ab:	52                   	push   %edx
c00245ac:	50                   	push   %eax
c00245ad:	8d 83 ed 50 ff ff    	lea    -0xaf13(%ebx),%eax
c00245b3:	50                   	push   %eax
c00245b4:	e8 cf 2c 00 00       	call   c0027288 <printf>
}
c00245b9:	83 c4 18             	add    $0x18,%esp
c00245bc:	5b                   	pop    %ebx
c00245bd:	c3                   	ret    

c00245be <map_key>:
/* Scans the array of keymaps K for SCANCODE.
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key(const struct keymap k[], unsigned scancode, uint8_t *c) {
c00245be:	55                   	push   %ebp
c00245bf:	57                   	push   %edi
c00245c0:	56                   	push   %esi
c00245c1:	53                   	push   %ebx
c00245c2:	83 ec 04             	sub    $0x4,%esp
c00245c5:	89 0c 24             	mov    %ecx,(%esp)
    for (; k->first_scancode != 0; k++)
c00245c8:	0f b6 18             	movzbl (%eax),%ebx
c00245cb:	84 db                	test   %bl,%bl
c00245cd:	74 50                	je     c002461f <map_key+0x61>
c00245cf:	89 c6                	mov    %eax,%esi
        if (scancode >= k->first_scancode
            && scancode < k->first_scancode + strlen(k->chars)) {
c00245d1:	b8 00 00 00 00       	mov    $0x0,%eax
c00245d6:	eb 0a                	jmp    c00245e2 <map_key+0x24>
    for (; k->first_scancode != 0; k++)
c00245d8:	83 c6 08             	add    $0x8,%esi
c00245db:	0f b6 1e             	movzbl (%esi),%ebx
c00245de:	84 db                	test   %bl,%bl
c00245e0:	74 30                	je     c0024612 <map_key+0x54>
        if (scancode >= k->first_scancode
c00245e2:	0f b6 db             	movzbl %bl,%ebx
c00245e5:	39 d3                	cmp    %edx,%ebx
c00245e7:	77 ef                	ja     c00245d8 <map_key+0x1a>
            && scancode < k->first_scancode + strlen(k->chars)) {
c00245e9:	8b 6e 04             	mov    0x4(%esi),%ebp
c00245ec:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00245f1:	89 ef                	mov    %ebp,%edi
c00245f3:	f2 ae                	repnz scas %es:(%edi),%al
c00245f5:	f7 d1                	not    %ecx
c00245f7:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c00245fb:	39 d1                	cmp    %edx,%ecx
c00245fd:	76 d9                	jbe    c00245d8 <map_key+0x1a>
            *c = k->chars[scancode - k->first_scancode];
c00245ff:	29 da                	sub    %ebx,%edx
c0024601:	0f b6 44 15 00       	movzbl 0x0(%ebp,%edx,1),%eax
c0024606:	8b 3c 24             	mov    (%esp),%edi
c0024609:	88 07                	mov    %al,(%edi)
            return true;
c002460b:	b8 01 00 00 00       	mov    $0x1,%eax
c0024610:	eb 05                	jmp    c0024617 <map_key+0x59>
        }

    return false;
c0024612:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024617:	83 c4 04             	add    $0x4,%esp
c002461a:	5b                   	pop    %ebx
c002461b:	5e                   	pop    %esi
c002461c:	5f                   	pop    %edi
c002461d:	5d                   	pop    %ebp
c002461e:	c3                   	ret    
    return false;
c002461f:	b8 00 00 00 00       	mov    $0x0,%eax
c0024624:	eb f1                	jmp    c0024617 <map_key+0x59>

c0024626 <keyboard_interrupt>:
keyboard_interrupt(struct intr_frame *args UNUSED) {
c0024626:	55                   	push   %ebp
c0024627:	57                   	push   %edi
c0024628:	56                   	push   %esi
c0024629:	53                   	push   %ebx
c002462a:	83 ec 2c             	sub    $0x2c,%esp
c002462d:	e8 65 92 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024632:	81 c3 ce 5e 01 00    	add    $0x15ece,%ebx
    bool shift = left_shift || right_shift;
c0024638:	ba 01 00 00 00       	mov    $0x1,%edx
c002463d:	80 bb f6 18 00 00 00 	cmpb   $0x0,0x18f6(%ebx)
c0024644:	75 07                	jne    c002464d <keyboard_interrupt+0x27>
c0024646:	0f b6 93 f5 18 00 00 	movzbl 0x18f5(%ebx),%edx
    bool alt = left_alt || right_alt;
c002464d:	bd 01 00 00 00       	mov    $0x1,%ebp
c0024652:	80 bb f4 18 00 00 00 	cmpb   $0x0,0x18f4(%ebx)
c0024659:	75 07                	jne    c0024662 <keyboard_interrupt+0x3c>
c002465b:	0f b6 ab f3 18 00 00 	movzbl 0x18f3(%ebx),%ebp
    bool ctrl = left_ctrl || right_ctrl;
c0024662:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0024669:	00 
c002466a:	80 bb f2 18 00 00 00 	cmpb   $0x0,0x18f2(%ebx)
c0024671:	75 0b                	jne    c002467e <keyboard_interrupt+0x58>
c0024673:	0f b6 83 f1 18 00 00 	movzbl 0x18f1(%ebx),%eax
c002467a:	89 44 24 08          	mov    %eax,0x8(%esp)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002467e:	e4 60                	in     $0x60,%al
    code = inb(DATA_REG);
c0024680:	0f b6 f0             	movzbl %al,%esi
    if (code == 0xe0)
c0024683:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
c0024689:	74 24                	je     c00246af <keyboard_interrupt+0x89>
    release = (code & 0x80) != 0;
c002468b:	83 e0 80             	and    $0xffffff80,%eax
c002468e:	0f b6 f8             	movzbl %al,%edi
    code &= ~0x80u;
c0024691:	81 e6 7f ff ff ff    	and    $0xffffff7f,%esi
    if (code == 0x3a) {
c0024697:	83 fe 3a             	cmp    $0x3a,%esi
c002469a:	75 25                	jne    c00246c1 <keyboard_interrupt+0x9b>
        if (!release)
c002469c:	85 ff                	test   %edi,%edi
c002469e:	75 07                	jne    c00246a7 <keyboard_interrupt+0x81>
            caps_lock = !caps_lock;
c00246a0:	80 b3 f0 18 00 00 01 	xorb   $0x1,0x18f0(%ebx)
}
c00246a7:	83 c4 2c             	add    $0x2c,%esp
c00246aa:	5b                   	pop    %ebx
c00246ab:	5e                   	pop    %esi
c00246ac:	5f                   	pop    %edi
c00246ad:	5d                   	pop    %ebp
c00246ae:	c3                   	ret    
c00246af:	e4 60                	in     $0x60,%al
    release = (code & 0x80) != 0;
c00246b1:	89 c1                	mov    %eax,%ecx
c00246b3:	83 e1 80             	and    $0xffffff80,%ecx
c00246b6:	0f b6 f9             	movzbl %cl,%edi
    code &= ~0x80u;
c00246b9:	83 e0 7f             	and    $0x7f,%eax
c00246bc:	80 cc e0             	or     $0xe0,%ah
c00246bf:	89 c6                	mov    %eax,%esi
    bool shift = left_shift || right_shift;
c00246c1:	89 d0                	mov    %edx,%eax
c00246c3:	83 e0 01             	and    $0x1,%eax
c00246c6:	88 44 24 0f          	mov    %al,0xf(%esp)
    } else if (map_key(invariant_keymap, code, &c)
c00246ca:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00246ce:	89 f2                	mov    %esi,%edx
c00246d0:	8d 83 60 78 ff ff    	lea    -0x87a0(%ebx),%eax
c00246d6:	e8 e3 fe ff ff       	call   c00245be <map_key>
c00246db:	84 c0                	test   %al,%al
c00246dd:	75 57                	jne    c0024736 <keyboard_interrupt+0x110>
               || (!shift && map_key(unshifted_keymap, code, &c))
c00246df:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00246e4:	74 3b                	je     c0024721 <keyboard_interrupt+0xfb>
               || (shift && map_key(shifted_keymap, code, &c))) {
c00246e6:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00246ea:	89 f2                	mov    %esi,%edx
c00246ec:	8d 83 e0 77 ff ff    	lea    -0x8820(%ebx),%eax
c00246f2:	e8 c7 fe ff ff       	call   c00245be <map_key>
c00246f7:	84 c0                	test   %al,%al
c00246f9:	75 3b                	jne    c0024736 <keyboard_interrupt+0x110>
            if (key->scancode == code) {
c00246fb:	83 fe 2a             	cmp    $0x2a,%esi
c00246fe:	0f 84 da 00 00 00    	je     c00247de <keyboard_interrupt+0x1b8>
        for (key = shift_keys; key->scancode != 0; key++)
c0024704:	8d 83 a0 77 ff ff    	lea    -0x8860(%ebx),%eax
c002470a:	83 c0 08             	add    $0x8,%eax
c002470d:	8b 10                	mov    (%eax),%edx
c002470f:	85 d2                	test   %edx,%edx
c0024711:	74 94                	je     c00246a7 <keyboard_interrupt+0x81>
            if (key->scancode == code) {
c0024713:	39 f2                	cmp    %esi,%edx
c0024715:	75 f3                	jne    c002470a <keyboard_interrupt+0xe4>
                *key->state_var = !release;
c0024717:	8b 40 04             	mov    0x4(%eax),%eax
c002471a:	85 ff                	test   %edi,%edi
c002471c:	0f 94 00             	sete   (%eax)
                break;
c002471f:	eb 86                	jmp    c00246a7 <keyboard_interrupt+0x81>
               || (!shift && map_key(unshifted_keymap, code, &c))
c0024721:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024725:	89 f2                	mov    %esi,%edx
c0024727:	8d 83 20 78 ff ff    	lea    -0x87e0(%ebx),%eax
c002472d:	e8 8c fe ff ff       	call   c00245be <map_key>
c0024732:	84 c0                	test   %al,%al
c0024734:	74 c5                	je     c00246fb <keyboard_interrupt+0xd5>
        if (!release) {
c0024736:	85 ff                	test   %edi,%edi
c0024738:	0f 85 69 ff ff ff    	jne    c00246a7 <keyboard_interrupt+0x81>
            if (c == 0177 && ctrl && alt)
c002473e:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
c0024743:	3c 7f                	cmp    $0x7f,%al
c0024745:	74 5a                	je     c00247a1 <keyboard_interrupt+0x17b>
            if (ctrl && c >= 0x40 && c < 0x60) {
c0024747:	8d 50 c0             	lea    -0x40(%eax),%edx
c002474a:	80 fa 1f             	cmp    $0x1f,%dl
c002474d:	77 07                	ja     c0024756 <keyboard_interrupt+0x130>
c002474f:	f6 44 24 08 01       	testb  $0x1,0x8(%esp)
c0024754:	75 6d                	jne    c00247c3 <keyboard_interrupt+0x19d>
            } else if (shift == caps_lock)
c0024756:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c002475b:	38 8b f0 18 00 00    	cmp    %cl,0x18f0(%ebx)
c0024761:	74 66                	je     c00247c9 <keyboard_interrupt+0x1a3>
            if (alt)
c0024763:	f7 c5 01 00 00 00    	test   $0x1,%ebp
c0024769:	74 05                	je     c0024770 <keyboard_interrupt+0x14a>
                c += 0x80;
c002476b:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
            if (!input_full()) {
c0024770:	e8 9a 1c 00 00       	call   c002640f <input_full>
c0024775:	84 c0                	test   %al,%al
c0024777:	0f 85 2a ff ff ff    	jne    c00246a7 <keyboard_interrupt+0x81>
                key_cnt++;
c002477d:	83 83 e8 18 00 00 01 	addl   $0x1,0x18e8(%ebx)
c0024784:	83 93 ec 18 00 00 00 	adcl   $0x0,0x18ec(%ebx)
                input_putc(c);
c002478b:	83 ec 0c             	sub    $0xc,%esp
c002478e:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0024793:	50                   	push   %eax
c0024794:	e8 9b 1b 00 00       	call   c0026334 <input_putc>
c0024799:	83 c4 10             	add    $0x10,%esp
c002479c:	e9 06 ff ff ff       	jmp    c00246a7 <keyboard_interrupt+0x81>
            if (c == 0177 && ctrl && alt)
c00247a1:	8b 54 24 08          	mov    0x8(%esp),%edx
c00247a5:	21 ea                	and    %ebp,%edx
c00247a7:	f6 c2 01             	test   $0x1,%dl
c00247aa:	75 12                	jne    c00247be <keyboard_interrupt+0x198>
            } else if (shift == caps_lock)
c00247ac:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c00247b1:	3a 8b f0 18 00 00    	cmp    0x18f0(%ebx),%cl
c00247b7:	75 aa                	jne    c0024763 <keyboard_interrupt+0x13d>
                c = tolower(c);
c00247b9:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c00247bc:	eb 1a                	jmp    c00247d8 <keyboard_interrupt+0x1b2>
                shutdown_reboot();
c00247be:	e8 3f 22 00 00       	call   c0026a02 <shutdown_reboot>
                c -= 0x40;
c00247c3:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c00247c7:	eb 9a                	jmp    c0024763 <keyboard_interrupt+0x13d>
                c = tolower(c);
c00247c9:	0f b6 c0             	movzbl %al,%eax
c00247cc:	8d 48 bf             	lea    -0x41(%eax),%ecx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c00247cf:	8d 50 20             	lea    0x20(%eax),%edx
c00247d2:	83 f9 1a             	cmp    $0x1a,%ecx
c00247d5:	0f 42 c2             	cmovb  %edx,%eax
c00247d8:	88 44 24 1f          	mov    %al,0x1f(%esp)
c00247dc:	eb 85                	jmp    c0024763 <keyboard_interrupt+0x13d>
        for (key = shift_keys; key->scancode != 0; key++)
c00247de:	8d 83 a0 77 ff ff    	lea    -0x8860(%ebx),%eax
c00247e4:	e9 2e ff ff ff       	jmp    c0024717 <keyboard_interrupt+0xf1>

c00247e9 <kbd_init>:
kbd_init(void) {
c00247e9:	53                   	push   %ebx
c00247ea:	83 ec 0c             	sub    $0xc,%esp
c00247ed:	e8 a5 90 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00247f2:	81 c3 0e 5d 01 00    	add    $0x15d0e,%ebx
    intr_register_ext(0x21, keyboard_interrupt, "8042 Keyboard");
c00247f8:	8d 83 00 51 ff ff    	lea    -0xaf00(%ebx),%eax
c00247fe:	50                   	push   %eax
c00247ff:	8d 83 26 a1 fe ff    	lea    -0x15eda(%ebx),%eax
c0024805:	50                   	push   %eax
c0024806:	6a 21                	push   $0x21
c0024808:	e8 f2 d4 ff ff       	call   c0021cff <intr_register_ext>
}
c002480d:	83 c4 18             	add    $0x18,%esp
c0024810:	5b                   	pop    %ebx
c0024811:	c3                   	ret    

c0024812 <kbd_print_stats>:
kbd_print_stats(void) {
c0024812:	53                   	push   %ebx
c0024813:	83 ec 0c             	sub    $0xc,%esp
c0024816:	e8 7c 90 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002481b:	81 c3 e5 5c 01 00    	add    $0x15ce5,%ebx
    printf("Keyboard: %lld keys pressed\n", key_cnt);
c0024821:	ff b3 ec 18 00 00    	pushl  0x18ec(%ebx)
c0024827:	ff b3 e8 18 00 00    	pushl  0x18e8(%ebx)
c002482d:	8d 83 0e 51 ff ff    	lea    -0xaef2(%ebx),%eax
c0024833:	50                   	push   %eax
c0024834:	e8 4f 2a 00 00       	call   c0027288 <printf>
}
c0024839:	83 c4 18             	add    $0x18,%esp
c002483c:	5b                   	pop    %ebx
c002483d:	c3                   	ret    

c002483e <move_cursor>:
    }
}

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor(void) {
c002483e:	e8 58 90 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0024843:	05 bd 5c 01 00       	add    $0x15cbd,%eax
    /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
    uint16_t cp = cx + COL_CNT * cy;
c0024848:	8b 88 00 19 00 00    	mov    0x1900(%eax),%ecx
c002484e:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0024851:	c1 e1 04             	shl    $0x4,%ecx
c0024854:	66 03 88 04 19 00 00 	add    0x1904(%eax),%cx
    outw(0x3d4, 0x0e | (cp & 0xff00));
c002485b:	89 c8                	mov    %ecx,%eax
c002485d:	b0 00                	mov    $0x0,%al
c002485f:	83 c8 0e             	or     $0xe,%eax

/* Writes the 16-bit DATA to PORT. */
static inline void
outw(uint16_t port, uint16_t data) {
    /* See [IA32-v2b] "OUT". */
    asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024862:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024867:	66 ef                	out    %ax,(%dx)
    outw(0x3d4, 0x0f | (cp << 8));
c0024869:	89 c8                	mov    %ecx,%eax
c002486b:	c1 e0 08             	shl    $0x8,%eax
c002486e:	83 c8 0f             	or     $0xf,%eax
c0024871:	66 ef                	out    %ax,(%dx)
}
c0024873:	c3                   	ret    

c0024874 <newline>:
newline(void) {
c0024874:	56                   	push   %esi
c0024875:	53                   	push   %ebx
c0024876:	83 ec 04             	sub    $0x4,%esp
c0024879:	e8 19 90 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002487e:	81 c3 82 5c 01 00    	add    $0x15c82,%ebx
    cx = 0;
c0024884:	c7 83 04 19 00 00 00 	movl   $0x0,0x1904(%ebx)
c002488b:	00 00 00 
    cy++;
c002488e:	8b 83 00 19 00 00    	mov    0x1900(%ebx),%eax
c0024894:	83 c0 01             	add    $0x1,%eax
    if (cy >= ROW_CNT) {
c0024897:	83 f8 18             	cmp    $0x18,%eax
c002489a:	77 0c                	ja     c00248a8 <newline+0x34>
    cy++;
c002489c:	89 83 00 19 00 00    	mov    %eax,0x1900(%ebx)
}
c00248a2:	83 c4 04             	add    $0x4,%esp
c00248a5:	5b                   	pop    %ebx
c00248a6:	5e                   	pop    %esi
c00248a7:	c3                   	ret    
        cy = ROW_CNT - 1;
c00248a8:	c7 83 00 19 00 00 18 	movl   $0x18,0x1900(%ebx)
c00248af:	00 00 00 
        memmove(&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c00248b2:	8b b3 fc 18 00 00    	mov    0x18fc(%ebx),%esi
c00248b8:	83 ec 04             	sub    $0x4,%esp
c00248bb:	68 00 0f 00 00       	push   $0xf00
c00248c0:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c00248c6:	50                   	push   %eax
c00248c7:	56                   	push   %esi
c00248c8:	e8 32 38 00 00       	call   c00280ff <memmove>
    for (x = 0; x < COL_CNT; x++) {
c00248cd:	8d 86 00 0f 00 00    	lea    0xf00(%esi),%eax
c00248d3:	81 c6 a0 0f 00 00    	add    $0xfa0,%esi
c00248d9:	83 c4 10             	add    $0x10,%esp
        fb[y][x][0] = ' ';
c00248dc:	c6 00 20             	movb   $0x20,(%eax)
        fb[y][x][1] = GRAY_ON_BLACK;
c00248df:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c00248e3:	83 c0 02             	add    $0x2,%eax
    for (x = 0; x < COL_CNT; x++) {
c00248e6:	39 f0                	cmp    %esi,%eax
c00248e8:	75 f2                	jne    c00248dc <newline+0x68>
c00248ea:	eb b6                	jmp    c00248a2 <newline+0x2e>

c00248ec <vga_putc>:
vga_putc(int c) {
c00248ec:	55                   	push   %ebp
c00248ed:	57                   	push   %edi
c00248ee:	56                   	push   %esi
c00248ef:	53                   	push   %ebx
c00248f0:	83 ec 0c             	sub    $0xc,%esp
c00248f3:	e8 9f 8f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00248f8:	81 c3 08 5c 01 00    	add    $0x15c08,%ebx
    enum intr_level old_level = intr_disable();
c00248fe:	e8 20 d2 ff ff       	call   c0021b23 <intr_disable>
c0024903:	89 c6                	mov    %eax,%esi
    if (!inited) {
c0024905:	80 bb f8 18 00 00 00 	cmpb   $0x0,0x18f8(%ebx)
c002490c:	74 1b                	je     c0024929 <vga_putc+0x3d>
    switch (c) {
c002490e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0024912:	83 e8 07             	sub    $0x7,%eax
c0024915:	83 f8 06             	cmp    $0x6,%eax
c0024918:	0f 87 23 01 00 00    	ja     c0024a41 <.L11>
c002491e:	89 df                	mov    %ebx,%edi
c0024920:	03 bc 83 18 37 ff ff 	add    -0xc8e8(%ebx,%eax,4),%edi
c0024927:	ff e7                	jmp    *%edi
        fb = ptov(0xb8000);
c0024929:	c7 83 fc 18 00 00 00 	movl   $0xc00b8000,0x18fc(%ebx)
c0024930:	80 0b c0 
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024933:	bd d4 03 00 00       	mov    $0x3d4,%ebp
c0024938:	b8 0e 00 00 00       	mov    $0xe,%eax
c002493d:	89 ea                	mov    %ebp,%edx
c002493f:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024940:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0024945:	89 ca                	mov    %ecx,%edx
c0024947:	ec                   	in     (%dx),%al
find_cursor(size_t *x, size_t *y) {
    /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
    uint16_t cp;

    outb(0x3d4, 0x0e);
    cp = inb(0x3d5) << 8;
c0024948:	89 c7                	mov    %eax,%edi
c002494a:	c1 e7 08             	shl    $0x8,%edi
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002494d:	b8 0f 00 00 00       	mov    $0xf,%eax
c0024952:	89 ea                	mov    %ebp,%edx
c0024954:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024955:	89 ca                	mov    %ecx,%edx
c0024957:	ec                   	in     (%dx),%al

    outb(0x3d4, 0x0f);
    cp |= inb(0x3d5);
c0024958:	0f b6 c0             	movzbl %al,%eax
c002495b:	09 c7                	or     %eax,%edi

    *x = cp % COL_CNT;
c002495d:	0f b7 c7             	movzwl %di,%eax
c0024960:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c0024966:	c1 e8 16             	shr    $0x16,%eax
c0024969:	8d 14 80             	lea    (%eax,%eax,4),%edx
c002496c:	c1 e2 04             	shl    $0x4,%edx
c002496f:	29 d7                	sub    %edx,%edi
c0024971:	0f b7 ff             	movzwl %di,%edi
c0024974:	89 bb 04 19 00 00    	mov    %edi,0x1904(%ebx)
    *y = cp / COL_CNT;
c002497a:	0f b7 c0             	movzwl %ax,%eax
c002497d:	89 83 00 19 00 00    	mov    %eax,0x1900(%ebx)
        inited = true;
c0024983:	c6 83 f8 18 00 00 01 	movb   $0x1,0x18f8(%ebx)
c002498a:	eb 82                	jmp    c002490e <vga_putc+0x22>

c002498c <.L14>:
c002498c:	8b 8b fc 18 00 00    	mov    0x18fc(%ebx),%ecx
c0024992:	8d b9 a0 0f 00 00    	lea    0xfa0(%ecx),%edi
vga_putc(int c) {
c0024998:	89 c8                	mov    %ecx,%eax
c002499a:	8d 91 a0 00 00 00    	lea    0xa0(%ecx),%edx
        fb[y][x][0] = ' ';
c00249a0:	c6 00 20             	movb   $0x20,(%eax)
        fb[y][x][1] = GRAY_ON_BLACK;
c00249a3:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c00249a7:	83 c0 02             	add    $0x2,%eax
    for (x = 0; x < COL_CNT; x++) {
c00249aa:	39 d0                	cmp    %edx,%eax
c00249ac:	75 f2                	jne    c00249a0 <.L14+0x14>
c00249ae:	89 d1                	mov    %edx,%ecx
    for (y = 0; y < ROW_CNT; y++)
c00249b0:	39 d7                	cmp    %edx,%edi
c00249b2:	75 e4                	jne    c0024998 <.L14+0xc>
    cx = cy = 0;
c00249b4:	c7 83 00 19 00 00 00 	movl   $0x0,0x1900(%ebx)
c00249bb:	00 00 00 
c00249be:	c7 83 04 19 00 00 00 	movl   $0x0,0x1904(%ebx)
c00249c5:	00 00 00 
    move_cursor();
c00249c8:	e8 71 fe ff ff       	call   c002483e <move_cursor>
c00249cd:	eb 05                	jmp    c00249d4 <.L15+0x5>

c00249cf <.L15>:
            newline();
c00249cf:	e8 a0 fe ff ff       	call   c0024874 <newline>
    move_cursor();
c00249d4:	e8 65 fe ff ff       	call   c002483e <move_cursor>
    intr_set_level(old_level);
c00249d9:	83 ec 0c             	sub    $0xc,%esp
c00249dc:	56                   	push   %esi
c00249dd:	e8 48 d1 ff ff       	call   c0021b2a <intr_set_level>
}
c00249e2:	83 c4 1c             	add    $0x1c,%esp
c00249e5:	5b                   	pop    %ebx
c00249e6:	5e                   	pop    %esi
c00249e7:	5f                   	pop    %edi
c00249e8:	5d                   	pop    %ebp
c00249e9:	c3                   	ret    

c00249ea <.L17>:
            if (cx > 0)
c00249ea:	8b 83 04 19 00 00    	mov    0x1904(%ebx),%eax
c00249f0:	85 c0                	test   %eax,%eax
c00249f2:	74 e0                	je     c00249d4 <.L15+0x5>
                cx--;
c00249f4:	83 e8 01             	sub    $0x1,%eax
c00249f7:	89 83 04 19 00 00    	mov    %eax,0x1904(%ebx)
c00249fd:	eb d5                	jmp    c00249d4 <.L15+0x5>

c00249ff <.L12>:
            cx = 0;
c00249ff:	c7 83 04 19 00 00 00 	movl   $0x0,0x1904(%ebx)
c0024a06:	00 00 00 
            break;
c0024a09:	eb c9                	jmp    c00249d4 <.L15+0x5>

c0024a0b <.L16>:
            cx = ROUND_UP (cx + 1, 8);
c0024a0b:	8b 83 04 19 00 00    	mov    0x1904(%ebx),%eax
c0024a11:	83 c0 08             	add    $0x8,%eax
c0024a14:	83 e0 f8             	and    $0xfffffff8,%eax
c0024a17:	89 83 04 19 00 00    	mov    %eax,0x1904(%ebx)
            if (cx >= COL_CNT)
c0024a1d:	83 f8 4f             	cmp    $0x4f,%eax
c0024a20:	76 b2                	jbe    c00249d4 <.L15+0x5>
                newline();
c0024a22:	e8 4d fe ff ff       	call   c0024874 <newline>
c0024a27:	eb ab                	jmp    c00249d4 <.L15+0x5>

c0024a29 <.L18>:
            intr_set_level(old_level);
c0024a29:	83 ec 0c             	sub    $0xc,%esp
c0024a2c:	56                   	push   %esi
c0024a2d:	e8 f8 d0 ff ff       	call   c0021b2a <intr_set_level>
            speaker_beep();
c0024a32:	e8 83 21 00 00       	call   c0026bba <speaker_beep>
            intr_disable();
c0024a37:	e8 e7 d0 ff ff       	call   c0021b23 <intr_disable>
            break;
c0024a3c:	83 c4 10             	add    $0x10,%esp
c0024a3f:	eb 93                	jmp    c00249d4 <.L15+0x5>

c0024a41 <.L11>:
            fb[cy][cx][0] = c;
c0024a41:	8b bb fc 18 00 00    	mov    0x18fc(%ebx),%edi
c0024a47:	8b 83 00 19 00 00    	mov    0x1900(%ebx),%eax
c0024a4d:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024a50:	c1 e0 05             	shl    $0x5,%eax
c0024a53:	01 f8                	add    %edi,%eax
c0024a55:	8b 8b 04 19 00 00    	mov    0x1904(%ebx),%ecx
c0024a5b:	0f b6 54 24 20       	movzbl 0x20(%esp),%edx
c0024a60:	88 14 48             	mov    %dl,(%eax,%ecx,2)
            fb[cy][cx][1] = GRAY_ON_BLACK;
c0024a63:	8b 83 00 19 00 00    	mov    0x1900(%ebx),%eax
c0024a69:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024a6c:	c1 e0 05             	shl    $0x5,%eax
c0024a6f:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0024a72:	8b 83 04 19 00 00    	mov    0x1904(%ebx),%eax
c0024a78:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
            if (++cx >= COL_CNT)
c0024a7d:	8b 83 04 19 00 00    	mov    0x1904(%ebx),%eax
c0024a83:	83 c0 01             	add    $0x1,%eax
c0024a86:	89 83 04 19 00 00    	mov    %eax,0x1904(%ebx)
c0024a8c:	83 f8 4f             	cmp    $0x4f,%eax
c0024a8f:	0f 86 3f ff ff ff    	jbe    c00249d4 <.L15+0x5>
                newline();
c0024a95:	e8 da fd ff ff       	call   c0024874 <newline>
c0024a9a:	e9 35 ff ff ff       	jmp    c00249d4 <.L15+0x5>

c0024a9f <init_poll>:
/* Initializes the serial port device for polling mode.
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll(void) {
c0024a9f:	57                   	push   %edi
c0024aa0:	56                   	push   %esi
c0024aa1:	53                   	push   %ebx
c0024aa2:	e8 f0 8d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024aa7:	81 c3 59 5a 01 00    	add    $0x15a59,%ebx
    ASSERT (mode == UNINIT);
c0024aad:	83 bb 94 19 00 00 00 	cmpl   $0x0,0x1994(%ebx)
c0024ab4:	75 65                	jne    c0024b1b <init_poll+0x7c>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024ab6:	b9 00 00 00 00       	mov    $0x0,%ecx
c0024abb:	bf f9 03 00 00       	mov    $0x3f9,%edi
c0024ac0:	89 c8                	mov    %ecx,%eax
c0024ac2:	89 fa                	mov    %edi,%edx
c0024ac4:	ee                   	out    %al,(%dx)
c0024ac5:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024aca:	ee                   	out    %al,(%dx)
c0024acb:	be fb 03 00 00       	mov    $0x3fb,%esi
c0024ad0:	b8 83 ff ff ff       	mov    $0xffffff83,%eax
c0024ad5:	89 f2                	mov    %esi,%edx
c0024ad7:	ee                   	out    %al,(%dx)
c0024ad8:	b8 0c 00 00 00       	mov    $0xc,%eax
c0024add:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024ae2:	ee                   	out    %al,(%dx)
c0024ae3:	89 c8                	mov    %ecx,%eax
c0024ae5:	89 fa                	mov    %edi,%edx
c0024ae7:	ee                   	out    %al,(%dx)
c0024ae8:	b8 03 00 00 00       	mov    $0x3,%eax
c0024aed:	89 f2                	mov    %esi,%edx
c0024aef:	ee                   	out    %al,(%dx)
c0024af0:	b8 08 00 00 00       	mov    $0x8,%eax
c0024af5:	ba fc 03 00 00       	mov    $0x3fc,%edx
c0024afa:	ee                   	out    %al,(%dx)
    outb(IER_REG, 0);                    /* Turn off all interrupts. */
    outb(FCR_REG, 0);                    /* Disable FIFO. */
    set_serial(9600);                    /* 9.6 kbps, N-8-1. */
    outb(MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
    intq_init(&txq);
c0024afb:	83 ec 0c             	sub    $0xc,%esp
c0024afe:	8d 83 20 19 00 00    	lea    0x1920(%ebx),%eax
c0024b04:	50                   	push   %eax
c0024b05:	e8 57 19 00 00       	call   c0026461 <intq_init>
    mode = POLL;
c0024b0a:	c7 83 94 19 00 00 01 	movl   $0x1,0x1994(%ebx)
c0024b11:	00 00 00 
}
c0024b14:	83 c4 10             	add    $0x10,%esp
c0024b17:	5b                   	pop    %ebx
c0024b18:	5e                   	pop    %esi
c0024b19:	5f                   	pop    %edi
c0024b1a:	c3                   	ret    
    ASSERT (mode == UNINIT);
c0024b1b:	83 ec 0c             	sub    $0xc,%esp
c0024b1e:	8d 83 87 51 ff ff    	lea    -0xae79(%ebx),%eax
c0024b24:	50                   	push   %eax
c0024b25:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024b2b:	50                   	push   %eax
c0024b2c:	8d 83 5c 37 ff ff    	lea    -0xc8a4(%ebx),%eax
c0024b32:	50                   	push   %eax
c0024b33:	6a 49                	push   $0x49
c0024b35:	8d 83 96 51 ff ff    	lea    -0xae6a(%ebx),%eax
c0024b3b:	50                   	push   %eax
c0024b3c:	e8 a3 43 00 00       	call   c0028ee4 <debug_panic>

c0024b41 <write_ier>:
    outb(LCR_REG, LCR_N81);
}

/* Update interrupt enable register. */
static void
write_ier(void) {
c0024b41:	56                   	push   %esi
c0024b42:	53                   	push   %ebx
c0024b43:	83 ec 04             	sub    $0x4,%esp
c0024b46:	e8 4c 8d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024b4b:	81 c3 b5 59 01 00    	add    $0x159b5,%ebx
    uint8_t ier = 0;

    ASSERT (intr_get_level() == INTR_OFF);
c0024b51:	e8 7b cf ff ff       	call   c0021ad1 <intr_get_level>
c0024b56:	85 c0                	test   %eax,%eax
c0024b58:	75 37                	jne    c0024b91 <write_ier+0x50>

    /* Enable transmit interrupt if we have any characters to
       transmit. */
    if (!intq_empty(&txq))
c0024b5a:	83 ec 0c             	sub    $0xc,%esp
c0024b5d:	8d 83 20 19 00 00    	lea    0x1920(%ebx),%eax
c0024b63:	50                   	push   %eax
c0024b64:	e8 34 19 00 00       	call   c002649d <intq_empty>
c0024b69:	83 c4 10             	add    $0x10,%esp
        ier |= IER_XMIT;
c0024b6c:	84 c0                	test   %al,%al
c0024b6e:	0f 94 c0             	sete   %al
c0024b71:	8d 34 00             	lea    (%eax,%eax,1),%esi

    /* Enable receive interrupt if we have room to store any
       characters we receive. */
    if (!input_full())
c0024b74:	e8 96 18 00 00       	call   c002640f <input_full>
        ier |= IER_RECV;
c0024b79:	89 f2                	mov    %esi,%edx
c0024b7b:	83 ca 01             	or     $0x1,%edx
c0024b7e:	84 c0                	test   %al,%al
c0024b80:	0f 44 f2             	cmove  %edx,%esi
c0024b83:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0024b88:	89 f0                	mov    %esi,%eax
c0024b8a:	ee                   	out    %al,(%dx)

    outb(IER_REG, ier);
}
c0024b8b:	83 c4 04             	add    $0x4,%esp
c0024b8e:	5b                   	pop    %ebx
c0024b8f:	5e                   	pop    %esi
c0024b90:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0024b91:	83 ec 0c             	sub    $0xc,%esp
c0024b94:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0024b9a:	50                   	push   %eax
c0024b9b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024ba1:	50                   	push   %eax
c0024ba2:	8d 83 50 37 ff ff    	lea    -0xc8b0(%ebx),%eax
c0024ba8:	50                   	push   %eax
c0024ba9:	68 af 00 00 00       	push   $0xaf
c0024bae:	8d 83 96 51 ff ff    	lea    -0xae6a(%ebx),%eax
c0024bb4:	50                   	push   %eax
c0024bb5:	e8 2a 43 00 00       	call   c0028ee4 <debug_panic>

c0024bba <serial_interrupt>:
    outb(THR_REG, byte);
}

/* Serial interrupt handler. */
static void
serial_interrupt(struct intr_frame *f UNUSED) {
c0024bba:	57                   	push   %edi
c0024bbb:	56                   	push   %esi
c0024bbc:	53                   	push   %ebx
c0024bbd:	e8 d5 8c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024bc2:	81 c3 3e 59 01 00    	add    $0x1593e,%ebx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024bc8:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024bcd:	ec                   	in     (%dx),%al
c0024bce:	be fd 03 00 00       	mov    $0x3fd,%esi
c0024bd3:	bf f8 03 00 00       	mov    $0x3f8,%edi
       occasionally miss an interrupt running under QEMU. */
    inb(IIR_REG);

    /* As long as we have room to receive a byte, and the hardware
       has a byte for us, receive a byte.  */
    while (!input_full() && (inb(LSR_REG) & LSR_DR) != 0)
c0024bd8:	e8 32 18 00 00       	call   c002640f <input_full>
c0024bdd:	84 c0                	test   %al,%al
c0024bdf:	75 4d                	jne    c0024c2e <serial_interrupt+0x74>
c0024be1:	89 f2                	mov    %esi,%edx
c0024be3:	ec                   	in     (%dx),%al
c0024be4:	a8 01                	test   $0x1,%al
c0024be6:	74 46                	je     c0024c2e <serial_interrupt+0x74>
c0024be8:	89 fa                	mov    %edi,%edx
c0024bea:	ec                   	in     (%dx),%al
        input_putc(inb(RBR_REG));
c0024beb:	83 ec 0c             	sub    $0xc,%esp
c0024bee:	0f b6 c0             	movzbl %al,%eax
c0024bf1:	50                   	push   %eax
c0024bf2:	e8 3d 17 00 00       	call   c0026334 <input_putc>
c0024bf7:	83 c4 10             	add    $0x10,%esp
c0024bfa:	eb dc                	jmp    c0024bd8 <serial_interrupt+0x1e>

    /* As long as we have a byte to transmit, and the hardware is
       ready to accept a byte for transmission, transmit a byte. */
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
        outb(THR_REG, intq_getc(&txq));
c0024bfc:	83 ec 0c             	sub    $0xc,%esp
c0024bff:	56                   	push   %esi
c0024c00:	e8 da 1a 00 00       	call   c00266df <intq_getc>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024c05:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024c0a:	ee                   	out    %al,(%dx)
c0024c0b:	83 c4 10             	add    $0x10,%esp
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c0024c0e:	83 ec 0c             	sub    $0xc,%esp
c0024c11:	56                   	push   %esi
c0024c12:	e8 86 18 00 00       	call   c002649d <intq_empty>
c0024c17:	83 c4 10             	add    $0x10,%esp
c0024c1a:	84 c0                	test   %al,%al
c0024c1c:	75 07                	jne    c0024c25 <serial_interrupt+0x6b>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024c1e:	89 fa                	mov    %edi,%edx
c0024c20:	ec                   	in     (%dx),%al
c0024c21:	a8 20                	test   $0x20,%al
c0024c23:	75 d7                	jne    c0024bfc <serial_interrupt+0x42>

    /* Update interrupt enable register based on queue status. */
    write_ier();
c0024c25:	e8 17 ff ff ff       	call   c0024b41 <write_ier>
}
c0024c2a:	5b                   	pop    %ebx
c0024c2b:	5e                   	pop    %esi
c0024c2c:	5f                   	pop    %edi
c0024c2d:	c3                   	ret    
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c0024c2e:	8d b3 20 19 00 00    	lea    0x1920(%ebx),%esi
c0024c34:	bf fd 03 00 00       	mov    $0x3fd,%edi
c0024c39:	eb d3                	jmp    c0024c0e <serial_interrupt+0x54>

c0024c3b <putc_poll>:
putc_poll(uint8_t byte) {
c0024c3b:	56                   	push   %esi
c0024c3c:	53                   	push   %ebx
c0024c3d:	83 ec 04             	sub    $0x4,%esp
c0024c40:	e8 52 8c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024c45:	81 c3 bb 58 01 00    	add    $0x158bb,%ebx
c0024c4b:	89 c6                	mov    %eax,%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0024c4d:	e8 7f ce ff ff       	call   c0021ad1 <intr_get_level>
c0024c52:	85 c0                	test   %eax,%eax
c0024c54:	75 18                	jne    c0024c6e <putc_poll+0x33>
c0024c56:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024c5b:	ec                   	in     (%dx),%al
    while ((inb(LSR_REG) & LSR_THRE) == 0)
c0024c5c:	a8 20                	test   $0x20,%al
c0024c5e:	74 fb                	je     c0024c5b <putc_poll+0x20>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024c60:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024c65:	89 f0                	mov    %esi,%eax
c0024c67:	ee                   	out    %al,(%dx)
}
c0024c68:	83 c4 04             	add    $0x4,%esp
c0024c6b:	5b                   	pop    %ebx
c0024c6c:	5e                   	pop    %esi
c0024c6d:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0024c6e:	83 ec 0c             	sub    $0xc,%esp
c0024c71:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0024c77:	50                   	push   %eax
c0024c78:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024c7e:	50                   	push   %eax
c0024c7f:	8d 83 44 37 ff ff    	lea    -0xc8bc(%ebx),%eax
c0024c85:	50                   	push   %eax
c0024c86:	68 c2 00 00 00       	push   $0xc2
c0024c8b:	8d 83 96 51 ff ff    	lea    -0xae6a(%ebx),%eax
c0024c91:	50                   	push   %eax
c0024c92:	e8 4d 42 00 00       	call   c0028ee4 <debug_panic>

c0024c97 <serial_init_queue>:
serial_init_queue(void) {
c0024c97:	56                   	push   %esi
c0024c98:	53                   	push   %ebx
c0024c99:	83 ec 04             	sub    $0x4,%esp
c0024c9c:	e8 f6 8b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024ca1:	81 c3 5f 58 01 00    	add    $0x1585f,%ebx
    if (mode == UNINIT)
c0024ca7:	83 bb 94 19 00 00 00 	cmpl   $0x0,0x1994(%ebx)
c0024cae:	74 45                	je     c0024cf5 <serial_init_queue+0x5e>
    ASSERT (mode == POLL);
c0024cb0:	83 bb 94 19 00 00 01 	cmpl   $0x1,0x1994(%ebx)
c0024cb7:	75 43                	jne    c0024cfc <serial_init_queue+0x65>
    intr_register_ext(0x20 + 4, serial_interrupt, "serial");
c0024cb9:	83 ec 04             	sub    $0x4,%esp
c0024cbc:	8d 83 ba 51 ff ff    	lea    -0xae46(%ebx),%eax
c0024cc2:	50                   	push   %eax
c0024cc3:	8d 83 ba a6 fe ff    	lea    -0x15946(%ebx),%eax
c0024cc9:	50                   	push   %eax
c0024cca:	6a 24                	push   $0x24
c0024ccc:	e8 2e d0 ff ff       	call   c0021cff <intr_register_ext>
    mode = QUEUE;
c0024cd1:	c7 83 94 19 00 00 02 	movl   $0x2,0x1994(%ebx)
c0024cd8:	00 00 00 
    old_level = intr_disable();
c0024cdb:	e8 43 ce ff ff       	call   c0021b23 <intr_disable>
c0024ce0:	89 c6                	mov    %eax,%esi
    write_ier();
c0024ce2:	e8 5a fe ff ff       	call   c0024b41 <write_ier>
    intr_set_level(old_level);
c0024ce7:	89 34 24             	mov    %esi,(%esp)
c0024cea:	e8 3b ce ff ff       	call   c0021b2a <intr_set_level>
}
c0024cef:	83 c4 14             	add    $0x14,%esp
c0024cf2:	5b                   	pop    %ebx
c0024cf3:	5e                   	pop    %esi
c0024cf4:	c3                   	ret    
        init_poll();
c0024cf5:	e8 a5 fd ff ff       	call   c0024a9f <init_poll>
c0024cfa:	eb b4                	jmp    c0024cb0 <serial_init_queue+0x19>
    ASSERT (mode == POLL);
c0024cfc:	83 ec 0c             	sub    $0xc,%esp
c0024cff:	8d 83 ad 51 ff ff    	lea    -0xae53(%ebx),%eax
c0024d05:	50                   	push   %eax
c0024d06:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024d0c:	50                   	push   %eax
c0024d0d:	8d 83 68 37 ff ff    	lea    -0xc898(%ebx),%eax
c0024d13:	50                   	push   %eax
c0024d14:	6a 5b                	push   $0x5b
c0024d16:	8d 83 96 51 ff ff    	lea    -0xae6a(%ebx),%eax
c0024d1c:	50                   	push   %eax
c0024d1d:	e8 c2 41 00 00       	call   c0028ee4 <debug_panic>

c0024d22 <serial_putc>:
serial_putc(uint8_t byte) {
c0024d22:	57                   	push   %edi
c0024d23:	56                   	push   %esi
c0024d24:	53                   	push   %ebx
c0024d25:	e8 6d 8b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024d2a:	81 c3 d6 57 01 00    	add    $0x157d6,%ebx
c0024d30:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0024d34:	e8 ea cd ff ff       	call   c0021b23 <intr_disable>
c0024d39:	89 c7                	mov    %eax,%edi
    if (mode != QUEUE) {
c0024d3b:	8b 83 94 19 00 00    	mov    0x1994(%ebx),%eax
c0024d41:	83 f8 02             	cmp    $0x2,%eax
c0024d44:	74 25                	je     c0024d6b <serial_putc+0x49>
        if (mode == UNINIT)
c0024d46:	85 c0                	test   %eax,%eax
c0024d48:	74 1a                	je     c0024d64 <serial_putc+0x42>
        putc_poll(byte);
c0024d4a:	89 f0                	mov    %esi,%eax
c0024d4c:	0f b6 c0             	movzbl %al,%eax
c0024d4f:	e8 e7 fe ff ff       	call   c0024c3b <putc_poll>
    intr_set_level(old_level);
c0024d54:	83 ec 0c             	sub    $0xc,%esp
c0024d57:	57                   	push   %edi
c0024d58:	e8 cd cd ff ff       	call   c0021b2a <intr_set_level>
}
c0024d5d:	83 c4 10             	add    $0x10,%esp
c0024d60:	5b                   	pop    %ebx
c0024d61:	5e                   	pop    %esi
c0024d62:	5f                   	pop    %edi
c0024d63:	c3                   	ret    
            init_poll();
c0024d64:	e8 36 fd ff ff       	call   c0024a9f <init_poll>
c0024d69:	eb df                	jmp    c0024d4a <serial_putc+0x28>
        if (old_level == INTR_OFF && intq_full(&txq)) {
c0024d6b:	85 ff                	test   %edi,%edi
c0024d6d:	74 1f                	je     c0024d8e <serial_putc+0x6c>
        intq_putc(&txq, byte);
c0024d6f:	83 ec 08             	sub    $0x8,%esp
c0024d72:	89 f0                	mov    %esi,%eax
c0024d74:	0f b6 f0             	movzbl %al,%esi
c0024d77:	56                   	push   %esi
c0024d78:	8d 83 20 19 00 00    	lea    0x1920(%ebx),%eax
c0024d7e:	50                   	push   %eax
c0024d7f:	e8 26 1a 00 00       	call   c00267aa <intq_putc>
        write_ier();
c0024d84:	e8 b8 fd ff ff       	call   c0024b41 <write_ier>
c0024d89:	83 c4 10             	add    $0x10,%esp
c0024d8c:	eb c6                	jmp    c0024d54 <serial_putc+0x32>
        if (old_level == INTR_OFF && intq_full(&txq)) {
c0024d8e:	83 ec 0c             	sub    $0xc,%esp
c0024d91:	8d 83 20 19 00 00    	lea    0x1920(%ebx),%eax
c0024d97:	50                   	push   %eax
c0024d98:	e8 52 17 00 00       	call   c00264ef <intq_full>
c0024d9d:	83 c4 10             	add    $0x10,%esp
c0024da0:	84 c0                	test   %al,%al
c0024da2:	74 cb                	je     c0024d6f <serial_putc+0x4d>
            putc_poll(intq_getc(&txq));
c0024da4:	83 ec 0c             	sub    $0xc,%esp
c0024da7:	8d 83 20 19 00 00    	lea    0x1920(%ebx),%eax
c0024dad:	50                   	push   %eax
c0024dae:	e8 2c 19 00 00       	call   c00266df <intq_getc>
c0024db3:	0f b6 c0             	movzbl %al,%eax
c0024db6:	e8 80 fe ff ff       	call   c0024c3b <putc_poll>
c0024dbb:	83 c4 10             	add    $0x10,%esp
c0024dbe:	eb af                	jmp    c0024d6f <serial_putc+0x4d>

c0024dc0 <serial_flush>:
serial_flush(void) {
c0024dc0:	57                   	push   %edi
c0024dc1:	56                   	push   %esi
c0024dc2:	53                   	push   %ebx
c0024dc3:	e8 cf 8a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024dc8:	81 c3 38 57 01 00    	add    $0x15738,%ebx
    enum intr_level old_level = intr_disable();
c0024dce:	e8 50 cd ff ff       	call   c0021b23 <intr_disable>
c0024dd3:	89 c7                	mov    %eax,%edi
    while (!intq_empty(&txq))
c0024dd5:	8d b3 20 19 00 00    	lea    0x1920(%ebx),%esi
c0024ddb:	83 ec 0c             	sub    $0xc,%esp
c0024dde:	56                   	push   %esi
c0024ddf:	e8 b9 16 00 00       	call   c002649d <intq_empty>
c0024de4:	83 c4 10             	add    $0x10,%esp
c0024de7:	84 c0                	test   %al,%al
c0024de9:	75 16                	jne    c0024e01 <serial_flush+0x41>
        putc_poll(intq_getc(&txq));
c0024deb:	83 ec 0c             	sub    $0xc,%esp
c0024dee:	56                   	push   %esi
c0024def:	e8 eb 18 00 00       	call   c00266df <intq_getc>
c0024df4:	0f b6 c0             	movzbl %al,%eax
c0024df7:	e8 3f fe ff ff       	call   c0024c3b <putc_poll>
c0024dfc:	83 c4 10             	add    $0x10,%esp
c0024dff:	eb da                	jmp    c0024ddb <serial_flush+0x1b>
    intr_set_level(old_level);
c0024e01:	83 ec 0c             	sub    $0xc,%esp
c0024e04:	57                   	push   %edi
c0024e05:	e8 20 cd ff ff       	call   c0021b2a <intr_set_level>
}
c0024e0a:	83 c4 10             	add    $0x10,%esp
c0024e0d:	5b                   	pop    %ebx
c0024e0e:	5e                   	pop    %esi
c0024e0f:	5f                   	pop    %edi
c0024e10:	c3                   	ret    

c0024e11 <serial_notify>:
serial_notify(void) {
c0024e11:	53                   	push   %ebx
c0024e12:	83 ec 08             	sub    $0x8,%esp
c0024e15:	e8 7d 8a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024e1a:	81 c3 e6 56 01 00    	add    $0x156e6,%ebx
    ASSERT (intr_get_level() == INTR_OFF);
c0024e20:	e8 ac cc ff ff       	call   c0021ad1 <intr_get_level>
c0024e25:	85 c0                	test   %eax,%eax
c0024e27:	75 0e                	jne    c0024e37 <serial_notify+0x26>
    if (mode == QUEUE)
c0024e29:	83 bb 94 19 00 00 02 	cmpl   $0x2,0x1994(%ebx)
c0024e30:	74 2e                	je     c0024e60 <serial_notify+0x4f>
}
c0024e32:	83 c4 08             	add    $0x8,%esp
c0024e35:	5b                   	pop    %ebx
c0024e36:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0024e37:	83 ec 0c             	sub    $0xc,%esp
c0024e3a:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0024e40:	50                   	push   %eax
c0024e41:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024e47:	50                   	push   %eax
c0024e48:	8d 83 34 37 ff ff    	lea    -0xc8cc(%ebx),%eax
c0024e4e:	50                   	push   %eax
c0024e4f:	68 92 00 00 00       	push   $0x92
c0024e54:	8d 83 96 51 ff ff    	lea    -0xae6a(%ebx),%eax
c0024e5a:	50                   	push   %eax
c0024e5b:	e8 84 40 00 00       	call   c0028ee4 <debug_panic>
        write_ier();
c0024e60:	e8 dc fc ff ff       	call   c0024b41 <write_ier>
}
c0024e65:	eb cb                	jmp    c0024e32 <serial_notify+0x21>

c0024e67 <check_sector>:
}

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector(struct block *block, block_sector_t sector) {
c0024e67:	53                   	push   %ebx
c0024e68:	83 ec 08             	sub    $0x8,%esp
c0024e6b:	e8 3b 8a 00 00       	call   c002d8ab <__x86.get_pc_thunk.cx>
c0024e70:	81 c1 90 56 01 00    	add    $0x15690,%ecx
    if (sector >= block->size) {
c0024e76:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0024e79:	39 d3                	cmp    %edx,%ebx
c0024e7b:	76 05                	jbe    c0024e82 <check_sector+0x1b>
                       ", "
                       "size=%"
                       PRDSNu
                       ")\n", block_name(block), sector, block->size);
    }
}
c0024e7d:	83 c4 08             	add    $0x8,%esp
c0024e80:	5b                   	pop    %ebx
c0024e81:	c3                   	ret    
        PANIC ("Access past end of device %s (sector=%"
c0024e82:	83 ec 04             	sub    $0x4,%esp
c0024e85:	53                   	push   %ebx
c0024e86:	52                   	push   %edx
}

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name(struct block *block) {
    return block->name;
c0024e87:	83 c0 08             	add    $0x8,%eax
        PANIC ("Access past end of device %s (sector=%"
c0024e8a:	50                   	push   %eax
c0024e8b:	8d 81 c4 51 ff ff    	lea    -0xae3c(%ecx),%eax
c0024e91:	50                   	push   %eax
c0024e92:	8d 81 98 37 ff ff    	lea    -0xc868(%ecx),%eax
c0024e98:	50                   	push   %eax
c0024e99:	6a 6a                	push   $0x6a
c0024e9b:	8d 81 52 52 ff ff    	lea    -0xadae(%ecx),%eax
c0024ea1:	50                   	push   %eax
c0024ea2:	89 cb                	mov    %ecx,%ebx
c0024ea4:	e8 3b 40 00 00       	call   c0028ee4 <debug_panic>

c0024ea9 <block_type_name>:
block_type_name(enum block_type type) {
c0024ea9:	53                   	push   %ebx
c0024eaa:	83 ec 08             	sub    $0x8,%esp
c0024ead:	e8 e5 89 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024eb2:	81 c3 4e 56 01 00    	add    $0x1564e,%ebx
c0024eb8:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (type < BLOCK_CNT);
c0024ebc:	83 f8 05             	cmp    $0x5,%eax
c0024ebf:	77 0c                	ja     c0024ecd <block_type_name+0x24>
    return block_type_names[type];
c0024ec1:	8b 84 83 b0 78 ff ff 	mov    -0x8750(%ebx,%eax,4),%eax
}
c0024ec8:	83 c4 08             	add    $0x8,%esp
c0024ecb:	5b                   	pop    %ebx
c0024ecc:	c3                   	ret    
    ASSERT (type < BLOCK_CNT);
c0024ecd:	83 ec 0c             	sub    $0xc,%esp
c0024ed0:	8d 83 68 52 ff ff    	lea    -0xad98(%ebx),%eax
c0024ed6:	50                   	push   %eax
c0024ed7:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024edd:	50                   	push   %eax
c0024ede:	8d 83 c8 37 ff ff    	lea    -0xc838(%ebx),%eax
c0024ee4:	50                   	push   %eax
c0024ee5:	6a 2d                	push   $0x2d
c0024ee7:	8d 83 52 52 ff ff    	lea    -0xadae(%ebx),%eax
c0024eed:	50                   	push   %eax
c0024eee:	e8 f1 3f 00 00       	call   c0028ee4 <debug_panic>

c0024ef3 <block_get_role>:
block_get_role(enum block_type role) {
c0024ef3:	53                   	push   %ebx
c0024ef4:	83 ec 08             	sub    $0x8,%esp
c0024ef7:	e8 9b 89 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024efc:	81 c3 04 56 01 00    	add    $0x15604,%ebx
c0024f02:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (role < BLOCK_ROLE_CNT);
c0024f06:	83 f8 03             	cmp    $0x3,%eax
c0024f09:	77 0c                	ja     c0024f17 <block_get_role+0x24>
    return block_by_role[role];
c0024f0b:	8b 84 83 98 19 00 00 	mov    0x1998(%ebx,%eax,4),%eax
}
c0024f12:	83 c4 08             	add    $0x8,%esp
c0024f15:	5b                   	pop    %ebx
c0024f16:	c3                   	ret    
    ASSERT (role < BLOCK_ROLE_CNT);
c0024f17:	83 ec 0c             	sub    $0xc,%esp
c0024f1a:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c0024f20:	50                   	push   %eax
c0024f21:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024f27:	50                   	push   %eax
c0024f28:	8d 83 b8 37 ff ff    	lea    -0xc848(%ebx),%eax
c0024f2e:	50                   	push   %eax
c0024f2f:	6a 35                	push   $0x35
c0024f31:	8d 83 52 52 ff ff    	lea    -0xadae(%ebx),%eax
c0024f37:	50                   	push   %eax
c0024f38:	e8 a7 3f 00 00       	call   c0028ee4 <debug_panic>

c0024f3d <block_set_role>:
block_set_role(enum block_type role, struct block *block) {
c0024f3d:	53                   	push   %ebx
c0024f3e:	83 ec 08             	sub    $0x8,%esp
c0024f41:	e8 51 89 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024f46:	81 c3 ba 55 01 00    	add    $0x155ba,%ebx
c0024f4c:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (role < BLOCK_ROLE_CNT);
c0024f50:	83 f8 03             	cmp    $0x3,%eax
c0024f53:	77 10                	ja     c0024f65 <block_set_role+0x28>
    block_by_role[role] = block;
c0024f55:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0024f59:	89 8c 83 98 19 00 00 	mov    %ecx,0x1998(%ebx,%eax,4)
}
c0024f60:	83 c4 08             	add    $0x8,%esp
c0024f63:	5b                   	pop    %ebx
c0024f64:	c3                   	ret    
    ASSERT (role < BLOCK_ROLE_CNT);
c0024f65:	83 ec 0c             	sub    $0xc,%esp
c0024f68:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c0024f6e:	50                   	push   %eax
c0024f6f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0024f75:	50                   	push   %eax
c0024f76:	8d 83 a8 37 ff ff    	lea    -0xc858(%ebx),%eax
c0024f7c:	50                   	push   %eax
c0024f7d:	6a 3c                	push   $0x3c
c0024f7f:	8d 83 52 52 ff ff    	lea    -0xadae(%ebx),%eax
c0024f85:	50                   	push   %eax
c0024f86:	e8 59 3f 00 00       	call   c0028ee4 <debug_panic>

c0024f8b <block_first>:
block_first(void) {
c0024f8b:	57                   	push   %edi
c0024f8c:	56                   	push   %esi
c0024f8d:	53                   	push   %ebx
c0024f8e:	e8 04 89 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024f93:	81 c3 6d 55 01 00    	add    $0x1556d,%ebx
    return list_elem_to_block(list_begin(&all_blocks));
c0024f99:	83 ec 0c             	sub    $0xc,%esp
c0024f9c:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c0024fa2:	57                   	push   %edi
c0024fa3:	e8 61 40 00 00       	call   c0029009 <list_begin>
c0024fa8:	89 c6                	mov    %eax,%esi

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block(struct list_elem *list_elem) {
    return (list_elem != list_end(&all_blocks)
c0024faa:	89 3c 24             	mov    %edi,(%esp)
c0024fad:	e8 f9 40 00 00       	call   c00290ab <list_end>
            ? list_entry (list_elem, struct block, list_elem)
            : NULL);
c0024fb2:	83 c4 10             	add    $0x10,%esp
c0024fb5:	39 c6                	cmp    %eax,%esi
c0024fb7:	b8 00 00 00 00       	mov    $0x0,%eax
c0024fbc:	0f 44 f0             	cmove  %eax,%esi
}
c0024fbf:	89 f0                	mov    %esi,%eax
c0024fc1:	5b                   	pop    %ebx
c0024fc2:	5e                   	pop    %esi
c0024fc3:	5f                   	pop    %edi
c0024fc4:	c3                   	ret    

c0024fc5 <block_next>:
block_next(struct block *block) {
c0024fc5:	56                   	push   %esi
c0024fc6:	53                   	push   %ebx
c0024fc7:	83 ec 10             	sub    $0x10,%esp
c0024fca:	e8 c8 88 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0024fcf:	81 c3 31 55 01 00    	add    $0x15531,%ebx
    return list_elem_to_block(list_next(&block->list_elem));
c0024fd5:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024fd9:	e8 70 40 00 00       	call   c002904e <list_next>
c0024fde:	89 c6                	mov    %eax,%esi
    return (list_elem != list_end(&all_blocks)
c0024fe0:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c0024fe6:	89 04 24             	mov    %eax,(%esp)
c0024fe9:	e8 bd 40 00 00       	call   c00290ab <list_end>
            : NULL);
c0024fee:	39 c6                	cmp    %eax,%esi
c0024ff0:	b8 00 00 00 00       	mov    $0x0,%eax
c0024ff5:	0f 44 f0             	cmove  %eax,%esi
}
c0024ff8:	89 f0                	mov    %esi,%eax
c0024ffa:	83 c4 14             	add    $0x14,%esp
c0024ffd:	5b                   	pop    %ebx
c0024ffe:	5e                   	pop    %esi
c0024fff:	c3                   	ret    

c0025000 <block_get_by_name>:
block_get_by_name(const char *name) {
c0025000:	55                   	push   %ebp
c0025001:	57                   	push   %edi
c0025002:	56                   	push   %esi
c0025003:	53                   	push   %ebx
c0025004:	83 ec 18             	sub    $0x18,%esp
c0025007:	e8 8b 88 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002500c:	81 c3 f4 54 01 00    	add    $0x154f4,%ebx
c0025012:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    for (e = list_begin(&all_blocks); e != list_end(&all_blocks);
c0025016:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c002501c:	50                   	push   %eax
c002501d:	e8 e7 3f 00 00       	call   c0029009 <list_begin>
c0025022:	89 c6                	mov    %eax,%esi
c0025024:	83 c4 10             	add    $0x10,%esp
c0025027:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c002502d:	83 ec 0c             	sub    $0xc,%esp
c0025030:	57                   	push   %edi
c0025031:	e8 75 40 00 00       	call   c00290ab <list_end>
c0025036:	83 c4 10             	add    $0x10,%esp
c0025039:	39 f0                	cmp    %esi,%eax
c002503b:	74 24                	je     c0025061 <block_get_by_name+0x61>
        if (!strcmp(name, block->name))
c002503d:	8d 46 08             	lea    0x8(%esi),%eax
c0025040:	83 ec 08             	sub    $0x8,%esp
c0025043:	50                   	push   %eax
c0025044:	55                   	push   %ebp
c0025045:	e8 50 31 00 00       	call   c002819a <strcmp>
c002504a:	83 c4 10             	add    $0x10,%esp
c002504d:	85 c0                	test   %eax,%eax
c002504f:	74 15                	je     c0025066 <block_get_by_name+0x66>
         e = list_next(e)) {
c0025051:	83 ec 0c             	sub    $0xc,%esp
c0025054:	56                   	push   %esi
c0025055:	e8 f4 3f 00 00       	call   c002904e <list_next>
c002505a:	89 c6                	mov    %eax,%esi
c002505c:	83 c4 10             	add    $0x10,%esp
c002505f:	eb cc                	jmp    c002502d <block_get_by_name+0x2d>
    return NULL;
c0025061:	be 00 00 00 00       	mov    $0x0,%esi
}
c0025066:	89 f0                	mov    %esi,%eax
c0025068:	83 c4 0c             	add    $0xc,%esp
c002506b:	5b                   	pop    %ebx
c002506c:	5e                   	pop    %esi
c002506d:	5f                   	pop    %edi
c002506e:	5d                   	pop    %ebp
c002506f:	c3                   	ret    

c0025070 <block_read>:
block_read(struct block *block, block_sector_t sector, void *buffer) {
c0025070:	56                   	push   %esi
c0025071:	53                   	push   %ebx
c0025072:	83 ec 04             	sub    $0x4,%esp
c0025075:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0025079:	8b 74 24 14          	mov    0x14(%esp),%esi
    check_sector(block, sector);
c002507d:	89 f2                	mov    %esi,%edx
c002507f:	89 d8                	mov    %ebx,%eax
c0025081:	e8 e1 fd ff ff       	call   c0024e67 <check_sector>
    block->ops->read(block->aux, sector, buffer);
c0025086:	83 ec 04             	sub    $0x4,%esp
c0025089:	8b 43 20             	mov    0x20(%ebx),%eax
c002508c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025090:	56                   	push   %esi
c0025091:	ff 73 24             	pushl  0x24(%ebx)
c0025094:	ff 10                	call   *(%eax)
    block->read_cnt++;
c0025096:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c002509a:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c002509e:	83 c4 14             	add    $0x14,%esp
c00250a1:	5b                   	pop    %ebx
c00250a2:	5e                   	pop    %esi
c00250a3:	c3                   	ret    

c00250a4 <block_write>:
block_write(struct block *block, block_sector_t sector, const void *buffer) {
c00250a4:	57                   	push   %edi
c00250a5:	56                   	push   %esi
c00250a6:	53                   	push   %ebx
c00250a7:	e8 eb 87 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00250ac:	81 c3 54 54 01 00    	add    $0x15454,%ebx
c00250b2:	8b 74 24 10          	mov    0x10(%esp),%esi
c00250b6:	8b 7c 24 14          	mov    0x14(%esp),%edi
    check_sector(block, sector);
c00250ba:	89 fa                	mov    %edi,%edx
c00250bc:	89 f0                	mov    %esi,%eax
c00250be:	e8 a4 fd ff ff       	call   c0024e67 <check_sector>
    ASSERT (block->type != BLOCK_FOREIGN);
c00250c3:	83 7e 18 05          	cmpl   $0x5,0x18(%esi)
c00250c7:	74 20                	je     c00250e9 <block_write+0x45>
    block->ops->write(block->aux, sector, buffer);
c00250c9:	83 ec 04             	sub    $0x4,%esp
c00250cc:	8b 46 20             	mov    0x20(%esi),%eax
c00250cf:	ff 74 24 1c          	pushl  0x1c(%esp)
c00250d3:	57                   	push   %edi
c00250d4:	ff 76 24             	pushl  0x24(%esi)
c00250d7:	ff 50 04             	call   *0x4(%eax)
    block->write_cnt++;
c00250da:	83 46 30 01          	addl   $0x1,0x30(%esi)
c00250de:	83 56 34 00          	adcl   $0x0,0x34(%esi)
}
c00250e2:	83 c4 10             	add    $0x10,%esp
c00250e5:	5b                   	pop    %ebx
c00250e6:	5e                   	pop    %esi
c00250e7:	5f                   	pop    %edi
c00250e8:	c3                   	ret    
    ASSERT (block->type != BLOCK_FOREIGN);
c00250e9:	83 ec 0c             	sub    $0xc,%esp
c00250ec:	8d 83 8f 52 ff ff    	lea    -0xad71(%ebx),%eax
c00250f2:	50                   	push   %eax
c00250f3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00250f9:	50                   	push   %eax
c00250fa:	8d 83 8c 37 ff ff    	lea    -0xc874(%ebx),%eax
c0025100:	50                   	push   %eax
c0025101:	68 81 00 00 00       	push   $0x81
c0025106:	8d 83 52 52 ff ff    	lea    -0xadae(%ebx),%eax
c002510c:	50                   	push   %eax
c002510d:	e8 d2 3d 00 00       	call   c0028ee4 <debug_panic>

c0025112 <block_size>:
    return block->size;
c0025112:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025116:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0025119:	c3                   	ret    

c002511a <block_name>:
    return block->name;
c002511a:	8b 44 24 04          	mov    0x4(%esp),%eax
c002511e:	83 c0 08             	add    $0x8,%eax
}
c0025121:	c3                   	ret    

c0025122 <block_type>:
    return block->type;
c0025122:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025126:	8b 40 18             	mov    0x18(%eax),%eax
}
c0025129:	c3                   	ret    

c002512a <block_print_stats>:
block_print_stats(void) {
c002512a:	55                   	push   %ebp
c002512b:	57                   	push   %edi
c002512c:	56                   	push   %esi
c002512d:	53                   	push   %ebx
c002512e:	83 ec 1c             	sub    $0x1c,%esp
c0025131:	e8 61 87 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025136:	81 c3 ca 53 01 00    	add    $0x153ca,%ebx
    for (i = 0; i < BLOCK_ROLE_CNT; i++) {
c002513c:	8d bb 98 19 00 00    	lea    0x1998(%ebx),%edi
c0025142:	8d 6f 10             	lea    0x10(%edi),%ebp
            printf("%s (%s): %llu reads, %llu writes\n",
c0025145:	8d 83 f8 51 ff ff    	lea    -0xae08(%ebx),%eax
c002514b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002514f:	eb 32                	jmp    c0025183 <block_print_stats+0x59>
c0025151:	83 ec 0c             	sub    $0xc,%esp
c0025154:	ff 76 18             	pushl  0x18(%esi)
c0025157:	e8 4d fd ff ff       	call   c0024ea9 <block_type_name>
c002515c:	83 c4 0c             	add    $0xc,%esp
c002515f:	ff 76 34             	pushl  0x34(%esi)
c0025162:	ff 76 30             	pushl  0x30(%esi)
c0025165:	ff 76 2c             	pushl  0x2c(%esi)
c0025168:	ff 76 28             	pushl  0x28(%esi)
c002516b:	50                   	push   %eax
c002516c:	83 c6 08             	add    $0x8,%esi
c002516f:	56                   	push   %esi
c0025170:	ff 74 24 28          	pushl  0x28(%esp)
c0025174:	e8 0f 21 00 00       	call   c0027288 <printf>
c0025179:	83 c4 20             	add    $0x20,%esp
c002517c:	83 c7 04             	add    $0x4,%edi
    for (i = 0; i < BLOCK_ROLE_CNT; i++) {
c002517f:	39 ef                	cmp    %ebp,%edi
c0025181:	74 08                	je     c002518b <block_print_stats+0x61>
        struct block *block = block_by_role[i];
c0025183:	8b 37                	mov    (%edi),%esi
        if (block != NULL) {
c0025185:	85 f6                	test   %esi,%esi
c0025187:	75 c8                	jne    c0025151 <block_print_stats+0x27>
c0025189:	eb f1                	jmp    c002517c <block_print_stats+0x52>
}
c002518b:	83 c4 1c             	add    $0x1c,%esp
c002518e:	5b                   	pop    %ebx
c002518f:	5e                   	pop    %esi
c0025190:	5f                   	pop    %edi
c0025191:	5d                   	pop    %ebp
c0025192:	c3                   	ret    

c0025193 <block_register>:
               const struct block_operations *ops, void *aux) {
c0025193:	55                   	push   %ebp
c0025194:	57                   	push   %edi
c0025195:	56                   	push   %esi
c0025196:	53                   	push   %ebx
c0025197:	83 ec 18             	sub    $0x18,%esp
c002519a:	e8 f8 86 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002519f:	81 c3 61 53 01 00    	add    $0x15361,%ebx
c00251a5:	8b 7c 24 38          	mov    0x38(%esp),%edi
    struct block *block = malloc(sizeof *block);
c00251a9:	6a 38                	push   $0x38
c00251ab:	e8 64 ea ff ff       	call   c0023c14 <malloc>
    if (block == NULL)
c00251b0:	83 c4 10             	add    $0x10,%esp
c00251b3:	85 c0                	test   %eax,%eax
c00251b5:	0f 84 c6 00 00 00    	je     c0025281 <block_register+0xee>
c00251bb:	89 c6                	mov    %eax,%esi
    list_push_back(&all_blocks, &block->list_elem);
c00251bd:	83 ec 08             	sub    $0x8,%esp
c00251c0:	50                   	push   %eax
c00251c1:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c00251c7:	50                   	push   %eax
c00251c8:	e8 c9 43 00 00       	call   c0029596 <list_push_back>
    strlcpy(block->name, name, sizeof block->name);
c00251cd:	8d 6e 08             	lea    0x8(%esi),%ebp
c00251d0:	83 c4 0c             	add    $0xc,%esp
c00251d3:	6a 10                	push   $0x10
c00251d5:	ff 74 24 28          	pushl  0x28(%esp)
c00251d9:	55                   	push   %ebp
c00251da:	e8 47 33 00 00       	call   c0028526 <strlcpy>
    block->type = type;
c00251df:	8b 44 24 34          	mov    0x34(%esp),%eax
c00251e3:	89 46 18             	mov    %eax,0x18(%esi)
    block->size = size;
c00251e6:	89 7e 1c             	mov    %edi,0x1c(%esi)
    block->ops = ops;
c00251e9:	8b 44 24 40          	mov    0x40(%esp),%eax
c00251ed:	89 46 20             	mov    %eax,0x20(%esi)
    block->aux = aux;
c00251f0:	8b 44 24 44          	mov    0x44(%esp),%eax
c00251f4:	89 46 24             	mov    %eax,0x24(%esi)
    block->read_cnt = 0;
c00251f7:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c00251fe:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
    block->write_cnt = 0;
c0025205:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
c002520c:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
    printf("%s: %'"PRDSNu" sectors (", block->name, block->size);
c0025213:	83 c4 0c             	add    $0xc,%esp
c0025216:	57                   	push   %edi
c0025217:	55                   	push   %ebp
c0025218:	8d 83 ac 52 ff ff    	lea    -0xad54(%ebx),%eax
c002521e:	50                   	push   %eax
c002521f:	e8 64 20 00 00       	call   c0027288 <printf>
    print_human_readable_size((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c0025224:	83 c4 08             	add    $0x8,%esp
c0025227:	8b 7e 1c             	mov    0x1c(%esi),%edi
c002522a:	bd 00 00 00 00       	mov    $0x0,%ebp
c002522f:	89 f8                	mov    %edi,%eax
c0025231:	89 ea                	mov    %ebp,%edx
c0025233:	0f a4 fa 09          	shld   $0x9,%edi,%edx
c0025237:	c1 e0 09             	shl    $0x9,%eax
c002523a:	52                   	push   %edx
c002523b:	50                   	push   %eax
c002523c:	e8 0d 2a 00 00       	call   c0027c4e <print_human_readable_size>
    printf(")");
c0025241:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0025248:	e8 2a 5c 00 00       	call   c002ae77 <putchar>
    if (extra_info != NULL)
c002524d:	83 c4 10             	add    $0x10,%esp
c0025250:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0025255:	74 16                	je     c002526d <block_register+0xda>
        printf(", %s", extra_info);
c0025257:	83 ec 08             	sub    $0x8,%esp
c002525a:	ff 74 24 30          	pushl  0x30(%esp)
c002525e:	8d 83 be 52 ff ff    	lea    -0xad42(%ebx),%eax
c0025264:	50                   	push   %eax
c0025265:	e8 1e 20 00 00       	call   c0027288 <printf>
c002526a:	83 c4 10             	add    $0x10,%esp
    printf("\n");
c002526d:	83 ec 0c             	sub    $0xc,%esp
c0025270:	6a 0a                	push   $0xa
c0025272:	e8 00 5c 00 00       	call   c002ae77 <putchar>
}
c0025277:	89 f0                	mov    %esi,%eax
c0025279:	83 c4 1c             	add    $0x1c,%esp
c002527c:	5b                   	pop    %ebx
c002527d:	5e                   	pop    %esi
c002527e:	5f                   	pop    %edi
c002527f:	5d                   	pop    %ebp
c0025280:	c3                   	ret    
        PANIC ("Failed to allocate memory for block device descriptor");
c0025281:	8d 83 1c 52 ff ff    	lea    -0xade4(%ebx),%eax
c0025287:	50                   	push   %eax
c0025288:	8d 83 7c 37 ff ff    	lea    -0xc884(%ebx),%eax
c002528e:	50                   	push   %eax
c002528f:	68 b2 00 00 00       	push   $0xb2
c0025294:	8d 83 52 52 ff ff    	lea    -0xadae(%ebx),%eax
c002529a:	50                   	push   %eax
c002529b:	e8 44 3c 00 00       	call   c0028ee4 <debug_panic>

c00252a0 <partition_read>:
}

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read(void *p_, block_sector_t sector, void *buffer) {
c00252a0:	53                   	push   %ebx
c00252a1:	83 ec 0c             	sub    $0xc,%esp
c00252a4:	e8 ee 85 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00252a9:	81 c3 57 52 01 00    	add    $0x15257,%ebx
c00252af:	8b 54 24 14          	mov    0x14(%esp),%edx
    struct partition *p = p_;
    block_read(p->block, p->start + sector, buffer);
c00252b3:	ff 74 24 1c          	pushl  0x1c(%esp)
c00252b7:	8b 42 04             	mov    0x4(%edx),%eax
c00252ba:	03 44 24 1c          	add    0x1c(%esp),%eax
c00252be:	50                   	push   %eax
c00252bf:	ff 32                	pushl  (%edx)
c00252c1:	e8 aa fd ff ff       	call   c0025070 <block_read>
}
c00252c6:	83 c4 18             	add    $0x18,%esp
c00252c9:	5b                   	pop    %ebx
c00252ca:	c3                   	ret    

c00252cb <read_partition_table>:
                     int *part_nr) {
c00252cb:	55                   	push   %ebp
c00252cc:	57                   	push   %edi
c00252cd:	56                   	push   %esi
c00252ce:	53                   	push   %ebx
c00252cf:	81 ec d8 00 00 00    	sub    $0xd8,%esp
c00252d5:	e8 bd 85 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00252da:	81 c3 26 52 01 00    	add    $0x15226,%ebx
c00252e0:	89 c6                	mov    %eax,%esi
c00252e2:	89 d7                	mov    %edx,%edi
c00252e4:	89 54 24 10          	mov    %edx,0x10(%esp)
c00252e8:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    if (sector >= block_size(block)) {
c00252ec:	50                   	push   %eax
c00252ed:	e8 20 fe ff ff       	call   c0025112 <block_size>
c00252f2:	83 c4 10             	add    $0x10,%esp
c00252f5:	39 f8                	cmp    %edi,%eax
c00252f7:	76 65                	jbe    c002535e <read_partition_table+0x93>
    pt = malloc(sizeof *pt);
c00252f9:	83 ec 0c             	sub    $0xc,%esp
c00252fc:	68 00 02 00 00       	push   $0x200
c0025301:	e8 0e e9 ff ff       	call   c0023c14 <malloc>
c0025306:	89 c5                	mov    %eax,%ebp
    if (pt == NULL)
c0025308:	83 c4 10             	add    $0x10,%esp
c002530b:	85 c0                	test   %eax,%eax
c002530d:	74 7a                	je     c0025389 <read_partition_table+0xbe>
    block_read(block, 0, pt);
c002530f:	83 ec 04             	sub    $0x4,%esp
c0025312:	50                   	push   %eax
c0025313:	6a 00                	push   $0x0
c0025315:	56                   	push   %esi
c0025316:	e8 55 fd ff ff       	call   c0025070 <block_read>
    if (pt->signature != 0xaa55) {
c002531b:	83 c4 10             	add    $0x10,%esp
c002531e:	66 81 bd fe 01 00 00 	cmpw   $0xaa55,0x1fe(%ebp)
c0025325:	55 aa 
c0025327:	0f 84 9a 00 00 00    	je     c00253c7 <read_partition_table+0xfc>
        if (primary_extended_sector == 0)
c002532d:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0025332:	75 71                	jne    c00253a5 <read_partition_table+0xda>
            printf("%s: Invalid partition table signature\n", block_name(block));
c0025334:	83 ec 0c             	sub    $0xc,%esp
c0025337:	56                   	push   %esi
c0025338:	e8 dd fd ff ff       	call   c002511a <block_name>
c002533d:	83 c4 08             	add    $0x8,%esp
c0025340:	50                   	push   %eax
c0025341:	8d 83 d8 57 ff ff    	lea    -0xa828(%ebx),%eax
c0025347:	50                   	push   %eax
c0025348:	e8 3b 1f 00 00       	call   c0027288 <printf>
c002534d:	83 c4 10             	add    $0x10,%esp
        free(pt);
c0025350:	83 ec 0c             	sub    $0xc,%esp
c0025353:	55                   	push   %ebp
c0025354:	e8 69 ea ff ff       	call   c0023dc2 <free>
        return;
c0025359:	83 c4 10             	add    $0x10,%esp
c002535c:	eb 20                	jmp    c002537e <read_partition_table+0xb3>
        printf("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c002535e:	83 ec 0c             	sub    $0xc,%esp
c0025361:	56                   	push   %esi
c0025362:	e8 b3 fd ff ff       	call   c002511a <block_name>
c0025367:	83 c4 0c             	add    $0xc,%esp
c002536a:	ff 74 24 08          	pushl  0x8(%esp)
c002536e:	50                   	push   %eax
c002536f:	8d 83 70 57 ff ff    	lea    -0xa890(%ebx),%eax
c0025375:	50                   	push   %eax
c0025376:	e8 0d 1f 00 00       	call   c0027288 <printf>
        return;
c002537b:	83 c4 10             	add    $0x10,%esp
}
c002537e:	81 c4 cc 00 00 00    	add    $0xcc,%esp
c0025384:	5b                   	pop    %ebx
c0025385:	5e                   	pop    %esi
c0025386:	5f                   	pop    %edi
c0025387:	5d                   	pop    %ebp
c0025388:	c3                   	ret    
        PANIC ("Failed to allocate memory for partition table.");
c0025389:	8d 83 a8 57 ff ff    	lea    -0xa858(%ebx),%eax
c002538f:	50                   	push   %eax
c0025390:	8d 83 e8 37 ff ff    	lea    -0xc818(%ebx),%eax
c0025396:	50                   	push   %eax
c0025397:	6a 56                	push   $0x56
c0025399:	8d 83 df 52 ff ff    	lea    -0xad21(%ebx),%eax
c002539f:	50                   	push   %eax
c00253a0:	e8 3f 3b 00 00       	call   c0028ee4 <debug_panic>
            printf("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c00253a5:	83 ec 0c             	sub    $0xc,%esp
c00253a8:	56                   	push   %esi
c00253a9:	e8 6c fd ff ff       	call   c002511a <block_name>
c00253ae:	83 c4 0c             	add    $0xc,%esp
c00253b1:	ff 74 24 08          	pushl  0x8(%esp)
c00253b5:	50                   	push   %eax
c00253b6:	8d 83 00 58 ff ff    	lea    -0xa800(%ebx),%eax
c00253bc:	50                   	push   %eax
c00253bd:	e8 c6 1e 00 00       	call   c0027288 <printf>
c00253c2:	83 c4 10             	add    $0x10,%esp
c00253c5:	eb 89                	jmp    c0025350 <read_partition_table+0x85>
c00253c7:	8d bd c2 01 00 00    	lea    0x1c2(%ebp),%edi
c00253cd:	8d 85 02 02 00 00    	lea    0x202(%ebp),%eax
c00253d3:	89 44 24 08          	mov    %eax,0x8(%esp)
            printf("%s: Extended partition in sector %"PRDSNu"\n",
c00253d7:	8d 83 34 58 ff ff    	lea    -0xa7cc(%ebx),%eax
c00253dd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        printf("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c00253e1:	8d 83 94 58 ff ff    	lea    -0xa76c(%ebx),%eax
c00253e7:	89 44 24 20          	mov    %eax,0x20(%esp)
c00253eb:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c00253ef:	89 74 24 14          	mov    %esi,0x14(%esp)
c00253f3:	eb 30                	jmp    c0025425 <read_partition_table+0x15a>
                read_partition_table(block, e->offset + primary_extended_sector,
c00253f5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00253f9:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00253fd:	89 ca                	mov    %ecx,%edx
c00253ff:	03 50 04             	add    0x4(%eax),%edx
c0025402:	83 ec 0c             	sub    $0xc,%esp
c0025405:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c002540c:	8b 44 24 24          	mov    0x24(%esp),%eax
c0025410:	e8 b6 fe ff ff       	call   c00252cb <read_partition_table>
c0025415:	83 c4 10             	add    $0x10,%esp
c0025418:	83 c7 10             	add    $0x10,%edi
    for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++) {
c002541b:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002541f:	0f 84 f0 01 00 00    	je     c0025615 <read_partition_table+0x34a>
        if (e->size == 0 || e->type == 0) {
c0025425:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0025429:	8b 77 08             	mov    0x8(%edi),%esi
c002542c:	85 f6                	test   %esi,%esi
c002542e:	74 e8                	je     c0025418 <read_partition_table+0x14d>
c0025430:	0f b6 2f             	movzbl (%edi),%ebp
c0025433:	89 e8                	mov    %ebp,%eax
c0025435:	84 c0                	test   %al,%al
c0025437:	74 df                	je     c0025418 <read_partition_table+0x14d>
                   || e->type == 0x0f    /* Windows 98 extended partition. */
c0025439:	3c 0f                	cmp    $0xf,%al
c002543b:	0f 94 c2             	sete   %dl
                   || e->type == 0xc5)   /* DR-DOS extended partition. */
c002543e:	3c c5                	cmp    $0xc5,%al
c0025440:	0f 94 c0             	sete   %al
c0025443:	08 c2                	or     %al,%dl
c0025445:	75 09                	jne    c0025450 <read_partition_table+0x185>
                   || e->type == 0x0f    /* Windows 98 extended partition. */
c0025447:	89 e8                	mov    %ebp,%eax
c0025449:	83 e0 7f             	and    $0x7f,%eax
                   || e->type == 0xc5)   /* DR-DOS extended partition. */
c002544c:	3c 05                	cmp    $0x5,%al
c002544e:	75 4c                	jne    c002549c <read_partition_table+0x1d1>
            printf("%s: Extended partition in sector %"PRDSNu"\n",
c0025450:	83 ec 0c             	sub    $0xc,%esp
c0025453:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025457:	55                   	push   %ebp
c0025458:	e8 bd fc ff ff       	call   c002511a <block_name>
c002545d:	83 c4 0c             	add    $0xc,%esp
c0025460:	8b 74 24 08          	mov    0x8(%esp),%esi
c0025464:	56                   	push   %esi
c0025465:	50                   	push   %eax
c0025466:	ff 74 24 28          	pushl  0x28(%esp)
c002546a:	e8 19 1e 00 00       	call   c0027288 <printf>
            if (sector == 0)
c002546f:	83 c4 10             	add    $0x10,%esp
c0025472:	85 f6                	test   %esi,%esi
c0025474:	0f 85 7b ff ff ff    	jne    c00253f5 <read_partition_table+0x12a>
                read_partition_table(block, e->offset, e->offset, part_nr);
c002547a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002547e:	8b 50 04             	mov    0x4(%eax),%edx
c0025481:	83 ec 0c             	sub    $0xc,%esp
c0025484:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c002548b:	89 d1                	mov    %edx,%ecx
c002548d:	89 e8                	mov    %ebp,%eax
c002548f:	e8 37 fe ff ff       	call   c00252cb <read_partition_table>
c0025494:	83 c4 10             	add    $0x10,%esp
c0025497:	e9 7c ff ff ff       	jmp    c0025418 <read_partition_table+0x14d>
            ++*part_nr;
c002549c:	8b 84 24 e0 00 00 00 	mov    0xe0(%esp),%eax
c00254a3:	8b 00                	mov    (%eax),%eax
c00254a5:	83 c0 01             	add    $0x1,%eax
c00254a8:	89 44 24 24          	mov    %eax,0x24(%esp)
c00254ac:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
c00254b3:	89 01                	mov    %eax,(%ecx)
            found_partition(block, e->type, e->offset + sector,
c00254b5:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c00254b9:	8b 44 24 04          	mov    0x4(%esp),%eax
c00254bd:	03 41 04             	add    0x4(%ecx),%eax
c00254c0:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (start >= block_size(block))
c00254c4:	83 ec 0c             	sub    $0xc,%esp
c00254c7:	ff 74 24 20          	pushl  0x20(%esp)
c00254cb:	e8 42 fc ff ff       	call   c0025112 <block_size>
c00254d0:	83 c4 10             	add    $0x10,%esp
c00254d3:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c00254d7:	73 55                	jae    c002552e <read_partition_table+0x263>
    else if (start + size < start || start + size > block_size(block))
c00254d9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00254dd:	01 f0                	add    %esi,%eax
c00254df:	89 44 24 28          	mov    %eax,0x28(%esp)
c00254e3:	72 15                	jb     c00254fa <read_partition_table+0x22f>
c00254e5:	83 ec 0c             	sub    $0xc,%esp
c00254e8:	ff 74 24 20          	pushl  0x20(%esp)
c00254ec:	e8 21 fc ff ff       	call   c0025112 <block_size>
c00254f1:	83 c4 10             	add    $0x10,%esp
c00254f4:	39 44 24 28          	cmp    %eax,0x28(%esp)
c00254f8:	76 5d                	jbe    c0025557 <read_partition_table+0x28c>
        printf("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c00254fa:	83 ec 0c             	sub    $0xc,%esp
c00254fd:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025501:	55                   	push   %ebp
c0025502:	e8 0b fc ff ff       	call   c0025112 <block_size>
c0025507:	89 c6                	mov    %eax,%esi
c0025509:	89 2c 24             	mov    %ebp,(%esp)
c002550c:	e8 09 fc ff ff       	call   c002511a <block_name>
c0025511:	89 34 24             	mov    %esi,(%esp)
c0025514:	ff 74 24 38          	pushl  0x38(%esp)
c0025518:	ff 74 24 38          	pushl  0x38(%esp)
c002551c:	50                   	push   %eax
c002551d:	ff 74 24 3c          	pushl  0x3c(%esp)
c0025521:	e8 62 1d 00 00       	call   c0027288 <printf>
c0025526:	83 c4 20             	add    $0x20,%esp
c0025529:	e9 ea fe ff ff       	jmp    c0025418 <read_partition_table+0x14d>
        printf("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c002552e:	83 ec 0c             	sub    $0xc,%esp
c0025531:	ff 74 24 20          	pushl  0x20(%esp)
c0025535:	e8 e0 fb ff ff       	call   c002511a <block_name>
c002553a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002553e:	ff 74 24 38          	pushl  0x38(%esp)
c0025542:	50                   	push   %eax
c0025543:	8d 83 5c 58 ff ff    	lea    -0xa7a4(%ebx),%eax
c0025549:	50                   	push   %eax
c002554a:	e8 39 1d 00 00       	call   c0027288 <printf>
c002554f:	83 c4 20             	add    $0x20,%esp
c0025552:	e9 c1 fe ff ff       	jmp    c0025418 <read_partition_table+0x14d>
            found_partition(block, e->type, e->offset + sector,
c0025557:	89 e8                	mov    %ebp,%eax
c0025559:	0f b6 c0             	movzbl %al,%eax
c002555c:	89 44 24 28          	mov    %eax,0x28(%esp)
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c0025560:	89 e8                	mov    %ebp,%eax
c0025562:	3c 20                	cmp    $0x20,%al
c0025564:	0f 84 c0 00 00 00    	je     c002562a <read_partition_table+0x35f>
c002556a:	3c 21                	cmp    $0x21,%al
c002556c:	0f 84 5b 01 00 00    	je     c00256cd <read_partition_table+0x402>
c0025572:	3c 22                	cmp    $0x22,%al
c0025574:	0f 84 60 01 00 00    	je     c00256da <read_partition_table+0x40f>
c002557a:	3c 23                	cmp    $0x23,%al
c002557c:	0f 84 65 01 00 00    	je     c00256e7 <read_partition_table+0x41c>
        p = malloc(sizeof *p);
c0025582:	83 ec 0c             	sub    $0xc,%esp
c0025585:	6a 08                	push   $0x8
c0025587:	e8 88 e6 ff ff       	call   c0023c14 <malloc>
c002558c:	89 c5                	mov    %eax,%ebp
        if (p == NULL)
c002558e:	83 c4 10             	add    $0x10,%esp
c0025591:	85 c0                	test   %eax,%eax
c0025593:	74 57                	je     c00255ec <read_partition_table+0x321>
        p->block = block;
c0025595:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025599:	89 45 00             	mov    %eax,0x0(%ebp)
        p->start = start;
c002559c:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00255a0:	89 55 04             	mov    %edx,0x4(%ebp)
        snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c00255a3:	83 ec 0c             	sub    $0xc,%esp
c00255a6:	50                   	push   %eax
c00255a7:	e8 6e fb ff ff       	call   c002511a <block_name>
c00255ac:	83 c4 04             	add    $0x4,%esp
c00255af:	ff 74 24 30          	pushl  0x30(%esp)
c00255b3:	50                   	push   %eax
c00255b4:	8d 83 f9 52 ff ff    	lea    -0xad07(%ebx),%eax
c00255ba:	50                   	push   %eax
c00255bb:	6a 10                	push   $0x10
c00255bd:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c00255c1:	50                   	push   %eax
c00255c2:	e8 52 24 00 00       	call   c0027a19 <snprintf>
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c00255c7:	8b 44 24 48          	mov    0x48(%esp),%eax
c00255cb:	8b 84 83 e0 78 ff ff 	mov    -0x8720(%ebx,%eax,4),%eax
c00255d2:	83 c4 20             	add    $0x20,%esp
c00255d5:	85 c0                	test   %eax,%eax
c00255d7:	75 32                	jne    c002560b <read_partition_table+0x340>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c00255d9:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c00255e0:	00 
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c00255e1:	8d 83 d7 52 ff ff    	lea    -0xad29(%ebx),%eax
c00255e7:	e9 99 00 00 00       	jmp    c0025685 <read_partition_table+0x3ba>
            PANIC ("Failed to allocate memory for partition descriptor");
c00255ec:	8d 83 c8 58 ff ff    	lea    -0xa738(%ebx),%eax
c00255f2:	50                   	push   %eax
c00255f3:	8d 83 d8 37 ff ff    	lea    -0xc828(%ebx),%eax
c00255f9:	50                   	push   %eax
c00255fa:	68 a6 00 00 00       	push   $0xa6
c00255ff:	8d 83 df 52 ff ff    	lea    -0xad21(%ebx),%eax
c0025605:	50                   	push   %eax
c0025606:	e8 d9 38 00 00       	call   c0028ee4 <debug_panic>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c002560b:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0025612:	00 
c0025613:	eb 70                	jmp    c0025685 <read_partition_table+0x3ba>
c0025615:	8b 6c 24 18          	mov    0x18(%esp),%ebp
    free(pt);
c0025619:	83 ec 0c             	sub    $0xc,%esp
c002561c:	55                   	push   %ebp
c002561d:	e8 a0 e7 ff ff       	call   c0023dc2 <free>
c0025622:	83 c4 10             	add    $0x10,%esp
c0025625:	e9 54 fd ff ff       	jmp    c002537e <read_partition_table+0xb3>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c002562a:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
c0025631:	00 
        p = malloc(sizeof *p);
c0025632:	83 ec 0c             	sub    $0xc,%esp
c0025635:	6a 08                	push   $0x8
c0025637:	e8 d8 e5 ff ff       	call   c0023c14 <malloc>
c002563c:	89 c5                	mov    %eax,%ebp
        if (p == NULL)
c002563e:	83 c4 10             	add    $0x10,%esp
c0025641:	85 c0                	test   %eax,%eax
c0025643:	74 a7                	je     c00255ec <read_partition_table+0x321>
        p->block = block;
c0025645:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025649:	89 45 00             	mov    %eax,0x0(%ebp)
        p->start = start;
c002564c:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0025650:	89 4d 04             	mov    %ecx,0x4(%ebp)
        snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c0025653:	83 ec 0c             	sub    $0xc,%esp
c0025656:	50                   	push   %eax
c0025657:	e8 be fa ff ff       	call   c002511a <block_name>
c002565c:	83 c4 04             	add    $0x4,%esp
c002565f:	ff 74 24 30          	pushl  0x30(%esp)
c0025663:	50                   	push   %eax
c0025664:	8d 83 f9 52 ff ff    	lea    -0xad07(%ebx),%eax
c002566a:	50                   	push   %eax
c002566b:	6a 10                	push   $0x10
c002566d:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025671:	50                   	push   %eax
c0025672:	e8 a2 23 00 00       	call   c0027a19 <snprintf>
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025677:	8b 44 24 48          	mov    0x48(%esp),%eax
c002567b:	8b 84 83 e0 78 ff ff 	mov    -0x8720(%ebx,%eax,4),%eax
c0025682:	83 c4 20             	add    $0x20,%esp
        snprintf(extra_info, sizeof extra_info, "%s (%02x)",
c0025685:	83 ec 0c             	sub    $0xc,%esp
c0025688:	ff 74 24 34          	pushl  0x34(%esp)
c002568c:	50                   	push   %eax
c002568d:	8d 83 fe 52 ff ff    	lea    -0xad02(%ebx),%eax
c0025693:	50                   	push   %eax
c0025694:	68 80 00 00 00       	push   $0x80
c0025699:	8d 44 24 5c          	lea    0x5c(%esp),%eax
c002569d:	89 44 24 28          	mov    %eax,0x28(%esp)
c00256a1:	50                   	push   %eax
c00256a2:	e8 72 23 00 00       	call   c0027a19 <snprintf>
        block_register(name, type, extra_info, size, &partition_operations, p);
c00256a7:	83 c4 18             	add    $0x18,%esp
c00256aa:	55                   	push   %ebp
c00256ab:	8d 83 d4 ff ff ff    	lea    -0x2c(%ebx),%eax
c00256b1:	50                   	push   %eax
c00256b2:	56                   	push   %esi
c00256b3:	ff 74 24 20          	pushl  0x20(%esp)
c00256b7:	ff 74 24 44          	pushl  0x44(%esp)
c00256bb:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c00256bf:	50                   	push   %eax
c00256c0:	e8 ce fa ff ff       	call   c0025193 <block_register>
c00256c5:	83 c4 20             	add    $0x20,%esp
c00256c8:	e9 4b fd ff ff       	jmp    c0025418 <read_partition_table+0x14d>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c00256cd:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c00256d4:	00 
c00256d5:	e9 58 ff ff ff       	jmp    c0025632 <read_partition_table+0x367>
c00256da:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c00256e1:	00 
c00256e2:	e9 4b ff ff ff       	jmp    c0025632 <read_partition_table+0x367>
c00256e7:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c00256ee:	00 
c00256ef:	e9 3e ff ff ff       	jmp    c0025632 <read_partition_table+0x367>

c00256f4 <partition_write>:

/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write(void *p_, block_sector_t sector, const void *buffer) {
c00256f4:	53                   	push   %ebx
c00256f5:	83 ec 0c             	sub    $0xc,%esp
c00256f8:	e8 9a 81 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00256fd:	81 c3 03 4e 01 00    	add    $0x14e03,%ebx
c0025703:	8b 54 24 14          	mov    0x14(%esp),%edx
    struct partition *p = p_;
    block_write(p->block, p->start + sector, buffer);
c0025707:	ff 74 24 1c          	pushl  0x1c(%esp)
c002570b:	8b 42 04             	mov    0x4(%edx),%eax
c002570e:	03 44 24 1c          	add    0x1c(%esp),%eax
c0025712:	50                   	push   %eax
c0025713:	ff 32                	pushl  (%edx)
c0025715:	e8 8a f9 ff ff       	call   c00250a4 <block_write>
}
c002571a:	83 c4 18             	add    $0x18,%esp
c002571d:	5b                   	pop    %ebx
c002571e:	c3                   	ret    

c002571f <partition_scan>:
partition_scan(struct block *block) {
c002571f:	56                   	push   %esi
c0025720:	53                   	push   %ebx
c0025721:	83 ec 20             	sub    $0x20,%esp
c0025724:	e8 6e 81 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025729:	81 c3 d7 4d 01 00    	add    $0x14dd7,%ebx
c002572f:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    int part_nr = 0;
c0025733:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c002573a:	00 
    read_partition_table(block, 0, 0, &part_nr);
c002573b:	8d 44 24 18          	lea    0x18(%esp),%eax
c002573f:	50                   	push   %eax
c0025740:	b9 00 00 00 00       	mov    $0x0,%ecx
c0025745:	ba 00 00 00 00       	mov    $0x0,%edx
c002574a:	89 f0                	mov    %esi,%eax
c002574c:	e8 7a fb ff ff       	call   c00252cb <read_partition_table>
    if (part_nr == 0)
c0025751:	83 c4 10             	add    $0x10,%esp
c0025754:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0025759:	74 06                	je     c0025761 <partition_scan+0x42>
}
c002575b:	83 c4 14             	add    $0x14,%esp
c002575e:	5b                   	pop    %ebx
c002575f:	5e                   	pop    %esi
c0025760:	c3                   	ret    
        printf("%s: Device contains no partitions\n", block_name(block));
c0025761:	83 ec 0c             	sub    $0xc,%esp
c0025764:	56                   	push   %esi
c0025765:	e8 b0 f9 ff ff       	call   c002511a <block_name>
c002576a:	83 c4 08             	add    $0x8,%esp
c002576d:	50                   	push   %eax
c002576e:	8d 83 fc 58 ff ff    	lea    -0xa704(%ebx),%eax
c0025774:	50                   	push   %eax
c0025775:	e8 0e 1b 00 00       	call   c0027288 <printf>
c002577a:	83 c4 10             	add    $0x10,%esp
}
c002577d:	eb dc                	jmp    c002575b <partition_scan+0x3c>

c002577f <descramble_ata_string>:

/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string(char *string, int size) {
c002577f:	57                   	push   %edi
c0025780:	56                   	push   %esi
c0025781:	53                   	push   %ebx
c0025782:	89 d7                	mov    %edx,%edi
    int i;

    /* Swap all pairs of bytes. */
    for (i = 0; i + 1 < size; i += 2) {
c0025784:	83 fa 01             	cmp    $0x1,%edx
c0025787:	7e 24                	jle    c00257ad <descramble_ata_string+0x2e>
c0025789:	89 c1                	mov    %eax,%ecx
c002578b:	8d 5a fe             	lea    -0x2(%edx),%ebx
c002578e:	83 e3 fe             	and    $0xfffffffe,%ebx
c0025791:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
        char tmp = string[i];
c0025795:	0f b6 19             	movzbl (%ecx),%ebx
        string[i] = string[i + 1];
c0025798:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
c002579c:	88 11                	mov    %dl,(%ecx)
        string[i + 1] = tmp;
c002579e:	88 59 01             	mov    %bl,0x1(%ecx)
c00257a1:	83 c1 02             	add    $0x2,%ecx
    for (i = 0; i + 1 < size; i += 2) {
c00257a4:	39 f1                	cmp    %esi,%ecx
c00257a6:	75 ed                	jne    c0025795 <descramble_ata_string+0x16>
    }

    /* Find the last non-white, non-null character. */
    for (size--; size > 0; size--) {
c00257a8:	8d 57 ff             	lea    -0x1(%edi),%edx
c00257ab:	eb 0c                	jmp    c00257b9 <descramble_ata_string+0x3a>
c00257ad:	8d 52 ff             	lea    -0x1(%edx),%edx
c00257b0:	eb 19                	jmp    c00257cb <descramble_ata_string+0x4c>
c00257b2:	83 ea 01             	sub    $0x1,%edx
c00257b5:	85 d2                	test   %edx,%edx
c00257b7:	7e 12                	jle    c00257cb <descramble_ata_string+0x4c>
        int c = string[size - 1];
c00257b9:	0f b6 4c 10 ff       	movzbl -0x1(%eax,%edx,1),%ecx
        if (c != '\0' && !isspace(c))
c00257be:	f6 c1 df             	test   $0xdf,%cl
c00257c1:	74 ef                	je     c00257b2 <descramble_ata_string+0x33>
          || c == '\r' || c == '\t' || c == '\v');
c00257c3:	83 e9 09             	sub    $0x9,%ecx
c00257c6:	80 f9 04             	cmp    $0x4,%cl
c00257c9:	76 e7                	jbe    c00257b2 <descramble_ata_string+0x33>
            break;
    }
    string[size] = '\0';
c00257cb:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

    return string;
}
c00257cf:	5b                   	pop    %ebx
c00257d0:	5e                   	pop    %esi
c00257d1:	5f                   	pop    %edi
c00257d2:	c3                   	ret    

c00257d3 <interrupt_handler>:
    wait_until_idle(d);
}

/* ATA interrupt handler. */
static void
interrupt_handler(struct intr_frame *f) {
c00257d3:	53                   	push   %ebx
c00257d4:	83 ec 08             	sub    $0x8,%esp
c00257d7:	e8 bb 80 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00257dc:	81 c3 24 4d 01 00    	add    $0x14d24,%ebx
    struct channel *c;

    for (c = channels; c < channels + CHANNEL_CNT; c++)
        if (f->vec_no == c->irq) {
c00257e2:	8b 44 24 10          	mov    0x10(%esp),%eax
c00257e6:	8b 40 30             	mov    0x30(%eax),%eax
c00257e9:	0f b6 93 ca 19 00 00 	movzbl 0x19ca(%ebx),%edx
c00257f0:	39 d0                	cmp    %edx,%eax
c00257f2:	74 30                	je     c0025824 <interrupt_handler+0x51>
c00257f4:	0f b6 93 3a 1a 00 00 	movzbl 0x1a3a(%ebx),%edx
c00257fb:	8d 8b 30 1a 00 00    	lea    0x1a30(%ebx),%ecx
c0025801:	39 c2                	cmp    %eax,%edx
c0025803:	74 25                	je     c002582a <interrupt_handler+0x57>
            } else
                printf("%s: unexpected interrupt\n", c->name);
            return;
        }

    NOT_REACHED ();
c0025805:	8d 83 60 48 ff ff    	lea    -0xb7a0(%ebx),%eax
c002580b:	50                   	push   %eax
c002580c:	8d 83 50 38 ff ff    	lea    -0xc7b0(%ebx),%eax
c0025812:	50                   	push   %eax
c0025813:	68 f0 01 00 00       	push   $0x1f0
c0025818:	8d 83 39 59 ff ff    	lea    -0xa6c7(%ebx),%eax
c002581e:	50                   	push   %eax
c002581f:	e8 c0 36 00 00       	call   c0028ee4 <debug_panic>
    for (c = channels; c < channels + CHANNEL_CNT; c++)
c0025824:	8d 8b c0 19 00 00    	lea    0x19c0(%ebx),%ecx
            if (c->expecting_interrupt) {
c002582a:	80 79 30 00          	cmpb   $0x0,0x30(%ecx)
c002582e:	74 1c                	je     c002584c <interrupt_handler+0x79>
                inb(reg_status (c));               /* Acknowledge interrupt. */
c0025830:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
c0025834:	8d 50 07             	lea    0x7(%eax),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025837:	ec                   	in     (%dx),%al
                sema_up(&c->completion_wait);      /* Wake up waiter. */
c0025838:	83 ec 0c             	sub    $0xc,%esp
c002583b:	83 c1 34             	add    $0x34,%ecx
c002583e:	51                   	push   %ecx
c002583f:	e8 db d5 ff ff       	call   c0022e1f <sema_up>
c0025844:	83 c4 10             	add    $0x10,%esp
}
c0025847:	83 c4 08             	add    $0x8,%esp
c002584a:	5b                   	pop    %ebx
c002584b:	c3                   	ret    
                printf("%s: unexpected interrupt\n", c->name);
c002584c:	83 ec 08             	sub    $0x8,%esp
c002584f:	51                   	push   %ecx
c0025850:	8d 83 1f 59 ff ff    	lea    -0xa6e1(%ebx),%eax
c0025856:	50                   	push   %eax
c0025857:	e8 2c 1a 00 00       	call   c0027288 <printf>
c002585c:	83 c4 10             	add    $0x10,%esp
            return;
c002585f:	eb e6                	jmp    c0025847 <interrupt_handler+0x74>

c0025861 <wait_until_idle>:
wait_until_idle(const struct ata_disk *d) {
c0025861:	57                   	push   %edi
c0025862:	56                   	push   %esi
c0025863:	53                   	push   %ebx
c0025864:	e8 2e 80 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025869:	81 c3 97 4c 01 00    	add    $0x14c97,%ebx
c002586f:	89 c7                	mov    %eax,%edi
        if ((inb(reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025871:	8b 40 08             	mov    0x8(%eax),%eax
c0025874:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025878:	8d 50 07             	lea    0x7(%eax),%edx
c002587b:	ec                   	in     (%dx),%al
c002587c:	a8 88                	test   $0x88,%al
c002587e:	74 4a                	je     c00258ca <wait_until_idle+0x69>
        timer_usleep(10);
c0025880:	83 ec 08             	sub    $0x8,%esp
c0025883:	6a 00                	push   $0x0
c0025885:	6a 0a                	push   $0xa
c0025887:	e8 8b ec ff ff       	call   c0024517 <timer_usleep>
c002588c:	83 c4 10             	add    $0x10,%esp
c002588f:	be e7 03 00 00       	mov    $0x3e7,%esi
        if ((inb(reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025894:	8b 47 08             	mov    0x8(%edi),%eax
c0025897:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002589b:	8d 50 07             	lea    0x7(%eax),%edx
c002589e:	ec                   	in     (%dx),%al
c002589f:	a8 88                	test   $0x88,%al
c00258a1:	74 27                	je     c00258ca <wait_until_idle+0x69>
        timer_usleep(10);
c00258a3:	83 ec 08             	sub    $0x8,%esp
c00258a6:	6a 00                	push   $0x0
c00258a8:	6a 0a                	push   $0xa
c00258aa:	e8 68 ec ff ff       	call   c0024517 <timer_usleep>
    for (i = 0; i < 1000; i++) {
c00258af:	83 c4 10             	add    $0x10,%esp
c00258b2:	83 ee 01             	sub    $0x1,%esi
c00258b5:	75 dd                	jne    c0025894 <wait_until_idle+0x33>
    printf("%s: idle timeout\n", d->name);
c00258b7:	83 ec 08             	sub    $0x8,%esp
c00258ba:	57                   	push   %edi
c00258bb:	8d 83 4d 59 ff ff    	lea    -0xa6b3(%ebx),%eax
c00258c1:	50                   	push   %eax
c00258c2:	e8 c1 19 00 00       	call   c0027288 <printf>
c00258c7:	83 c4 10             	add    $0x10,%esp
}
c00258ca:	5b                   	pop    %ebx
c00258cb:	5e                   	pop    %esi
c00258cc:	5f                   	pop    %edi
c00258cd:	c3                   	ret    

c00258ce <select_device>:
select_device(const struct ata_disk *d) {
c00258ce:	53                   	push   %ebx
c00258cf:	83 ec 10             	sub    $0x10,%esp
c00258d2:	e8 c0 7f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00258d7:	81 c3 29 4c 01 00    	add    $0x14c29,%ebx
    struct channel *c = d->channel;
c00258dd:	8b 50 08             	mov    0x8(%eax),%edx
    if (d->dev_no == 1)
c00258e0:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
        dev |= DEV_DEV;
c00258e4:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
c00258e9:	b9 b0 ff ff ff       	mov    $0xffffffb0,%ecx
c00258ee:	0f 44 c1             	cmove  %ecx,%eax
    outb(reg_device (c), dev);
c00258f1:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
c00258f5:	8d 51 06             	lea    0x6(%ecx),%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00258f8:	ee                   	out    %al,(%dx)
    inb(reg_alt_status (c));
c00258f9:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00258ff:	ec                   	in     (%dx),%al
    timer_nsleep(400);
c0025900:	6a 00                	push   $0x0
c0025902:	68 90 01 00 00       	push   $0x190
c0025907:	e8 24 ec ff ff       	call   c0024530 <timer_nsleep>
}
c002590c:	83 c4 18             	add    $0x18,%esp
c002590f:	5b                   	pop    %ebx
c0025910:	c3                   	ret    

c0025911 <check_device_type>:
check_device_type(struct ata_disk *d) {
c0025911:	55                   	push   %ebp
c0025912:	57                   	push   %edi
c0025913:	56                   	push   %esi
c0025914:	53                   	push   %ebx
c0025915:	83 ec 0c             	sub    $0xc,%esp
c0025918:	89 c6                	mov    %eax,%esi
    struct channel *c = d->channel;
c002591a:	8b 58 08             	mov    0x8(%eax),%ebx
    select_device(d);
c002591d:	e8 ac ff ff ff       	call   c00258ce <select_device>
    error = inb(reg_error (c));
c0025922:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c0025926:	8d 51 01             	lea    0x1(%ecx),%edx
c0025929:	ec                   	in     (%dx),%al
c002592a:	89 c3                	mov    %eax,%ebx
    lbam = inb(reg_lbam (c));
c002592c:	8d 51 04             	lea    0x4(%ecx),%edx
c002592f:	ec                   	in     (%dx),%al
c0025930:	89 c5                	mov    %eax,%ebp
    lbah = inb(reg_lbah (c));
c0025932:	8d 51 05             	lea    0x5(%ecx),%edx
c0025935:	ec                   	in     (%dx),%al
c0025936:	89 c7                	mov    %eax,%edi
    status = inb(reg_status (c));
c0025938:	8d 51 07             	lea    0x7(%ecx),%edx
c002593b:	ec                   	in     (%dx),%al
    if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c002593c:	80 fb 01             	cmp    $0x1,%bl
c002593f:	74 0b                	je     c002594c <check_device_type+0x3b>
c0025941:	80 fb 81             	cmp    $0x81,%bl
c0025944:	75 3b                	jne    c0025981 <check_device_type+0x70>
c0025946:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c002594a:	74 35                	je     c0025981 <check_device_type+0x70>
        || (status & STA_DRDY) == 0
c002594c:	a8 40                	test   $0x40,%al
c002594e:	74 31                	je     c0025981 <check_device_type+0x70>
        || (status & STA_BSY) != 0) {
c0025950:	84 c0                	test   %al,%al
c0025952:	78 2d                	js     c0025981 <check_device_type+0x70>
        d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025954:	b8 01 00 00 00       	mov    $0x1,%eax
c0025959:	89 f9                	mov    %edi,%ecx
c002595b:	89 eb                	mov    %ebp,%ebx
c002595d:	08 d9                	or     %bl,%cl
c002595f:	74 12                	je     c0025973 <check_device_type+0x62>
c0025961:	80 fb 3c             	cmp    $0x3c,%bl
c0025964:	0f 94 c2             	sete   %dl
c0025967:	89 f8                	mov    %edi,%eax
c0025969:	3c c3                	cmp    $0xc3,%al
c002596b:	0f 94 c0             	sete   %al
c002596e:	0f b6 c0             	movzbl %al,%eax
c0025971:	21 d0                	and    %edx,%eax
c0025973:	88 46 10             	mov    %al,0x10(%esi)
c0025976:	80 66 10 01          	andb   $0x1,0x10(%esi)
        return true;
c002597a:	b8 01 00 00 00       	mov    $0x1,%eax
c002597f:	eb 0a                	jmp    c002598b <check_device_type+0x7a>
        d->is_ata = false;
c0025981:	c6 46 10 00          	movb   $0x0,0x10(%esi)
        return error != 0x81;
c0025985:	80 fb 81             	cmp    $0x81,%bl
c0025988:	0f 95 c0             	setne  %al
}
c002598b:	83 c4 0c             	add    $0xc,%esp
c002598e:	5b                   	pop    %ebx
c002598f:	5e                   	pop    %esi
c0025990:	5f                   	pop    %edi
c0025991:	5d                   	pop    %ebp
c0025992:	c3                   	ret    

c0025993 <select_sector>:
select_sector(struct ata_disk *d, block_sector_t sec_no) {
c0025993:	55                   	push   %ebp
c0025994:	57                   	push   %edi
c0025995:	56                   	push   %esi
c0025996:	53                   	push   %ebx
c0025997:	83 ec 0c             	sub    $0xc,%esp
c002599a:	e8 f8 7e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002599f:	81 c3 61 4b 01 00    	add    $0x14b61,%ebx
    struct channel *c = d->channel;
c00259a5:	8b 68 08             	mov    0x8(%eax),%ebp
    ASSERT (sec_no < (1UL << 28));
c00259a8:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c00259ae:	77 5e                	ja     c0025a0e <select_sector+0x7b>
c00259b0:	89 c7                	mov    %eax,%edi
c00259b2:	89 d6                	mov    %edx,%esi
    wait_until_idle(d);
c00259b4:	e8 a8 fe ff ff       	call   c0025861 <wait_until_idle>
    select_device(d);
c00259b9:	89 f8                	mov    %edi,%eax
c00259bb:	e8 0e ff ff ff       	call   c00258ce <select_device>
    wait_until_idle(d);
c00259c0:	89 f8                	mov    %edi,%eax
c00259c2:	e8 9a fe ff ff       	call   c0025861 <wait_until_idle>
    outb(reg_nsect (c), 1);
c00259c7:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
c00259cb:	8d 51 02             	lea    0x2(%ecx),%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00259ce:	b8 01 00 00 00       	mov    $0x1,%eax
c00259d3:	ee                   	out    %al,(%dx)
    outb(reg_lbal (c), sec_no);
c00259d4:	8d 51 03             	lea    0x3(%ecx),%edx
c00259d7:	89 f0                	mov    %esi,%eax
c00259d9:	ee                   	out    %al,(%dx)
    outb(reg_lbam (c), sec_no >> 8);
c00259da:	89 f0                	mov    %esi,%eax
c00259dc:	c1 e8 08             	shr    $0x8,%eax
c00259df:	8d 51 04             	lea    0x4(%ecx),%edx
c00259e2:	ee                   	out    %al,(%dx)
    outb(reg_lbah (c), (sec_no >> 16));
c00259e3:	89 f0                	mov    %esi,%eax
c00259e5:	c1 e8 10             	shr    $0x10,%eax
c00259e8:	8d 51 05             	lea    0x5(%ecx),%edx
c00259eb:	ee                   	out    %al,(%dx)
         DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00259ec:	83 7f 0c 01          	cmpl   $0x1,0xc(%edi)
c00259f0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
c00259f5:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c00259fa:	0f 45 c2             	cmovne %edx,%eax
c00259fd:	c1 ee 18             	shr    $0x18,%esi
c0025a00:	09 f0                	or     %esi,%eax
    outb(reg_device (c),
c0025a02:	8d 51 06             	lea    0x6(%ecx),%edx
c0025a05:	ee                   	out    %al,(%dx)
}
c0025a06:	83 c4 0c             	add    $0xc,%esp
c0025a09:	5b                   	pop    %ebx
c0025a0a:	5e                   	pop    %esi
c0025a0b:	5f                   	pop    %edi
c0025a0c:	5d                   	pop    %ebp
c0025a0d:	c3                   	ret    
    ASSERT (sec_no < (1UL << 28));
c0025a0e:	83 ec 0c             	sub    $0xc,%esp
c0025a11:	8d 83 5f 59 ff ff    	lea    -0xa6a1(%ebx),%eax
c0025a17:	50                   	push   %eax
c0025a18:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0025a1e:	50                   	push   %eax
c0025a1f:	8d 83 20 38 ff ff    	lea    -0xc7e0(%ebx),%eax
c0025a25:	50                   	push   %eax
c0025a26:	68 7b 01 00 00       	push   $0x17b
c0025a2b:	8d 83 39 59 ff ff    	lea    -0xa6c7(%ebx),%eax
c0025a31:	50                   	push   %eax
c0025a32:	e8 ad 34 00 00       	call   c0028ee4 <debug_panic>

c0025a37 <wait_while_busy>:
wait_while_busy(const struct ata_disk *d) {
c0025a37:	55                   	push   %ebp
c0025a38:	57                   	push   %edi
c0025a39:	56                   	push   %esi
c0025a3a:	53                   	push   %ebx
c0025a3b:	83 ec 1c             	sub    $0x1c,%esp
c0025a3e:	e8 54 7e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025a43:	81 c3 bd 4a 01 00    	add    $0x14abd,%ebx
c0025a49:	89 c5                	mov    %eax,%ebp
    struct channel *c = d->channel;
c0025a4b:	8b 78 08             	mov    0x8(%eax),%edi
    for (i = 0; i < 3000; i++) {
c0025a4e:	be 00 00 00 00       	mov    $0x0,%esi
            printf("%s: busy, waiting...", d->name);
c0025a53:	8d 83 74 59 ff ff    	lea    -0xa68c(%ebx),%eax
c0025a59:	89 44 24 0c          	mov    %eax,0xc(%esp)
        if (!(inb(reg_alt_status (c)) & STA_BSY)) {
c0025a5d:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025a61:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025a67:	ec                   	in     (%dx),%al
c0025a68:	84 c0                	test   %al,%al
c0025a6a:	79 34                	jns    c0025aa0 <wait_while_busy+0x69>
        timer_msleep(10);
c0025a6c:	83 ec 08             	sub    $0x8,%esp
c0025a6f:	6a 00                	push   $0x0
c0025a71:	6a 0a                	push   $0xa
c0025a73:	e8 86 ea ff ff       	call   c00244fe <timer_msleep>
    for (i = 0; i < 3000; i++) {
c0025a78:	83 c6 01             	add    $0x1,%esi
c0025a7b:	83 c4 10             	add    $0x10,%esp
c0025a7e:	81 fe b8 0b 00 00    	cmp    $0xbb8,%esi
c0025a84:	74 4f                	je     c0025ad5 <wait_while_busy+0x9e>
        if (i == 700)
c0025a86:	81 fe bc 02 00 00    	cmp    $0x2bc,%esi
c0025a8c:	75 cf                	jne    c0025a5d <wait_while_busy+0x26>
            printf("%s: busy, waiting...", d->name);
c0025a8e:	83 ec 08             	sub    $0x8,%esp
c0025a91:	55                   	push   %ebp
c0025a92:	ff 74 24 18          	pushl  0x18(%esp)
c0025a96:	e8 ed 17 00 00       	call   c0027288 <printf>
c0025a9b:	83 c4 10             	add    $0x10,%esp
c0025a9e:	eb bd                	jmp    c0025a5d <wait_while_busy+0x26>
            if (i >= 700)
c0025aa0:	81 fe bb 02 00 00    	cmp    $0x2bb,%esi
c0025aa6:	7f 19                	jg     c0025ac1 <wait_while_busy+0x8a>
            return (inb(reg_alt_status (c)) & STA_DRQ) != 0;
c0025aa8:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025aac:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025ab2:	ec                   	in     (%dx),%al
c0025ab3:	c0 e8 03             	shr    $0x3,%al
c0025ab6:	83 e0 01             	and    $0x1,%eax
}
c0025ab9:	83 c4 1c             	add    $0x1c,%esp
c0025abc:	5b                   	pop    %ebx
c0025abd:	5e                   	pop    %esi
c0025abe:	5f                   	pop    %edi
c0025abf:	5d                   	pop    %ebp
c0025ac0:	c3                   	ret    
                printf("ok\n");
c0025ac1:	83 ec 0c             	sub    $0xc,%esp
c0025ac4:	8d 83 89 59 ff ff    	lea    -0xa677(%ebx),%eax
c0025aca:	50                   	push   %eax
c0025acb:	e8 35 53 00 00       	call   c002ae05 <puts>
c0025ad0:	83 c4 10             	add    $0x10,%esp
c0025ad3:	eb d3                	jmp    c0025aa8 <wait_while_busy+0x71>
    printf("failed\n");
c0025ad5:	83 ec 0c             	sub    $0xc,%esp
c0025ad8:	8d 83 04 62 ff ff    	lea    -0x9dfc(%ebx),%eax
c0025ade:	50                   	push   %eax
c0025adf:	e8 21 53 00 00       	call   c002ae05 <puts>
    return false;
c0025ae4:	83 c4 10             	add    $0x10,%esp
c0025ae7:	b8 00 00 00 00       	mov    $0x0,%eax
c0025aec:	eb cb                	jmp    c0025ab9 <wait_while_busy+0x82>

c0025aee <issue_pio_command>:
issue_pio_command(struct channel *c, uint8_t command) {
c0025aee:	57                   	push   %edi
c0025aef:	56                   	push   %esi
c0025af0:	53                   	push   %ebx
c0025af1:	e8 a1 7d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025af6:	81 c3 0a 4a 01 00    	add    $0x14a0a,%ebx
c0025afc:	89 c7                	mov    %eax,%edi
c0025afe:	89 d6                	mov    %edx,%esi
    ASSERT (intr_get_level() == INTR_ON);
c0025b00:	e8 cc bf ff ff       	call   c0021ad1 <intr_get_level>
c0025b05:	83 f8 01             	cmp    $0x1,%eax
c0025b08:	75 12                	jne    c0025b1c <issue_pio_command+0x2e>
    c->expecting_interrupt = true;
c0025b0a:	c6 47 30 01          	movb   $0x1,0x30(%edi)
    outb(reg_command (c), command);
c0025b0e:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025b12:	83 c2 07             	add    $0x7,%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025b15:	89 f0                	mov    %esi,%eax
c0025b17:	ee                   	out    %al,(%dx)
}
c0025b18:	5b                   	pop    %ebx
c0025b19:	5e                   	pop    %esi
c0025b1a:	5f                   	pop    %edi
c0025b1b:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c0025b1c:	83 ec 0c             	sub    $0xc,%esp
c0025b1f:	8d 83 96 50 ff ff    	lea    -0xaf6a(%ebx),%eax
c0025b25:	50                   	push   %eax
c0025b26:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0025b2c:	50                   	push   %eax
c0025b2d:	8d 83 00 38 ff ff    	lea    -0xc800(%ebx),%eax
c0025b33:	50                   	push   %eax
c0025b34:	68 8c 01 00 00       	push   $0x18c
c0025b39:	8d 83 39 59 ff ff    	lea    -0xa6c7(%ebx),%eax
c0025b3f:	50                   	push   %eax
c0025b40:	e8 9f 33 00 00       	call   c0028ee4 <debug_panic>

c0025b45 <ide_write>:
ide_write(void *d_, block_sector_t sec_no, const void *buffer) {
c0025b45:	55                   	push   %ebp
c0025b46:	57                   	push   %edi
c0025b47:	56                   	push   %esi
c0025b48:	53                   	push   %ebx
c0025b49:	83 ec 18             	sub    $0x18,%esp
c0025b4c:	e8 46 7d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025b51:	81 c3 af 49 01 00    	add    $0x149af,%ebx
c0025b57:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    struct channel *c = d->channel;
c0025b5b:	8b 7e 08             	mov    0x8(%esi),%edi
    lock_acquire(&c->lock);
c0025b5e:	8d 6f 0c             	lea    0xc(%edi),%ebp
c0025b61:	55                   	push   %ebp
c0025b62:	e8 bb d4 ff ff       	call   c0023022 <lock_acquire>
    select_sector(d, sec_no);
c0025b67:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025b6b:	89 f0                	mov    %esi,%eax
c0025b6d:	e8 21 fe ff ff       	call   c0025993 <select_sector>
    issue_pio_command(c, CMD_WRITE_SECTOR_RETRY);
c0025b72:	ba 30 00 00 00       	mov    $0x30,%edx
c0025b77:	89 f8                	mov    %edi,%eax
c0025b79:	e8 70 ff ff ff       	call   c0025aee <issue_pio_command>
    if (!wait_while_busy(d))
c0025b7e:	89 f0                	mov    %esi,%eax
c0025b80:	e8 b2 fe ff ff       	call   c0025a37 <wait_while_busy>
c0025b85:	83 c4 10             	add    $0x10,%esp
c0025b88:	84 c0                	test   %al,%al
c0025b8a:	74 2c                	je     c0025bb8 <ide_write+0x73>
/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw(uint16_t port, const void *addr, size_t cnt) {
    /* See [IA32-v2b] "OUTS". */
    asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025b8c:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025b90:	8b 74 24 28          	mov    0x28(%esp),%esi
c0025b94:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025b99:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
    sema_down(&c->completion_wait);
c0025b9c:	83 ec 0c             	sub    $0xc,%esp
c0025b9f:	83 c7 34             	add    $0x34,%edi
c0025ba2:	57                   	push   %edi
c0025ba3:	e8 4c d1 ff ff       	call   c0022cf4 <sema_down>
    lock_release(&c->lock);
c0025ba8:	89 2c 24             	mov    %ebp,(%esp)
c0025bab:	e8 73 d6 ff ff       	call   c0023223 <lock_release>
}
c0025bb0:	83 c4 1c             	add    $0x1c,%esp
c0025bb3:	5b                   	pop    %ebx
c0025bb4:	5e                   	pop    %esi
c0025bb5:	5f                   	pop    %edi
c0025bb6:	5d                   	pop    %ebp
c0025bb7:	c3                   	ret    
        PANIC ("%s: disk write failed, sector=%"
c0025bb8:	83 ec 08             	sub    $0x8,%esp
c0025bbb:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025bbf:	56                   	push   %esi
c0025bc0:	8d 83 d8 59 ff ff    	lea    -0xa628(%ebx),%eax
c0025bc6:	50                   	push   %eax
c0025bc7:	8d 83 30 38 ff ff    	lea    -0xc7d0(%ebx),%eax
c0025bcd:	50                   	push   %eax
c0025bce:	68 68 01 00 00       	push   $0x168
c0025bd3:	8d 83 39 59 ff ff    	lea    -0xa6c7(%ebx),%eax
c0025bd9:	50                   	push   %eax
c0025bda:	e8 05 33 00 00       	call   c0028ee4 <debug_panic>

c0025bdf <identify_ata_device>:
identify_ata_device(struct ata_disk *d) {
c0025bdf:	55                   	push   %ebp
c0025be0:	57                   	push   %edi
c0025be1:	56                   	push   %esi
c0025be2:	53                   	push   %ebx
c0025be3:	81 ec 8c 02 00 00    	sub    $0x28c,%esp
c0025be9:	e8 a9 7c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025bee:	81 c3 12 49 01 00    	add    $0x14912,%ebx
    struct channel *c = d->channel;
c0025bf4:	8b 78 08             	mov    0x8(%eax),%edi
    ASSERT (d->is_ata);
c0025bf7:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c0025bfb:	74 4a                	je     c0025c47 <identify_ata_device+0x68>
c0025bfd:	89 c6                	mov    %eax,%esi
    wait_until_idle(d);
c0025bff:	e8 5d fc ff ff       	call   c0025861 <wait_until_idle>
    select_device(d);
c0025c04:	89 f0                	mov    %esi,%eax
c0025c06:	e8 c3 fc ff ff       	call   c00258ce <select_device>
    wait_until_idle(d);
c0025c0b:	89 f0                	mov    %esi,%eax
c0025c0d:	e8 4f fc ff ff       	call   c0025861 <wait_until_idle>
    issue_pio_command(c, CMD_IDENTIFY_DEVICE);
c0025c12:	ba ec 00 00 00       	mov    $0xec,%edx
c0025c17:	89 f8                	mov    %edi,%eax
c0025c19:	e8 d0 fe ff ff       	call   c0025aee <issue_pio_command>
    sema_down(&c->completion_wait);
c0025c1e:	83 ec 0c             	sub    $0xc,%esp
c0025c21:	8d 47 34             	lea    0x34(%edi),%eax
c0025c24:	50                   	push   %eax
c0025c25:	e8 ca d0 ff ff       	call   c0022cf4 <sema_down>
    if (!wait_while_busy(d)) {
c0025c2a:	89 f0                	mov    %esi,%eax
c0025c2c:	e8 06 fe ff ff       	call   c0025a37 <wait_while_busy>
c0025c31:	83 c4 10             	add    $0x10,%esp
c0025c34:	84 c0                	test   %al,%al
c0025c36:	75 38                	jne    c0025c70 <identify_ata_device+0x91>
        d->is_ata = false;
c0025c38:	c6 46 10 00          	movb   $0x0,0x10(%esi)
}
c0025c3c:	81 c4 8c 02 00 00    	add    $0x28c,%esp
c0025c42:	5b                   	pop    %ebx
c0025c43:	5e                   	pop    %esi
c0025c44:	5f                   	pop    %edi
c0025c45:	5d                   	pop    %ebp
c0025c46:	c3                   	ret    
    ASSERT (d->is_ata);
c0025c47:	83 ec 0c             	sub    $0xc,%esp
c0025c4a:	8d 83 8c 59 ff ff    	lea    -0xa674(%ebx),%eax
c0025c50:	50                   	push   %eax
c0025c51:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0025c57:	50                   	push   %eax
c0025c58:	8d 83 3c 38 ff ff    	lea    -0xc7c4(%ebx),%eax
c0025c5e:	50                   	push   %eax
c0025c5f:	68 05 01 00 00       	push   $0x105
c0025c64:	8d 83 39 59 ff ff    	lea    -0xa6c7(%ebx),%eax
c0025c6a:	50                   	push   %eax
c0025c6b:	e8 74 32 00 00       	call   c0028ee4 <debug_panic>
    asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025c70:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025c74:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025c7b:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025c80:	66 f3 6d             	rep insw (%dx),%es:(%edi)
    capacity = *(uint32_t *) &id[60 * 2];
c0025c83:	8b bc 24 f8 00 00 00 	mov    0xf8(%esp),%edi
    model = descramble_ata_string(&id[10 * 2], 20);
c0025c8a:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0025c91:	ba 14 00 00 00       	mov    $0x14,%edx
c0025c96:	e8 e4 fa ff ff       	call   c002577f <descramble_ata_string>
c0025c9b:	89 c5                	mov    %eax,%ebp
    serial = descramble_ata_string(&id[27 * 2], 40);
c0025c9d:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0025ca4:	ba 28 00 00 00       	mov    $0x28,%edx
c0025ca9:	e8 d1 fa ff ff       	call   c002577f <descramble_ata_string>
    snprintf(extra_info, sizeof extra_info,
c0025cae:	83 ec 0c             	sub    $0xc,%esp
c0025cb1:	50                   	push   %eax
c0025cb2:	55                   	push   %ebp
c0025cb3:	8d 83 96 59 ff ff    	lea    -0xa66a(%ebx),%eax
c0025cb9:	50                   	push   %eax
c0025cba:	68 80 00 00 00       	push   $0x80
c0025cbf:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0025cc3:	50                   	push   %eax
c0025cc4:	e8 50 1d 00 00       	call   c0027a19 <snprintf>
    if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE) {
c0025cc9:	83 c4 20             	add    $0x20,%esp
c0025ccc:	81 ff ff ff 1f 00    	cmp    $0x1fffff,%edi
c0025cd2:	77 2a                	ja     c0025cfe <identify_ata_device+0x11f>
    block = block_register(d->name, BLOCK_RAW, extra_info, capacity,
c0025cd4:	83 ec 08             	sub    $0x8,%esp
c0025cd7:	56                   	push   %esi
c0025cd8:	8d 83 dc ff ff ff    	lea    -0x24(%ebx),%eax
c0025cde:	50                   	push   %eax
c0025cdf:	57                   	push   %edi
c0025ce0:	8d 44 24 14          	lea    0x14(%esp),%eax
c0025ce4:	50                   	push   %eax
c0025ce5:	6a 04                	push   $0x4
c0025ce7:	56                   	push   %esi
c0025ce8:	e8 a6 f4 ff ff       	call   c0025193 <block_register>
    partition_scan(block);
c0025ced:	83 c4 14             	add    $0x14,%esp
c0025cf0:	50                   	push   %eax
c0025cf1:	e8 29 fa ff ff       	call   c002571f <partition_scan>
c0025cf6:	83 c4 10             	add    $0x10,%esp
c0025cf9:	e9 3e ff ff ff       	jmp    c0025c3c <identify_ata_device+0x5d>
        printf("%s: ignoring ", d->name);
c0025cfe:	83 ec 08             	sub    $0x8,%esp
c0025d01:	56                   	push   %esi
c0025d02:	8d 83 ae 59 ff ff    	lea    -0xa652(%ebx),%eax
c0025d08:	50                   	push   %eax
c0025d09:	e8 7a 15 00 00       	call   c0027288 <printf>
        print_human_readable_size(capacity * 512);
c0025d0e:	83 c4 08             	add    $0x8,%esp
c0025d11:	c1 e7 09             	shl    $0x9,%edi
c0025d14:	ba 00 00 00 00       	mov    $0x0,%edx
c0025d19:	52                   	push   %edx
c0025d1a:	57                   	push   %edi
c0025d1b:	e8 2e 1f 00 00       	call   c0027c4e <print_human_readable_size>
        printf("disk for safety\n");
c0025d20:	8d 83 bc 59 ff ff    	lea    -0xa644(%ebx),%eax
c0025d26:	89 04 24             	mov    %eax,(%esp)
c0025d29:	e8 d7 50 00 00       	call   c002ae05 <puts>
        d->is_ata = false;
c0025d2e:	c6 46 10 00          	movb   $0x0,0x10(%esi)
        return;
c0025d32:	83 c4 10             	add    $0x10,%esp
c0025d35:	e9 02 ff ff ff       	jmp    c0025c3c <identify_ata_device+0x5d>

c0025d3a <ide_read>:
ide_read(void *d_, block_sector_t sec_no, void *buffer) {
c0025d3a:	55                   	push   %ebp
c0025d3b:	57                   	push   %edi
c0025d3c:	56                   	push   %esi
c0025d3d:	53                   	push   %ebx
c0025d3e:	83 ec 18             	sub    $0x18,%esp
c0025d41:	e8 51 7b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025d46:	81 c3 ba 47 01 00    	add    $0x147ba,%ebx
c0025d4c:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    struct channel *c = d->channel;
c0025d50:	8b 77 08             	mov    0x8(%edi),%esi
    lock_acquire(&c->lock);
c0025d53:	8d 6e 0c             	lea    0xc(%esi),%ebp
c0025d56:	55                   	push   %ebp
c0025d57:	e8 c6 d2 ff ff       	call   c0023022 <lock_acquire>
    select_sector(d, sec_no);
c0025d5c:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025d60:	89 f8                	mov    %edi,%eax
c0025d62:	e8 2c fc ff ff       	call   c0025993 <select_sector>
    issue_pio_command(c, CMD_READ_SECTOR_RETRY);
c0025d67:	ba 20 00 00 00       	mov    $0x20,%edx
c0025d6c:	89 f0                	mov    %esi,%eax
c0025d6e:	e8 7b fd ff ff       	call   c0025aee <issue_pio_command>
    sema_down(&c->completion_wait);
c0025d73:	8d 46 34             	lea    0x34(%esi),%eax
c0025d76:	89 04 24             	mov    %eax,(%esp)
c0025d79:	e8 76 cf ff ff       	call   c0022cf4 <sema_down>
    if (!wait_while_busy(d))
c0025d7e:	89 f8                	mov    %edi,%eax
c0025d80:	e8 b2 fc ff ff       	call   c0025a37 <wait_while_busy>
c0025d85:	83 c4 10             	add    $0x10,%esp
c0025d88:	84 c0                	test   %al,%al
c0025d8a:	74 21                	je     c0025dad <ide_read+0x73>
c0025d8c:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0025d90:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0025d94:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025d99:	66 f3 6d             	rep insw (%dx),%es:(%edi)
    lock_release(&c->lock);
c0025d9c:	83 ec 0c             	sub    $0xc,%esp
c0025d9f:	55                   	push   %ebp
c0025da0:	e8 7e d4 ff ff       	call   c0023223 <lock_release>
}
c0025da5:	83 c4 1c             	add    $0x1c,%esp
c0025da8:	5b                   	pop    %ebx
c0025da9:	5e                   	pop    %esi
c0025daa:	5f                   	pop    %edi
c0025dab:	5d                   	pop    %ebp
c0025dac:	c3                   	ret    
        PANIC ("%s: disk read failed, sector=%"
c0025dad:	83 ec 08             	sub    $0x8,%esp
c0025db0:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025db4:	57                   	push   %edi
c0025db5:	8d 83 fc 59 ff ff    	lea    -0xa604(%ebx),%eax
c0025dbb:	50                   	push   %eax
c0025dbc:	8d 83 14 38 ff ff    	lea    -0xc7ec(%ebx),%eax
c0025dc2:	50                   	push   %eax
c0025dc3:	68 55 01 00 00       	push   $0x155
c0025dc8:	8d 83 39 59 ff ff    	lea    -0xa6c7(%ebx),%eax
c0025dce:	50                   	push   %eax
c0025dcf:	e8 10 31 00 00       	call   c0028ee4 <debug_panic>

c0025dd4 <ide_init>:
ide_init(void) {
c0025dd4:	55                   	push   %ebp
c0025dd5:	57                   	push   %edi
c0025dd6:	56                   	push   %esi
c0025dd7:	53                   	push   %ebx
c0025dd8:	83 ec 2c             	sub    $0x2c,%esp
c0025ddb:	e8 b7 7a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0025de0:	81 c3 20 47 01 00    	add    $0x14720,%ebx
        snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c0025de6:	6a 00                	push   $0x0
c0025de8:	8d 83 cc 59 ff ff    	lea    -0xa634(%ebx),%eax
c0025dee:	50                   	push   %eax
c0025def:	6a 08                	push   $0x8
c0025df1:	8d b3 c0 19 00 00    	lea    0x19c0(%ebx),%esi
c0025df7:	56                   	push   %esi
c0025df8:	e8 1c 1c 00 00       	call   c0027a19 <snprintf>
                c->reg_base = 0x1f0;
c0025dfd:	66 c7 83 c8 19 00 00 	movw   $0x1f0,0x19c8(%ebx)
c0025e04:	f0 01 
                c->irq = 14 + 0x20;
c0025e06:	c6 83 ca 19 00 00 2e 	movb   $0x2e,0x19ca(%ebx)
        lock_init(&c->lock);
c0025e0d:	8d 83 cc 19 00 00    	lea    0x19cc(%ebx),%eax
c0025e13:	89 04 24             	mov    %eax,(%esp)
c0025e16:	e8 5b d1 ff ff       	call   c0022f76 <lock_init>
        c->expecting_interrupt = false;
c0025e1b:	c6 83 f0 19 00 00 00 	movb   $0x0,0x19f0(%ebx)
        sema_init(&c->completion_wait, 0);
c0025e22:	83 c4 08             	add    $0x8,%esp
c0025e25:	6a 00                	push   $0x0
c0025e27:	8d 83 f4 19 00 00    	lea    0x19f4(%ebx),%eax
c0025e2d:	50                   	push   %eax
c0025e2e:	e8 6d ce ff ff       	call   c0022ca0 <sema_init>
            snprintf(d->name, sizeof d->name,
c0025e33:	6a 61                	push   $0x61
c0025e35:	8d bb d3 59 ff ff    	lea    -0xa62d(%ebx),%edi
c0025e3b:	57                   	push   %edi
c0025e3c:	6a 08                	push   $0x8
c0025e3e:	8d ab 08 1a 00 00    	lea    0x1a08(%ebx),%ebp
c0025e44:	55                   	push   %ebp
c0025e45:	e8 cf 1b 00 00       	call   c0027a19 <snprintf>
            d->channel = c;
c0025e4a:	89 b3 10 1a 00 00    	mov    %esi,0x1a10(%ebx)
            d->dev_no = dev_no;
c0025e50:	c7 83 14 1a 00 00 00 	movl   $0x0,0x1a14(%ebx)
c0025e57:	00 00 00 
            d->is_ata = false;
c0025e5a:	c6 83 18 1a 00 00 00 	movb   $0x0,0x1a18(%ebx)
            snprintf(d->name, sizeof d->name,
c0025e61:	83 c4 20             	add    $0x20,%esp
c0025e64:	6a 62                	push   $0x62
c0025e66:	57                   	push   %edi
c0025e67:	6a 08                	push   $0x8
c0025e69:	8d 83 1c 1a 00 00    	lea    0x1a1c(%ebx),%eax
c0025e6f:	50                   	push   %eax
c0025e70:	e8 a4 1b 00 00       	call   c0027a19 <snprintf>
            d->channel = c;
c0025e75:	89 b3 24 1a 00 00    	mov    %esi,0x1a24(%ebx)
            d->dev_no = dev_no;
c0025e7b:	c7 83 28 1a 00 00 01 	movl   $0x1,0x1a28(%ebx)
c0025e82:	00 00 00 
            d->is_ata = false;
c0025e85:	c6 83 2c 1a 00 00 00 	movb   $0x0,0x1a2c(%ebx)
        intr_register_ext(c->irq, interrupt_handler, c->name);
c0025e8c:	83 c4 0c             	add    $0xc,%esp
c0025e8f:	56                   	push   %esi
c0025e90:	8d 83 d3 b2 fe ff    	lea    -0x14d2d(%ebx),%eax
c0025e96:	50                   	push   %eax
c0025e97:	0f b6 83 ca 19 00 00 	movzbl 0x19ca(%ebx),%eax
c0025e9e:	50                   	push   %eax
c0025e9f:	e8 5b be ff ff       	call   c0021cff <intr_register_ext>
        select_device(d);
c0025ea4:	89 e8                	mov    %ebp,%eax
c0025ea6:	e8 23 fa ff ff       	call   c00258ce <select_device>
        outb(reg_nsect (c), 0x55);
c0025eab:	0f b7 8b c8 19 00 00 	movzwl 0x19c8(%ebx),%ecx
c0025eb2:	8d 69 02             	lea    0x2(%ecx),%ebp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025eb5:	bf 55 00 00 00       	mov    $0x55,%edi
c0025eba:	89 f8                	mov    %edi,%eax
c0025ebc:	89 ea                	mov    %ebp,%edx
c0025ebe:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c0025ebf:	83 c1 03             	add    $0x3,%ecx
c0025ec2:	be aa ff ff ff       	mov    $0xffffffaa,%esi
c0025ec7:	89 f0                	mov    %esi,%eax
c0025ec9:	89 ca                	mov    %ecx,%edx
c0025ecb:	ee                   	out    %al,(%dx)
c0025ecc:	89 ea                	mov    %ebp,%edx
c0025ece:	ee                   	out    %al,(%dx)
c0025ecf:	89 f8                	mov    %edi,%eax
c0025ed1:	89 ca                	mov    %ecx,%edx
c0025ed3:	ee                   	out    %al,(%dx)
c0025ed4:	89 ea                	mov    %ebp,%edx
c0025ed6:	ee                   	out    %al,(%dx)
c0025ed7:	89 f0                	mov    %esi,%eax
c0025ed9:	89 ca                	mov    %ecx,%edx
c0025edb:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025edc:	89 ea                	mov    %ebp,%edx
c0025ede:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c0025edf:	83 c4 10             	add    $0x10,%esp
c0025ee2:	ba 00 00 00 00       	mov    $0x0,%edx
c0025ee7:	3c 55                	cmp    $0x55,%al
c0025ee9:	0f 84 d6 01 00 00    	je     c00260c5 <ide_init+0x2f1>
c0025eef:	89 d0                	mov    %edx,%eax
c0025ef1:	83 e0 01             	and    $0x1,%eax
c0025ef4:	88 44 24 08          	mov    %al,0x8(%esp)
        present[dev_no] = (inb(reg_nsect (c)) == 0x55
c0025ef8:	88 44 24 1e          	mov    %al,0x1e(%esp)
        select_device(d);
c0025efc:	8d 83 1c 1a 00 00    	lea    0x1a1c(%ebx),%eax
c0025f02:	e8 c7 f9 ff ff       	call   c00258ce <select_device>
        outb(reg_nsect (c), 0x55);
c0025f07:	0f b7 ab c8 19 00 00 	movzwl 0x19c8(%ebx),%ebp
c0025f0e:	8d 4d 02             	lea    0x2(%ebp),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f11:	b8 55 00 00 00       	mov    $0x55,%eax
c0025f16:	89 ca                	mov    %ecx,%edx
c0025f18:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c0025f19:	8d 75 03             	lea    0x3(%ebp),%esi
c0025f1c:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c0025f21:	89 f8                	mov    %edi,%eax
c0025f23:	89 f2                	mov    %esi,%edx
c0025f25:	ee                   	out    %al,(%dx)
c0025f26:	89 ca                	mov    %ecx,%edx
c0025f28:	ee                   	out    %al,(%dx)
c0025f29:	b8 55 00 00 00       	mov    $0x55,%eax
c0025f2e:	89 f2                	mov    %esi,%edx
c0025f30:	ee                   	out    %al,(%dx)
c0025f31:	89 ca                	mov    %ecx,%edx
c0025f33:	ee                   	out    %al,(%dx)
c0025f34:	89 f8                	mov    %edi,%eax
c0025f36:	89 f2                	mov    %esi,%edx
c0025f38:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f39:	89 ca                	mov    %ecx,%edx
c0025f3b:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c0025f3c:	ba 00 00 00 00       	mov    $0x0,%edx
c0025f41:	3c 55                	cmp    $0x55,%al
c0025f43:	0f 84 8c 01 00 00    	je     c00260d5 <ide_init+0x301>
c0025f49:	89 d6                	mov    %edx,%esi
c0025f4b:	83 e6 01             	and    $0x1,%esi
        present[dev_no] = (inb(reg_nsect (c)) == 0x55
c0025f4e:	89 f0                	mov    %esi,%eax
c0025f50:	88 44 24 1f          	mov    %al,0x1f(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f54:	bf 00 00 00 00       	mov    $0x0,%edi
    outb(reg_ctl (c), 0);
c0025f59:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c0025f5f:	89 f8                	mov    %edi,%eax
c0025f61:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c0025f62:	83 ec 08             	sub    $0x8,%esp
c0025f65:	6a 00                	push   $0x0
c0025f67:	6a 0a                	push   $0xa
c0025f69:	e8 a9 e5 ff ff       	call   c0024517 <timer_usleep>
    outb(reg_ctl (c), CTL_SRST);
c0025f6e:	0f b7 93 c8 19 00 00 	movzwl 0x19c8(%ebx),%edx
c0025f75:	66 81 c2 06 02       	add    $0x206,%dx
c0025f7a:	b8 04 00 00 00       	mov    $0x4,%eax
c0025f7f:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c0025f80:	83 c4 08             	add    $0x8,%esp
c0025f83:	6a 00                	push   $0x0
c0025f85:	6a 0a                	push   $0xa
c0025f87:	e8 8b e5 ff ff       	call   c0024517 <timer_usleep>
    outb(reg_ctl (c), 0);
c0025f8c:	0f b7 93 c8 19 00 00 	movzwl 0x19c8(%ebx),%edx
c0025f93:	66 81 c2 06 02       	add    $0x206,%dx
c0025f98:	89 f8                	mov    %edi,%eax
c0025f9a:	ee                   	out    %al,(%dx)
    timer_msleep(150);
c0025f9b:	83 c4 08             	add    $0x8,%esp
c0025f9e:	6a 00                	push   $0x0
c0025fa0:	68 96 00 00 00       	push   $0x96
c0025fa5:	e8 54 e5 ff ff       	call   c00244fe <timer_msleep>
    if (present[0]) {
c0025faa:	83 c4 10             	add    $0x10,%esp
c0025fad:	80 7c 24 08 00       	cmpb   $0x0,0x8(%esp)
c0025fb2:	0f 85 2d 01 00 00    	jne    c00260e5 <ide_init+0x311>
    if (present[1]) {
c0025fb8:	89 f0                	mov    %esi,%eax
c0025fba:	84 c0                	test   %al,%al
c0025fbc:	0f 85 3e 01 00 00    	jne    c0026100 <ide_init+0x32c>
        if (check_device_type(&c->devices[0]))
c0025fc2:	8d 83 08 1a 00 00    	lea    0x1a08(%ebx),%eax
c0025fc8:	e8 44 f9 ff ff       	call   c0025911 <check_device_type>
c0025fcd:	84 c0                	test   %al,%al
c0025fcf:	0f 85 78 01 00 00    	jne    c002614d <ide_init+0x379>
            if (c->devices[dev_no].is_ata)
c0025fd5:	80 bb 18 1a 00 00 00 	cmpb   $0x0,0x1a18(%ebx)
c0025fdc:	0f 85 7b 01 00 00    	jne    c002615d <ide_init+0x389>
c0025fe2:	80 bb 2c 1a 00 00 00 	cmpb   $0x0,0x1a2c(%ebx)
c0025fe9:	0f 85 7e 01 00 00    	jne    c002616d <ide_init+0x399>
        snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c0025fef:	6a 01                	push   $0x1
c0025ff1:	8d 83 cc 59 ff ff    	lea    -0xa634(%ebx),%eax
c0025ff7:	50                   	push   %eax
c0025ff8:	6a 08                	push   $0x8
c0025ffa:	8d b3 30 1a 00 00    	lea    0x1a30(%ebx),%esi
c0026000:	56                   	push   %esi
c0026001:	e8 13 1a 00 00       	call   c0027a19 <snprintf>
                c->reg_base = 0x170;
c0026006:	66 c7 83 38 1a 00 00 	movw   $0x170,0x1a38(%ebx)
c002600d:	70 01 
                c->irq = 15 + 0x20;
c002600f:	c6 83 3a 1a 00 00 2f 	movb   $0x2f,0x1a3a(%ebx)
        lock_init(&c->lock);
c0026016:	8d 83 3c 1a 00 00    	lea    0x1a3c(%ebx),%eax
c002601c:	89 04 24             	mov    %eax,(%esp)
c002601f:	e8 52 cf ff ff       	call   c0022f76 <lock_init>
        c->expecting_interrupt = false;
c0026024:	c6 83 60 1a 00 00 00 	movb   $0x0,0x1a60(%ebx)
        sema_init(&c->completion_wait, 0);
c002602b:	83 c4 08             	add    $0x8,%esp
c002602e:	6a 00                	push   $0x0
c0026030:	8d 83 64 1a 00 00    	lea    0x1a64(%ebx),%eax
c0026036:	50                   	push   %eax
c0026037:	e8 64 cc ff ff       	call   c0022ca0 <sema_init>
            snprintf(d->name, sizeof d->name,
c002603c:	6a 63                	push   $0x63
c002603e:	8d bb d3 59 ff ff    	lea    -0xa62d(%ebx),%edi
c0026044:	57                   	push   %edi
c0026045:	6a 08                	push   $0x8
c0026047:	8d ab 78 1a 00 00    	lea    0x1a78(%ebx),%ebp
c002604d:	55                   	push   %ebp
c002604e:	e8 c6 19 00 00       	call   c0027a19 <snprintf>
            d->channel = c;
c0026053:	89 b3 80 1a 00 00    	mov    %esi,0x1a80(%ebx)
            d->dev_no = dev_no;
c0026059:	c7 83 84 1a 00 00 00 	movl   $0x0,0x1a84(%ebx)
c0026060:	00 00 00 
            d->is_ata = false;
c0026063:	c6 83 88 1a 00 00 00 	movb   $0x0,0x1a88(%ebx)
            snprintf(d->name, sizeof d->name,
c002606a:	83 c4 20             	add    $0x20,%esp
c002606d:	6a 64                	push   $0x64
c002606f:	57                   	push   %edi
c0026070:	6a 08                	push   $0x8
c0026072:	8d 83 8c 1a 00 00    	lea    0x1a8c(%ebx),%eax
c0026078:	50                   	push   %eax
c0026079:	e8 9b 19 00 00       	call   c0027a19 <snprintf>
            d->channel = c;
c002607e:	89 b3 94 1a 00 00    	mov    %esi,0x1a94(%ebx)
            d->dev_no = dev_no;
c0026084:	c7 83 98 1a 00 00 01 	movl   $0x1,0x1a98(%ebx)
c002608b:	00 00 00 
            d->is_ata = false;
c002608e:	c6 83 9c 1a 00 00 00 	movb   $0x0,0x1a9c(%ebx)
        intr_register_ext(c->irq, interrupt_handler, c->name);
c0026095:	83 c4 0c             	add    $0xc,%esp
c0026098:	56                   	push   %esi
c0026099:	8d 83 d3 b2 fe ff    	lea    -0x14d2d(%ebx),%eax
c002609f:	50                   	push   %eax
c00260a0:	0f b6 83 3a 1a 00 00 	movzbl 0x1a3a(%ebx),%eax
c00260a7:	50                   	push   %eax
c00260a8:	e8 52 bc ff ff       	call   c0021cff <intr_register_ext>
    for (dev_no = 0; dev_no < 2; dev_no++) {
c00260ad:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c00260b1:	8d 6c 24 2e          	lea    0x2e(%esp),%ebp
c00260b5:	8d 44 24 30          	lea    0x30(%esp),%eax
c00260b9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00260bd:	83 c4 10             	add    $0x10,%esp
c00260c0:	e9 cd 00 00 00       	jmp    c0026192 <ide_init+0x3be>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00260c5:	89 ca                	mov    %ecx,%edx
c00260c7:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c00260c8:	3c aa                	cmp    $0xaa,%al
c00260ca:	0f 94 c2             	sete   %dl
c00260cd:	0f b6 d2             	movzbl %dl,%edx
c00260d0:	e9 1a fe ff ff       	jmp    c0025eef <ide_init+0x11b>
c00260d5:	89 f2                	mov    %esi,%edx
c00260d7:	ec                   	in     (%dx),%al
c00260d8:	3c aa                	cmp    $0xaa,%al
c00260da:	0f 94 c2             	sete   %dl
c00260dd:	0f b6 d2             	movzbl %dl,%edx
c00260e0:	e9 64 fe ff ff       	jmp    c0025f49 <ide_init+0x175>
        select_device(&c->devices[0]);
c00260e5:	8d 83 08 1a 00 00    	lea    0x1a08(%ebx),%eax
c00260eb:	e8 de f7 ff ff       	call   c00258ce <select_device>
        wait_while_busy(&c->devices[0]);
c00260f0:	8d 83 08 1a 00 00    	lea    0x1a08(%ebx),%eax
c00260f6:	e8 3c f9 ff ff       	call   c0025a37 <wait_while_busy>
c00260fb:	e9 b8 fe ff ff       	jmp    c0025fb8 <ide_init+0x1e4>
        select_device(&c->devices[1]);
c0026100:	8d 83 1c 1a 00 00    	lea    0x1a1c(%ebx),%eax
c0026106:	e8 c3 f7 ff ff       	call   c00258ce <select_device>
c002610b:	be b8 0b 00 00       	mov    $0xbb8,%esi
c0026110:	eb 14                	jmp    c0026126 <ide_init+0x352>
            timer_msleep(10);
c0026112:	83 ec 08             	sub    $0x8,%esp
c0026115:	6a 00                	push   $0x0
c0026117:	6a 0a                	push   $0xa
c0026119:	e8 e0 e3 ff ff       	call   c00244fe <timer_msleep>
        for (i = 0; i < 3000; i++) {
c002611e:	83 c4 10             	add    $0x10,%esp
c0026121:	83 ee 01             	sub    $0x1,%esi
c0026124:	74 17                	je     c002613d <ide_init+0x369>
            if (inb(reg_nsect (c)) == 1 && inb(reg_lbal (c)) == 1)
c0026126:	0f b7 8b c8 19 00 00 	movzwl 0x19c8(%ebx),%ecx
c002612d:	8d 51 02             	lea    0x2(%ecx),%edx
c0026130:	ec                   	in     (%dx),%al
c0026131:	3c 01                	cmp    $0x1,%al
c0026133:	75 dd                	jne    c0026112 <ide_init+0x33e>
c0026135:	8d 51 03             	lea    0x3(%ecx),%edx
c0026138:	ec                   	in     (%dx),%al
c0026139:	3c 01                	cmp    $0x1,%al
c002613b:	75 d5                	jne    c0026112 <ide_init+0x33e>
        wait_while_busy(&c->devices[1]);
c002613d:	8d 83 1c 1a 00 00    	lea    0x1a1c(%ebx),%eax
c0026143:	e8 ef f8 ff ff       	call   c0025a37 <wait_while_busy>
c0026148:	e9 75 fe ff ff       	jmp    c0025fc2 <ide_init+0x1ee>
            check_device_type(&c->devices[1]);
c002614d:	8d 83 1c 1a 00 00    	lea    0x1a1c(%ebx),%eax
c0026153:	e8 b9 f7 ff ff       	call   c0025911 <check_device_type>
c0026158:	e9 78 fe ff ff       	jmp    c0025fd5 <ide_init+0x201>
                identify_ata_device(&c->devices[dev_no]);
c002615d:	8d 83 08 1a 00 00    	lea    0x1a08(%ebx),%eax
c0026163:	e8 77 fa ff ff       	call   c0025bdf <identify_ata_device>
c0026168:	e9 75 fe ff ff       	jmp    c0025fe2 <ide_init+0x20e>
c002616d:	8d 83 1c 1a 00 00    	lea    0x1a1c(%ebx),%eax
c0026173:	e8 67 fa ff ff       	call   c0025bdf <identify_ata_device>
c0026178:	e9 72 fe ff ff       	jmp    c0025fef <ide_init+0x21b>
                           && inb(reg_lbal (c)) == 0xaa);
c002617d:	88 55 00             	mov    %dl,0x0(%ebp)
c0026180:	80 65 00 01          	andb   $0x1,0x0(%ebp)
c0026184:	83 44 24 08 14       	addl   $0x14,0x8(%esp)
c0026189:	83 c5 01             	add    $0x1,%ebp
    for (dev_no = 0; dev_no < 2; dev_no++) {
c002618c:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c0026190:	74 55                	je     c00261e7 <ide_init+0x413>
        select_device(d);
c0026192:	8b 44 24 08          	mov    0x8(%esp),%eax
c0026196:	e8 33 f7 ff ff       	call   c00258ce <select_device>
        outb(reg_nsect (c), 0x55);
c002619b:	0f b7 bb 38 1a 00 00 	movzwl 0x1a38(%ebx),%edi
c00261a2:	8d 4f 02             	lea    0x2(%edi),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00261a5:	b8 55 00 00 00       	mov    $0x55,%eax
c00261aa:	89 ca                	mov    %ecx,%edx
c00261ac:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c00261ad:	8d 77 03             	lea    0x3(%edi),%esi
c00261b0:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c00261b5:	89 f2                	mov    %esi,%edx
c00261b7:	ee                   	out    %al,(%dx)
c00261b8:	89 ca                	mov    %ecx,%edx
c00261ba:	ee                   	out    %al,(%dx)
c00261bb:	b8 55 00 00 00       	mov    $0x55,%eax
c00261c0:	89 f2                	mov    %esi,%edx
c00261c2:	ee                   	out    %al,(%dx)
c00261c3:	89 ca                	mov    %ecx,%edx
c00261c5:	ee                   	out    %al,(%dx)
c00261c6:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c00261cb:	89 f2                	mov    %esi,%edx
c00261cd:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00261ce:	89 ca                	mov    %ecx,%edx
c00261d0:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c00261d1:	ba 00 00 00 00       	mov    $0x0,%edx
c00261d6:	3c 55                	cmp    $0x55,%al
c00261d8:	75 a3                	jne    c002617d <ide_init+0x3a9>
c00261da:	89 f2                	mov    %esi,%edx
c00261dc:	ec                   	in     (%dx),%al
c00261dd:	3c aa                	cmp    $0xaa,%al
c00261df:	0f 94 c2             	sete   %dl
c00261e2:	0f b6 d2             	movzbl %dl,%edx
c00261e5:	eb 96                	jmp    c002617d <ide_init+0x3a9>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00261e7:	be 00 00 00 00       	mov    $0x0,%esi
    outb(reg_ctl (c), 0);
c00261ec:	8d 97 06 02 00 00    	lea    0x206(%edi),%edx
c00261f2:	89 f0                	mov    %esi,%eax
c00261f4:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c00261f5:	83 ec 08             	sub    $0x8,%esp
c00261f8:	6a 00                	push   $0x0
c00261fa:	6a 0a                	push   $0xa
c00261fc:	e8 16 e3 ff ff       	call   c0024517 <timer_usleep>
    outb(reg_ctl (c), CTL_SRST);
c0026201:	0f b7 93 38 1a 00 00 	movzwl 0x1a38(%ebx),%edx
c0026208:	66 81 c2 06 02       	add    $0x206,%dx
c002620d:	b8 04 00 00 00       	mov    $0x4,%eax
c0026212:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c0026213:	83 c4 08             	add    $0x8,%esp
c0026216:	6a 00                	push   $0x0
c0026218:	6a 0a                	push   $0xa
c002621a:	e8 f8 e2 ff ff       	call   c0024517 <timer_usleep>
    outb(reg_ctl (c), 0);
c002621f:	0f b7 93 38 1a 00 00 	movzwl 0x1a38(%ebx),%edx
c0026226:	66 81 c2 06 02       	add    $0x206,%dx
c002622b:	89 f0                	mov    %esi,%eax
c002622d:	ee                   	out    %al,(%dx)
    timer_msleep(150);
c002622e:	83 c4 08             	add    $0x8,%esp
c0026231:	6a 00                	push   $0x0
c0026233:	68 96 00 00 00       	push   $0x96
c0026238:	e8 c1 e2 ff ff       	call   c00244fe <timer_msleep>
    if (present[0]) {
c002623d:	83 c4 10             	add    $0x10,%esp
c0026240:	80 7c 24 1e 00       	cmpb   $0x0,0x1e(%esp)
c0026245:	75 38                	jne    c002627f <ide_init+0x4ab>
    if (present[1]) {
c0026247:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c002624c:	75 49                	jne    c0026297 <ide_init+0x4c3>
        if (check_device_type(&c->devices[0]))
c002624e:	8d 83 78 1a 00 00    	lea    0x1a78(%ebx),%eax
c0026254:	e8 b8 f6 ff ff       	call   c0025911 <check_device_type>
c0026259:	84 c0                	test   %al,%al
c002625b:	0f 85 83 00 00 00    	jne    c00262e4 <ide_init+0x510>
            if (c->devices[dev_no].is_ata)
c0026261:	80 bb 88 1a 00 00 00 	cmpb   $0x0,0x1a88(%ebx)
c0026268:	0f 85 96 00 00 00    	jne    c0026304 <ide_init+0x530>
c002626e:	80 bb 9c 1a 00 00 00 	cmpb   $0x0,0x1a9c(%ebx)
c0026275:	75 7d                	jne    c00262f4 <ide_init+0x520>
}
c0026277:	83 c4 2c             	add    $0x2c,%esp
c002627a:	5b                   	pop    %ebx
c002627b:	5e                   	pop    %esi
c002627c:	5f                   	pop    %edi
c002627d:	5d                   	pop    %ebp
c002627e:	c3                   	ret    
        select_device(&c->devices[0]);
c002627f:	8d 83 78 1a 00 00    	lea    0x1a78(%ebx),%eax
c0026285:	e8 44 f6 ff ff       	call   c00258ce <select_device>
        wait_while_busy(&c->devices[0]);
c002628a:	8d 83 78 1a 00 00    	lea    0x1a78(%ebx),%eax
c0026290:	e8 a2 f7 ff ff       	call   c0025a37 <wait_while_busy>
c0026295:	eb b0                	jmp    c0026247 <ide_init+0x473>
        select_device(&c->devices[1]);
c0026297:	8d 83 8c 1a 00 00    	lea    0x1a8c(%ebx),%eax
c002629d:	e8 2c f6 ff ff       	call   c00258ce <select_device>
c00262a2:	be b8 0b 00 00       	mov    $0xbb8,%esi
c00262a7:	eb 14                	jmp    c00262bd <ide_init+0x4e9>
            timer_msleep(10);
c00262a9:	83 ec 08             	sub    $0x8,%esp
c00262ac:	6a 00                	push   $0x0
c00262ae:	6a 0a                	push   $0xa
c00262b0:	e8 49 e2 ff ff       	call   c00244fe <timer_msleep>
        for (i = 0; i < 3000; i++) {
c00262b5:	83 c4 10             	add    $0x10,%esp
c00262b8:	83 ee 01             	sub    $0x1,%esi
c00262bb:	74 17                	je     c00262d4 <ide_init+0x500>
            if (inb(reg_nsect (c)) == 1 && inb(reg_lbal (c)) == 1)
c00262bd:	0f b7 8b 38 1a 00 00 	movzwl 0x1a38(%ebx),%ecx
c00262c4:	8d 51 02             	lea    0x2(%ecx),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00262c7:	ec                   	in     (%dx),%al
c00262c8:	3c 01                	cmp    $0x1,%al
c00262ca:	75 dd                	jne    c00262a9 <ide_init+0x4d5>
c00262cc:	8d 51 03             	lea    0x3(%ecx),%edx
c00262cf:	ec                   	in     (%dx),%al
c00262d0:	3c 01                	cmp    $0x1,%al
c00262d2:	75 d5                	jne    c00262a9 <ide_init+0x4d5>
        wait_while_busy(&c->devices[1]);
c00262d4:	8d 83 8c 1a 00 00    	lea    0x1a8c(%ebx),%eax
c00262da:	e8 58 f7 ff ff       	call   c0025a37 <wait_while_busy>
c00262df:	e9 6a ff ff ff       	jmp    c002624e <ide_init+0x47a>
            check_device_type(&c->devices[1]);
c00262e4:	8d 83 8c 1a 00 00    	lea    0x1a8c(%ebx),%eax
c00262ea:	e8 22 f6 ff ff       	call   c0025911 <check_device_type>
c00262ef:	e9 6d ff ff ff       	jmp    c0026261 <ide_init+0x48d>
                identify_ata_device(&c->devices[dev_no]);
c00262f4:	8d 83 8c 1a 00 00    	lea    0x1a8c(%ebx),%eax
c00262fa:	e8 e0 f8 ff ff       	call   c0025bdf <identify_ata_device>
}
c00262ff:	e9 73 ff ff ff       	jmp    c0026277 <ide_init+0x4a3>
                identify_ata_device(&c->devices[dev_no]);
c0026304:	8d 83 78 1a 00 00    	lea    0x1a78(%ebx),%eax
c002630a:	e8 d0 f8 ff ff       	call   c0025bdf <identify_ata_device>
c002630f:	e9 5a ff ff ff       	jmp    c002626e <ide_init+0x49a>

c0026314 <input_init>:
/* Stores keys from the keyboard and serial port. */
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init(void) {
c0026314:	53                   	push   %ebx
c0026315:	83 ec 14             	sub    $0x14,%esp
c0026318:	e8 7a 75 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002631d:	81 c3 e3 41 01 00    	add    $0x141e3,%ebx
    intq_init(&buffer);
c0026323:	8d 83 a0 1a 00 00    	lea    0x1aa0(%ebx),%eax
c0026329:	50                   	push   %eax
c002632a:	e8 32 01 00 00       	call   c0026461 <intq_init>
}
c002632f:	83 c4 18             	add    $0x18,%esp
c0026332:	5b                   	pop    %ebx
c0026333:	c3                   	ret    

c0026334 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc(uint8_t key) {
c0026334:	56                   	push   %esi
c0026335:	53                   	push   %ebx
c0026336:	83 ec 04             	sub    $0x4,%esp
c0026339:	e8 59 75 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002633e:	81 c3 c2 41 01 00    	add    $0x141c2,%ebx
c0026344:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0026348:	e8 84 b7 ff ff       	call   c0021ad1 <intr_get_level>
c002634d:	85 c0                	test   %eax,%eax
c002634f:	75 36                	jne    c0026387 <input_putc+0x53>
    ASSERT (!intq_full(&buffer));
c0026351:	83 ec 0c             	sub    $0xc,%esp
c0026354:	8d 83 a0 1a 00 00    	lea    0x1aa0(%ebx),%eax
c002635a:	50                   	push   %eax
c002635b:	e8 8f 01 00 00       	call   c00264ef <intq_full>
c0026360:	83 c4 10             	add    $0x10,%esp
c0026363:	84 c0                	test   %al,%al
c0026365:	75 46                	jne    c00263ad <input_putc+0x79>

    intq_putc(&buffer, key);
c0026367:	83 ec 08             	sub    $0x8,%esp
c002636a:	89 f0                	mov    %esi,%eax
c002636c:	0f b6 f0             	movzbl %al,%esi
c002636f:	56                   	push   %esi
c0026370:	8d 83 a0 1a 00 00    	lea    0x1aa0(%ebx),%eax
c0026376:	50                   	push   %eax
c0026377:	e8 2e 04 00 00       	call   c00267aa <intq_putc>
    serial_notify();
c002637c:	e8 90 ea ff ff       	call   c0024e11 <serial_notify>
}
c0026381:	83 c4 14             	add    $0x14,%esp
c0026384:	5b                   	pop    %ebx
c0026385:	5e                   	pop    %esi
c0026386:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026387:	83 ec 0c             	sub    $0xc,%esp
c002638a:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0026390:	50                   	push   %eax
c0026391:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0026397:	50                   	push   %eax
c0026398:	8d 83 70 38 ff ff    	lea    -0xc790(%ebx),%eax
c002639e:	50                   	push   %eax
c002639f:	6a 13                	push   $0x13
c00263a1:	8d 83 1c 5a ff ff    	lea    -0xa5e4(%ebx),%eax
c00263a7:	50                   	push   %eax
c00263a8:	e8 37 2b 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (!intq_full(&buffer));
c00263ad:	83 ec 0c             	sub    $0xc,%esp
c00263b0:	8d 83 32 5a ff ff    	lea    -0xa5ce(%ebx),%eax
c00263b6:	50                   	push   %eax
c00263b7:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00263bd:	50                   	push   %eax
c00263be:	8d 83 70 38 ff ff    	lea    -0xc790(%ebx),%eax
c00263c4:	50                   	push   %eax
c00263c5:	6a 14                	push   $0x14
c00263c7:	8d 83 1c 5a ff ff    	lea    -0xa5e4(%ebx),%eax
c00263cd:	50                   	push   %eax
c00263ce:	e8 11 2b 00 00       	call   c0028ee4 <debug_panic>

c00263d3 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc(void) {
c00263d3:	57                   	push   %edi
c00263d4:	56                   	push   %esi
c00263d5:	53                   	push   %ebx
c00263d6:	e8 bc 74 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00263db:	81 c3 25 41 01 00    	add    $0x14125,%ebx
    enum intr_level old_level;
    uint8_t key;

    old_level = intr_disable();
c00263e1:	e8 3d b7 ff ff       	call   c0021b23 <intr_disable>
c00263e6:	89 c7                	mov    %eax,%edi
    key = intq_getc(&buffer);
c00263e8:	83 ec 0c             	sub    $0xc,%esp
c00263eb:	8d 83 a0 1a 00 00    	lea    0x1aa0(%ebx),%eax
c00263f1:	50                   	push   %eax
c00263f2:	e8 e8 02 00 00       	call   c00266df <intq_getc>
c00263f7:	89 c6                	mov    %eax,%esi
    serial_notify();
c00263f9:	e8 13 ea ff ff       	call   c0024e11 <serial_notify>
    intr_set_level(old_level);
c00263fe:	89 3c 24             	mov    %edi,(%esp)
c0026401:	e8 24 b7 ff ff       	call   c0021b2a <intr_set_level>

    return key;
c0026406:	83 c4 10             	add    $0x10,%esp
}
c0026409:	89 f0                	mov    %esi,%eax
c002640b:	5b                   	pop    %ebx
c002640c:	5e                   	pop    %esi
c002640d:	5f                   	pop    %edi
c002640e:	c3                   	ret    

c002640f <input_full>:

/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full(void) {
c002640f:	53                   	push   %ebx
c0026410:	83 ec 08             	sub    $0x8,%esp
c0026413:	e8 7f 74 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026418:	81 c3 e8 40 01 00    	add    $0x140e8,%ebx
    ASSERT (intr_get_level() == INTR_OFF);
c002641e:	e8 ae b6 ff ff       	call   c0021ad1 <intr_get_level>
c0026423:	85 c0                	test   %eax,%eax
c0026425:	75 14                	jne    c002643b <input_full+0x2c>
    return intq_full(&buffer);
c0026427:	83 ec 0c             	sub    $0xc,%esp
c002642a:	8d 83 a0 1a 00 00    	lea    0x1aa0(%ebx),%eax
c0026430:	50                   	push   %eax
c0026431:	e8 b9 00 00 00       	call   c00264ef <intq_full>
}
c0026436:	83 c4 18             	add    $0x18,%esp
c0026439:	5b                   	pop    %ebx
c002643a:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c002643b:	83 ec 0c             	sub    $0xc,%esp
c002643e:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0026444:	50                   	push   %eax
c0026445:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002644b:	50                   	push   %eax
c002644c:	8d 83 64 38 ff ff    	lea    -0xc79c(%ebx),%eax
c0026452:	50                   	push   %eax
c0026453:	6a 2e                	push   $0x2e
c0026455:	8d 83 1c 5a ff ff    	lea    -0xa5e4(%ebx),%eax
c002645b:	50                   	push   %eax
c002645c:	e8 83 2a 00 00       	call   c0028ee4 <debug_panic>

c0026461 <intq_init>:

static void signal(struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init(struct intq *q) {
c0026461:	56                   	push   %esi
c0026462:	53                   	push   %ebx
c0026463:	83 ec 10             	sub    $0x10,%esp
c0026466:	e8 2c 74 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002646b:	81 c3 95 40 01 00    	add    $0x14095,%ebx
c0026471:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    lock_init(&q->lock);
c0026475:	56                   	push   %esi
c0026476:	e8 fb ca ff ff       	call   c0022f76 <lock_init>
    q->not_full = q->not_empty = NULL;
c002647b:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c0026482:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
    q->head = q->tail = 0;
c0026489:	c7 46 70 00 00 00 00 	movl   $0x0,0x70(%esi)
c0026490:	c7 46 6c 00 00 00 00 	movl   $0x0,0x6c(%esi)
}
c0026497:	83 c4 14             	add    $0x14,%esp
c002649a:	5b                   	pop    %ebx
c002649b:	5e                   	pop    %esi
c002649c:	c3                   	ret    

c002649d <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty(const struct intq *q) {
c002649d:	56                   	push   %esi
c002649e:	53                   	push   %ebx
c002649f:	83 ec 04             	sub    $0x4,%esp
c00264a2:	e8 f0 73 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00264a7:	81 c3 59 40 01 00    	add    $0x14059,%ebx
c00264ad:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c00264b1:	e8 1b b6 ff ff       	call   c0021ad1 <intr_get_level>
c00264b6:	85 c0                	test   %eax,%eax
c00264b8:	75 0f                	jne    c00264c9 <intq_empty+0x2c>
    return q->head == q->tail;
c00264ba:	8b 46 70             	mov    0x70(%esi),%eax
c00264bd:	39 46 6c             	cmp    %eax,0x6c(%esi)
c00264c0:	0f 94 c0             	sete   %al
}
c00264c3:	83 c4 04             	add    $0x4,%esp
c00264c6:	5b                   	pop    %ebx
c00264c7:	5e                   	pop    %esi
c00264c8:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c00264c9:	83 ec 0c             	sub    $0xc,%esp
c00264cc:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c00264d2:	50                   	push   %eax
c00264d3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00264d9:	50                   	push   %eax
c00264da:	8d 83 b0 38 ff ff    	lea    -0xc750(%ebx),%eax
c00264e0:	50                   	push   %eax
c00264e1:	6a 16                	push   $0x16
c00264e3:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c00264e9:	50                   	push   %eax
c00264ea:	e8 f5 29 00 00       	call   c0028ee4 <debug_panic>

c00264ef <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full(const struct intq *q) {
c00264ef:	56                   	push   %esi
c00264f0:	53                   	push   %ebx
c00264f1:	83 ec 04             	sub    $0x4,%esp
c00264f4:	e8 9e 73 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00264f9:	81 c3 07 40 01 00    	add    $0x14007,%ebx
c00264ff:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0026503:	e8 c9 b5 ff ff       	call   c0021ad1 <intr_get_level>
c0026508:	85 c0                	test   %eax,%eax
c002650a:	75 1d                	jne    c0026529 <intq_full+0x3a>
}

/* Returns the position after POS within an intq. */
static int
next(int pos) {
    return (pos + 1) % INTQ_BUFSIZE;
c002650c:	8b 46 6c             	mov    0x6c(%esi),%eax
c002650f:	83 c0 01             	add    $0x1,%eax
c0026512:	99                   	cltd   
c0026513:	c1 ea 1a             	shr    $0x1a,%edx
c0026516:	01 d0                	add    %edx,%eax
c0026518:	83 e0 3f             	and    $0x3f,%eax
c002651b:	29 d0                	sub    %edx,%eax
    return next(q->head) == q->tail;
c002651d:	3b 46 70             	cmp    0x70(%esi),%eax
c0026520:	0f 94 c0             	sete   %al
}
c0026523:	83 c4 04             	add    $0x4,%esp
c0026526:	5b                   	pop    %ebx
c0026527:	5e                   	pop    %esi
c0026528:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026529:	83 ec 0c             	sub    $0xc,%esp
c002652c:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0026532:	50                   	push   %eax
c0026533:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0026539:	50                   	push   %eax
c002653a:	8d 83 a4 38 ff ff    	lea    -0xc75c(%ebx),%eax
c0026540:	50                   	push   %eax
c0026541:	6a 1d                	push   $0x1d
c0026543:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c0026549:	50                   	push   %eax
c002654a:	e8 95 29 00 00       	call   c0028ee4 <debug_panic>

c002654f <wait>:
}

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait(struct intq *q UNUSED, struct thread **waiter) {
c002654f:	57                   	push   %edi
c0026550:	56                   	push   %esi
c0026551:	53                   	push   %ebx
c0026552:	e8 40 73 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026557:	81 c3 a9 3f 01 00    	add    $0x13fa9,%ebx
c002655d:	89 c6                	mov    %eax,%esi
c002655f:	89 d7                	mov    %edx,%edi
    ASSERT (!intr_context());
c0026561:	e8 63 b8 ff ff       	call   c0021dc9 <intr_context>
c0026566:	84 c0                	test   %al,%al
c0026568:	75 3b                	jne    c00265a5 <wait+0x56>
    ASSERT (intr_get_level() == INTR_OFF);
c002656a:	e8 62 b5 ff ff       	call   c0021ad1 <intr_get_level>
c002656f:	85 c0                	test   %eax,%eax
c0026571:	75 58                	jne    c00265cb <wait+0x7c>
    ASSERT ((waiter == &q->not_empty && intq_empty(q))
c0026573:	8d 46 28             	lea    0x28(%esi),%eax
c0026576:	39 c7                	cmp    %eax,%edi
c0026578:	74 77                	je     c00265f1 <wait+0xa2>
c002657a:	8d 46 24             	lea    0x24(%esi),%eax
c002657d:	39 c7                	cmp    %eax,%edi
c002657f:	0f 85 81 00 00 00    	jne    c0026606 <wait+0xb7>
c0026585:	83 ec 0c             	sub    $0xc,%esp
c0026588:	56                   	push   %esi
c0026589:	e8 61 ff ff ff       	call   c00264ef <intq_full>
c002658e:	83 c4 10             	add    $0x10,%esp
c0026591:	84 c0                	test   %al,%al
c0026593:	74 71                	je     c0026606 <wait+0xb7>
            || (waiter == &q->not_full && intq_full(q)));

    *waiter = thread_current();
c0026595:	e8 13 a8 ff ff       	call   c0020dad <thread_current>
c002659a:	89 07                	mov    %eax,(%edi)
    thread_block();
c002659c:	e8 8d ad ff ff       	call   c002132e <thread_block>
}
c00265a1:	5b                   	pop    %ebx
c00265a2:	5e                   	pop    %esi
c00265a3:	5f                   	pop    %edi
c00265a4:	c3                   	ret    
    ASSERT (!intr_context());
c00265a5:	83 ec 0c             	sub    $0xc,%esp
c00265a8:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c00265ae:	50                   	push   %eax
c00265af:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00265b5:	50                   	push   %eax
c00265b6:	8d 83 90 38 ff ff    	lea    -0xc770(%ebx),%eax
c00265bc:	50                   	push   %eax
c00265bd:	6a 52                	push   $0x52
c00265bf:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c00265c5:	50                   	push   %eax
c00265c6:	e8 19 29 00 00       	call   c0028ee4 <debug_panic>
    ASSERT (intr_get_level() == INTR_OFF);
c00265cb:	83 ec 0c             	sub    $0xc,%esp
c00265ce:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c00265d4:	50                   	push   %eax
c00265d5:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00265db:	50                   	push   %eax
c00265dc:	8d 83 90 38 ff ff    	lea    -0xc770(%ebx),%eax
c00265e2:	50                   	push   %eax
c00265e3:	6a 53                	push   $0x53
c00265e5:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c00265eb:	50                   	push   %eax
c00265ec:	e8 f3 28 00 00       	call   c0028ee4 <debug_panic>
    ASSERT ((waiter == &q->not_empty && intq_empty(q))
c00265f1:	83 ec 0c             	sub    $0xc,%esp
c00265f4:	56                   	push   %esi
c00265f5:	e8 a3 fe ff ff       	call   c002649d <intq_empty>
c00265fa:	83 c4 10             	add    $0x10,%esp
c00265fd:	84 c0                	test   %al,%al
c00265ff:	75 94                	jne    c0026595 <wait+0x46>
c0026601:	e9 74 ff ff ff       	jmp    c002657a <wait+0x2b>
c0026606:	83 ec 0c             	sub    $0xc,%esp
c0026609:	8d 83 5c 5a ff ff    	lea    -0xa5a4(%ebx),%eax
c002660f:	50                   	push   %eax
c0026610:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0026616:	50                   	push   %eax
c0026617:	8d 83 90 38 ff ff    	lea    -0xc770(%ebx),%eax
c002661d:	50                   	push   %eax
c002661e:	6a 55                	push   $0x55
c0026620:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c0026626:	50                   	push   %eax
c0026627:	e8 b8 28 00 00       	call   c0028ee4 <debug_panic>

c002662c <signal>:
/* WAITER must be the address of Q's not_empty or not_full
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal(struct intq *q UNUSED, struct thread **waiter) {
c002662c:	57                   	push   %edi
c002662d:	56                   	push   %esi
c002662e:	53                   	push   %ebx
c002662f:	e8 63 72 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026634:	81 c3 cc 3e 01 00    	add    $0x13ecc,%ebx
c002663a:	89 c7                	mov    %eax,%edi
c002663c:	89 d6                	mov    %edx,%esi
    ASSERT (intr_get_level() == INTR_OFF);
c002663e:	e8 8e b4 ff ff       	call   c0021ad1 <intr_get_level>
c0026643:	85 c0                	test   %eax,%eax
c0026645:	75 3a                	jne    c0026681 <signal+0x55>
    ASSERT ((waiter == &q->not_empty && !intq_empty(q))
c0026647:	8d 47 28             	lea    0x28(%edi),%eax
c002664a:	39 c6                	cmp    %eax,%esi
c002664c:	74 59                	je     c00266a7 <signal+0x7b>
c002664e:	8d 47 24             	lea    0x24(%edi),%eax
c0026651:	39 c6                	cmp    %eax,%esi
c0026653:	75 64                	jne    c00266b9 <signal+0x8d>
c0026655:	83 ec 0c             	sub    $0xc,%esp
c0026658:	57                   	push   %edi
c0026659:	e8 91 fe ff ff       	call   c00264ef <intq_full>
c002665e:	83 c4 10             	add    $0x10,%esp
c0026661:	84 c0                	test   %al,%al
c0026663:	75 54                	jne    c00266b9 <signal+0x8d>
            || (waiter == &q->not_full && !intq_full(q)));

    if (*waiter != NULL) {
c0026665:	8b 06                	mov    (%esi),%eax
c0026667:	85 c0                	test   %eax,%eax
c0026669:	74 12                	je     c002667d <signal+0x51>
        thread_unblock(*waiter);
c002666b:	83 ec 0c             	sub    $0xc,%esp
c002666e:	50                   	push   %eax
c002666f:	e8 86 a6 ff ff       	call   c0020cfa <thread_unblock>
        *waiter = NULL;
c0026674:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c002667a:	83 c4 10             	add    $0x10,%esp
    }
}
c002667d:	5b                   	pop    %ebx
c002667e:	5e                   	pop    %esi
c002667f:	5f                   	pop    %edi
c0026680:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026681:	83 ec 0c             	sub    $0xc,%esp
c0026684:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c002668a:	50                   	push   %eax
c002668b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0026691:	50                   	push   %eax
c0026692:	8d 83 88 38 ff ff    	lea    -0xc778(%ebx),%eax
c0026698:	50                   	push   %eax
c0026699:	6a 61                	push   $0x61
c002669b:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c00266a1:	50                   	push   %eax
c00266a2:	e8 3d 28 00 00       	call   c0028ee4 <debug_panic>
    ASSERT ((waiter == &q->not_empty && !intq_empty(q))
c00266a7:	83 ec 0c             	sub    $0xc,%esp
c00266aa:	57                   	push   %edi
c00266ab:	e8 ed fd ff ff       	call   c002649d <intq_empty>
c00266b0:	83 c4 10             	add    $0x10,%esp
c00266b3:	84 c0                	test   %al,%al
c00266b5:	74 ae                	je     c0026665 <signal+0x39>
c00266b7:	eb 95                	jmp    c002664e <signal+0x22>
c00266b9:	83 ec 0c             	sub    $0xc,%esp
c00266bc:	8d 83 b4 5a ff ff    	lea    -0xa54c(%ebx),%eax
c00266c2:	50                   	push   %eax
c00266c3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00266c9:	50                   	push   %eax
c00266ca:	8d 83 88 38 ff ff    	lea    -0xc778(%ebx),%eax
c00266d0:	50                   	push   %eax
c00266d1:	6a 63                	push   $0x63
c00266d3:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c00266d9:	50                   	push   %eax
c00266da:	e8 05 28 00 00       	call   c0028ee4 <debug_panic>

c00266df <intq_getc>:
intq_getc(struct intq *q) {
c00266df:	57                   	push   %edi
c00266e0:	56                   	push   %esi
c00266e1:	53                   	push   %ebx
c00266e2:	e8 b0 71 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00266e7:	81 c3 19 3e 01 00    	add    $0x13e19,%ebx
c00266ed:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c00266f1:	e8 db b3 ff ff       	call   c0021ad1 <intr_get_level>
c00266f6:	85 c0                	test   %eax,%eax
c00266f8:	75 3b                	jne    c0026735 <intq_getc+0x56>
        wait(q, &q->not_empty);
c00266fa:	8d 7e 28             	lea    0x28(%esi),%edi
    while (intq_empty(q)) {
c00266fd:	83 ec 0c             	sub    $0xc,%esp
c0026700:	56                   	push   %esi
c0026701:	e8 97 fd ff ff       	call   c002649d <intq_empty>
c0026706:	83 c4 10             	add    $0x10,%esp
c0026709:	84 c0                	test   %al,%al
c002670b:	74 74                	je     c0026781 <intq_getc+0xa2>
        ASSERT (!intr_context());
c002670d:	e8 b7 b6 ff ff       	call   c0021dc9 <intr_context>
c0026712:	84 c0                	test   %al,%al
c0026714:	75 45                	jne    c002675b <intq_getc+0x7c>
        lock_acquire(&q->lock);
c0026716:	83 ec 0c             	sub    $0xc,%esp
c0026719:	56                   	push   %esi
c002671a:	e8 03 c9 ff ff       	call   c0023022 <lock_acquire>
        wait(q, &q->not_empty);
c002671f:	89 fa                	mov    %edi,%edx
c0026721:	89 f0                	mov    %esi,%eax
c0026723:	e8 27 fe ff ff       	call   c002654f <wait>
        lock_release(&q->lock);
c0026728:	89 34 24             	mov    %esi,(%esp)
c002672b:	e8 f3 ca ff ff       	call   c0023223 <lock_release>
c0026730:	83 c4 10             	add    $0x10,%esp
c0026733:	eb c8                	jmp    c00266fd <intq_getc+0x1e>
    ASSERT (intr_get_level() == INTR_OFF);
c0026735:	83 ec 0c             	sub    $0xc,%esp
c0026738:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c002673e:	50                   	push   %eax
c002673f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0026745:	50                   	push   %eax
c0026746:	8d 83 98 38 ff ff    	lea    -0xc768(%ebx),%eax
c002674c:	50                   	push   %eax
c002674d:	6a 28                	push   $0x28
c002674f:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c0026755:	50                   	push   %eax
c0026756:	e8 89 27 00 00       	call   c0028ee4 <debug_panic>
        ASSERT (!intr_context());
c002675b:	83 ec 0c             	sub    $0xc,%esp
c002675e:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c0026764:	50                   	push   %eax
c0026765:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002676b:	50                   	push   %eax
c002676c:	8d 83 98 38 ff ff    	lea    -0xc768(%ebx),%eax
c0026772:	50                   	push   %eax
c0026773:	6a 2a                	push   $0x2a
c0026775:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c002677b:	50                   	push   %eax
c002677c:	e8 63 27 00 00       	call   c0028ee4 <debug_panic>
    byte = q->buf[q->tail];
c0026781:	8b 46 70             	mov    0x70(%esi),%eax
c0026784:	0f b6 5c 06 2c       	movzbl 0x2c(%esi,%eax,1),%ebx
    return (pos + 1) % INTQ_BUFSIZE;
c0026789:	83 c0 01             	add    $0x1,%eax
c002678c:	99                   	cltd   
c002678d:	c1 ea 1a             	shr    $0x1a,%edx
c0026790:	01 d0                	add    %edx,%eax
c0026792:	83 e0 3f             	and    $0x3f,%eax
c0026795:	29 d0                	sub    %edx,%eax
    q->tail = next(q->tail);
c0026797:	89 46 70             	mov    %eax,0x70(%esi)
    signal(q, &q->not_full);
c002679a:	8d 56 24             	lea    0x24(%esi),%edx
c002679d:	89 f0                	mov    %esi,%eax
c002679f:	e8 88 fe ff ff       	call   c002662c <signal>
}
c00267a4:	89 d8                	mov    %ebx,%eax
c00267a6:	5b                   	pop    %ebx
c00267a7:	5e                   	pop    %esi
c00267a8:	5f                   	pop    %edi
c00267a9:	c3                   	ret    

c00267aa <intq_putc>:
intq_putc(struct intq *q, uint8_t byte) {
c00267aa:	55                   	push   %ebp
c00267ab:	57                   	push   %edi
c00267ac:	56                   	push   %esi
c00267ad:	53                   	push   %ebx
c00267ae:	83 ec 0c             	sub    $0xc,%esp
c00267b1:	e8 e1 70 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00267b6:	81 c3 4a 3d 01 00    	add    $0x13d4a,%ebx
c00267bc:	8b 74 24 20          	mov    0x20(%esp),%esi
c00267c0:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    ASSERT (intr_get_level() == INTR_OFF);
c00267c4:	e8 08 b3 ff ff       	call   c0021ad1 <intr_get_level>
c00267c9:	85 c0                	test   %eax,%eax
c00267cb:	75 3b                	jne    c0026808 <intq_putc+0x5e>
        wait(q, &q->not_full);
c00267cd:	8d 7e 24             	lea    0x24(%esi),%edi
    while (intq_full(q)) {
c00267d0:	83 ec 0c             	sub    $0xc,%esp
c00267d3:	56                   	push   %esi
c00267d4:	e8 16 fd ff ff       	call   c00264ef <intq_full>
c00267d9:	83 c4 10             	add    $0x10,%esp
c00267dc:	84 c0                	test   %al,%al
c00267de:	74 74                	je     c0026854 <intq_putc+0xaa>
        ASSERT (!intr_context());
c00267e0:	e8 e4 b5 ff ff       	call   c0021dc9 <intr_context>
c00267e5:	84 c0                	test   %al,%al
c00267e7:	75 45                	jne    c002682e <intq_putc+0x84>
        lock_acquire(&q->lock);
c00267e9:	83 ec 0c             	sub    $0xc,%esp
c00267ec:	56                   	push   %esi
c00267ed:	e8 30 c8 ff ff       	call   c0023022 <lock_acquire>
        wait(q, &q->not_full);
c00267f2:	89 fa                	mov    %edi,%edx
c00267f4:	89 f0                	mov    %esi,%eax
c00267f6:	e8 54 fd ff ff       	call   c002654f <wait>
        lock_release(&q->lock);
c00267fb:	89 34 24             	mov    %esi,(%esp)
c00267fe:	e8 20 ca ff ff       	call   c0023223 <lock_release>
c0026803:	83 c4 10             	add    $0x10,%esp
c0026806:	eb c8                	jmp    c00267d0 <intq_putc+0x26>
    ASSERT (intr_get_level() == INTR_OFF);
c0026808:	83 ec 0c             	sub    $0xc,%esp
c002680b:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0026811:	50                   	push   %eax
c0026812:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0026818:	50                   	push   %eax
c0026819:	8d 83 7c 38 ff ff    	lea    -0xc784(%ebx),%eax
c002681f:	50                   	push   %eax
c0026820:	6a 3b                	push   $0x3b
c0026822:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c0026828:	50                   	push   %eax
c0026829:	e8 b6 26 00 00       	call   c0028ee4 <debug_panic>
        ASSERT (!intr_context());
c002682e:	83 ec 0c             	sub    $0xc,%esp
c0026831:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c0026837:	50                   	push   %eax
c0026838:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002683e:	50                   	push   %eax
c002683f:	8d 83 7c 38 ff ff    	lea    -0xc784(%ebx),%eax
c0026845:	50                   	push   %eax
c0026846:	6a 3d                	push   $0x3d
c0026848:	8d 83 46 5a ff ff    	lea    -0xa5ba(%ebx),%eax
c002684e:	50                   	push   %eax
c002684f:	e8 90 26 00 00       	call   c0028ee4 <debug_panic>
    q->buf[q->head] = byte;
c0026854:	8b 46 6c             	mov    0x6c(%esi),%eax
c0026857:	89 e9                	mov    %ebp,%ecx
c0026859:	88 4c 06 2c          	mov    %cl,0x2c(%esi,%eax,1)
    return (pos + 1) % INTQ_BUFSIZE;
c002685d:	83 c0 01             	add    $0x1,%eax
c0026860:	99                   	cltd   
c0026861:	c1 ea 1a             	shr    $0x1a,%edx
c0026864:	01 d0                	add    %edx,%eax
c0026866:	83 e0 3f             	and    $0x3f,%eax
c0026869:	29 d0                	sub    %edx,%eax
    q->head = next(q->head);
c002686b:	89 46 6c             	mov    %eax,0x6c(%esi)
    signal(q, &q->not_empty);
c002686e:	8d 56 28             	lea    0x28(%esi),%edx
c0026871:	89 f0                	mov    %esi,%eax
c0026873:	e8 b4 fd ff ff       	call   c002662c <signal>
}
c0026878:	83 c4 0c             	add    $0xc,%esp
c002687b:	5b                   	pop    %ebx
c002687c:	5e                   	pop    %esi
c002687d:	5f                   	pop    %edi
c002687e:	5d                   	pop    %ebp
c002687f:	c3                   	ret    

c0026880 <rtc_get_time>:
static uint8_t cmos_read(uint8_t index);

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time(void) {
c0026880:	55                   	push   %ebp
c0026881:	57                   	push   %edi
c0026882:	56                   	push   %esi
c0026883:	53                   	push   %ebx
c0026884:	83 ec 10             	sub    $0x10,%esp
c0026887:	e8 0f 70 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c002688c:	05 74 3c 01 00       	add    $0x13c74,%eax
c0026891:	89 44 24 0c          	mov    %eax,0xc(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026895:	be 00 00 00 00       	mov    $0x0,%esi
c002689a:	bf 02 00 00 00       	mov    $0x2,%edi
c002689f:	89 f0                	mov    %esi,%eax
c00268a1:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268a3:	e4 71                	in     $0x71,%al
}

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin(uint8_t x) {
    return (x & 0x0f) + ((x >> 4) * 10);
c00268a5:	89 c2                	mov    %eax,%edx
c00268a7:	c0 ea 04             	shr    $0x4,%dl
c00268aa:	0f b6 d2             	movzbl %dl,%edx
c00268ad:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00268b0:	83 e0 0f             	and    $0xf,%eax
c00268b3:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268b6:	89 f8                	mov    %edi,%eax
c00268b8:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268ba:	e4 71                	in     $0x71,%al
c00268bc:	88 44 24 08          	mov    %al,0x8(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268c0:	b8 04 00 00 00       	mov    $0x4,%eax
c00268c5:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268c7:	e4 71                	in     $0x71,%al
c00268c9:	88 44 24 04          	mov    %al,0x4(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268cd:	b8 07 00 00 00       	mov    $0x7,%eax
c00268d2:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268d4:	e4 71                	in     $0x71,%al
c00268d6:	88 04 24             	mov    %al,(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268d9:	b8 08 00 00 00       	mov    $0x8,%eax
c00268de:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268e0:	e4 71                	in     $0x71,%al
c00268e2:	89 c5                	mov    %eax,%ebp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268e4:	b8 09 00 00 00       	mov    $0x9,%eax
c00268e9:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268eb:	e4 71                	in     $0x71,%al
c00268ed:	89 c1                	mov    %eax,%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268ef:	89 f0                	mov    %esi,%eax
c00268f1:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268f3:	e4 71                	in     $0x71,%al
c00268f5:	89 c2                	mov    %eax,%edx
c00268f7:	c0 ea 04             	shr    $0x4,%dl
c00268fa:	0f b6 d2             	movzbl %dl,%edx
c00268fd:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026900:	83 e0 0f             	and    $0xf,%eax
c0026903:	8d 04 50             	lea    (%eax,%edx,2),%eax
    } while (sec != bcd_to_bin(cmos_read(RTC_REG_SEC)));
c0026906:	39 d8                	cmp    %ebx,%eax
c0026908:	75 95                	jne    c002689f <rtc_get_time+0x1f>
    return (x & 0x0f) + ((x >> 4) * 10);
c002690a:	89 c8                	mov    %ecx,%eax
c002690c:	c0 e8 04             	shr    $0x4,%al
c002690f:	0f b6 c0             	movzbl %al,%eax
c0026912:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0026915:	83 e1 0f             	and    $0xf,%ecx
c0026918:	8d 04 41             	lea    (%ecx,%eax,2),%eax
        year += 100;
c002691b:	8d 48 64             	lea    0x64(%eax),%ecx
c002691e:	83 f8 46             	cmp    $0x46,%eax
c0026921:	0f 4c c1             	cmovl  %ecx,%eax
    return (x & 0x0f) + ((x >> 4) * 10);
c0026924:	89 ea                	mov    %ebp,%edx
c0026926:	89 e9                	mov    %ebp,%ecx
c0026928:	c0 e9 04             	shr    $0x4,%cl
c002692b:	0f b6 c9             	movzbl %cl,%ecx
c002692e:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026931:	83 e2 0f             	and    $0xf,%edx
c0026934:	8d 2c 4a             	lea    (%edx,%ecx,2),%ebp
    year -= 70;
c0026937:	8d 78 ba             	lea    -0x46(%eax),%edi
    time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c002693a:	8d 50 bc             	lea    -0x44(%eax),%edx
c002693d:	83 e8 47             	sub    $0x47,%eax
c0026940:	0f 48 c2             	cmovs  %edx,%eax
c0026943:	c1 f8 02             	sar    $0x2,%eax
c0026946:	69 d7 6d 01 00 00    	imul   $0x16d,%edi,%edx
c002694c:	01 d0                	add    %edx,%eax
c002694e:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    for (i = 1; i <= mon; i++)
c0026954:	85 ed                	test   %ebp,%ebp
c0026956:	7e 1c                	jle    c0026974 <rtc_get_time+0xf4>
c0026958:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002695c:	8d 96 c0 38 ff ff    	lea    -0xc740(%esi),%edx
c0026962:	8d 34 aa             	lea    (%edx,%ebp,4),%esi
        time += days_per_month[i - 1] * 24 * 60 * 60;
c0026965:	69 0a 80 51 01 00    	imul   $0x15180,(%edx),%ecx
c002696b:	01 c8                	add    %ecx,%eax
c002696d:	83 c2 04             	add    $0x4,%edx
    for (i = 1; i <= mon; i++)
c0026970:	39 f2                	cmp    %esi,%edx
c0026972:	75 f1                	jne    c0026965 <rtc_get_time+0xe5>
    if (mon > 2 && year % 4 == 0)
c0026974:	83 fd 02             	cmp    $0x2,%ebp
c0026977:	7e 0e                	jle    c0026987 <rtc_get_time+0x107>
c0026979:	83 e7 03             	and    $0x3,%edi
        time += 24 * 60 * 60;
c002697c:	8d 90 80 51 01 00    	lea    0x15180(%eax),%edx
c0026982:	85 ff                	test   %edi,%edi
c0026984:	0f 44 c2             	cmove  %edx,%eax
    return (x & 0x0f) + ((x >> 4) * 10);
c0026987:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c002698c:	c0 ea 04             	shr    $0x4,%dl
c002698f:	0f b6 d2             	movzbl %dl,%edx
c0026992:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026995:	8b 54 24 04          	mov    0x4(%esp),%edx
c0026999:	83 e2 0f             	and    $0xf,%edx
c002699c:	8d 0c 4a             	lea    (%edx,%ecx,2),%ecx
    time += hour * 60 * 60;
c002699f:	69 c9 10 0e 00 00    	imul   $0xe10,%ecx,%ecx
    return (x & 0x0f) + ((x >> 4) * 10);
c00269a5:	0f b6 54 24 08       	movzbl 0x8(%esp),%edx
c00269aa:	c0 ea 04             	shr    $0x4,%dl
c00269ad:	0f b6 d2             	movzbl %dl,%edx
c00269b0:	8d 34 92             	lea    (%edx,%edx,4),%esi
c00269b3:	8b 54 24 08          	mov    0x8(%esp),%edx
c00269b7:	83 e2 0f             	and    $0xf,%edx
c00269ba:	8d 14 72             	lea    (%edx,%esi,2),%edx
    time += min * 60;
c00269bd:	6b d2 3c             	imul   $0x3c,%edx,%edx
    time += sec;
c00269c0:	01 d1                	add    %edx,%ecx
c00269c2:	01 cb                	add    %ecx,%ebx
    return (x & 0x0f) + ((x >> 4) * 10);
c00269c4:	0f b6 14 24          	movzbl (%esp),%edx
c00269c8:	c0 ea 04             	shr    $0x4,%dl
c00269cb:	0f b6 d2             	movzbl %dl,%edx
c00269ce:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c00269d1:	8b 14 24             	mov    (%esp),%edx
c00269d4:	83 e2 0f             	and    $0xf,%edx
    time += (mday - 1) * 24 * 60 * 60;
c00269d7:	8d 54 4a ff          	lea    -0x1(%edx,%ecx,2),%edx
c00269db:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
    time += sec;
c00269e1:	01 d3                	add    %edx,%ebx
c00269e3:	01 d8                	add    %ebx,%eax
}
c00269e5:	83 c4 10             	add    $0x10,%esp
c00269e8:	5b                   	pop    %ebx
c00269e9:	5e                   	pop    %esi
c00269ea:	5f                   	pop    %edi
c00269eb:	5d                   	pop    %ebp
c00269ec:	c3                   	ret    

c00269ed <shutdown_configure>:
}

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure(enum shutdown_type type) {
c00269ed:	e8 a9 6e 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c00269f2:	05 0e 3b 01 00       	add    $0x13b0e,%eax
    how = type;
c00269f7:	8b 54 24 04          	mov    0x4(%esp),%edx
c00269fb:	89 90 14 1b 00 00    	mov    %edx,0x1b14(%eax)
}
c0026a01:	c3                   	ret    

c0026a02 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot(void) {
c0026a02:	57                   	push   %edi
c0026a03:	56                   	push   %esi
c0026a04:	53                   	push   %ebx
c0026a05:	e8 8d 6e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026a0a:	81 c3 f6 3a 01 00    	add    $0x13af6,%ebx
    printf("Rebooting...\n");
c0026a10:	83 ec 0c             	sub    $0xc,%esp
c0026a13:	8d 83 0d 5b ff ff    	lea    -0xa4f3(%ebx),%eax
c0026a19:	50                   	push   %eax
c0026a1a:	e8 e6 43 00 00       	call   c002ae05 <puts>
c0026a1f:	83 c4 10             	add    $0x10,%esp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026a22:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
c0026a27:	eb 1f                	jmp    c0026a48 <shutdown_reboot+0x46>
            if ((inb(CONTROL_REG) & 0x02) == 0)
                break;
            timer_udelay(2);
        }

        timer_udelay(50);
c0026a29:	83 ec 08             	sub    $0x8,%esp
c0026a2c:	6a 00                	push   $0x0
c0026a2e:	6a 32                	push   $0x32
c0026a30:	e8 2d db ff ff       	call   c0024562 <timer_udelay>
c0026a35:	89 f8                	mov    %edi,%eax
c0026a37:	e6 64                	out    %al,$0x64

        /* Pulse bit 0 of the output port P2 of the keyboard controller.
         * This will reset the CPU. */
        outb(CONTROL_REG, 0xfe);
        timer_udelay(50);
c0026a39:	83 c4 08             	add    $0x8,%esp
c0026a3c:	6a 00                	push   $0x0
c0026a3e:	6a 32                	push   $0x32
c0026a40:	e8 1d db ff ff       	call   c0024562 <timer_udelay>
    for (;;) {
c0026a45:	83 c4 10             	add    $0x10,%esp
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026a48:	e4 64                	in     $0x64,%al
            if ((inb(CONTROL_REG) & 0x02) == 0)
c0026a4a:	a8 02                	test   $0x2,%al
c0026a4c:	74 db                	je     c0026a29 <shutdown_reboot+0x27>
            timer_udelay(2);
c0026a4e:	83 ec 08             	sub    $0x8,%esp
c0026a51:	6a 00                	push   $0x0
c0026a53:	6a 02                	push   $0x2
c0026a55:	e8 08 db ff ff       	call   c0024562 <timer_udelay>
c0026a5a:	83 c4 10             	add    $0x10,%esp
c0026a5d:	be ff ff 00 00       	mov    $0xffff,%esi
c0026a62:	e4 64                	in     $0x64,%al
            if ((inb(CONTROL_REG) & 0x02) == 0)
c0026a64:	a8 02                	test   $0x2,%al
c0026a66:	74 c1                	je     c0026a29 <shutdown_reboot+0x27>
            timer_udelay(2);
c0026a68:	83 ec 08             	sub    $0x8,%esp
c0026a6b:	6a 00                	push   $0x0
c0026a6d:	6a 02                	push   $0x2
c0026a6f:	e8 ee da ff ff       	call   c0024562 <timer_udelay>
        for (i = 0; i < 0x10000; i++) {
c0026a74:	83 c4 10             	add    $0x10,%esp
c0026a77:	83 ee 01             	sub    $0x1,%esi
c0026a7a:	75 e6                	jne    c0026a62 <shutdown_reboot+0x60>
c0026a7c:	eb ab                	jmp    c0026a29 <shutdown_reboot+0x27>

c0026a7e <shutdown_power_off>:
}

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off(void) {
c0026a7e:	53                   	push   %ebx
c0026a7f:	83 ec 18             	sub    $0x18,%esp
c0026a82:	e8 10 6e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026a87:	81 c3 79 3a 01 00    	add    $0x13a79,%ebx
    const char s[] = "Shutdown";
c0026a8d:	c7 44 24 07 53 68 75 	movl   $0x74756853,0x7(%esp)
c0026a94:	74 
c0026a95:	c7 44 24 0b 64 6f 77 	movl   $0x6e776f64,0xb(%esp)
c0026a9c:	6e 
c0026a9d:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
}

/* Print statistics about Pintos execution. */
static void
print_stats(void) {
    timer_print_stats();
c0026aa2:	e8 ed da ff ff       	call   c0024594 <timer_print_stats>
    thread_print_stats();
c0026aa7:	e8 01 a2 ff ff       	call   c0020cad <thread_print_stats>
#ifdef FILESYS
    block_print_stats ();
#endif
    console_print_stats();
c0026aac:	e8 e5 42 00 00       	call   c002ad96 <console_print_stats>
    kbd_print_stats();
c0026ab1:	e8 5c dd ff ff       	call   c0024812 <kbd_print_stats>
    printf("Powering off...\n");
c0026ab6:	83 ec 0c             	sub    $0xc,%esp
c0026ab9:	8d 83 1a 5b ff ff    	lea    -0xa4e6(%ebx),%eax
c0026abf:	50                   	push   %eax
c0026ac0:	e8 40 43 00 00       	call   c002ae05 <puts>
    serial_flush();
c0026ac5:	e8 f6 e2 ff ff       	call   c0024dc0 <serial_flush>
    asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026aca:	b8 00 20 00 00       	mov    $0x2000,%eax
c0026acf:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c0026ad4:	66 ef                	out    %ax,(%dx)
    for (p = s; *p != '\0'; p++)
c0026ad6:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
c0026adb:	83 c4 10             	add    $0x10,%esp
c0026ade:	84 c0                	test   %al,%al
c0026ae0:	74 14                	je     c0026af6 <shutdown_power_off+0x78>
c0026ae2:	8d 4c 24 07          	lea    0x7(%esp),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ae6:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c0026aeb:	ee                   	out    %al,(%dx)
c0026aec:	83 c1 01             	add    $0x1,%ecx
c0026aef:	0f b6 01             	movzbl (%ecx),%eax
c0026af2:	84 c0                	test   %al,%al
c0026af4:	75 f5                	jne    c0026aeb <shutdown_power_off+0x6d>
c0026af6:	b8 31 00 00 00       	mov    $0x31,%eax
c0026afb:	ba 01 05 00 00       	mov    $0x501,%edx
c0026b00:	ee                   	out    %al,(%dx)
    asm volatile ("cli; hlt" : : : "memory");
c0026b01:	fa                   	cli    
c0026b02:	f4                   	hlt    
    printf("still running...\n");
c0026b03:	83 ec 0c             	sub    $0xc,%esp
c0026b06:	8d 83 2a 5b ff ff    	lea    -0xa4d6(%ebx),%eax
c0026b0c:	50                   	push   %eax
c0026b0d:	e8 f3 42 00 00       	call   c002ae05 <puts>
c0026b12:	83 c4 10             	add    $0x10,%esp
    for (;;);
c0026b15:	eb fe                	jmp    c0026b15 <shutdown_power_off+0x97>

c0026b17 <shutdown>:
shutdown(void) {
c0026b17:	83 ec 0c             	sub    $0xc,%esp
c0026b1a:	e8 7c 6d 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0026b1f:	05 e1 39 01 00       	add    $0x139e1,%eax
    switch (how) {
c0026b24:	8b 80 14 1b 00 00    	mov    0x1b14(%eax),%eax
c0026b2a:	83 f8 01             	cmp    $0x1,%eax
c0026b2d:	74 09                	je     c0026b38 <shutdown+0x21>
c0026b2f:	83 f8 02             	cmp    $0x2,%eax
c0026b32:	74 09                	je     c0026b3d <shutdown+0x26>
}
c0026b34:	83 c4 0c             	add    $0xc,%esp
c0026b37:	c3                   	ret    
            shutdown_power_off();
c0026b38:	e8 41 ff ff ff       	call   c0026a7e <shutdown_power_off>
            shutdown_reboot();
c0026b3d:	e8 c0 fe ff ff       	call   c0026a02 <shutdown_reboot>

c0026b42 <speaker_off>:
}

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off(void) {
c0026b42:	53                   	push   %ebx
c0026b43:	83 ec 08             	sub    $0x8,%esp
c0026b46:	e8 4c 6d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026b4b:	81 c3 b5 39 01 00    	add    $0x139b5,%ebx
    enum intr_level old_level = intr_disable();
c0026b51:	e8 cd af ff ff       	call   c0021b23 <intr_disable>
c0026b56:	89 c2                	mov    %eax,%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b58:	e4 61                	in     $0x61,%al
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b5a:	83 e0 fc             	and    $0xfffffffc,%eax
c0026b5d:	e6 61                	out    %al,$0x61
    outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
    intr_set_level(old_level);
c0026b5f:	83 ec 0c             	sub    $0xc,%esp
c0026b62:	52                   	push   %edx
c0026b63:	e8 c2 af ff ff       	call   c0021b2a <intr_set_level>
}
c0026b68:	83 c4 18             	add    $0x18,%esp
c0026b6b:	5b                   	pop    %ebx
c0026b6c:	c3                   	ret    

c0026b6d <speaker_on>:
speaker_on(int frequency) {
c0026b6d:	57                   	push   %edi
c0026b6e:	56                   	push   %esi
c0026b6f:	53                   	push   %ebx
c0026b70:	e8 22 6d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026b75:	81 c3 8b 39 01 00    	add    $0x1398b,%ebx
c0026b7b:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (frequency >= 20 && frequency <= 20000) {
c0026b7f:	8d 46 ec             	lea    -0x14(%esi),%eax
c0026b82:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c0026b87:	77 2a                	ja     c0026bb3 <speaker_on+0x46>
        enum intr_level old_level = intr_disable();
c0026b89:	e8 95 af ff ff       	call   c0021b23 <intr_disable>
c0026b8e:	89 c7                	mov    %eax,%edi
        pit_configure_channel(2, 3, frequency);
c0026b90:	83 ec 04             	sub    $0x4,%esp
c0026b93:	56                   	push   %esi
c0026b94:	6a 03                	push   $0x3
c0026b96:	6a 02                	push   $0x2
c0026b98:	e8 a9 d3 ff ff       	call   c0023f46 <pit_configure_channel>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b9d:	e4 61                	in     $0x61,%al
        outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026b9f:	83 c8 03             	or     $0x3,%eax
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ba2:	e6 61                	out    %al,$0x61
        intr_set_level(old_level);
c0026ba4:	89 3c 24             	mov    %edi,(%esp)
c0026ba7:	e8 7e af ff ff       	call   c0021b2a <intr_set_level>
c0026bac:	83 c4 10             	add    $0x10,%esp
}
c0026baf:	5b                   	pop    %ebx
c0026bb0:	5e                   	pop    %esi
c0026bb1:	5f                   	pop    %edi
c0026bb2:	c3                   	ret    
        speaker_off();
c0026bb3:	e8 8a ff ff ff       	call   c0026b42 <speaker_off>
}
c0026bb8:	eb f5                	jmp    c0026baf <speaker_on+0x42>

c0026bba <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep(void) {
c0026bba:	53                   	push   %ebx
c0026bbb:	83 ec 08             	sub    $0x8,%esp
c0026bbe:	e8 d4 6c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026bc3:	81 c3 3d 39 01 00    	add    $0x1393d,%ebx

       We can't just enable interrupts while we sleep.  For one
       thing, we get called (indirectly) from printf, which should
       always work, even during boot before we're ready to enable
       interrupts. */
    if (intr_get_level() == INTR_ON) {
c0026bc9:	e8 03 af ff ff       	call   c0021ad1 <intr_get_level>
c0026bce:	83 f8 01             	cmp    $0x1,%eax
c0026bd1:	74 05                	je     c0026bd8 <speaker_beep+0x1e>
        speaker_on(440);
        timer_msleep(250);
        speaker_off();
    }
}
c0026bd3:	83 c4 08             	add    $0x8,%esp
c0026bd6:	5b                   	pop    %ebx
c0026bd7:	c3                   	ret    
        speaker_on(440);
c0026bd8:	83 ec 0c             	sub    $0xc,%esp
c0026bdb:	68 b8 01 00 00       	push   $0x1b8
c0026be0:	e8 88 ff ff ff       	call   c0026b6d <speaker_on>
        timer_msleep(250);
c0026be5:	83 c4 08             	add    $0x8,%esp
c0026be8:	6a 00                	push   $0x0
c0026bea:	68 fa 00 00 00       	push   $0xfa
c0026bef:	e8 0a d9 ff ff       	call   c00244fe <timer_msleep>
        speaker_off();
c0026bf4:	e8 49 ff ff ff       	call   c0026b42 <speaker_off>
c0026bf9:	83 c4 10             	add    $0x10,%esp
}
c0026bfc:	eb d5                	jmp    c0026bd3 <speaker_beep+0x19>

c0026bfe <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026bfe:	55                   	push   %ebp
c0026bff:	89 e5                	mov    %esp,%ebp
c0026c01:	57                   	push   %edi
c0026c02:	56                   	push   %esi
c0026c03:	53                   	push   %ebx
c0026c04:	83 ec 14             	sub    $0x14,%esp
c0026c07:	e8 8b 6c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026c0c:	81 c3 f4 38 01 00    	add    $0x138f4,%ebx
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026c12:	ff 75 04             	pushl  0x4(%ebp)
c0026c15:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c0026c1b:	50                   	push   %eax
c0026c1c:	e8 67 06 00 00       	call   c0027288 <printf>
  for (frame = __builtin_frame_address (1);
c0026c21:	8b 75 00             	mov    0x0(%ebp),%esi
c0026c24:	83 c4 10             	add    $0x10,%esp
c0026c27:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026c2d:	76 29                	jbe    c0026c58 <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026c2f:	83 3e 00             	cmpl   $0x0,(%esi)
c0026c32:	74 24                	je     c0026c58 <debug_backtrace+0x5a>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026c34:	8d bb 46 5b ff ff    	lea    -0xa4ba(%ebx),%edi
c0026c3a:	83 ec 08             	sub    $0x8,%esp
c0026c3d:	ff 76 04             	pushl  0x4(%esi)
c0026c40:	57                   	push   %edi
c0026c41:	e8 42 06 00 00       	call   c0027288 <printf>
       frame = frame[0]) 
c0026c46:	8b 36                	mov    (%esi),%esi
  for (frame = __builtin_frame_address (1);
c0026c48:	83 c4 10             	add    $0x10,%esp
c0026c4b:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026c51:	76 05                	jbe    c0026c58 <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026c53:	83 3e 00             	cmpl   $0x0,(%esi)
c0026c56:	75 e2                	jne    c0026c3a <debug_backtrace+0x3c>
  printf (".\n");
c0026c58:	83 ec 0c             	sub    $0xc,%esp
c0026c5b:	8d 83 e3 56 ff ff    	lea    -0xa91d(%ebx),%eax
c0026c61:	50                   	push   %eax
c0026c62:	e8 9e 41 00 00       	call   c002ae05 <puts>

  if (!explained) 
c0026c67:	83 c4 10             	add    $0x10,%esp
c0026c6a:	80 bb 18 1b 00 00 00 	cmpb   $0x0,0x1b18(%ebx)
c0026c71:	74 08                	je     c0026c7b <debug_backtrace+0x7d>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026c73:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0026c76:	5b                   	pop    %ebx
c0026c77:	5e                   	pop    %esi
c0026c78:	5f                   	pop    %edi
c0026c79:	5d                   	pop    %ebp
c0026c7a:	c3                   	ret    
      explained = true;
c0026c7b:	c6 83 18 1b 00 00 01 	movb   $0x1,0x1b18(%ebx)
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026c82:	83 ec 0c             	sub    $0xc,%esp
c0026c85:	8d 83 4c 5b ff ff    	lea    -0xa4b4(%ebx),%eax
c0026c8b:	50                   	push   %eax
c0026c8c:	e8 74 41 00 00       	call   c002ae05 <puts>
c0026c91:	83 c4 10             	add    $0x10,%esp
}
c0026c94:	eb dd                	jmp    c0026c73 <debug_backtrace+0x75>

c0026c96 <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026c96:	55                   	push   %ebp
c0026c97:	57                   	push   %edi
c0026c98:	56                   	push   %esi
c0026c99:	53                   	push   %ebx
c0026c9a:	83 ec 04             	sub    $0x4,%esp
c0026c9d:	e8 01 6c 00 00       	call   c002d8a3 <__x86.get_pc_thunk.di>
c0026ca2:	81 c7 5e 38 01 00    	add    $0x1385e,%edi
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026ca8:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c0026cad:	88 84 38 40 1b 00 00 	mov    %al,0x1b40(%eax,%edi,1)
  for (i = 0; i < 256; i++) 
c0026cb4:	83 c0 01             	add    $0x1,%eax
c0026cb7:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026cbc:	75 ef                	jne    c0026cad <random_init+0x17>
c0026cbe:	8d 8f 40 1b 00 00    	lea    0x1b40(%edi),%ecx
  for (i = j = 0; i < 256; i++) 
c0026cc4:	bb 00 00 00 00       	mov    $0x0,%ebx
c0026cc9:	ba 00 00 00 00       	mov    $0x0,%edx
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
c0026cce:	89 cd                	mov    %ecx,%ebp
c0026cd0:	88 5c 24 03          	mov    %bl,0x3(%esp)
      j += s[i] + seedp[i % sizeof seed];
c0026cd4:	89 d0                	mov    %edx,%eax
c0026cd6:	83 e0 03             	and    $0x3,%eax
c0026cd9:	0f b6 31             	movzbl (%ecx),%esi
c0026cdc:	89 f3                	mov    %esi,%ebx
c0026cde:	02 5c 04 18          	add    0x18(%esp,%eax,1),%bl
c0026ce2:	00 5c 24 03          	add    %bl,0x3(%esp)
c0026ce6:	0f b6 44 24 03       	movzbl 0x3(%esp),%eax
      swap_byte (s + i, s + j);
c0026ceb:	0f b6 c0             	movzbl %al,%eax
c0026cee:	01 e8                	add    %ebp,%eax
  *a = *b;
c0026cf0:	0f b6 18             	movzbl (%eax),%ebx
c0026cf3:	88 19                	mov    %bl,(%ecx)
  *b = t;
c0026cf5:	89 f3                	mov    %esi,%ebx
c0026cf7:	88 18                	mov    %bl,(%eax)
  for (i = j = 0; i < 256; i++) 
c0026cf9:	83 c2 01             	add    $0x1,%edx
c0026cfc:	83 c1 01             	add    $0x1,%ecx
c0026cff:	81 fa 00 01 00 00    	cmp    $0x100,%edx
c0026d05:	75 cd                	jne    c0026cd4 <random_init+0x3e>
    }

  s_i = s_j = 0;
c0026d07:	c6 87 21 1b 00 00 00 	movb   $0x0,0x1b21(%edi)
c0026d0e:	c6 87 22 1b 00 00 00 	movb   $0x0,0x1b22(%edi)
  inited = true;
c0026d15:	c6 87 20 1b 00 00 01 	movb   $0x1,0x1b20(%edi)
}
c0026d1c:	83 c4 04             	add    $0x4,%esp
c0026d1f:	5b                   	pop    %ebx
c0026d20:	5e                   	pop    %esi
c0026d21:	5f                   	pop    %edi
c0026d22:	5d                   	pop    %ebp
c0026d23:	c3                   	ret    

c0026d24 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026d24:	55                   	push   %ebp
c0026d25:	57                   	push   %edi
c0026d26:	56                   	push   %esi
c0026d27:	53                   	push   %ebx
c0026d28:	83 ec 14             	sub    $0x14,%esp
c0026d2b:	e8 6b 6b 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0026d30:	05 d0 37 01 00       	add    $0x137d0,%eax
c0026d35:	89 44 24 08          	mov    %eax,0x8(%esp)
c0026d39:	8b 74 24 28          	mov    0x28(%esp),%esi
c0026d3d:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  uint8_t *buf;

  if (!inited)
c0026d41:	80 b8 20 1b 00 00 00 	cmpb   $0x0,0x1b20(%eax)
c0026d48:	0f 84 ac 00 00 00    	je     c0026dfa <random_bytes+0xd6>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c0026d4e:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0026d51:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0026d55:	85 db                	test   %ebx,%ebx
c0026d57:	0f 84 95 00 00 00    	je     c0026df2 <random_bytes+0xce>
c0026d5d:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0026d61:	0f b6 87 21 1b 00 00 	movzbl 0x1b21(%edi),%eax
c0026d68:	88 44 24 11          	mov    %al,0x11(%esp)
c0026d6c:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c0026d6f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0026d73:	89 f3                	mov    %esi,%ebx
c0026d75:	0f b6 87 22 1b 00 00 	movzbl 0x1b22(%edi),%eax
c0026d7c:	83 c0 01             	add    $0x1,%eax
c0026d7f:	88 44 24 13          	mov    %al,0x13(%esp)
c0026d83:	89 f2                	mov    %esi,%edx
c0026d85:	29 d0                	sub    %edx,%eax
c0026d87:	88 44 24 12          	mov    %al,0x12(%esp)
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c0026d8b:	8d 87 40 1b 00 00    	lea    0x1b40(%edi),%eax
      s_i++;
c0026d91:	0f b6 7c 24 12       	movzbl 0x12(%esp),%edi
c0026d96:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
      s_j += s[s_i];
c0026d99:	0f b6 d2             	movzbl %dl,%edx
c0026d9c:	0f b6 4c 24 11       	movzbl 0x11(%esp),%ecx
c0026da1:	02 0c 10             	add    (%eax,%edx,1),%cl
c0026da4:	88 4c 24 11          	mov    %cl,0x11(%esp)
      swap_byte (s + s_i, s + s_j);
c0026da8:	0f b6 f1             	movzbl %cl,%esi
c0026dab:	89 34 24             	mov    %esi,(%esp)
c0026dae:	01 c6                	add    %eax,%esi
c0026db0:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  uint8_t t = *a;
c0026db3:	0f b6 2f             	movzbl (%edi),%ebp
  *a = *b;
c0026db6:	0f b6 0e             	movzbl (%esi),%ecx
c0026db9:	88 0f                	mov    %cl,(%edi)
  *b = t;
c0026dbb:	89 e9                	mov    %ebp,%ecx
c0026dbd:	88 0e                	mov    %cl,(%esi)

      s_k = s[s_i] + s[s_j];
c0026dbf:	02 0c 10             	add    (%eax,%edx,1),%cl
      *buf = s[s_k];
c0026dc2:	0f b6 d1             	movzbl %cl,%edx
c0026dc5:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
c0026dc9:	88 13                	mov    %dl,(%ebx)
  for (buf = buf_; size-- > 0; buf++)
c0026dcb:	83 c3 01             	add    $0x1,%ebx
c0026dce:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
c0026dd2:	75 bd                	jne    c0026d91 <random_bytes+0x6d>
c0026dd4:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
c0026dd9:	02 44 24 0c          	add    0xc(%esp),%al
c0026ddd:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026de1:	88 83 22 1b 00 00    	mov    %al,0x1b22(%ebx)
c0026de7:	0f b6 44 24 11       	movzbl 0x11(%esp),%eax
c0026dec:	88 83 21 1b 00 00    	mov    %al,0x1b21(%ebx)
    }
}
c0026df2:	83 c4 14             	add    $0x14,%esp
c0026df5:	5b                   	pop    %ebx
c0026df6:	5e                   	pop    %esi
c0026df7:	5f                   	pop    %edi
c0026df8:	5d                   	pop    %ebp
c0026df9:	c3                   	ret    
    random_init (0);
c0026dfa:	6a 00                	push   $0x0
c0026dfc:	e8 95 fe ff ff       	call   c0026c96 <random_init>
c0026e01:	83 c4 04             	add    $0x4,%esp
c0026e04:	e9 45 ff ff ff       	jmp    c0026d4e <random_bytes+0x2a>

c0026e09 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0026e09:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0026e0c:	6a 04                	push   $0x4
c0026e0e:	8d 44 24 10          	lea    0x10(%esp),%eax
c0026e12:	50                   	push   %eax
c0026e13:	e8 0c ff ff ff       	call   c0026d24 <random_bytes>
  return ul;
}
c0026e18:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026e1c:	83 c4 18             	add    $0x18,%esp
c0026e1f:	c3                   	ret    

c0026e20 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0026e20:	53                   	push   %ebx
c0026e21:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026e25:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c0026e29:	8b 50 04             	mov    0x4(%eax),%edx
c0026e2c:	8d 4a 01             	lea    0x1(%edx),%ecx
c0026e2f:	89 48 04             	mov    %ecx,0x4(%eax)
c0026e32:	3b 50 08             	cmp    0x8(%eax),%edx
c0026e35:	7d 09                	jge    c0026e40 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c0026e37:	8b 10                	mov    (%eax),%edx
c0026e39:	8d 4a 01             	lea    0x1(%edx),%ecx
c0026e3c:	89 08                	mov    %ecx,(%eax)
c0026e3e:	88 1a                	mov    %bl,(%edx)
}
c0026e40:	5b                   	pop    %ebx
c0026e41:	c3                   	ret    

c0026e42 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0026e42:	55                   	push   %ebp
c0026e43:	57                   	push   %edi
c0026e44:	56                   	push   %esi
c0026e45:	53                   	push   %ebx
c0026e46:	83 ec 0c             	sub    $0xc,%esp
c0026e49:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c0026e4d:	85 d2                	test   %edx,%edx
c0026e4f:	74 1a                	je     c0026e6b <output_dup+0x29>
c0026e51:	8d 5a ff             	lea    -0x1(%edx),%ebx
c0026e54:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c0026e56:	0f be f0             	movsbl %al,%esi
c0026e59:	83 ec 08             	sub    $0x8,%esp
c0026e5c:	57                   	push   %edi
c0026e5d:	56                   	push   %esi
c0026e5e:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c0026e60:	83 eb 01             	sub    $0x1,%ebx
c0026e63:	83 c4 10             	add    $0x10,%esp
c0026e66:	83 fb ff             	cmp    $0xffffffff,%ebx
c0026e69:	75 ee                	jne    c0026e59 <output_dup+0x17>
}
c0026e6b:	83 c4 0c             	add    $0xc,%esp
c0026e6e:	5b                   	pop    %ebx
c0026e6f:	5e                   	pop    %esi
c0026e70:	5f                   	pop    %edi
c0026e71:	5d                   	pop    %ebp
c0026e72:	c3                   	ret    

c0026e73 <format_integer>:
{
c0026e73:	55                   	push   %ebp
c0026e74:	57                   	push   %edi
c0026e75:	56                   	push   %esi
c0026e76:	53                   	push   %ebx
c0026e77:	83 ec 7c             	sub    $0x7c,%esp
c0026e7a:	e8 18 6a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0026e7f:	81 c3 81 36 01 00    	add    $0x13681,%ebx
c0026e85:	89 c6                	mov    %eax,%esi
c0026e87:	89 d7                	mov    %edx,%edi
c0026e89:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  sign = 0;
c0026e90:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026e97:	00 
  if (is_signed) 
c0026e98:	84 c9                	test   %cl,%cl
c0026e9a:	74 20                	je     c0026ebc <format_integer+0x49>
      if (c->flags & PLUS)
c0026e9c:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0026ea3:	8b 11                	mov    (%ecx),%edx
c0026ea5:	f6 c2 02             	test   $0x2,%dl
c0026ea8:	0f 84 88 00 00 00    	je     c0026f36 <format_integer+0xc3>
        sign = negative ? '-' : '+';
c0026eae:	3c 01                	cmp    $0x1,%al
c0026eb0:	19 c0                	sbb    %eax,%eax
c0026eb2:	83 e0 fe             	and    $0xfffffffe,%eax
c0026eb5:	83 c0 2d             	add    $0x2d,%eax
c0026eb8:	89 44 24 20          	mov    %eax,0x20(%esp)
  x = (c->flags & POUND) && value ? b->x : 0;
c0026ebc:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0026ec3:	8b 00                	mov    (%eax),%eax
c0026ec5:	89 44 24 28          	mov    %eax,0x28(%esp)
c0026ec9:	83 e0 08             	and    $0x8,%eax
c0026ecc:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0026ed0:	89 f1                	mov    %esi,%ecx
c0026ed2:	09 f9                	or     %edi,%ecx
c0026ed4:	74 08                	je     c0026ede <format_integer+0x6b>
c0026ed6:	85 c0                	test   %eax,%eax
c0026ed8:	0f 85 82 00 00 00    	jne    c0026f60 <format_integer+0xed>
  while (value > 0) 
c0026ede:	89 fa                	mov    %edi,%edx
c0026ee0:	09 f2                	or     %esi,%edx
c0026ee2:	0f 84 e2 02 00 00    	je     c00271ca <format_integer+0x357>
  x = (c->flags & POUND) && value ? b->x : 0;
c0026ee8:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0026eef:	00 
      *cp++ = b->digits[value % b->base];
c0026ef0:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026ef7:	8b 40 04             	mov    0x4(%eax),%eax
c0026efa:	89 44 24 18          	mov    %eax,0x18(%esp)
c0026efe:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026f05:	8b 00                	mov    (%eax),%eax
c0026f07:	89 44 24 08          	mov    %eax,0x8(%esp)
c0026f0b:	89 c1                	mov    %eax,%ecx
c0026f0d:	c1 f9 1f             	sar    $0x1f,%ecx
c0026f10:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0026f14:	b9 00 00 00 00       	mov    $0x0,%ecx
c0026f19:	8d 6c 24 30          	lea    0x30(%esp),%ebp
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0026f1d:	8b 44 24 28          	mov    0x28(%esp),%eax
c0026f21:	c1 e8 05             	shr    $0x5,%eax
c0026f24:	83 e0 01             	and    $0x1,%eax
c0026f27:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0026f2b:	89 6c 24 14          	mov    %ebp,0x14(%esp)
c0026f2f:	89 cd                	mov    %ecx,%ebp
c0026f31:	e9 90 00 00 00       	jmp    c0026fc6 <format_integer+0x153>
      else if (c->flags & SPACE)
c0026f36:	f6 c2 04             	test   $0x4,%dl
c0026f39:	74 13                	je     c0026f4e <format_integer+0xdb>
        sign = negative ? '-' : ' ';
c0026f3b:	3c 01                	cmp    $0x1,%al
c0026f3d:	19 c0                	sbb    %eax,%eax
c0026f3f:	83 e0 f3             	and    $0xfffffff3,%eax
c0026f42:	83 c0 2d             	add    $0x2d,%eax
c0026f45:	89 44 24 20          	mov    %eax,0x20(%esp)
c0026f49:	e9 6e ff ff ff       	jmp    c0026ebc <format_integer+0x49>
        sign = '-';
c0026f4e:	3c 01                	cmp    $0x1,%al
c0026f50:	19 c0                	sbb    %eax,%eax
c0026f52:	f7 d0                	not    %eax
c0026f54:	83 e0 2d             	and    $0x2d,%eax
c0026f57:	89 44 24 20          	mov    %eax,0x20(%esp)
c0026f5b:	e9 5c ff ff ff       	jmp    c0026ebc <format_integer+0x49>
  x = (c->flags & POUND) && value ? b->x : 0;
c0026f60:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026f67:	8b 40 08             	mov    0x8(%eax),%eax
c0026f6a:	89 44 24 24          	mov    %eax,0x24(%esp)
  while (value > 0) 
c0026f6e:	eb 80                	jmp    c0026ef0 <format_integer+0x7d>
c0026f70:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026f74:	89 44 24 10          	mov    %eax,0x10(%esp)
      *cp++ = b->digits[value % b->base];
c0026f78:	8b 44 24 10          	mov    0x10(%esp),%eax
c0026f7c:	8d 50 01             	lea    0x1(%eax),%edx
c0026f7f:	89 54 24 14          	mov    %edx,0x14(%esp)
c0026f83:	ff 74 24 0c          	pushl  0xc(%esp)
c0026f87:	ff 74 24 0c          	pushl  0xc(%esp)
c0026f8b:	57                   	push   %edi
c0026f8c:	56                   	push   %esi
c0026f8d:	e8 7f 19 00 00       	call   c0028911 <__umoddi3>
c0026f92:	83 c4 10             	add    $0x10,%esp
c0026f95:	8b 54 24 18          	mov    0x18(%esp),%edx
c0026f99:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
c0026f9d:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0026fa1:	88 01                	mov    %al,(%ecx)
      value /= b->base;
c0026fa3:	ff 74 24 0c          	pushl  0xc(%esp)
c0026fa7:	ff 74 24 0c          	pushl  0xc(%esp)
c0026fab:	57                   	push   %edi
c0026fac:	56                   	push   %esi
c0026fad:	e8 43 19 00 00       	call   c00288f5 <__udivdi3>
c0026fb2:	83 c4 10             	add    $0x10,%esp
      digit_cnt++;
c0026fb5:	83 c5 01             	add    $0x1,%ebp
  while (value > 0) 
c0026fb8:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0026fbc:	1b 7c 24 0c          	sbb    0xc(%esp),%edi
c0026fc0:	72 34                	jb     c0026ff6 <format_integer+0x183>
      value /= b->base;
c0026fc2:	89 c6                	mov    %eax,%esi
c0026fc4:	89 d7                	mov    %edx,%edi
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0026fc6:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0026fcb:	74 a3                	je     c0026f70 <format_integer+0xfd>
c0026fcd:	85 ed                	test   %ebp,%ebp
c0026fcf:	7e 9f                	jle    c0026f70 <format_integer+0xfd>
c0026fd1:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c0026fd8:	89 e8                	mov    %ebp,%eax
c0026fda:	99                   	cltd   
c0026fdb:	f7 79 0c             	idivl  0xc(%ecx)
c0026fde:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026fe2:	89 44 24 10          	mov    %eax,0x10(%esp)
c0026fe6:	85 d2                	test   %edx,%edx
c0026fe8:	75 8e                	jne    c0026f78 <format_integer+0x105>
        *cp++ = ',';
c0026fea:	8d 48 01             	lea    0x1(%eax),%ecx
c0026fed:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0026ff1:	c6 00 2c             	movb   $0x2c,(%eax)
c0026ff4:	eb 82                	jmp    c0026f78 <format_integer+0x105>
c0026ff6:	8b 6c 24 14          	mov    0x14(%esp),%ebp
  precision = c->precision < 0 ? 1 : c->precision;
c0026ffa:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027001:	8b 50 08             	mov    0x8(%eax),%edx
c0027004:	85 d2                	test   %edx,%edx
c0027006:	b8 01 00 00 00       	mov    $0x1,%eax
c002700b:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c002700e:	8d 44 24 30          	lea    0x30(%esp),%eax
c0027012:	89 ef                	mov    %ebp,%edi
c0027014:	29 c7                	sub    %eax,%edi
c0027016:	39 fa                	cmp    %edi,%edx
c0027018:	7e 21                	jle    c002703b <format_integer+0x1c8>
c002701a:	8d 44 24 6f          	lea    0x6f(%esp),%eax
c002701e:	39 c5                	cmp    %eax,%ebp
c0027020:	73 19                	jae    c002703b <format_integer+0x1c8>
c0027022:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c0027026:	89 c3                	mov    %eax,%ebx
    *cp++ = '0';
c0027028:	83 c5 01             	add    $0x1,%ebp
c002702b:	c6 45 ff 30          	movb   $0x30,-0x1(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c002702f:	89 e8                	mov    %ebp,%eax
c0027031:	29 c8                	sub    %ecx,%eax
c0027033:	39 d0                	cmp    %edx,%eax
c0027035:	7d 04                	jge    c002703b <format_integer+0x1c8>
c0027037:	39 dd                	cmp    %ebx,%ebp
c0027039:	72 ed                	jb     c0027028 <format_integer+0x1b5>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c002703b:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0027040:	74 10                	je     c0027052 <format_integer+0x1df>
c0027042:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0027049:	83 38 08             	cmpl   $0x8,(%eax)
c002704c:	0f 84 eb 00 00 00    	je     c002713d <format_integer+0x2ca>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0027052:	8d 74 24 30          	lea    0x30(%esp),%esi
c0027056:	29 ee                	sub    %ebp,%esi
c0027058:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002705f:	03 70 04             	add    0x4(%eax),%esi
c0027062:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0027066:	85 ff                	test   %edi,%edi
c0027068:	b8 02 00 00 00       	mov    $0x2,%eax
c002706d:	0f 44 c7             	cmove  %edi,%eax
c0027070:	29 c6                	sub    %eax,%esi
c0027072:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0027077:	0f 95 c0             	setne  %al
c002707a:	0f b6 c0             	movzbl %al,%eax
  if (pad_cnt < 0)
c002707d:	29 c6                	sub    %eax,%esi
c002707f:	b8 00 00 00 00       	mov    $0x0,%eax
c0027084:	0f 48 f0             	cmovs  %eax,%esi
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027087:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c002708c:	0f 84 c9 00 00 00    	je     c002715b <format_integer+0x2e8>
  if (sign)
c0027092:	8b 44 24 20          	mov    0x20(%esp),%eax
c0027096:	85 c0                	test   %eax,%eax
c0027098:	74 15                	je     c00270af <format_integer+0x23c>
    output (sign, aux);
c002709a:	83 ec 08             	sub    $0x8,%esp
c002709d:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c00270a4:	50                   	push   %eax
c00270a5:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c00270ac:	83 c4 10             	add    $0x10,%esp
  if (x) 
c00270af:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00270b3:	85 ff                	test   %edi,%edi
c00270b5:	74 2d                	je     c00270e4 <format_integer+0x271>
      output ('0', aux);
c00270b7:	83 ec 08             	sub    $0x8,%esp
c00270ba:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c00270c1:	6a 30                	push   $0x30
c00270c3:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c00270ca:	83 c4 08             	add    $0x8,%esp
c00270cd:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c00270d4:	89 f8                	mov    %edi,%eax
c00270d6:	0f be c0             	movsbl %al,%eax
c00270d9:	50                   	push   %eax
c00270da:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c00270e1:	83 c4 10             	add    $0x10,%esp
  if (c->flags & ZERO)
c00270e4:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00270eb:	f6 00 10             	testb  $0x10,(%eax)
c00270ee:	0f 85 8c 00 00 00    	jne    c0027180 <format_integer+0x30d>
  while (cp > buf)
c00270f4:	8d 44 24 30          	lea    0x30(%esp),%eax
c00270f8:	89 c7                	mov    %eax,%edi
c00270fa:	39 c5                	cmp    %eax,%ebp
c00270fc:	76 2b                	jbe    c0027129 <format_integer+0x2b6>
c00270fe:	89 74 24 08          	mov    %esi,0x8(%esp)
c0027102:	8b 9c 24 9c 00 00 00 	mov    0x9c(%esp),%ebx
c0027109:	8b b4 24 a0 00 00 00 	mov    0xa0(%esp),%esi
    output (*--cp, aux);
c0027110:	83 ed 01             	sub    $0x1,%ebp
c0027113:	83 ec 08             	sub    $0x8,%esp
c0027116:	56                   	push   %esi
c0027117:	0f be 45 00          	movsbl 0x0(%ebp),%eax
c002711b:	50                   	push   %eax
c002711c:	ff d3                	call   *%ebx
  while (cp > buf)
c002711e:	83 c4 10             	add    $0x10,%esp
c0027121:	39 fd                	cmp    %edi,%ebp
c0027123:	75 eb                	jne    c0027110 <format_integer+0x29d>
c0027125:	8b 74 24 08          	mov    0x8(%esp),%esi
  if (c->flags & MINUS)
c0027129:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027130:	f6 00 01             	testb  $0x1,(%eax)
c0027133:	75 70                	jne    c00271a5 <format_integer+0x332>
}
c0027135:	83 c4 7c             	add    $0x7c,%esp
c0027138:	5b                   	pop    %ebx
c0027139:	5e                   	pop    %esi
c002713a:	5f                   	pop    %edi
c002713b:	5d                   	pop    %ebp
c002713c:	c3                   	ret    
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c002713d:	8d 44 24 30          	lea    0x30(%esp),%eax
c0027141:	39 c5                	cmp    %eax,%ebp
c0027143:	74 0a                	je     c002714f <format_integer+0x2dc>
c0027145:	80 7d ff 30          	cmpb   $0x30,-0x1(%ebp)
c0027149:	0f 84 03 ff ff ff    	je     c0027052 <format_integer+0x1df>
    *cp++ = '0';
c002714f:	c6 45 00 30          	movb   $0x30,0x0(%ebp)
c0027153:	8d 6d 01             	lea    0x1(%ebp),%ebp
c0027156:	e9 f7 fe ff ff       	jmp    c0027052 <format_integer+0x1df>
    output_dup (' ', pad_cnt, output, aux);
c002715b:	83 ec 0c             	sub    $0xc,%esp
c002715e:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027165:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c002716c:	89 f2                	mov    %esi,%edx
c002716e:	b8 20 00 00 00       	mov    $0x20,%eax
c0027173:	e8 ca fc ff ff       	call   c0026e42 <output_dup>
c0027178:	83 c4 10             	add    $0x10,%esp
c002717b:	e9 12 ff ff ff       	jmp    c0027092 <format_integer+0x21f>
    output_dup ('0', pad_cnt, output, aux);
c0027180:	83 ec 0c             	sub    $0xc,%esp
c0027183:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c002718a:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027191:	89 f2                	mov    %esi,%edx
c0027193:	b8 30 00 00 00       	mov    $0x30,%eax
c0027198:	e8 a5 fc ff ff       	call   c0026e42 <output_dup>
c002719d:	83 c4 10             	add    $0x10,%esp
c00271a0:	e9 4f ff ff ff       	jmp    c00270f4 <format_integer+0x281>
    output_dup (' ', pad_cnt, output, aux);
c00271a5:	83 ec 0c             	sub    $0xc,%esp
c00271a8:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c00271af:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c00271b6:	89 f2                	mov    %esi,%edx
c00271b8:	b8 20 00 00 00       	mov    $0x20,%eax
c00271bd:	e8 80 fc ff ff       	call   c0026e42 <output_dup>
c00271c2:	83 c4 10             	add    $0x10,%esp
}
c00271c5:	e9 6b ff ff ff       	jmp    c0027135 <format_integer+0x2c2>
  precision = c->precision < 0 ? 1 : c->precision;
c00271ca:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00271d1:	8b 50 08             	mov    0x8(%eax),%edx
  cp = buf;
c00271d4:	8d 6c 24 30          	lea    0x30(%esp),%ebp
  x = (c->flags & POUND) && value ? b->x : 0;
c00271d8:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00271df:	00 
  precision = c->precision < 0 ? 1 : c->precision;
c00271e0:	85 d2                	test   %edx,%edx
c00271e2:	0f 89 26 fe ff ff    	jns    c002700e <format_integer+0x19b>
    *cp++ = '0';
c00271e8:	8d 6c 24 31          	lea    0x31(%esp),%ebp
c00271ec:	c6 44 24 30 30       	movb   $0x30,0x30(%esp)
c00271f1:	e9 45 fe ff ff       	jmp    c002703b <format_integer+0x1c8>

c00271f6 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c00271f6:	55                   	push   %ebp
c00271f7:	57                   	push   %edi
c00271f8:	56                   	push   %esi
c00271f9:	53                   	push   %ebx
c00271fa:	83 ec 1c             	sub    $0x1c,%esp
c00271fd:	89 c5                	mov    %eax,%ebp
c00271ff:	89 d6                	mov    %edx,%esi
c0027201:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0027205:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027209:	8b 51 04             	mov    0x4(%ecx),%edx
c002720c:	39 f2                	cmp    %esi,%edx
c002720e:	7e 3f                	jle    c002724f <format_string+0x59>
c0027210:	f6 01 01             	testb  $0x1,(%ecx)
c0027213:	74 1d                	je     c0027232 <format_string+0x3c>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0027215:	85 f6                	test   %esi,%esi
c0027217:	7f 3a                	jg     c0027253 <format_string+0x5d>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c0027219:	29 f2                	sub    %esi,%edx
c002721b:	83 ec 0c             	sub    $0xc,%esp
c002721e:	57                   	push   %edi
c002721f:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0027223:	b8 20 00 00 00       	mov    $0x20,%eax
c0027228:	e8 15 fc ff ff       	call   c0026e42 <output_dup>
c002722d:	83 c4 10             	add    $0x10,%esp
}
c0027230:	eb 4e                	jmp    c0027280 <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
c0027232:	29 f2                	sub    %esi,%edx
c0027234:	83 ec 0c             	sub    $0xc,%esp
c0027237:	57                   	push   %edi
c0027238:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c002723c:	b8 20 00 00 00       	mov    $0x20,%eax
c0027241:	e8 fc fb ff ff       	call   c0026e42 <output_dup>
  for (i = 0; i < length; i++)
c0027246:	83 c4 10             	add    $0x10,%esp
c0027249:	85 f6                	test   %esi,%esi
c002724b:	7f 06                	jg     c0027253 <format_string+0x5d>
c002724d:	eb 21                	jmp    c0027270 <format_string+0x7a>
c002724f:	85 f6                	test   %esi,%esi
c0027251:	7e 2d                	jle    c0027280 <format_string+0x8a>
{
c0027253:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c0027258:	83 ec 08             	sub    $0x8,%esp
c002725b:	57                   	push   %edi
c002725c:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c0027261:	50                   	push   %eax
c0027262:	ff 54 24 40          	call   *0x40(%esp)
  for (i = 0; i < length; i++)
c0027266:	83 c3 01             	add    $0x1,%ebx
c0027269:	83 c4 10             	add    $0x10,%esp
c002726c:	39 de                	cmp    %ebx,%esi
c002726e:	7f e8                	jg     c0027258 <format_string+0x62>
  if (c->width > length && (c->flags & MINUS) != 0)
c0027270:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027274:	8b 50 04             	mov    0x4(%eax),%edx
c0027277:	39 f2                	cmp    %esi,%edx
c0027279:	7e 05                	jle    c0027280 <format_string+0x8a>
c002727b:	f6 00 01             	testb  $0x1,(%eax)
c002727e:	75 99                	jne    c0027219 <format_string+0x23>
}
c0027280:	83 c4 1c             	add    $0x1c,%esp
c0027283:	5b                   	pop    %ebx
c0027284:	5e                   	pop    %esi
c0027285:	5f                   	pop    %edi
c0027286:	5d                   	pop    %ebp
c0027287:	c3                   	ret    

c0027288 <printf>:
{
c0027288:	53                   	push   %ebx
c0027289:	83 ec 08             	sub    $0x8,%esp
c002728c:	e8 06 66 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0027291:	81 c3 6f 32 01 00    	add    $0x1326f,%ebx
  va_start (args, format);
c0027297:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c002729b:	83 ec 08             	sub    $0x8,%esp
c002729e:	50                   	push   %eax
c002729f:	ff 74 24 1c          	pushl  0x1c(%esp)
c00272a3:	e8 1a 3b 00 00       	call   c002adc2 <vprintf>
}
c00272a8:	83 c4 18             	add    $0x18,%esp
c00272ab:	5b                   	pop    %ebx
c00272ac:	c3                   	ret    

c00272ad <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c00272ad:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c00272b0:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c00272b4:	ff 74 24 18          	pushl  0x18(%esp)
c00272b8:	ff 74 24 18          	pushl  0x18(%esp)
c00272bc:	50                   	push   %eax
c00272bd:	ff 74 24 1c          	pushl  0x1c(%esp)
c00272c1:	e8 04 00 00 00       	call   c00272ca <__vprintf>
  va_end (args);
}
c00272c6:	83 c4 1c             	add    $0x1c,%esp
c00272c9:	c3                   	ret    

c00272ca <__vprintf>:
{
c00272ca:	55                   	push   %ebp
c00272cb:	57                   	push   %edi
c00272cc:	56                   	push   %esi
c00272cd:	53                   	push   %ebx
c00272ce:	83 ec 4c             	sub    $0x4c,%esp
c00272d1:	e8 c9 65 00 00       	call   c002d89f <__x86.get_pc_thunk.bp>
c00272d6:	81 c5 2a 32 01 00    	add    $0x1322a,%ebp
c00272dc:	8b 74 24 60          	mov    0x60(%esp),%esi
c00272e0:	8b 7c 24 64          	mov    0x64(%esp),%edi
  for (; *format != '\0'; format++)
c00272e4:	0f b6 06             	movzbl (%esi),%eax
c00272e7:	84 c0                	test   %al,%al
c00272e9:	75 27                	jne    c0027312 <__vprintf+0x48>
}
c00272eb:	83 c4 4c             	add    $0x4c,%esp
c00272ee:	5b                   	pop    %ebx
c00272ef:	5e                   	pop    %esi
c00272f0:	5f                   	pop    %edi
c00272f1:	5d                   	pop    %ebp
c00272f2:	c3                   	ret    
          output (*format, aux);
c00272f3:	83 ec 08             	sub    $0x8,%esp
c00272f6:	ff 74 24 74          	pushl  0x74(%esp)
c00272fa:	0f be c0             	movsbl %al,%eax
c00272fd:	50                   	push   %eax
c00272fe:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c0027302:	83 c4 10             	add    $0x10,%esp
c0027305:	89 f3                	mov    %esi,%ebx
  for (; *format != '\0'; format++)
c0027307:	8d 73 01             	lea    0x1(%ebx),%esi
c002730a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002730e:	84 c0                	test   %al,%al
c0027310:	74 d9                	je     c00272eb <__vprintf+0x21>
      if (*format != '%') 
c0027312:	3c 25                	cmp    $0x25,%al
c0027314:	75 dd                	jne    c00272f3 <__vprintf+0x29>
      format++;
c0027316:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c0027319:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c002731d:	74 17                	je     c0027336 <__vprintf+0x6c>
  c->flags = 0;
c002731f:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c0027326:	00 
c0027327:	c6 04 24 00          	movb   $0x0,(%esp)
c002732b:	ba 00 00 00 00       	mov    $0x0,%edx
c0027330:	89 7c 24 64          	mov    %edi,0x64(%esp)
c0027334:	eb 1b                	jmp    c0027351 <.L80+0x9>
          output ('%', aux);
c0027336:	83 ec 08             	sub    $0x8,%esp
c0027339:	ff 74 24 74          	pushl  0x74(%esp)
c002733d:	6a 25                	push   $0x25
c002733f:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c0027343:	83 c4 10             	add    $0x10,%esp
c0027346:	eb bf                	jmp    c0027307 <__vprintf+0x3d>

c0027348 <.L80>:
          c->flags |= MINUS;
c0027348:	83 ca 01             	or     $0x1,%edx
          break;
c002734b:	c6 04 24 01          	movb   $0x1,(%esp)
      switch (*format++) 
c002734f:	89 f3                	mov    %esi,%ebx
c0027351:	8d 73 01             	lea    0x1(%ebx),%esi
c0027354:	0f b6 46 ff          	movzbl -0x1(%esi),%eax
c0027358:	8d 48 e0             	lea    -0x20(%eax),%ecx
c002735b:	80 f9 10             	cmp    $0x10,%cl
c002735e:	77 27                	ja     c0027387 <.L77>
c0027360:	0f b6 c9             	movzbl %cl,%ecx
c0027363:	89 ef                	mov    %ebp,%edi
c0027365:	03 bc 8d f0 38 ff ff 	add    -0xc710(%ebp,%ecx,4),%edi
c002736c:	ff e7                	jmp    *%edi

c002736e <.L81>:
          c->flags |= PLUS;
c002736e:	83 ca 02             	or     $0x2,%edx
          break;
c0027371:	eb d8                	jmp    c002734b <.L80+0x3>

c0027373 <.L84>:
          c->flags |= SPACE;
c0027373:	83 ca 04             	or     $0x4,%edx
          break;
c0027376:	eb d3                	jmp    c002734b <.L80+0x3>

c0027378 <.L83>:
          c->flags |= POUND;
c0027378:	83 ca 08             	or     $0x8,%edx
          break;
c002737b:	eb ce                	jmp    c002734b <.L80+0x3>

c002737d <.L78>:
          c->flags |= ZERO;
c002737d:	83 ca 10             	or     $0x10,%edx
          break;
c0027380:	eb c9                	jmp    c002734b <.L80+0x3>

c0027382 <.L82>:
          c->flags |= GROUP;
c0027382:	83 ca 20             	or     $0x20,%edx
          break;
c0027385:	eb c4                	jmp    c002734b <.L80+0x3>

c0027387 <.L77>:
c0027387:	8b 7c 24 64          	mov    0x64(%esp),%edi
c002738b:	80 3c 24 00          	cmpb   $0x0,(%esp)
c002738f:	74 0f                	je     c00273a0 <.L77+0x19>
    c->flags &= ~ZERO;
c0027391:	89 d1                	mov    %edx,%ecx
c0027393:	83 e1 ef             	and    $0xffffffef,%ecx
c0027396:	f6 c2 01             	test   $0x1,%dl
c0027399:	0f 45 d1             	cmovne %ecx,%edx
c002739c:	89 54 24 30          	mov    %edx,0x30(%esp)
  if (c->flags & PLUS)
c00273a0:	8b 54 24 30          	mov    0x30(%esp),%edx
c00273a4:	f6 c2 02             	test   $0x2,%dl
c00273a7:	74 07                	je     c00273b0 <.L77+0x29>
    c->flags &= ~SPACE;
c00273a9:	83 e2 fb             	and    $0xfffffffb,%edx
c00273ac:	89 54 24 30          	mov    %edx,0x30(%esp)
  c->width = 0;
c00273b0:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
c00273b7:	00 
  if (*format == '*')
c00273b8:	3c 2a                	cmp    $0x2a,%al
c00273ba:	74 47                	je     c0027403 <.L77+0x7c>
      for (; isdigit (*format); format++)
c00273bc:	0f be c0             	movsbl %al,%eax
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00273bf:	8d 48 d0             	lea    -0x30(%eax),%ecx
c00273c2:	ba 00 00 00 00       	mov    $0x0,%edx
c00273c7:	83 f9 09             	cmp    $0x9,%ecx
c00273ca:	77 21                	ja     c00273ed <.L77+0x66>
        c->width = c->width * 10 + *format - '0';
c00273cc:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00273cf:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
      for (; isdigit (*format); format++)
c00273d3:	83 c3 01             	add    $0x1,%ebx
c00273d6:	0f be 03             	movsbl (%ebx),%eax
c00273d9:	8d 48 d0             	lea    -0x30(%eax),%ecx
c00273dc:	83 f9 09             	cmp    $0x9,%ecx
c00273df:	76 eb                	jbe    c00273cc <.L77+0x45>
c00273e1:	89 54 24 34          	mov    %edx,0x34(%esp)
  if (c->width < 0) 
c00273e5:	8b 44 24 34          	mov    0x34(%esp),%eax
c00273e9:	85 c0                	test   %eax,%eax
c00273eb:	78 23                	js     c0027410 <.L77+0x89>
  c->precision = -1;
c00273ed:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c00273f4:	ff 
  if (*format == '.') 
c00273f5:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c00273f8:	74 23                	je     c002741d <.L77+0x96>
  if (c->precision >= 0)
c00273fa:	8b 44 24 38          	mov    0x38(%esp),%eax
c00273fe:	89 04 24             	mov    %eax,(%esp)
c0027401:	eb 69                	jmp    c002746c <.L77+0xe5>
      c->width = va_arg (*args, int);
c0027403:	8b 07                	mov    (%edi),%eax
c0027405:	89 44 24 34          	mov    %eax,0x34(%esp)
c0027409:	8d 7f 04             	lea    0x4(%edi),%edi
      switch (*format++) 
c002740c:	89 f3                	mov    %esi,%ebx
c002740e:	eb d5                	jmp    c00273e5 <.L77+0x5e>
      c->width = -c->width;
c0027410:	f7 d8                	neg    %eax
c0027412:	89 44 24 34          	mov    %eax,0x34(%esp)
      c->flags |= MINUS;
c0027416:	83 4c 24 30 01       	orl    $0x1,0x30(%esp)
c002741b:	eb d0                	jmp    c00273ed <.L77+0x66>
      if (*format == '*') 
c002741d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027421:	3c 2a                	cmp    $0x2a,%al
c0027423:	74 6f                	je     c0027494 <.L77+0x10d>
      format++;
c0027425:	83 c3 01             	add    $0x1,%ebx
          c->precision = 0;
c0027428:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
c002742f:	00 
          for (; isdigit (*format); format++)
c0027430:	0f be c0             	movsbl %al,%eax
c0027433:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027436:	83 fa 09             	cmp    $0x9,%edx
c0027439:	77 25                	ja     c0027460 <.L77+0xd9>
c002743b:	ba 00 00 00 00       	mov    $0x0,%edx
            c->precision = c->precision * 10 + *format - '0';
c0027440:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0027443:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
          for (; isdigit (*format); format++)
c0027447:	83 c3 01             	add    $0x1,%ebx
c002744a:	0f be 03             	movsbl (%ebx),%eax
c002744d:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0027450:	83 f9 09             	cmp    $0x9,%ecx
c0027453:	76 eb                	jbe    c0027440 <.L77+0xb9>
c0027455:	89 54 24 38          	mov    %edx,0x38(%esp)
      if (c->precision < 0) 
c0027459:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002745e:	78 42                	js     c00274a2 <.L77+0x11b>
  if (c->precision >= 0)
c0027460:	8b 44 24 38          	mov    0x38(%esp),%eax
c0027464:	89 04 24             	mov    %eax,(%esp)
    c->flags &= ~ZERO;
c0027467:	83 64 24 30 ef       	andl   $0xffffffef,0x30(%esp)
  c->type = INT;
c002746c:	c7 44 24 3c 03 00 00 	movl   $0x3,0x3c(%esp)
c0027473:	00 
  switch (*format++) 
c0027474:	8d 73 01             	lea    0x1(%ebx),%esi
c0027477:	0f b6 03             	movzbl (%ebx),%eax
c002747a:	8d 50 98             	lea    -0x68(%eax),%edx
c002747d:	80 fa 12             	cmp    $0x12,%dl
c0027480:	0f 87 56 01 00 00    	ja     c00275dc <.L97>
c0027486:	0f b6 d2             	movzbl %dl,%edx
c0027489:	89 e9                	mov    %ebp,%ecx
c002748b:	03 8c 95 34 39 ff ff 	add    -0xc6cc(%ebp,%edx,4),%ecx
c0027492:	ff e1                	jmp    *%ecx
          format++;
c0027494:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c0027497:	8b 07                	mov    (%edi),%eax
c0027499:	89 44 24 38          	mov    %eax,0x38(%esp)
c002749d:	8d 7f 04             	lea    0x4(%edi),%edi
c00274a0:	eb b7                	jmp    c0027459 <.L77+0xd2>
        c->precision = -1;
c00274a2:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c00274a9:	ff 
c00274aa:	e9 4b ff ff ff       	jmp    c00273fa <.L77+0x73>

c00274af <.L103>:
      if (*format == 'h') 
c00274af:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00274b3:	3c 68                	cmp    $0x68,%al
c00274b5:	74 25                	je     c00274dc <.L103+0x2d>
        c->type = SHORT;
c00274b7:	c7 44 24 3c 02 00 00 	movl   $0x2,0x3c(%esp)
c00274be:	00 
      switch (*format) 
c00274bf:	0f be d0             	movsbl %al,%edx
c00274c2:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00274c5:	80 fb 33             	cmp    $0x33,%bl
c00274c8:	0f 87 ae 04 00 00    	ja     c002797c <.L105>
c00274ce:	0f b6 db             	movzbl %bl,%ebx
c00274d1:	89 e9                	mov    %ebp,%ecx
c00274d3:	03 8c 9d 80 39 ff ff 	add    -0xc680(%ebp,%ebx,4),%ecx
c00274da:	ff e1                	jmp    *%ecx
          format++;
c00274dc:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = CHAR;
c00274df:	c7 44 24 3c 01 00 00 	movl   $0x1,0x3c(%esp)
c00274e6:	00 
      switch (*format) 
c00274e7:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c00274eb:	0f be d0             	movsbl %al,%edx
c00274ee:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00274f1:	80 fb 33             	cmp    $0x33,%bl
c00274f4:	0f 87 82 04 00 00    	ja     c002797c <.L105>
c00274fa:	0f b6 db             	movzbl %bl,%ebx
c00274fd:	89 e9                	mov    %ebp,%ecx
c00274ff:	03 8c 9d 50 3a ff ff 	add    -0xc5b0(%ebp,%ebx,4),%ecx
c0027506:	ff e1                	jmp    *%ecx

c0027508 <.L102>:
      c->type = INTMAX;
c0027508:	c7 44 24 3c 04 00 00 	movl   $0x4,0x3c(%esp)
c002750f:	00 
      switch (*format) 
c0027510:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027514:	0f be d0             	movsbl %al,%edx
c0027517:	8d 58 bb             	lea    -0x45(%eax),%ebx
c002751a:	80 fb 33             	cmp    $0x33,%bl
c002751d:	0f 87 59 04 00 00    	ja     c002797c <.L105>
c0027523:	0f b6 db             	movzbl %bl,%ebx
c0027526:	89 e9                	mov    %ebp,%ecx
c0027528:	03 8c 9d 20 3b ff ff 	add    -0xc4e0(%ebp,%ebx,4),%ecx
c002752f:	ff e1                	jmp    *%ecx

c0027531 <.L101>:
      if (*format == 'l')
c0027531:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027535:	3c 6c                	cmp    $0x6c,%al
c0027537:	74 25                	je     c002755e <.L101+0x2d>
        c->type = LONG;
c0027539:	c7 44 24 3c 05 00 00 	movl   $0x5,0x3c(%esp)
c0027540:	00 
      switch (*format) 
c0027541:	0f be d0             	movsbl %al,%edx
c0027544:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0027547:	80 fb 33             	cmp    $0x33,%bl
c002754a:	0f 87 2c 04 00 00    	ja     c002797c <.L105>
c0027550:	0f b6 db             	movzbl %bl,%ebx
c0027553:	89 e9                	mov    %ebp,%ecx
c0027555:	03 8c 9d f0 3b ff ff 	add    -0xc410(%ebp,%ebx,4),%ecx
c002755c:	ff e1                	jmp    *%ecx
          format++;
c002755e:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = LONGLONG;
c0027561:	c7 44 24 3c 06 00 00 	movl   $0x6,0x3c(%esp)
c0027568:	00 
      switch (*format) 
c0027569:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c002756d:	0f be d0             	movsbl %al,%edx
c0027570:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0027573:	80 fb 33             	cmp    $0x33,%bl
c0027576:	0f 87 00 04 00 00    	ja     c002797c <.L105>
c002757c:	0f b6 db             	movzbl %bl,%ebx
c002757f:	89 e9                	mov    %ebp,%ecx
c0027581:	03 8c 9d c0 3c ff ff 	add    -0xc340(%ebp,%ebx,4),%ecx
c0027588:	ff e1                	jmp    *%ecx

c002758a <.L100>:
      c->type = PTRDIFFT;
c002758a:	c7 44 24 3c 07 00 00 	movl   $0x7,0x3c(%esp)
c0027591:	00 
      switch (*format) 
c0027592:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027596:	0f be d0             	movsbl %al,%edx
c0027599:	8d 58 bb             	lea    -0x45(%eax),%ebx
c002759c:	80 fb 33             	cmp    $0x33,%bl
c002759f:	0f 87 d7 03 00 00    	ja     c002797c <.L105>
c00275a5:	0f b6 db             	movzbl %bl,%ebx
c00275a8:	89 e9                	mov    %ebp,%ecx
c00275aa:	03 8c 9d 90 3d ff ff 	add    -0xc270(%ebp,%ebx,4),%ecx
c00275b1:	ff e1                	jmp    *%ecx

c00275b3 <.L98>:
      c->type = SIZET;
c00275b3:	c7 44 24 3c 08 00 00 	movl   $0x8,0x3c(%esp)
c00275ba:	00 
      switch (*format) 
c00275bb:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00275bf:	0f be d0             	movsbl %al,%edx
c00275c2:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00275c5:	80 fb 33             	cmp    $0x33,%bl
c00275c8:	0f 87 ae 03 00 00    	ja     c002797c <.L105>
c00275ce:	0f b6 db             	movzbl %bl,%ebx
c00275d1:	89 e9                	mov    %ebp,%ecx
c00275d3:	03 8c 9d 60 3e ff ff 	add    -0xc1a0(%ebp,%ebx,4),%ecx
c00275da:	ff e1                	jmp    *%ecx

c00275dc <.L97>:
c00275dc:	0f be d0             	movsbl %al,%edx
c00275df:	8d 70 bb             	lea    -0x45(%eax),%esi
c00275e2:	89 f1                	mov    %esi,%ecx
c00275e4:	80 f9 33             	cmp    $0x33,%cl
c00275e7:	0f 87 8d 03 00 00    	ja     c002797a <.L149>
c00275ed:	0f b6 f1             	movzbl %cl,%esi
c00275f0:	89 e9                	mov    %ebp,%ecx
c00275f2:	03 8c b5 30 3f ff ff 	add    -0xc0d0(%ebp,%esi,4),%ecx
c00275f9:	ff e1                	jmp    *%ecx

c00275fb <.L152>:
c00275fb:	89 de                	mov    %ebx,%esi

c00275fd <.L111>:
            switch (c.type) 
c00275fd:	83 7c 24 3c 08       	cmpl   $0x8,0x3c(%esp)
c0027602:	0f 87 20 01 00 00    	ja     c0027728 <.L128>
c0027608:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002760c:	89 eb                	mov    %ebp,%ebx
c002760e:	03 9c 85 00 40 ff ff 	add    -0xc000(%ebp,%eax,4),%ebx
c0027615:	ff e3                	jmp    *%ebx

c0027617 <.L137>:
                value = (signed char) va_arg (args, int);
c0027617:	0f be 0f             	movsbl (%edi),%ecx
c002761a:	89 c8                	mov    %ecx,%eax
c002761c:	99                   	cltd   
c002761d:	89 0c 24             	mov    %ecx,(%esp)
c0027620:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027624:	8d 7f 04             	lea    0x4(%edi),%edi
            format_integer (value < 0 ? -value : value,
c0027627:	8b 54 24 04          	mov    0x4(%esp),%edx
c002762b:	c1 fa 1f             	sar    $0x1f,%edx
c002762e:	89 d3                	mov    %edx,%ebx
c0027630:	33 1c 24             	xor    (%esp),%ebx
c0027633:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c0027637:	89 d3                	mov    %edx,%ebx
c0027639:	33 5c 24 04          	xor    0x4(%esp),%ebx
c002763d:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0027641:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0027645:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027649:	29 d1                	sub    %edx,%ecx
c002764b:	19 d3                	sbb    %edx,%ebx
c002764d:	89 c8                	mov    %ecx,%eax
c002764f:	89 da                	mov    %ebx,%edx
c0027651:	83 ec 0c             	sub    $0xc,%esp
c0027654:	ff 74 24 78          	pushl  0x78(%esp)
c0027658:	ff 74 24 78          	pushl  0x78(%esp)
c002765c:	8d 4c 24 44          	lea    0x44(%esp),%ecx
c0027660:	51                   	push   %ecx
c0027661:	8d 8d 10 7d ff ff    	lea    -0x82f0(%ebp),%ecx
c0027667:	51                   	push   %ecx
c0027668:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c002766c:	c1 e9 1f             	shr    $0x1f,%ecx
c002766f:	51                   	push   %ecx
c0027670:	b9 01 00 00 00       	mov    $0x1,%ecx
c0027675:	e8 f9 f7 ff ff       	call   c0026e73 <format_integer>
          break;
c002767a:	83 c4 20             	add    $0x20,%esp
c002767d:	89 f3                	mov    %esi,%ebx
c002767f:	e9 83 fc ff ff       	jmp    c0027307 <__vprintf+0x3d>

c0027684 <.L136>:
                value = (short) va_arg (args, int);
c0027684:	0f bf 0f             	movswl (%edi),%ecx
c0027687:	89 c8                	mov    %ecx,%eax
c0027689:	99                   	cltd   
c002768a:	89 0c 24             	mov    %ecx,(%esp)
c002768d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027691:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027694:	eb 91                	jmp    c0027627 <.L137+0x10>

c0027696 <.L135>:
                value = va_arg (args, int);
c0027696:	8b 0f                	mov    (%edi),%ecx
c0027698:	89 c8                	mov    %ecx,%eax
c002769a:	99                   	cltd   
c002769b:	89 0c 24             	mov    %ecx,(%esp)
c002769e:	89 54 24 04          	mov    %edx,0x4(%esp)
c00276a2:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00276a5:	eb 80                	jmp    c0027627 <.L137+0x10>

c00276a7 <.L134>:
                value = va_arg (args, intmax_t);
c00276a7:	8b 07                	mov    (%edi),%eax
c00276a9:	8b 57 04             	mov    0x4(%edi),%edx
c00276ac:	89 04 24             	mov    %eax,(%esp)
c00276af:	89 54 24 04          	mov    %edx,0x4(%esp)
c00276b3:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00276b6:	e9 6c ff ff ff       	jmp    c0027627 <.L137+0x10>

c00276bb <.L133>:
                value = va_arg (args, long);
c00276bb:	8b 0f                	mov    (%edi),%ecx
c00276bd:	89 c8                	mov    %ecx,%eax
c00276bf:	99                   	cltd   
c00276c0:	89 0c 24             	mov    %ecx,(%esp)
c00276c3:	89 54 24 04          	mov    %edx,0x4(%esp)
c00276c7:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00276ca:	e9 58 ff ff ff       	jmp    c0027627 <.L137+0x10>

c00276cf <.L132>:
                value = va_arg (args, long long);
c00276cf:	8b 07                	mov    (%edi),%eax
c00276d1:	8b 57 04             	mov    0x4(%edi),%edx
c00276d4:	89 04 24             	mov    %eax,(%esp)
c00276d7:	89 54 24 04          	mov    %edx,0x4(%esp)
c00276db:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00276de:	e9 44 ff ff ff       	jmp    c0027627 <.L137+0x10>

c00276e3 <.L131>:
                value = va_arg (args, ptrdiff_t);
c00276e3:	8b 0f                	mov    (%edi),%ecx
c00276e5:	89 c8                	mov    %ecx,%eax
c00276e7:	99                   	cltd   
c00276e8:	89 0c 24             	mov    %ecx,(%esp)
c00276eb:	89 54 24 04          	mov    %edx,0x4(%esp)
c00276ef:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00276f2:	e9 30 ff ff ff       	jmp    c0027627 <.L137+0x10>

c00276f7 <.L129>:
                value = va_arg (args, size_t);
c00276f7:	8d 47 04             	lea    0x4(%edi),%eax
c00276fa:	8b 0f                	mov    (%edi),%ecx
c00276fc:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027701:	89 0c 24             	mov    %ecx,(%esp)
c0027704:	89 5c 24 04          	mov    %ebx,0x4(%esp)
                if (value > SIZE_MAX / 2)
c0027708:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
c002770d:	39 ca                	cmp    %ecx,%edx
c002770f:	ba 00 00 00 00       	mov    $0x0,%edx
c0027714:	19 da                	sbb    %ebx,%edx
                value = va_arg (args, size_t);
c0027716:	89 c7                	mov    %eax,%edi
                if (value > SIZE_MAX / 2)
c0027718:	0f 8d 09 ff ff ff    	jge    c0027627 <.L137+0x10>
                  value = value - SIZE_MAX - 1;
c002771e:	83 6c 24 04 01       	subl   $0x1,0x4(%esp)
c0027723:	e9 ff fe ff ff       	jmp    c0027627 <.L137+0x10>

c0027728 <.L128>:
                NOT_REACHED ();
c0027728:	8d 85 60 48 ff ff    	lea    -0xb7a0(%ebp),%eax
c002772e:	50                   	push   %eax
c002772f:	8d 85 24 40 ff ff    	lea    -0xbfdc(%ebp),%eax
c0027735:	50                   	push   %eax
c0027736:	68 dc 00 00 00       	push   $0xdc
c002773b:	8d 85 ed 5b ff ff    	lea    -0xa413(%ebp),%eax
c0027741:	50                   	push   %eax
c0027742:	89 eb                	mov    %ebp,%ebx
c0027744:	e8 9b 17 00 00       	call   c0028ee4 <debug_panic>

c0027749 <.L126>:
                value = va_arg (args, unsigned);
c0027749:	8b 17                	mov    (%edi),%edx
c002774b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027750:	89 54 24 10          	mov    %edx,0x10(%esp)
c0027754:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c0027758:	8d 7f 04             	lea    0x4(%edi),%edi
            switch (*format) 
c002775b:	3c 6f                	cmp    $0x6f,%al
c002775d:	0f 84 1c 01 00 00    	je     c002787f <.L124+0x71>
c0027763:	3c 6f                	cmp    $0x6f,%al
c0027765:	0f 8e bc 00 00 00    	jle    c0027827 <.L124+0x19>
c002776b:	3c 75                	cmp    $0x75,%al
c002776d:	0f 84 14 01 00 00    	je     c0027887 <.L124+0x79>
c0027773:	3c 78                	cmp    $0x78,%al
c0027775:	0f 85 e3 00 00 00    	jne    c002785e <.L124+0x50>
              case 'x': b = &base_x; break;
c002777b:	8d 85 f0 7c ff ff    	lea    -0x8310(%ebp),%eax
c0027781:	e9 ab 00 00 00       	jmp    c0027831 <.L124+0x23>

c0027786 <.L106>:
                value = (unsigned char) va_arg (args, unsigned);
c0027786:	0f b6 17             	movzbl (%edi),%edx
c0027789:	89 54 24 10          	mov    %edx,0x10(%esp)
c002778d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0027794:	00 
                break;
c0027795:	89 f3                	mov    %esi,%ebx
                value = (unsigned char) va_arg (args, unsigned);
c0027797:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c002779a:	eb bf                	jmp    c002775b <.L126+0x12>

c002779c <.L113>:
                value = (unsigned short) va_arg (args, unsigned);
c002779c:	0f b7 17             	movzwl (%edi),%edx
c002779f:	89 54 24 10          	mov    %edx,0x10(%esp)
c00277a3:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c00277aa:	00 
                break;
c00277ab:	89 f3                	mov    %esi,%ebx
                value = (unsigned short) va_arg (args, unsigned);
c00277ad:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00277b0:	eb a9                	jmp    c002775b <.L126+0x12>

c00277b2 <.L115>:
                value = va_arg (args, uintmax_t);
c00277b2:	8b 0f                	mov    (%edi),%ecx
c00277b4:	8b 5f 04             	mov    0x4(%edi),%ebx
c00277b7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00277bb:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c00277bf:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, uintmax_t);
c00277c1:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00277c4:	eb 95                	jmp    c002775b <.L126+0x12>

c00277c6 <.L120>:
                value = va_arg (args, unsigned long);
c00277c6:	8b 0f                	mov    (%edi),%ecx
c00277c8:	bb 00 00 00 00       	mov    $0x0,%ebx
c00277cd:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00277d1:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c00277d5:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, unsigned long);
c00277d7:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00277da:	e9 7c ff ff ff       	jmp    c002775b <.L126+0x12>

c00277df <.L118>:
                value = va_arg (args, unsigned long long);
c00277df:	8b 0f                	mov    (%edi),%ecx
c00277e1:	8b 5f 04             	mov    0x4(%edi),%ebx
c00277e4:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00277e8:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c00277ec:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, unsigned long long);
c00277ee:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00277f1:	e9 65 ff ff ff       	jmp    c002775b <.L126+0x12>

c00277f6 <.L122>:
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c00277f6:	8b 1f                	mov    (%edi),%ebx
c00277f8:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c00277fc:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0027803:	00 
                break;
c0027804:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, ptrdiff_t);
c0027806:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027809:	e9 4d ff ff ff       	jmp    c002775b <.L126+0x12>

c002780e <.L124>:
                value = va_arg (args, size_t);
c002780e:	8b 0f                	mov    (%edi),%ecx
c0027810:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027815:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027819:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c002781d:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, size_t);
c002781f:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027822:	e9 34 ff ff ff       	jmp    c002775b <.L126+0x12>
c0027827:	3c 58                	cmp    $0x58,%al
c0027829:	75 33                	jne    c002785e <.L124+0x50>
              case 'X': b = &base_X; break;
c002782b:	8d 85 e0 7c ff ff    	lea    -0x8320(%ebp),%eax
            format_integer (value, false, false, b, &c, output, aux);
c0027831:	83 ec 0c             	sub    $0xc,%esp
c0027834:	ff 74 24 78          	pushl  0x78(%esp)
c0027838:	ff 74 24 78          	pushl  0x78(%esp)
c002783c:	8d 54 24 44          	lea    0x44(%esp),%edx
c0027840:	52                   	push   %edx
c0027841:	50                   	push   %eax
c0027842:	6a 00                	push   $0x0
c0027844:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027849:	8b 44 24 30          	mov    0x30(%esp),%eax
c002784d:	8b 54 24 34          	mov    0x34(%esp),%edx
c0027851:	e8 1d f6 ff ff       	call   c0026e73 <format_integer>
          break;
c0027856:	83 c4 20             	add    $0x20,%esp
c0027859:	e9 a9 fa ff ff       	jmp    c0027307 <__vprintf+0x3d>
              default: NOT_REACHED ();
c002785e:	8d 85 60 48 ff ff    	lea    -0xb7a0(%ebp),%eax
c0027864:	50                   	push   %eax
c0027865:	8d 85 24 40 ff ff    	lea    -0xbfdc(%ebp),%eax
c002786b:	50                   	push   %eax
c002786c:	68 14 01 00 00       	push   $0x114
c0027871:	8d 85 ed 5b ff ff    	lea    -0xa413(%ebp),%eax
c0027877:	50                   	push   %eax
c0027878:	89 eb                	mov    %ebp,%ebx
c002787a:	e8 65 16 00 00       	call   c0028ee4 <debug_panic>
              case 'o': b = &base_o; break;
c002787f:	8d 85 00 7d ff ff    	lea    -0x8300(%ebp),%eax
c0027885:	eb aa                	jmp    c0027831 <.L124+0x23>
              case 'u': b = &base_d; break;
c0027887:	8d 85 10 7d ff ff    	lea    -0x82f0(%ebp),%eax
c002788d:	eb a2                	jmp    c0027831 <.L124+0x23>

c002788f <.L151>:
      switch (*format) 
c002788f:	89 de                	mov    %ebx,%esi

c0027891 <.L112>:
            char ch = va_arg (args, int);
c0027891:	8d 47 04             	lea    0x4(%edi),%eax
c0027894:	89 04 24             	mov    %eax,(%esp)
c0027897:	8b 07                	mov    (%edi),%eax
c0027899:	88 44 24 2f          	mov    %al,0x2f(%esp)
            format_string (&ch, 1, &c, output, aux);
c002789d:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c00278a1:	8d 44 24 2f          	lea    0x2f(%esp),%eax
c00278a5:	83 ec 08             	sub    $0x8,%esp
c00278a8:	ff 74 24 74          	pushl  0x74(%esp)
c00278ac:	ff 74 24 74          	pushl  0x74(%esp)
c00278b0:	ba 01 00 00 00       	mov    $0x1,%edx
c00278b5:	e8 3c f9 ff ff       	call   c00271f6 <format_string>
          break;
c00278ba:	83 c4 10             	add    $0x10,%esp
c00278bd:	89 f3                	mov    %esi,%ebx
            char ch = va_arg (args, int);
c00278bf:	8b 3c 24             	mov    (%esp),%edi
          break;
c00278c2:	e9 40 fa ff ff       	jmp    c0027307 <__vprintf+0x3d>

c00278c7 <.L154>:
      switch (*format) 
c00278c7:	89 de                	mov    %ebx,%esi

c00278c9 <.L108>:
            const char *s = va_arg (args, char *);
c00278c9:	8d 47 04             	lea    0x4(%edi),%eax
c00278cc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00278d0:	8b 3f                	mov    (%edi),%edi
              s = "(null)";
c00278d2:	85 ff                	test   %edi,%edi
c00278d4:	8d 85 e6 5b ff ff    	lea    -0xa41a(%ebp),%eax
c00278da:	0f 44 f8             	cmove  %eax,%edi
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c00278dd:	83 ec 08             	sub    $0x8,%esp
c00278e0:	ff 74 24 08          	pushl  0x8(%esp)
c00278e4:	57                   	push   %edi
c00278e5:	89 eb                	mov    %ebp,%ebx
c00278e7:	e8 0e 0c 00 00       	call   c00284fa <strnlen>
c00278ec:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c00278f0:	83 c4 08             	add    $0x8,%esp
c00278f3:	ff 74 24 74          	pushl  0x74(%esp)
c00278f7:	ff 74 24 74          	pushl  0x74(%esp)
c00278fb:	89 c2                	mov    %eax,%edx
c00278fd:	89 f8                	mov    %edi,%eax
c00278ff:	e8 f2 f8 ff ff       	call   c00271f6 <format_string>
          break;
c0027904:	83 c4 10             	add    $0x10,%esp
c0027907:	89 f3                	mov    %esi,%ebx
            const char *s = va_arg (args, char *);
c0027909:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
          break;
c002790d:	e9 f5 f9 ff ff       	jmp    c0027307 <__vprintf+0x3d>

c0027912 <.L153>:
      switch (*format) 
c0027912:	89 de                	mov    %ebx,%esi

c0027914 <.L109>:
            void *p = va_arg (args, void *);
c0027914:	8d 47 04             	lea    0x4(%edi),%eax
c0027917:	89 04 24             	mov    %eax,(%esp)
c002791a:	8b 07                	mov    (%edi),%eax
            c.flags = POUND;
c002791c:	c7 44 24 30 08 00 00 	movl   $0x8,0x30(%esp)
c0027923:	00 
            format_integer ((uintptr_t) p, false, false,
c0027924:	ba 00 00 00 00       	mov    $0x0,%edx
c0027929:	83 ec 0c             	sub    $0xc,%esp
c002792c:	ff 74 24 78          	pushl  0x78(%esp)
c0027930:	ff 74 24 78          	pushl  0x78(%esp)
c0027934:	8d 4c 24 44          	lea    0x44(%esp),%ecx
c0027938:	51                   	push   %ecx
c0027939:	8d 8d f0 7c ff ff    	lea    -0x8310(%ebp),%ecx
c002793f:	51                   	push   %ecx
c0027940:	6a 00                	push   $0x0
c0027942:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027947:	e8 27 f5 ff ff       	call   c0026e73 <format_integer>
          break;
c002794c:	83 c4 20             	add    $0x20,%esp
c002794f:	89 f3                	mov    %esi,%ebx
            void *p = va_arg (args, void *);
c0027951:	8b 3c 24             	mov    (%esp),%edi
          break;
c0027954:	e9 ae f9 ff ff       	jmp    c0027307 <__vprintf+0x3d>

c0027959 <.L150>:
      switch (*format) 
c0027959:	89 de                	mov    %ebx,%esi

c002795b <.L110>:
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c002795b:	52                   	push   %edx
c002795c:	ff 74 24 70          	pushl  0x70(%esp)
c0027960:	ff 74 24 70          	pushl  0x70(%esp)
c0027964:	8d 85 ff 5b ff ff    	lea    -0xa401(%ebp),%eax
c002796a:	50                   	push   %eax
c002796b:	e8 3d f9 ff ff       	call   c00272ad <__printf>
          break;
c0027970:	83 c4 10             	add    $0x10,%esp
c0027973:	89 f3                	mov    %esi,%ebx
c0027975:	e9 8d f9 ff ff       	jmp    c0027307 <__vprintf+0x3d>

c002797a <.L149>:
      switch (*format) 
c002797a:	89 de                	mov    %ebx,%esi

c002797c <.L105>:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c002797c:	52                   	push   %edx
c002797d:	ff 74 24 70          	pushl  0x70(%esp)
c0027981:	ff 74 24 70          	pushl  0x70(%esp)
c0027985:	8d 85 15 5c ff ff    	lea    -0xa3eb(%ebp),%eax
c002798b:	50                   	push   %eax
c002798c:	e8 1c f9 ff ff       	call   c00272ad <__printf>
          break;
c0027991:	83 c4 10             	add    $0x10,%esp
c0027994:	89 f3                	mov    %esi,%ebx
c0027996:	e9 6c f9 ff ff       	jmp    c0027307 <__vprintf+0x3d>

c002799b <vsnprintf>:
{
c002799b:	56                   	push   %esi
c002799c:	53                   	push   %ebx
c002799d:	83 ec 14             	sub    $0x14,%esp
c00279a0:	e8 f2 5e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00279a5:	81 c3 5b 2b 01 00    	add    $0x12b5b,%ebx
c00279ab:	8b 44 24 24          	mov    0x24(%esp),%eax
c00279af:	8b 54 24 28          	mov    0x28(%esp),%edx
c00279b3:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c00279b7:	8b 74 24 20          	mov    0x20(%esp),%esi
c00279bb:	89 74 24 04          	mov    %esi,0x4(%esp)
  aux.length = 0;
c00279bf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c00279c6:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00279c7:	85 c0                	test   %eax,%eax
c00279c9:	74 26                	je     c00279f1 <vsnprintf+0x56>
c00279cb:	83 e8 01             	sub    $0x1,%eax
c00279ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c00279d2:	8d 44 24 04          	lea    0x4(%esp),%eax
c00279d6:	50                   	push   %eax
c00279d7:	8d 83 20 c9 fe ff    	lea    -0x136e0(%ebx),%eax
c00279dd:	50                   	push   %eax
c00279de:	51                   	push   %ecx
c00279df:	52                   	push   %edx
c00279e0:	e8 e5 f8 ff ff       	call   c00272ca <__vprintf>
    *aux.p = '\0';
c00279e5:	8b 44 24 14          	mov    0x14(%esp),%eax
c00279e9:	c6 00 00             	movb   $0x0,(%eax)
c00279ec:	83 c4 10             	add    $0x10,%esp
c00279ef:	eb 1e                	jmp    c0027a0f <vsnprintf+0x74>
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00279f1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00279f8:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c00279f9:	8d 44 24 04          	lea    0x4(%esp),%eax
c00279fd:	50                   	push   %eax
c00279fe:	8d 83 20 c9 fe ff    	lea    -0x136e0(%ebx),%eax
c0027a04:	50                   	push   %eax
c0027a05:	51                   	push   %ecx
c0027a06:	52                   	push   %edx
c0027a07:	e8 be f8 ff ff       	call   c00272ca <__vprintf>
c0027a0c:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c0027a0f:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c0027a13:	83 c4 14             	add    $0x14,%esp
c0027a16:	5b                   	pop    %ebx
c0027a17:	5e                   	pop    %esi
c0027a18:	c3                   	ret    

c0027a19 <snprintf>:
{
c0027a19:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0027a1c:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0027a20:	50                   	push   %eax
c0027a21:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027a25:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027a29:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027a2d:	e8 69 ff ff ff       	call   c002799b <vsnprintf>
}
c0027a32:	83 c4 1c             	add    $0x1c,%esp
c0027a35:	c3                   	ret    

c0027a36 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027a36:	55                   	push   %ebp
c0027a37:	57                   	push   %edi
c0027a38:	56                   	push   %esi
c0027a39:	53                   	push   %ebx
c0027a3a:	83 ec 2c             	sub    $0x2c,%esp
c0027a3d:	e8 61 5e 00 00       	call   c002d8a3 <__x86.get_pc_thunk.di>
c0027a42:	81 c7 be 2a 01 00    	add    $0x12abe,%edi
c0027a48:	0f b6 44 24 4c       	movzbl 0x4c(%esp),%eax
c0027a4d:	88 44 24 17          	mov    %al,0x17(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027a51:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c0027a56:	0f 84 ea 01 00 00    	je     c0027c46 <hex_dump+0x210>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027a5c:	8d 87 2c 5c ff ff    	lea    -0xa3d4(%edi),%eax
c0027a62:	89 44 24 18          	mov    %eax,0x18(%esp)
c0027a66:	eb 5a                	jmp    c0027ac2 <hex_dump+0x8c>
      for (i = 0; i < start; i++)
c0027a68:	89 eb                	mov    %ebp,%ebx
c0027a6a:	e9 c2 00 00 00       	jmp    c0027b31 <hex_dump+0xfb>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0027a6f:	89 ee                	mov    %ebp,%esi
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
            printf (" ");
c0027a71:	83 ec 0c             	sub    $0xc,%esp
c0027a74:	6a 20                	push   $0x20
c0027a76:	89 fb                	mov    %edi,%ebx
c0027a78:	e8 fa 33 00 00       	call   c002ae77 <putchar>
          for (; i < per_line; i++)
c0027a7d:	83 c6 01             	add    $0x1,%esi
c0027a80:	83 c4 10             	add    $0x10,%esp
c0027a83:	83 fe 0f             	cmp    $0xf,%esi
c0027a86:	76 e9                	jbe    c0027a71 <hex_dump+0x3b>
          printf ("|");
c0027a88:	83 ec 0c             	sub    $0xc,%esp
c0027a8b:	6a 7c                	push   $0x7c
c0027a8d:	89 fb                	mov    %edi,%ebx
c0027a8f:	e8 e3 33 00 00       	call   c002ae77 <putchar>
c0027a94:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027a97:	83 ec 0c             	sub    $0xc,%esp
c0027a9a:	6a 0a                	push   $0xa
c0027a9c:	89 fb                	mov    %edi,%ebx
c0027a9e:	e8 d4 33 00 00       	call   c002ae77 <putchar>

      ofs += n;
c0027aa3:	8b 44 24 20          	mov    0x20(%esp),%eax
c0027aa7:	01 44 24 50          	add    %eax,0x50(%esp)
      buf += n;
c0027aab:	01 44 24 54          	add    %eax,0x54(%esp)
      size -= n;
c0027aaf:	89 e8                	mov    %ebp,%eax
c0027ab1:	2b 44 24 1c          	sub    0x1c(%esp),%eax
  while (size > 0)
c0027ab5:	83 c4 10             	add    $0x10,%esp
c0027ab8:	01 44 24 48          	add    %eax,0x48(%esp)
c0027abc:	0f 84 84 01 00 00    	je     c0027c46 <hex_dump+0x210>
      start = ofs % per_line;
c0027ac2:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c0027ac6:	83 e5 0f             	and    $0xf,%ebp
      if (end - start > size)
c0027ac9:	ba 10 00 00 00       	mov    $0x10,%edx
c0027ace:	29 ea                	sub    %ebp,%edx
        end = start + size;
c0027ad0:	89 e8                	mov    %ebp,%eax
c0027ad2:	03 44 24 48          	add    0x48(%esp),%eax
c0027ad6:	3b 54 24 48          	cmp    0x48(%esp),%edx
c0027ada:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027adf:	0f 46 c1             	cmovbe %ecx,%eax
c0027ae2:	89 44 24 0c          	mov    %eax,0xc(%esp)
      n = end - start;
c0027ae6:	29 e8                	sub    %ebp,%eax
c0027ae8:	89 44 24 10          	mov    %eax,0x10(%esp)
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027aec:	83 ec 04             	sub    $0x4,%esp
c0027aef:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027af3:	83 e0 f0             	and    $0xfffffff0,%eax
c0027af6:	ba 00 00 00 00       	mov    $0x0,%edx
c0027afb:	52                   	push   %edx
c0027afc:	50                   	push   %eax
c0027afd:	ff 74 24 24          	pushl  0x24(%esp)
c0027b01:	e8 82 f7 ff ff       	call   c0027288 <printf>
      for (i = 0; i < start; i++)
c0027b06:	83 c4 10             	add    $0x10,%esp
c0027b09:	85 ed                	test   %ebp,%ebp
c0027b0b:	0f 84 57 ff ff ff    	je     c0027a68 <hex_dump+0x32>
c0027b11:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c0027b16:	8d b7 34 5c ff ff    	lea    -0xa3cc(%edi),%esi
c0027b1c:	83 ec 0c             	sub    $0xc,%esp
c0027b1f:	56                   	push   %esi
c0027b20:	e8 63 f7 ff ff       	call   c0027288 <printf>
      for (i = 0; i < start; i++)
c0027b25:	83 c3 01             	add    $0x1,%ebx
c0027b28:	83 c4 10             	add    $0x10,%esp
c0027b2b:	39 dd                	cmp    %ebx,%ebp
c0027b2d:	75 ed                	jne    c0027b1c <hex_dump+0xe6>
c0027b2f:	89 eb                	mov    %ebp,%ebx
      for (; i < end; i++) 
c0027b31:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0027b35:	0f 86 fb 00 00 00    	jbe    c0027c36 <hex_dump+0x200>
        printf ("%02hhx%c",
c0027b3b:	be 20 00 00 00       	mov    $0x20,%esi
c0027b40:	83 fb 07             	cmp    $0x7,%ebx
c0027b43:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027b48:	0f 45 c6             	cmovne %esi,%eax
c0027b4b:	83 ec 04             	sub    $0x4,%esp
c0027b4e:	50                   	push   %eax
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027b4f:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0027b53:	29 e8                	sub    %ebp,%eax
        printf ("%02hhx%c",
c0027b55:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
c0027b59:	50                   	push   %eax
c0027b5a:	8d 87 38 5c ff ff    	lea    -0xa3c8(%edi),%eax
c0027b60:	50                   	push   %eax
c0027b61:	e8 22 f7 ff ff       	call   c0027288 <printf>
      for (; i < end; i++) 
c0027b66:	83 c3 01             	add    $0x1,%ebx
c0027b69:	83 c4 10             	add    $0x10,%esp
c0027b6c:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0027b70:	75 ce                	jne    c0027b40 <hex_dump+0x10a>
      if (ascii) 
c0027b72:	80 7c 24 17 00       	cmpb   $0x0,0x17(%esp)
c0027b77:	0f 84 1a ff ff ff    	je     c0027a97 <hex_dump+0x61>
          for (; i < per_line; i++)
c0027b7d:	83 fb 0f             	cmp    $0xf,%ebx
c0027b80:	77 1a                	ja     c0027b9c <hex_dump+0x166>
            printf ("   ");
c0027b82:	8d b7 34 5c ff ff    	lea    -0xa3cc(%edi),%esi
c0027b88:	83 ec 0c             	sub    $0xc,%esp
c0027b8b:	56                   	push   %esi
c0027b8c:	e8 f7 f6 ff ff       	call   c0027288 <printf>
          for (; i < per_line; i++)
c0027b91:	83 c3 01             	add    $0x1,%ebx
c0027b94:	83 c4 10             	add    $0x10,%esp
c0027b97:	83 fb 10             	cmp    $0x10,%ebx
c0027b9a:	75 ec                	jne    c0027b88 <hex_dump+0x152>
          printf ("|");
c0027b9c:	83 ec 0c             	sub    $0xc,%esp
c0027b9f:	6a 7c                	push   $0x7c
c0027ba1:	89 fb                	mov    %edi,%ebx
c0027ba3:	e8 cf 32 00 00       	call   c002ae77 <putchar>
          for (i = 0; i < start; i++)
c0027ba8:	83 c4 10             	add    $0x10,%esp
c0027bab:	85 ed                	test   %ebp,%ebp
c0027bad:	74 75                	je     c0027c24 <hex_dump+0x1ee>
c0027baf:	be 00 00 00 00       	mov    $0x0,%esi
            printf (" ");
c0027bb4:	83 ec 0c             	sub    $0xc,%esp
c0027bb7:	6a 20                	push   $0x20
c0027bb9:	89 fb                	mov    %edi,%ebx
c0027bbb:	e8 b7 32 00 00       	call   c002ae77 <putchar>
          for (i = 0; i < start; i++)
c0027bc0:	83 c6 01             	add    $0x1,%esi
c0027bc3:	83 c4 10             	add    $0x10,%esp
c0027bc6:	39 f5                	cmp    %esi,%ebp
c0027bc8:	75 ea                	jne    c0027bb4 <hex_dump+0x17e>
          for (; i < end; i++)
c0027bca:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c0027bce:	0f 86 9b fe ff ff    	jbe    c0027a6f <hex_dump+0x39>
          for (i = 0; i < start; i++)
c0027bd4:	89 ee                	mov    %ebp,%esi
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027bd6:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027bda:	29 e8                	sub    %ebp,%eax
c0027bdc:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c0027be0:	89 c5                	mov    %eax,%ebp
c0027be2:	0f b6 44 35 00       	movzbl 0x0(%ebp,%esi,1),%eax
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027be7:	0f b6 d0             	movzbl %al,%edx
c0027bea:	83 ea 20             	sub    $0x20,%edx
c0027bed:	83 fa 5f             	cmp    $0x5f,%edx
c0027bf0:	b9 2e 00 00 00       	mov    $0x2e,%ecx
c0027bf5:	0f 43 c1             	cmovae %ecx,%eax
            printf ("%c",
c0027bf8:	83 ec 0c             	sub    $0xc,%esp
c0027bfb:	0f b6 c0             	movzbl %al,%eax
c0027bfe:	50                   	push   %eax
c0027bff:	89 fb                	mov    %edi,%ebx
c0027c01:	e8 71 32 00 00       	call   c002ae77 <putchar>
          for (; i < end; i++)
c0027c06:	83 c6 01             	add    $0x1,%esi
c0027c09:	83 c4 10             	add    $0x10,%esp
c0027c0c:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c0027c10:	77 d0                	ja     c0027be2 <hex_dump+0x1ac>
c0027c12:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
          for (; i < per_line; i++)
c0027c16:	83 fe 0f             	cmp    $0xf,%esi
c0027c19:	0f 86 52 fe ff ff    	jbe    c0027a71 <hex_dump+0x3b>
c0027c1f:	e9 64 fe ff ff       	jmp    c0027a88 <hex_dump+0x52>
          for (i = 0; i < start; i++)
c0027c24:	89 ee                	mov    %ebp,%esi
          for (; i < end; i++)
c0027c26:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0027c2b:	75 a9                	jne    c0027bd6 <hex_dump+0x1a0>
          for (i = 0; i < start; i++)
c0027c2d:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027c31:	e9 3b fe ff ff       	jmp    c0027a71 <hex_dump+0x3b>
      if (ascii) 
c0027c36:	80 7c 24 17 00       	cmpb   $0x0,0x17(%esp)
c0027c3b:	0f 84 56 fe ff ff    	je     c0027a97 <hex_dump+0x61>
c0027c41:	e9 3c ff ff ff       	jmp    c0027b82 <hex_dump+0x14c>
    }
}
c0027c46:	83 c4 2c             	add    $0x2c,%esp
c0027c49:	5b                   	pop    %ebx
c0027c4a:	5e                   	pop    %esi
c0027c4b:	5f                   	pop    %edi
c0027c4c:	5d                   	pop    %ebp
c0027c4d:	c3                   	ret    

c0027c4e <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027c4e:	55                   	push   %ebp
c0027c4f:	57                   	push   %edi
c0027c50:	56                   	push   %esi
c0027c51:	53                   	push   %ebx
c0027c52:	83 ec 1c             	sub    $0x1c,%esp
c0027c55:	e8 49 5c 00 00       	call   c002d8a3 <__x86.get_pc_thunk.di>
c0027c5a:	81 c7 a6 28 01 00    	add    $0x128a6,%edi
c0027c60:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0027c64:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027c68:	8b 54 24 34          	mov    0x34(%esp),%edx
  if (size == 1)
c0027c6c:	89 c1                	mov    %eax,%ecx
c0027c6e:	83 f1 01             	xor    $0x1,%ecx
c0027c71:	89 d3                	mov    %edx,%ebx
c0027c73:	09 cb                	or     %ecx,%ebx
c0027c75:	74 6e                	je     c0027ce5 <print_human_readable_size+0x97>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027c77:	b9 ff 03 00 00       	mov    $0x3ff,%ecx
c0027c7c:	39 c1                	cmp    %eax,%ecx
c0027c7e:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027c83:	19 d1                	sbb    %edx,%ecx
c0027c85:	73 76                	jae    c0027cfd <print_human_readable_size+0xaf>
c0027c87:	8d 8f e4 ff ff ff    	lea    -0x1c(%edi),%ecx
c0027c8d:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027c92:	83 bf e8 ff ff ff 00 	cmpl   $0x0,-0x18(%edi)
c0027c99:	74 44                	je     c0027cdf <print_human_readable_size+0x91>
        size /= 1024;
c0027c9b:	89 c6                	mov    %eax,%esi
c0027c9d:	89 d7                	mov    %edx,%edi
c0027c9f:	0f ac d6 0a          	shrd   $0xa,%edx,%esi
c0027ca3:	c1 ef 0a             	shr    $0xa,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027ca6:	83 c1 04             	add    $0x4,%ecx
c0027ca9:	bd ff ff 0f 00       	mov    $0xfffff,%ebp
c0027cae:	39 c5                	cmp    %eax,%ebp
c0027cb0:	89 dd                	mov    %ebx,%ebp
c0027cb2:	19 d5                	sbb    %edx,%ebp
c0027cb4:	73 0a                	jae    c0027cc0 <print_human_readable_size+0x72>
        size /= 1024;
c0027cb6:	89 f0                	mov    %esi,%eax
c0027cb8:	89 fa                	mov    %edi,%edx
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027cba:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
c0027cbe:	75 db                	jne    c0027c9b <print_human_readable_size+0x4d>
      printf ("%"PRIu64" %s", size, *fp);
c0027cc0:	ff 31                	pushl  (%ecx)
c0027cc2:	57                   	push   %edi
c0027cc3:	56                   	push   %esi
c0027cc4:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027cc8:	8d 80 48 5c ff ff    	lea    -0xa3b8(%eax),%eax
c0027cce:	50                   	push   %eax
c0027ccf:	e8 b4 f5 ff ff       	call   c0027288 <printf>
c0027cd4:	83 c4 10             	add    $0x10,%esp
    }
}
c0027cd7:	83 c4 1c             	add    $0x1c,%esp
c0027cda:	5b                   	pop    %ebx
c0027cdb:	5e                   	pop    %esi
c0027cdc:	5f                   	pop    %edi
c0027cdd:	5d                   	pop    %ebp
c0027cde:	c3                   	ret    
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027cdf:	89 c6                	mov    %eax,%esi
c0027ce1:	89 d7                	mov    %edx,%edi
c0027ce3:	eb db                	jmp    c0027cc0 <print_human_readable_size+0x72>
    printf ("1 byte");
c0027ce5:	83 ec 0c             	sub    $0xc,%esp
c0027ce8:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027cec:	8d 80 41 5c ff ff    	lea    -0xa3bf(%eax),%eax
c0027cf2:	50                   	push   %eax
c0027cf3:	e8 90 f5 ff ff       	call   c0027288 <printf>
c0027cf8:	83 c4 10             	add    $0x10,%esp
c0027cfb:	eb da                	jmp    c0027cd7 <print_human_readable_size+0x89>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027cfd:	89 c6                	mov    %eax,%esi
c0027cff:	89 d7                	mov    %edx,%edi
c0027d01:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027d05:	8d 88 e4 ff ff ff    	lea    -0x1c(%eax),%ecx
c0027d0b:	eb b3                	jmp    c0027cc0 <print_human_readable_size+0x72>

c0027d0d <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0027d0d:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c0027d10:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027d14:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027d18:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027d1c:	ff 10                	call   *(%eax)
}
c0027d1e:	83 c4 1c             	add    $0x1c,%esp
c0027d21:	c3                   	ret    

c0027d22 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0027d22:	55                   	push   %ebp
c0027d23:	57                   	push   %edi
c0027d24:	56                   	push   %esi
c0027d25:	53                   	push   %ebx
c0027d26:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c0027d2a:	8d 72 ff             	lea    -0x1(%edx),%esi
c0027d2d:	0f af f7             	imul   %edi,%esi
  unsigned char *b = array + (b_idx - 1) * size;
c0027d30:	83 e9 01             	sub    $0x1,%ecx
c0027d33:	0f af cf             	imul   %edi,%ecx
  size_t i;

  for (i = 0; i < size; i++)
c0027d36:	85 ff                	test   %edi,%edi
c0027d38:	74 21                	je     c0027d5b <do_swap+0x39>
c0027d3a:	8d 14 30             	lea    (%eax,%esi,1),%edx
c0027d3d:	01 f8                	add    %edi,%eax
c0027d3f:	8d 3c 30             	lea    (%eax,%esi,1),%edi
    {
      unsigned char t = a[i];
c0027d42:	0f b6 2a             	movzbl (%edx),%ebp
      a[i] = b[i];
c0027d45:	89 d0                	mov    %edx,%eax
c0027d47:	29 f0                	sub    %esi,%eax
c0027d49:	0f b6 1c 08          	movzbl (%eax,%ecx,1),%ebx
c0027d4d:	88 1a                	mov    %bl,(%edx)
      b[i] = t;
c0027d4f:	89 eb                	mov    %ebp,%ebx
c0027d51:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
c0027d54:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < size; i++)
c0027d57:	39 fa                	cmp    %edi,%edx
c0027d59:	75 e7                	jne    c0027d42 <do_swap+0x20>
    }
}
c0027d5b:	5b                   	pop    %ebx
c0027d5c:	5e                   	pop    %esi
c0027d5d:	5f                   	pop    %edi
c0027d5e:	5d                   	pop    %ebp
c0027d5f:	c3                   	ret    

c0027d60 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0027d60:	55                   	push   %ebp
c0027d61:	57                   	push   %edi
c0027d62:	56                   	push   %esi
c0027d63:	53                   	push   %ebx
c0027d64:	83 ec 1c             	sub    $0x1c,%esp
c0027d67:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027d6b:	89 d7                	mov    %edx,%edi
c0027d6d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027d71:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0027d75:	eb 4a                	jmp    c0027dc1 <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027d77:	83 ec 04             	sub    $0x4,%esp
c0027d7a:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027d7e:	8d 47 ff             	lea    -0x1(%edi),%eax
c0027d81:	0f af c5             	imul   %ebp,%eax
c0027d84:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027d88:	01 d0                	add    %edx,%eax
c0027d8a:	50                   	push   %eax
c0027d8b:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027d8e:	0f af c5             	imul   %ebp,%eax
c0027d91:	01 d0                	add    %edx,%eax
c0027d93:	50                   	push   %eax
c0027d94:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027d98:	83 c4 10             	add    $0x10,%esp
c0027d9b:	85 c0                	test   %eax,%eax
c0027d9d:	7e 2e                	jle    c0027dcd <heapify+0x6d>
        max = left;
      if (right <= cnt
c0027d9f:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027da3:	76 5b                	jbe    c0027e00 <heapify+0xa0>
        max = left;
c0027da5:	89 de                	mov    %ebx,%esi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0027da7:	39 f7                	cmp    %esi,%edi
c0027da9:	74 4d                	je     c0027df8 <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0027dab:	83 ec 0c             	sub    $0xc,%esp
c0027dae:	55                   	push   %ebp
c0027daf:	89 f1                	mov    %esi,%ecx
c0027db1:	89 fa                	mov    %edi,%edx
c0027db3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0027db7:	e8 66 ff ff ff       	call   c0027d22 <do_swap>
      i = max;
c0027dbc:	89 f7                	mov    %esi,%edi
    {
c0027dbe:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c0027dc1:	8d 1c 3f             	lea    (%edi,%edi,1),%ebx
      size_t right = 2 * i + 1;
c0027dc4:	8d 73 01             	lea    0x1(%ebx),%esi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027dc7:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0027dcb:	76 aa                	jbe    c0027d77 <heapify+0x17>
      if (right <= cnt
c0027dcd:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027dd1:	77 25                	ja     c0027df8 <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027dd3:	83 ec 04             	sub    $0x4,%esp
c0027dd6:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027dda:	8d 47 ff             	lea    -0x1(%edi),%eax
c0027ddd:	0f af c5             	imul   %ebp,%eax
c0027de0:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0027de4:	01 c8                	add    %ecx,%eax
c0027de6:	50                   	push   %eax
c0027de7:	0f af dd             	imul   %ebp,%ebx
c0027dea:	01 cb                	add    %ecx,%ebx
c0027dec:	53                   	push   %ebx
c0027ded:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0027df1:	83 c4 10             	add    $0x10,%esp
c0027df4:	85 c0                	test   %eax,%eax
c0027df6:	7f af                	jg     c0027da7 <heapify+0x47>
    }
}
c0027df8:	83 c4 1c             	add    $0x1c,%esp
c0027dfb:	5b                   	pop    %ebx
c0027dfc:	5e                   	pop    %esi
c0027dfd:	5f                   	pop    %edi
c0027dfe:	5d                   	pop    %ebp
c0027dff:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027e00:	83 ec 04             	sub    $0x4,%esp
c0027e03:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027e07:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027e0a:	0f af c5             	imul   %ebp,%eax
c0027e0d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027e11:	01 d0                	add    %edx,%eax
c0027e13:	50                   	push   %eax
c0027e14:	89 d8                	mov    %ebx,%eax
c0027e16:	0f af c5             	imul   %ebp,%eax
c0027e19:	01 d0                	add    %edx,%eax
c0027e1b:	50                   	push   %eax
c0027e1c:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0027e20:	83 c4 10             	add    $0x10,%esp
c0027e23:	85 c0                	test   %eax,%eax
        max = left;
c0027e25:	0f 4e f3             	cmovle %ebx,%esi
c0027e28:	e9 7a ff ff ff       	jmp    c0027da7 <heapify+0x47>

c0027e2d <atoi>:
{
c0027e2d:	56                   	push   %esi
c0027e2e:	53                   	push   %ebx
c0027e2f:	83 ec 04             	sub    $0x4,%esp
c0027e32:	e8 60 5a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0027e37:	81 c3 c9 26 01 00    	add    $0x126c9,%ebx
c0027e3d:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c0027e41:	85 d2                	test   %edx,%edx
c0027e43:	75 29                	jne    c0027e6e <atoi+0x41>
c0027e45:	83 ec 0c             	sub    $0xc,%esp
c0027e48:	8d 83 e7 5c ff ff    	lea    -0xa319(%ebx),%eax
c0027e4e:	50                   	push   %eax
c0027e4f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0027e55:	50                   	push   %eax
c0027e56:	8d 83 38 40 ff ff    	lea    -0xbfc8(%ebx),%eax
c0027e5c:	50                   	push   %eax
c0027e5d:	6a 0f                	push   $0xf
c0027e5f:	8d 83 98 5c ff ff    	lea    -0xa368(%ebx),%eax
c0027e65:	50                   	push   %eax
c0027e66:	e8 79 10 00 00       	call   c0028ee4 <debug_panic>
    s++;
c0027e6b:	83 c2 01             	add    $0x1,%edx
  while (isspace ((unsigned char) *s))
c0027e6e:	0f b6 02             	movzbl (%edx),%eax
          || c == '\r' || c == '\t' || c == '\v');
c0027e71:	3c 20                	cmp    $0x20,%al
c0027e73:	74 f6                	je     c0027e6b <atoi+0x3e>
c0027e75:	8d 48 f7             	lea    -0x9(%eax),%ecx
c0027e78:	80 f9 04             	cmp    $0x4,%cl
c0027e7b:	76 ee                	jbe    c0027e6b <atoi+0x3e>
  if (*s == '+')
c0027e7d:	3c 2b                	cmp    $0x2b,%al
c0027e7f:	74 40                	je     c0027ec1 <atoi+0x94>
  negative = false;
c0027e81:	bb 00 00 00 00       	mov    $0x0,%ebx
  else if (*s == '-')
c0027e86:	3c 2d                	cmp    $0x2d,%al
c0027e88:	74 41                	je     c0027ecb <atoi+0x9e>
  for (value = 0; isdigit (*s); s++)
c0027e8a:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027e8d:	8d 41 d0             	lea    -0x30(%ecx),%eax
c0027e90:	83 f8 09             	cmp    $0x9,%eax
c0027e93:	77 40                	ja     c0027ed5 <atoi+0xa8>
c0027e95:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c0027e9a:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0027e9d:	01 c0                	add    %eax,%eax
c0027e9f:	83 e9 30             	sub    $0x30,%ecx
c0027ea2:	29 c8                	sub    %ecx,%eax
  for (value = 0; isdigit (*s); s++)
c0027ea4:	83 c2 01             	add    $0x1,%edx
c0027ea7:	0f be 0a             	movsbl (%edx),%ecx
c0027eaa:	8d 71 d0             	lea    -0x30(%ecx),%esi
c0027ead:	83 fe 09             	cmp    $0x9,%esi
c0027eb0:	76 e8                	jbe    c0027e9a <atoi+0x6d>
    value = -value;
c0027eb2:	89 c2                	mov    %eax,%edx
c0027eb4:	f7 da                	neg    %edx
c0027eb6:	84 db                	test   %bl,%bl
c0027eb8:	0f 44 c2             	cmove  %edx,%eax
}
c0027ebb:	83 c4 04             	add    $0x4,%esp
c0027ebe:	5b                   	pop    %ebx
c0027ebf:	5e                   	pop    %esi
c0027ec0:	c3                   	ret    
    s++;
c0027ec1:	83 c2 01             	add    $0x1,%edx
  negative = false;
c0027ec4:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027ec9:	eb bf                	jmp    c0027e8a <atoi+0x5d>
      s++;
c0027ecb:	83 c2 01             	add    $0x1,%edx
      negative = true;
c0027ece:	bb 01 00 00 00       	mov    $0x1,%ebx
c0027ed3:	eb b5                	jmp    c0027e8a <atoi+0x5d>
  for (value = 0; isdigit (*s); s++)
c0027ed5:	b8 00 00 00 00       	mov    $0x0,%eax
c0027eda:	eb d6                	jmp    c0027eb2 <atoi+0x85>

c0027edc <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0027edc:	55                   	push   %ebp
c0027edd:	57                   	push   %edi
c0027ede:	56                   	push   %esi
c0027edf:	53                   	push   %ebx
c0027ee0:	83 ec 0c             	sub    $0xc,%esp
c0027ee3:	e8 af 59 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0027ee8:	81 c3 18 26 01 00    	add    $0x12618,%ebx
c0027eee:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0027ef2:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027ef6:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0027efa:	85 ff                	test   %edi,%edi
c0027efc:	75 08                	jne    c0027f06 <sort+0x2a>
c0027efe:	85 f6                	test   %esi,%esi
c0027f00:	0f 85 89 00 00 00    	jne    c0027f8f <sort+0xb3>
  ASSERT (compare != NULL);
c0027f06:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0027f0b:	0f 84 a7 00 00 00    	je     c0027fb8 <sort+0xdc>
  ASSERT (size > 0);
c0027f11:	85 ed                	test   %ebp,%ebp
c0027f13:	0f 84 c8 00 00 00    	je     c0027fe1 <sort+0x105>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0027f19:	89 f3                	mov    %esi,%ebx
c0027f1b:	d1 eb                	shr    %ebx
c0027f1d:	83 fe 01             	cmp    $0x1,%esi
c0027f20:	76 65                	jbe    c0027f87 <sort+0xab>
c0027f22:	89 74 24 24          	mov    %esi,0x24(%esp)
c0027f26:	89 fe                	mov    %edi,%esi
c0027f28:	8b 7c 24 24          	mov    0x24(%esp),%edi
    heapify (array, i, cnt, size, compare, aux);
c0027f2c:	83 ec 04             	sub    $0x4,%esp
c0027f2f:	ff 74 24 34          	pushl  0x34(%esp)
c0027f33:	ff 74 24 34          	pushl  0x34(%esp)
c0027f37:	55                   	push   %ebp
c0027f38:	89 f9                	mov    %edi,%ecx
c0027f3a:	89 da                	mov    %ebx,%edx
c0027f3c:	89 f0                	mov    %esi,%eax
c0027f3e:	e8 1d fe ff ff       	call   c0027d60 <heapify>
  for (i = cnt / 2; i > 0; i--)
c0027f43:	83 c4 10             	add    $0x10,%esp
c0027f46:	83 eb 01             	sub    $0x1,%ebx
c0027f49:	75 e1                	jne    c0027f2c <sort+0x50>
c0027f4b:	89 f3                	mov    %esi,%ebx
c0027f4d:	89 fe                	mov    %edi,%esi
c0027f4f:	8b 7c 24 30          	mov    0x30(%esp),%edi

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
    {
      do_swap (array, 1, i, size);
c0027f53:	83 ec 0c             	sub    $0xc,%esp
c0027f56:	55                   	push   %ebp
c0027f57:	89 f1                	mov    %esi,%ecx
c0027f59:	ba 01 00 00 00       	mov    $0x1,%edx
c0027f5e:	89 d8                	mov    %ebx,%eax
c0027f60:	e8 bd fd ff ff       	call   c0027d22 <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c0027f65:	83 ee 01             	sub    $0x1,%esi
c0027f68:	83 c4 0c             	add    $0xc,%esp
c0027f6b:	57                   	push   %edi
c0027f6c:	ff 74 24 34          	pushl  0x34(%esp)
c0027f70:	55                   	push   %ebp
c0027f71:	89 f1                	mov    %esi,%ecx
c0027f73:	ba 01 00 00 00       	mov    $0x1,%edx
c0027f78:	89 d8                	mov    %ebx,%eax
c0027f7a:	e8 e1 fd ff ff       	call   c0027d60 <heapify>
  for (i = cnt; i > 1; i--) 
c0027f7f:	83 c4 10             	add    $0x10,%esp
c0027f82:	83 fe 01             	cmp    $0x1,%esi
c0027f85:	75 cc                	jne    c0027f53 <sort+0x77>
    }
}
c0027f87:	83 c4 0c             	add    $0xc,%esp
c0027f8a:	5b                   	pop    %ebx
c0027f8b:	5e                   	pop    %esi
c0027f8c:	5f                   	pop    %edi
c0027f8d:	5d                   	pop    %ebp
c0027f8e:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c0027f8f:	83 ec 0c             	sub    $0xc,%esp
c0027f92:	8d 83 ab 5c ff ff    	lea    -0xa355(%ebx),%eax
c0027f98:	50                   	push   %eax
c0027f99:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0027f9f:	50                   	push   %eax
c0027fa0:	8d 83 30 40 ff ff    	lea    -0xbfd0(%ebx),%eax
c0027fa6:	50                   	push   %eax
c0027fa7:	68 8a 00 00 00       	push   $0x8a
c0027fac:	8d 83 98 5c ff ff    	lea    -0xa368(%ebx),%eax
c0027fb2:	50                   	push   %eax
c0027fb3:	e8 2c 0f 00 00       	call   c0028ee4 <debug_panic>
  ASSERT (compare != NULL);
c0027fb8:	83 ec 0c             	sub    $0xc,%esp
c0027fbb:	8d 83 c5 5c ff ff    	lea    -0xa33b(%ebx),%eax
c0027fc1:	50                   	push   %eax
c0027fc2:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0027fc8:	50                   	push   %eax
c0027fc9:	8d 83 30 40 ff ff    	lea    -0xbfd0(%ebx),%eax
c0027fcf:	50                   	push   %eax
c0027fd0:	68 8b 00 00 00       	push   $0x8b
c0027fd5:	8d 83 98 5c ff ff    	lea    -0xa368(%ebx),%eax
c0027fdb:	50                   	push   %eax
c0027fdc:	e8 03 0f 00 00       	call   c0028ee4 <debug_panic>
  ASSERT (size > 0);
c0027fe1:	83 ec 0c             	sub    $0xc,%esp
c0027fe4:	8d 83 d5 5c ff ff    	lea    -0xa32b(%ebx),%eax
c0027fea:	50                   	push   %eax
c0027feb:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0027ff1:	50                   	push   %eax
c0027ff2:	8d 83 30 40 ff ff    	lea    -0xbfd0(%ebx),%eax
c0027ff8:	50                   	push   %eax
c0027ff9:	68 8c 00 00 00       	push   $0x8c
c0027ffe:	8d 83 98 5c ff ff    	lea    -0xa368(%ebx),%eax
c0028004:	50                   	push   %eax
c0028005:	e8 da 0e 00 00       	call   c0028ee4 <debug_panic>

c002800a <qsort>:
{
c002800a:	83 ec 18             	sub    $0x18,%esp
c002800d:	e8 89 58 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c0028012:	05 ee 24 01 00       	add    $0x124ee,%eax
  sort (array, cnt, size, compare_thunk, &compare);
c0028017:	8d 54 24 28          	lea    0x28(%esp),%edx
c002801b:	52                   	push   %edx
c002801c:	8d 80 0d d8 fe ff    	lea    -0x127f3(%eax),%eax
c0028022:	50                   	push   %eax
c0028023:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028027:	ff 74 24 2c          	pushl  0x2c(%esp)
c002802b:	ff 74 24 2c          	pushl  0x2c(%esp)
c002802f:	e8 a8 fe ff ff       	call   c0027edc <sort>
}
c0028034:	83 c4 2c             	add    $0x2c,%esp
c0028037:	c3                   	ret    

c0028038 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c0028038:	55                   	push   %ebp
c0028039:	57                   	push   %edi
c002803a:	56                   	push   %esi
c002803b:	53                   	push   %ebx
c002803c:	83 ec 0c             	sub    $0xc,%esp
c002803f:	8b 74 24 24          	mov    0x24(%esp),%esi
c0028043:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c0028047:	89 fd                	mov    %edi,%ebp
c0028049:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c002804e:	01 f5                	add    %esi,%ebp

  while (first < last) 
c0028050:	39 ee                	cmp    %ebp,%esi
c0028052:	72 0d                	jb     c0028061 <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c0028054:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028059:	eb 3c                	jmp    c0028097 <binary_search+0x5f>
      const unsigned char *middle = first + (range / 2) * size;
c002805b:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c002805d:	39 ee                	cmp    %ebp,%esi
c002805f:	73 31                	jae    c0028092 <binary_search+0x5a>
      size_t range = (last - first) / size;
c0028061:	89 e8                	mov    %ebp,%eax
c0028063:	29 f0                	sub    %esi,%eax
c0028065:	ba 00 00 00 00       	mov    $0x0,%edx
c002806a:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c002806c:	d1 e8                	shr    %eax
c002806e:	0f af c7             	imul   %edi,%eax
c0028071:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c0028074:	83 ec 04             	sub    $0x4,%esp
c0028077:	ff 74 24 38          	pushl  0x38(%esp)
c002807b:	53                   	push   %ebx
c002807c:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028080:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c0028084:	83 c4 10             	add    $0x10,%esp
c0028087:	85 c0                	test   %eax,%eax
c0028089:	78 d0                	js     c002805b <binary_search+0x23>
      else if (cmp > 0) 
c002808b:	7e 0a                	jle    c0028097 <binary_search+0x5f>
        first = middle + size;
c002808d:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c0028090:	eb cb                	jmp    c002805d <binary_search+0x25>
  return NULL;
c0028092:	bb 00 00 00 00       	mov    $0x0,%ebx
}
c0028097:	89 d8                	mov    %ebx,%eax
c0028099:	83 c4 0c             	add    $0xc,%esp
c002809c:	5b                   	pop    %ebx
c002809d:	5e                   	pop    %esi
c002809e:	5f                   	pop    %edi
c002809f:	5d                   	pop    %ebp
c00280a0:	c3                   	ret    

c00280a1 <bsearch>:
{
c00280a1:	83 ec 14             	sub    $0x14,%esp
c00280a4:	e8 f2 57 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c00280a9:	05 57 24 01 00       	add    $0x12457,%eax
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00280ae:	8d 54 24 28          	lea    0x28(%esp),%edx
c00280b2:	52                   	push   %edx
c00280b3:	8d 80 0d d8 fe ff    	lea    -0x127f3(%eax),%eax
c00280b9:	50                   	push   %eax
c00280ba:	ff 74 24 2c          	pushl  0x2c(%esp)
c00280be:	ff 74 24 2c          	pushl  0x2c(%esp)
c00280c2:	ff 74 24 2c          	pushl  0x2c(%esp)
c00280c6:	ff 74 24 2c          	pushl  0x2c(%esp)
c00280ca:	e8 69 ff ff ff       	call   c0028038 <binary_search>
}
c00280cf:	83 c4 2c             	add    $0x2c,%esp
c00280d2:	c3                   	ret    

c00280d3 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c00280d3:	56                   	push   %esi
c00280d4:	53                   	push   %ebx
c00280d5:	8b 74 24 0c          	mov    0xc(%esp),%esi
c00280d9:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00280dd:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c00280e1:	85 db                	test   %ebx,%ebx
c00280e3:	74 15                	je     c00280fa <memcpy+0x27>
c00280e5:	01 f3                	add    %esi,%ebx
  unsigned char *dst = dst_;
c00280e7:	89 f2                	mov    %esi,%edx
    *dst++ = *src++;
c00280e9:	83 c1 01             	add    $0x1,%ecx
c00280ec:	83 c2 01             	add    $0x1,%edx
c00280ef:	0f b6 41 ff          	movzbl -0x1(%ecx),%eax
c00280f3:	88 42 ff             	mov    %al,-0x1(%edx)
  while (size-- > 0)
c00280f6:	39 d3                	cmp    %edx,%ebx
c00280f8:	75 ef                	jne    c00280e9 <memcpy+0x16>

  return dst_;
}
c00280fa:	89 f0                	mov    %esi,%eax
c00280fc:	5b                   	pop    %ebx
c00280fd:	5e                   	pop    %esi
c00280fe:	c3                   	ret    

c00280ff <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00280ff:	56                   	push   %esi
c0028100:	53                   	push   %ebx
c0028101:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028105:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0028109:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c002810d:	39 c8                	cmp    %ecx,%eax
c002810f:	73 1d                	jae    c002812e <memmove+0x2f>
    {
      while (size-- > 0)
c0028111:	85 db                	test   %ebx,%ebx
c0028113:	74 16                	je     c002812b <memmove+0x2c>
c0028115:	8d 14 18             	lea    (%eax,%ebx,1),%edx
        *dst++ = *src++;
c0028118:	83 c1 01             	add    $0x1,%ecx
c002811b:	83 c0 01             	add    $0x1,%eax
c002811e:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
c0028122:	88 58 ff             	mov    %bl,-0x1(%eax)
      while (size-- > 0)
c0028125:	39 d0                	cmp    %edx,%eax
c0028127:	75 ef                	jne    c0028118 <memmove+0x19>
        *dst++ = *src++;
c0028129:	89 d0                	mov    %edx,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c002812b:	5b                   	pop    %ebx
c002812c:	5e                   	pop    %esi
c002812d:	c3                   	ret    
      dst += size;
c002812e:	8d 34 18             	lea    (%eax,%ebx,1),%esi
      while (size-- > 0)
c0028131:	8d 53 ff             	lea    -0x1(%ebx),%edx
c0028134:	85 db                	test   %ebx,%ebx
c0028136:	74 11                	je     c0028149 <memmove+0x4a>
        *--dst = *--src;
c0028138:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c002813c:	88 1c 10             	mov    %bl,(%eax,%edx,1)
      while (size-- > 0)
c002813f:	83 ea 01             	sub    $0x1,%edx
c0028142:	83 fa ff             	cmp    $0xffffffff,%edx
c0028145:	75 f1                	jne    c0028138 <memmove+0x39>
c0028147:	eb e2                	jmp    c002812b <memmove+0x2c>
      dst += size;
c0028149:	89 f0                	mov    %esi,%eax
c002814b:	eb de                	jmp    c002812b <memmove+0x2c>

c002814d <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c002814d:	56                   	push   %esi
c002814e:	53                   	push   %ebx
c002814f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028153:	8b 54 24 10          	mov    0x10(%esp),%edx
c0028157:	8b 74 24 14          	mov    0x14(%esp),%esi
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c002815b:	85 f6                	test   %esi,%esi
c002815d:	74 34                	je     c0028193 <memcmp+0x46>
    if (*a != *b)
c002815f:	0f b6 08             	movzbl (%eax),%ecx
c0028162:	0f b6 1a             	movzbl (%edx),%ebx
c0028165:	01 c6                	add    %eax,%esi
c0028167:	38 d9                	cmp    %bl,%cl
c0028169:	75 14                	jne    c002817f <memcmp+0x32>
  for (; size-- > 0; a++, b++)
c002816b:	83 c0 01             	add    $0x1,%eax
c002816e:	83 c2 01             	add    $0x1,%edx
c0028171:	39 c6                	cmp    %eax,%esi
c0028173:	74 17                	je     c002818c <memcmp+0x3f>
    if (*a != *b)
c0028175:	0f b6 08             	movzbl (%eax),%ecx
c0028178:	0f b6 1a             	movzbl (%edx),%ebx
c002817b:	38 d9                	cmp    %bl,%cl
c002817d:	74 ec                	je     c002816b <memcmp+0x1e>
      return *a > *b ? +1 : -1;
c002817f:	38 cb                	cmp    %cl,%bl
c0028181:	19 c0                	sbb    %eax,%eax
c0028183:	83 e0 02             	and    $0x2,%eax
c0028186:	83 e8 01             	sub    $0x1,%eax
  return 0;
}
c0028189:	5b                   	pop    %ebx
c002818a:	5e                   	pop    %esi
c002818b:	c3                   	ret    
  return 0;
c002818c:	b8 00 00 00 00       	mov    $0x0,%eax
c0028191:	eb f6                	jmp    c0028189 <memcmp+0x3c>
c0028193:	b8 00 00 00 00       	mov    $0x0,%eax
c0028198:	eb ef                	jmp    c0028189 <memcmp+0x3c>

c002819a <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c002819a:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002819e:	8b 44 24 08          	mov    0x8(%esp),%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c00281a2:	0f b6 11             	movzbl (%ecx),%edx
c00281a5:	84 d2                	test   %dl,%dl
c00281a7:	74 15                	je     c00281be <strcmp+0x24>
c00281a9:	3a 10                	cmp    (%eax),%dl
c00281ab:	75 11                	jne    c00281be <strcmp+0x24>
    {
      a++;
c00281ad:	83 c1 01             	add    $0x1,%ecx
      b++;
c00281b0:	83 c0 01             	add    $0x1,%eax
  while (*a != '\0' && *a == *b) 
c00281b3:	0f b6 11             	movzbl (%ecx),%edx
c00281b6:	84 d2                	test   %dl,%dl
c00281b8:	74 04                	je     c00281be <strcmp+0x24>
c00281ba:	3a 10                	cmp    (%eax),%dl
c00281bc:	74 ef                	je     c00281ad <strcmp+0x13>
    }

  return *a < *b ? -1 : *a > *b;
c00281be:	0f b6 08             	movzbl (%eax),%ecx
c00281c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00281c6:	38 d1                	cmp    %dl,%cl
c00281c8:	77 06                	ja     c00281d0 <strcmp+0x36>
c00281ca:	0f 92 c0             	setb   %al
c00281cd:	0f b6 c0             	movzbl %al,%eax
}
c00281d0:	c3                   	ret    

c00281d1 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c00281d1:	53                   	push   %ebx
c00281d2:	8b 44 24 08          	mov    0x8(%esp),%eax
c00281d6:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00281da:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c00281de:	85 d2                	test   %edx,%edx
c00281e0:	74 1c                	je     c00281fe <memchr+0x2d>
c00281e2:	89 d9                	mov    %ebx,%ecx
    if (*block == ch)
c00281e4:	3a 18                	cmp    (%eax),%bl
c00281e6:	74 14                	je     c00281fc <memchr+0x2b>
c00281e8:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c00281ea:	83 c0 01             	add    $0x1,%eax
c00281ed:	39 c2                	cmp    %eax,%edx
c00281ef:	74 06                	je     c00281f7 <memchr+0x26>
    if (*block == ch)
c00281f1:	38 08                	cmp    %cl,(%eax)
c00281f3:	75 f5                	jne    c00281ea <memchr+0x19>
c00281f5:	eb 05                	jmp    c00281fc <memchr+0x2b>
      return (void *) block;

  return NULL;
c00281f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00281fc:	5b                   	pop    %ebx
c00281fd:	c3                   	ret    
  return NULL;
c00281fe:	b8 00 00 00 00       	mov    $0x0,%eax
c0028203:	eb f7                	jmp    c00281fc <memchr+0x2b>

c0028205 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0028205:	53                   	push   %ebx
c0028206:	8b 44 24 08          	mov    0x8(%esp),%eax
c002820a:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c002820e:	0f b6 18             	movzbl (%eax),%ebx
c0028211:	38 da                	cmp    %bl,%dl
c0028213:	74 19                	je     c002822e <strchr+0x29>
c0028215:	89 d1                	mov    %edx,%ecx
      return (char *) string;
    else if (*string == '\0')
c0028217:	84 db                	test   %bl,%bl
c0028219:	74 15                	je     c0028230 <strchr+0x2b>
      return NULL;
    else
      string++;
c002821b:	83 c0 01             	add    $0x1,%eax
    if (*string == c)
c002821e:	0f b6 10             	movzbl (%eax),%edx
c0028221:	38 ca                	cmp    %cl,%dl
c0028223:	74 09                	je     c002822e <strchr+0x29>
    else if (*string == '\0')
c0028225:	84 d2                	test   %dl,%dl
c0028227:	75 f2                	jne    c002821b <strchr+0x16>
      return NULL;
c0028229:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002822e:	5b                   	pop    %ebx
c002822f:	c3                   	ret    
      return NULL;
c0028230:	b8 00 00 00 00       	mov    $0x0,%eax
c0028235:	eb f7                	jmp    c002822e <strchr+0x29>

c0028237 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0028237:	57                   	push   %edi
c0028238:	56                   	push   %esi
c0028239:	53                   	push   %ebx
c002823a:	8b 74 24 10          	mov    0x10(%esp),%esi
c002823e:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028242:	0f b6 06             	movzbl (%esi),%eax
c0028245:	84 c0                	test   %al,%al
c0028247:	74 27                	je     c0028270 <strcspn+0x39>
c0028249:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c002824e:	0f be c0             	movsbl %al,%eax
c0028251:	50                   	push   %eax
c0028252:	57                   	push   %edi
c0028253:	e8 ad ff ff ff       	call   c0028205 <strchr>
c0028258:	83 c4 08             	add    $0x8,%esp
c002825b:	85 c0                	test   %eax,%eax
c002825d:	75 0b                	jne    c002826a <strcspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c002825f:	83 c3 01             	add    $0x1,%ebx
c0028262:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0028266:	84 c0                	test   %al,%al
c0028268:	75 e4                	jne    c002824e <strcspn+0x17>
      break;
  return length;
}
c002826a:	89 d8                	mov    %ebx,%eax
c002826c:	5b                   	pop    %ebx
c002826d:	5e                   	pop    %esi
c002826e:	5f                   	pop    %edi
c002826f:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0028270:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0028275:	eb f3                	jmp    c002826a <strcspn+0x33>

c0028277 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c0028277:	56                   	push   %esi
c0028278:	53                   	push   %ebx
c0028279:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002827d:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c0028281:	0f b6 13             	movzbl (%ebx),%edx
c0028284:	84 d2                	test   %dl,%dl
c0028286:	74 1d                	je     c00282a5 <strpbrk+0x2e>
    if (strchr (stop, *string) != NULL)
c0028288:	0f be d2             	movsbl %dl,%edx
c002828b:	52                   	push   %edx
c002828c:	56                   	push   %esi
c002828d:	e8 73 ff ff ff       	call   c0028205 <strchr>
c0028292:	83 c4 08             	add    $0x8,%esp
c0028295:	85 c0                	test   %eax,%eax
c0028297:	75 13                	jne    c00282ac <strpbrk+0x35>
  for (; *string != '\0'; string++)
c0028299:	83 c3 01             	add    $0x1,%ebx
c002829c:	0f b6 13             	movzbl (%ebx),%edx
c002829f:	84 d2                	test   %dl,%dl
c00282a1:	75 e5                	jne    c0028288 <strpbrk+0x11>
c00282a3:	eb 09                	jmp    c00282ae <strpbrk+0x37>
      return (char *) string;
  return NULL;
c00282a5:	b8 00 00 00 00       	mov    $0x0,%eax
c00282aa:	eb 02                	jmp    c00282ae <strpbrk+0x37>
c00282ac:	89 d8                	mov    %ebx,%eax
}
c00282ae:	5b                   	pop    %ebx
c00282af:	5e                   	pop    %esi
c00282b0:	c3                   	ret    

c00282b1 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c00282b1:	53                   	push   %ebx
c00282b2:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c00282b6:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
c00282bb:	0f b6 0a             	movzbl (%edx),%ecx
c00282be:	84 c9                	test   %cl,%cl
c00282c0:	74 16                	je     c00282d8 <strrchr+0x27>
  const char *p = NULL;
c00282c2:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
c00282c7:	38 cb                	cmp    %cl,%bl
c00282c9:	0f 44 c2             	cmove  %edx,%eax
  for (; *string != '\0'; string++)
c00282cc:	83 c2 01             	add    $0x1,%edx
c00282cf:	0f b6 0a             	movzbl (%edx),%ecx
c00282d2:	84 c9                	test   %cl,%cl
c00282d4:	75 f1                	jne    c00282c7 <strrchr+0x16>
      p = string;
  return (char *) p;
}
c00282d6:	5b                   	pop    %ebx
c00282d7:	c3                   	ret    
  const char *p = NULL;
c00282d8:	b8 00 00 00 00       	mov    $0x0,%eax
  return (char *) p;
c00282dd:	eb f7                	jmp    c00282d6 <strrchr+0x25>

c00282df <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c00282df:	57                   	push   %edi
c00282e0:	56                   	push   %esi
c00282e1:	53                   	push   %ebx
c00282e2:	8b 74 24 10          	mov    0x10(%esp),%esi
c00282e6:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c00282ea:	0f b6 06             	movzbl (%esi),%eax
c00282ed:	84 c0                	test   %al,%al
c00282ef:	74 27                	je     c0028318 <strspn+0x39>
c00282f1:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c00282f6:	0f be c0             	movsbl %al,%eax
c00282f9:	50                   	push   %eax
c00282fa:	57                   	push   %edi
c00282fb:	e8 05 ff ff ff       	call   c0028205 <strchr>
c0028300:	83 c4 08             	add    $0x8,%esp
c0028303:	85 c0                	test   %eax,%eax
c0028305:	74 0b                	je     c0028312 <strspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c0028307:	83 c3 01             	add    $0x1,%ebx
c002830a:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c002830e:	84 c0                	test   %al,%al
c0028310:	75 e4                	jne    c00282f6 <strspn+0x17>
      break;
  return length;
}
c0028312:	89 d8                	mov    %ebx,%eax
c0028314:	5b                   	pop    %ebx
c0028315:	5e                   	pop    %esi
c0028316:	5f                   	pop    %edi
c0028317:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0028318:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c002831d:	eb f3                	jmp    c0028312 <strspn+0x33>

c002831f <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c002831f:	55                   	push   %ebp
c0028320:	57                   	push   %edi
c0028321:	56                   	push   %esi
c0028322:	53                   	push   %ebx
c0028323:	83 ec 1c             	sub    $0x1c,%esp
c0028326:	e8 6c 55 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002832b:	81 c3 d5 21 01 00    	add    $0x121d5,%ebx
c0028331:	8b 74 24 30          	mov    0x30(%esp),%esi
c0028335:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c0028339:	85 ff                	test   %edi,%edi
c002833b:	74 33                	je     c0028370 <strtok_r+0x51>
  ASSERT (save_ptr != NULL);
c002833d:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0028342:	74 55                	je     c0028399 <strtok_r+0x7a>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028344:	85 f6                	test   %esi,%esi
c0028346:	74 7a                	je     c00283c2 <strtok_r+0xa3>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0028348:	0f b6 1e             	movzbl (%esi),%ebx
c002834b:	83 ec 08             	sub    $0x8,%esp
c002834e:	0f be c3             	movsbl %bl,%eax
c0028351:	50                   	push   %eax
c0028352:	57                   	push   %edi
c0028353:	e8 ad fe ff ff       	call   c0028205 <strchr>
c0028358:	83 c4 10             	add    $0x10,%esp
c002835b:	85 c0                	test   %eax,%eax
c002835d:	0f 84 a9 00 00 00    	je     c002840c <strtok_r+0xed>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0028363:	84 db                	test   %bl,%bl
c0028365:	0f 84 8e 00 00 00    	je     c00283f9 <strtok_r+0xda>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c002836b:	83 c6 01             	add    $0x1,%esi
c002836e:	eb d8                	jmp    c0028348 <strtok_r+0x29>
  ASSERT (delimiters != NULL);
c0028370:	83 ec 0c             	sub    $0xc,%esp
c0028373:	8d 83 de 5c ff ff    	lea    -0xa322(%ebx),%eax
c0028379:	50                   	push   %eax
c002837a:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0028380:	50                   	push   %eax
c0028381:	8d 83 50 40 ff ff    	lea    -0xbfb0(%ebx),%eax
c0028387:	50                   	push   %eax
c0028388:	68 ef 00 00 00       	push   $0xef
c002838d:	8d 83 f1 5c ff ff    	lea    -0xa30f(%ebx),%eax
c0028393:	50                   	push   %eax
c0028394:	e8 4b 0b 00 00       	call   c0028ee4 <debug_panic>
  ASSERT (save_ptr != NULL);
c0028399:	83 ec 0c             	sub    $0xc,%esp
c002839c:	8d 83 04 5d ff ff    	lea    -0xa2fc(%ebx),%eax
c00283a2:	50                   	push   %eax
c00283a3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00283a9:	50                   	push   %eax
c00283aa:	8d 83 50 40 ff ff    	lea    -0xbfb0(%ebx),%eax
c00283b0:	50                   	push   %eax
c00283b1:	68 f0 00 00 00       	push   $0xf0
c00283b6:	8d 83 f1 5c ff ff    	lea    -0xa30f(%ebx),%eax
c00283bc:	50                   	push   %eax
c00283bd:	e8 22 0b 00 00       	call   c0028ee4 <debug_panic>
    s = *save_ptr;
c00283c2:	8b 44 24 38          	mov    0x38(%esp),%eax
c00283c6:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c00283c8:	85 f6                	test   %esi,%esi
c00283ca:	0f 85 78 ff ff ff    	jne    c0028348 <strtok_r+0x29>
c00283d0:	83 ec 0c             	sub    $0xc,%esp
c00283d3:	8d 83 e7 5c ff ff    	lea    -0xa319(%ebx),%eax
c00283d9:	50                   	push   %eax
c00283da:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00283e0:	50                   	push   %eax
c00283e1:	8d 83 50 40 ff ff    	lea    -0xbfb0(%ebx),%eax
c00283e7:	50                   	push   %eax
c00283e8:	68 f6 00 00 00       	push   $0xf6
c00283ed:	8d 83 f1 5c ff ff    	lea    -0xa30f(%ebx),%eax
c00283f3:	50                   	push   %eax
c00283f4:	e8 eb 0a 00 00       	call   c0028ee4 <debug_panic>
          *save_ptr = s;
c00283f9:	8b 44 24 38          	mov    0x38(%esp),%eax
c00283fd:	89 30                	mov    %esi,(%eax)
          return NULL;
c00283ff:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c0028404:	83 c4 1c             	add    $0x1c,%esp
c0028407:	5b                   	pop    %ebx
c0028408:	5e                   	pop    %esi
c0028409:	5f                   	pop    %edi
c002840a:	5d                   	pop    %ebp
c002840b:	c3                   	ret    
c002840c:	89 f3                	mov    %esi,%ebx
c002840e:	eb 02                	jmp    c0028412 <strtok_r+0xf3>
    s++;
c0028410:	89 eb                	mov    %ebp,%ebx
c0028412:	8d 6b 01             	lea    0x1(%ebx),%ebp
  while (strchr (delimiters, *s) == NULL)
c0028415:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0028419:	88 44 24 0f          	mov    %al,0xf(%esp)
c002841d:	83 ec 08             	sub    $0x8,%esp
c0028420:	0f be c0             	movsbl %al,%eax
c0028423:	50                   	push   %eax
c0028424:	57                   	push   %edi
c0028425:	e8 db fd ff ff       	call   c0028205 <strchr>
c002842a:	83 c4 10             	add    $0x10,%esp
c002842d:	85 c0                	test   %eax,%eax
c002842f:	74 df                	je     c0028410 <strtok_r+0xf1>
  if (*s != '\0') 
c0028431:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0028436:	74 11                	je     c0028449 <strtok_r+0x12a>
      *s = '\0';
c0028438:	c6 45 00 00          	movb   $0x0,0x0(%ebp)
      *save_ptr = s + 1;
c002843c:	83 c3 02             	add    $0x2,%ebx
c002843f:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028443:	89 18                	mov    %ebx,(%eax)
c0028445:	89 f0                	mov    %esi,%eax
c0028447:	eb bb                	jmp    c0028404 <strtok_r+0xe5>
    *save_ptr = s;
c0028449:	8b 44 24 38          	mov    0x38(%esp),%eax
c002844d:	89 28                	mov    %ebp,(%eax)
c002844f:	89 f0                	mov    %esi,%eax
c0028451:	eb b1                	jmp    c0028404 <strtok_r+0xe5>

c0028453 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028453:	53                   	push   %ebx
c0028454:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028458:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002845c:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0028460:	85 c9                	test   %ecx,%ecx
c0028462:	74 0e                	je     c0028472 <memset+0x1f>
c0028464:	01 c1                	add    %eax,%ecx
  unsigned char *dst = dst_;
c0028466:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c0028468:	83 c2 01             	add    $0x1,%edx
c002846b:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c002846e:	39 d1                	cmp    %edx,%ecx
c0028470:	75 f6                	jne    c0028468 <memset+0x15>

  return dst_;
}
c0028472:	5b                   	pop    %ebx
c0028473:	c3                   	ret    

c0028474 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0028474:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c0028478:	89 d0                	mov    %edx,%eax
c002847a:	80 3a 00             	cmpb   $0x0,(%edx)
c002847d:	75 03                	jne    c0028482 <strlen+0xe>
    continue;
  return p - string;
c002847f:	29 d0                	sub    %edx,%eax
}
c0028481:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c0028482:	83 c0 01             	add    $0x1,%eax
c0028485:	80 38 00             	cmpb   $0x0,(%eax)
c0028488:	74 f5                	je     c002847f <strlen+0xb>
c002848a:	eb f6                	jmp    c0028482 <strlen+0xe>

c002848c <strstr>:
{
c002848c:	55                   	push   %ebp
c002848d:	57                   	push   %edi
c002848e:	56                   	push   %esi
c002848f:	53                   	push   %ebx
c0028490:	83 ec 04             	sub    $0x4,%esp
c0028493:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c0028497:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002849c:	b8 00 00 00 00       	mov    $0x0,%eax
c00284a1:	89 d9                	mov    %ebx,%ecx
c00284a3:	8b 7c 24 18          	mov    0x18(%esp),%edi
c00284a7:	f2 ae                	repnz scas %es:(%edi),%al
c00284a9:	f7 d1                	not    %ecx
c00284ab:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c00284ae:	89 d9                	mov    %ebx,%ecx
c00284b0:	89 ef                	mov    %ebp,%edi
c00284b2:	f2 ae                	repnz scas %es:(%edi),%al
c00284b4:	89 c8                	mov    %ecx,%eax
c00284b6:	f7 d0                	not    %eax
c00284b8:	8d 70 ff             	lea    -0x1(%eax),%esi
  return NULL;
c00284bb:	bf 00 00 00 00       	mov    $0x0,%edi
  if (haystack_len >= needle_len) 
c00284c0:	39 f2                	cmp    %esi,%edx
c00284c2:	72 2c                	jb     c00284f0 <strstr+0x64>
      for (i = 0; i <= haystack_len - needle_len; i++)
c00284c4:	29 f2                	sub    %esi,%edx
c00284c6:	89 14 24             	mov    %edx,(%esp)
c00284c9:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (!memcmp (haystack + i, needle, needle_len))
c00284ce:	89 df                	mov    %ebx,%edi
c00284d0:	03 7c 24 18          	add    0x18(%esp),%edi
c00284d4:	56                   	push   %esi
c00284d5:	55                   	push   %ebp
c00284d6:	57                   	push   %edi
c00284d7:	e8 71 fc ff ff       	call   c002814d <memcmp>
c00284dc:	83 c4 0c             	add    $0xc,%esp
c00284df:	85 c0                	test   %eax,%eax
c00284e1:	74 0d                	je     c00284f0 <strstr+0x64>
      for (i = 0; i <= haystack_len - needle_len; i++)
c00284e3:	83 c3 01             	add    $0x1,%ebx
c00284e6:	3b 1c 24             	cmp    (%esp),%ebx
c00284e9:	76 e3                	jbe    c00284ce <strstr+0x42>
  return NULL;
c00284eb:	bf 00 00 00 00       	mov    $0x0,%edi
}
c00284f0:	89 f8                	mov    %edi,%eax
c00284f2:	83 c4 04             	add    $0x4,%esp
c00284f5:	5b                   	pop    %ebx
c00284f6:	5e                   	pop    %esi
c00284f7:	5f                   	pop    %edi
c00284f8:	5d                   	pop    %ebp
c00284f9:	c3                   	ret    

c00284fa <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00284fa:	8b 54 24 04          	mov    0x4(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00284fe:	80 3a 00             	cmpb   $0x0,(%edx)
c0028501:	74 07                	je     c002850a <strnlen+0x10>
c0028503:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028508:	75 06                	jne    c0028510 <strnlen+0x16>
c002850a:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
c002850f:	c3                   	ret    
  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028510:	b8 00 00 00 00       	mov    $0x0,%eax
c0028515:	83 c0 01             	add    $0x1,%eax
c0028518:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c002851c:	74 f1                	je     c002850f <strnlen+0x15>
c002851e:	39 44 24 08          	cmp    %eax,0x8(%esp)
c0028522:	76 eb                	jbe    c002850f <strnlen+0x15>
c0028524:	eb ef                	jmp    c0028515 <strnlen+0x1b>

c0028526 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0028526:	55                   	push   %ebp
c0028527:	57                   	push   %edi
c0028528:	56                   	push   %esi
c0028529:	53                   	push   %ebx
c002852a:	83 ec 0c             	sub    $0xc,%esp
c002852d:	e8 65 53 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0028532:	81 c3 ce 1f 01 00    	add    $0x11fce,%ebx
c0028538:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002853c:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c0028540:	85 ed                	test   %ebp,%ebp
c0028542:	74 49                	je     c002858d <strlcpy+0x67>
  ASSERT (src != NULL);
c0028544:	85 d2                	test   %edx,%edx
c0028546:	74 6e                	je     c00285b6 <strlcpy+0x90>

  src_len = strlen (src);
c0028548:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002854d:	b8 00 00 00 00       	mov    $0x0,%eax
c0028552:	89 d7                	mov    %edx,%edi
c0028554:	f2 ae                	repnz scas %es:(%edi),%al
c0028556:	89 ce                	mov    %ecx,%esi
c0028558:	f7 d6                	not    %esi
c002855a:	8d 76 ff             	lea    -0x1(%esi),%esi
  if (size > 0) 
c002855d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0028562:	74 1f                	je     c0028583 <strlcpy+0x5d>
    {
      size_t dst_len = size - 1;
c0028564:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028568:	8d 78 ff             	lea    -0x1(%eax),%edi
      if (src_len < dst_len)
c002856b:	39 fe                	cmp    %edi,%esi
c002856d:	0f 46 fe             	cmovbe %esi,%edi
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c0028570:	83 ec 04             	sub    $0x4,%esp
c0028573:	57                   	push   %edi
c0028574:	52                   	push   %edx
c0028575:	55                   	push   %ebp
c0028576:	e8 58 fb ff ff       	call   c00280d3 <memcpy>
      dst[dst_len] = '\0';
c002857b:	c6 44 3d 00 00       	movb   $0x0,0x0(%ebp,%edi,1)
c0028580:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
c0028583:	89 f0                	mov    %esi,%eax
c0028585:	83 c4 0c             	add    $0xc,%esp
c0028588:	5b                   	pop    %ebx
c0028589:	5e                   	pop    %esi
c002858a:	5f                   	pop    %edi
c002858b:	5d                   	pop    %ebp
c002858c:	c3                   	ret    
  ASSERT (dst != NULL);
c002858d:	83 ec 0c             	sub    $0xc,%esp
c0028590:	8d 83 15 5d ff ff    	lea    -0xa2eb(%ebx),%eax
c0028596:	50                   	push   %eax
c0028597:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002859d:	50                   	push   %eax
c002859e:	8d 83 48 40 ff ff    	lea    -0xbfb8(%ebx),%eax
c00285a4:	50                   	push   %eax
c00285a5:	68 4a 01 00 00       	push   $0x14a
c00285aa:	8d 83 f1 5c ff ff    	lea    -0xa30f(%ebx),%eax
c00285b0:	50                   	push   %eax
c00285b1:	e8 2e 09 00 00       	call   c0028ee4 <debug_panic>
  ASSERT (src != NULL);
c00285b6:	83 ec 0c             	sub    $0xc,%esp
c00285b9:	8d 83 21 5d ff ff    	lea    -0xa2df(%ebx),%eax
c00285bf:	50                   	push   %eax
c00285c0:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00285c6:	50                   	push   %eax
c00285c7:	8d 83 48 40 ff ff    	lea    -0xbfb8(%ebx),%eax
c00285cd:	50                   	push   %eax
c00285ce:	68 4b 01 00 00       	push   $0x14b
c00285d3:	8d 83 f1 5c ff ff    	lea    -0xa30f(%ebx),%eax
c00285d9:	50                   	push   %eax
c00285da:	e8 05 09 00 00       	call   c0028ee4 <debug_panic>

c00285df <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c00285df:	55                   	push   %ebp
c00285e0:	57                   	push   %edi
c00285e1:	56                   	push   %esi
c00285e2:	53                   	push   %ebx
c00285e3:	83 ec 1c             	sub    $0x1c,%esp
c00285e6:	e8 ac 52 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00285eb:	81 c3 15 1f 01 00    	add    $0x11f15,%ebx
c00285f1:	8b 54 24 34          	mov    0x34(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c00285f5:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c00285fa:	74 75                	je     c0028671 <strlcat+0x92>
  ASSERT (src != NULL);
c00285fc:	85 d2                	test   %edx,%edx
c00285fe:	0f 84 96 00 00 00    	je     c002869a <strlcat+0xbb>

  src_len = strlen (src);
c0028604:	be ff ff ff ff       	mov    $0xffffffff,%esi
c0028609:	b8 00 00 00 00       	mov    $0x0,%eax
c002860e:	89 f1                	mov    %esi,%ecx
c0028610:	89 d7                	mov    %edx,%edi
c0028612:	f2 ae                	repnz scas %es:(%edi),%al
c0028614:	f7 d1                	not    %ecx
c0028616:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
c0028619:	89 f1                	mov    %esi,%ecx
c002861b:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002861f:	f2 ae                	repnz scas %es:(%edi),%al
c0028621:	89 ce                	mov    %ecx,%esi
c0028623:	f7 d6                	not    %esi
c0028625:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size) 
c0028628:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002862d:	74 36                	je     c0028665 <strlcat+0x86>
c002862f:	3b 74 24 38          	cmp    0x38(%esp),%esi
c0028633:	73 30                	jae    c0028665 <strlcat+0x86>
    {
      size_t copy_cnt = size - dst_len - 1;
c0028635:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028639:	83 e8 01             	sub    $0x1,%eax
c002863c:	29 f0                	sub    %esi,%eax
      if (src_len < copy_cnt)
c002863e:	39 c5                	cmp    %eax,%ebp
c0028640:	0f 46 c5             	cmovbe %ebp,%eax
c0028643:	89 c7                	mov    %eax,%edi
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c0028645:	89 f0                	mov    %esi,%eax
c0028647:	03 44 24 30          	add    0x30(%esp),%eax
c002864b:	83 ec 04             	sub    $0x4,%esp
c002864e:	57                   	push   %edi
c002864f:	52                   	push   %edx
c0028650:	89 44 24 18          	mov    %eax,0x18(%esp)
c0028654:	50                   	push   %eax
c0028655:	e8 79 fa ff ff       	call   c00280d3 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
c002865a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002865e:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
c0028662:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
c0028665:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
}
c0028669:	83 c4 1c             	add    $0x1c,%esp
c002866c:	5b                   	pop    %ebx
c002866d:	5e                   	pop    %esi
c002866e:	5f                   	pop    %edi
c002866f:	5d                   	pop    %ebp
c0028670:	c3                   	ret    
  ASSERT (dst != NULL);
c0028671:	83 ec 0c             	sub    $0xc,%esp
c0028674:	8d 83 15 5d ff ff    	lea    -0xa2eb(%ebx),%eax
c002867a:	50                   	push   %eax
c002867b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0028681:	50                   	push   %eax
c0028682:	8d 83 40 40 ff ff    	lea    -0xbfc0(%ebx),%eax
c0028688:	50                   	push   %eax
c0028689:	68 68 01 00 00       	push   $0x168
c002868e:	8d 83 f1 5c ff ff    	lea    -0xa30f(%ebx),%eax
c0028694:	50                   	push   %eax
c0028695:	e8 4a 08 00 00       	call   c0028ee4 <debug_panic>
  ASSERT (src != NULL);
c002869a:	83 ec 0c             	sub    $0xc,%esp
c002869d:	8d 83 21 5d ff ff    	lea    -0xa2df(%ebx),%eax
c00286a3:	50                   	push   %eax
c00286a4:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00286aa:	50                   	push   %eax
c00286ab:	8d 83 40 40 ff ff    	lea    -0xbfc0(%ebx),%eax
c00286b1:	50                   	push   %eax
c00286b2:	68 69 01 00 00       	push   $0x169
c00286b7:	8d 83 f1 5c ff ff    	lea    -0xa30f(%ebx),%eax
c00286bd:	50                   	push   %eax
c00286be:	e8 21 08 00 00       	call   c0028ee4 <debug_panic>

c00286c3 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c00286c3:	55                   	push   %ebp
c00286c4:	57                   	push   %edi
c00286c5:	56                   	push   %esi
c00286c6:	53                   	push   %ebx
c00286c7:	83 ec 1c             	sub    $0x1c,%esp
c00286ca:	89 44 24 08          	mov    %eax,0x8(%esp)
c00286ce:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00286d2:	8b 44 24 30          	mov    0x30(%esp),%eax
c00286d6:	8b 54 24 34          	mov    0x34(%esp),%edx
c00286da:	89 04 24             	mov    %eax,(%esp)
c00286dd:	89 54 24 04          	mov    %edx,0x4(%esp)
  if ((d >> 32) == 0) 
c00286e1:	85 d2                	test   %edx,%edx
c00286e3:	0f 84 08 01 00 00    	je     c00287f1 <udiv64+0x12e>
c00286e9:	89 d0                	mov    %edx,%eax
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c00286eb:	8b 7c 24 08          	mov    0x8(%esp),%edi
c00286ef:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00286f3:	8b 1c 24             	mov    (%esp),%ebx
c00286f6:	8b 74 24 04          	mov    0x4(%esp),%esi
c00286fa:	39 df                	cmp    %ebx,%edi
c00286fc:	89 ef                	mov    %ebp,%edi
c00286fe:	19 f7                	sbb    %esi,%edi
        return 0;
c0028700:	b9 00 00 00 00       	mov    $0x0,%ecx
c0028705:	bb 00 00 00 00       	mov    $0x0,%ebx
      if (n < d)
c002870a:	0f 82 33 01 00 00    	jb     c0028843 <udiv64+0x180>
  if (x <= 0x0000FFFF)
c0028710:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
c0028716:	77 0a                	ja     c0028722 <udiv64+0x5f>
      x <<= 16; 
c0028718:	c1 e0 10             	shl    $0x10,%eax
c002871b:	89 c2                	mov    %eax,%edx
      n += 16;
c002871d:	b9 10 00 00 00       	mov    $0x10,%ecx
  if (x <= 0x00FFFFFF)
c0028722:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
c0028728:	77 06                	ja     c0028730 <udiv64+0x6d>
      n += 8;
c002872a:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c002872d:	c1 e2 08             	shl    $0x8,%edx
  if (x <= 0x0FFFFFFF)
c0028730:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0028736:	77 06                	ja     c002873e <udiv64+0x7b>
      n += 4;
c0028738:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c002873b:	c1 e2 04             	shl    $0x4,%edx
  if (x <= 0x3FFFFFFF)
c002873e:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
c0028744:	77 06                	ja     c002874c <udiv64+0x89>
      n += 2;
c0028746:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c0028749:	c1 e2 02             	shl    $0x2,%edx
    n++;
c002874c:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
c0028752:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c0028755:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0028759:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c002875d:	89 ea                	mov    %ebp,%edx
c002875f:	d1 ea                	shr    %edx
c0028761:	89 d3                	mov    %edx,%ebx
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028763:	89 f8                	mov    %edi,%eax
c0028765:	89 ea                	mov    %ebp,%edx
c0028767:	0f ac e8 01          	shrd   $0x1,%ebp,%eax
c002876b:	d1 ea                	shr    %edx
c002876d:	89 44 24 10          	mov    %eax,0x10(%esp)
c0028771:	89 54 24 14          	mov    %edx,0x14(%esp)
c0028775:	8b 34 24             	mov    (%esp),%esi
c0028778:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002877c:	0f a5 f7             	shld   %cl,%esi,%edi
c002877f:	d3 e6                	shl    %cl,%esi
c0028781:	f6 c1 20             	test   $0x20,%cl
c0028784:	74 02                	je     c0028788 <udiv64+0xc5>
c0028786:	89 f7                	mov    %esi,%edi
  asm ("divl %4"
c0028788:	89 da                	mov    %ebx,%edx
c002878a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002878e:	f7 f7                	div    %edi
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028790:	ba 1f 00 00 00       	mov    $0x1f,%edx
c0028795:	29 ca                	sub    %ecx,%edx
c0028797:	89 d1                	mov    %edx,%ecx
c0028799:	d3 e8                	shr    %cl,%eax
c002879b:	89 c1                	mov    %eax,%ecx
c002879d:	bb 00 00 00 00       	mov    $0x0,%ebx
          return n - (q - 1) * d < d ? q - 1 : q; 
c00287a2:	89 44 24 10          	mov    %eax,0x10(%esp)
c00287a6:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c00287aa:	83 c1 ff             	add    $0xffffffff,%ecx
c00287ad:	83 d3 ff             	adc    $0xffffffff,%ebx
c00287b0:	89 dd                	mov    %ebx,%ebp
c00287b2:	8b 34 24             	mov    (%esp),%esi
c00287b5:	8b 7c 24 04          	mov    0x4(%esp),%edi
c00287b9:	0f af ee             	imul   %esi,%ebp
c00287bc:	89 f8                	mov    %edi,%eax
c00287be:	0f af c1             	imul   %ecx,%eax
c00287c1:	01 c5                	add    %eax,%ebp
c00287c3:	89 c8                	mov    %ecx,%eax
c00287c5:	f7 24 24             	mull   (%esp)
c00287c8:	01 ea                	add    %ebp,%edx
c00287ca:	8b 7c 24 08          	mov    0x8(%esp),%edi
c00287ce:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00287d2:	29 c7                	sub    %eax,%edi
c00287d4:	19 d5                	sbb    %edx,%ebp
c00287d6:	89 f8                	mov    %edi,%eax
c00287d8:	8b 34 24             	mov    (%esp),%esi
c00287db:	8b 7c 24 04          	mov    0x4(%esp),%edi
c00287df:	39 f0                	cmp    %esi,%eax
c00287e1:	89 e8                	mov    %ebp,%eax
c00287e3:	19 f8                	sbb    %edi,%eax
c00287e5:	72 5c                	jb     c0028843 <udiv64+0x180>
c00287e7:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00287eb:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c00287ef:	eb 52                	jmp    c0028843 <udiv64+0x180>
      uint32_t n1 = n >> 32;
c00287f1:	8b 7c 24 08          	mov    0x8(%esp),%edi
c00287f5:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00287f9:	89 e8                	mov    %ebp,%eax
      uint32_t d0 = d;
c00287fb:	8b 0c 24             	mov    (%esp),%ecx
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c00287fe:	ba 00 00 00 00       	mov    $0x0,%edx
c0028803:	f7 f1                	div    %ecx
c0028805:	89 c1                	mov    %eax,%ecx
c0028807:	89 d3                	mov    %edx,%ebx
c0028809:	89 da                	mov    %ebx,%edx
c002880b:	b8 00 00 00 00       	mov    $0x0,%eax
c0028810:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0028814:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002881b:	00 
c002881c:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0028820:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0028824:	01 c3                	add    %eax,%ebx
c0028826:	11 d6                	adc    %edx,%esi
  asm ("divl %4"
c0028828:	89 f2                	mov    %esi,%edx
c002882a:	89 d8                	mov    %ebx,%eax
c002882c:	f7 34 24             	divl   (%esp)
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c002882f:	89 cd                	mov    %ecx,%ebp
c0028831:	bf 00 00 00 00       	mov    $0x0,%edi
c0028836:	89 f9                	mov    %edi,%ecx
c0028838:	89 eb                	mov    %ebp,%ebx
c002883a:	ba 00 00 00 00       	mov    $0x0,%edx
c002883f:	01 c1                	add    %eax,%ecx
c0028841:	11 d3                	adc    %edx,%ebx
        }
    }
}
c0028843:	89 c8                	mov    %ecx,%eax
c0028845:	89 da                	mov    %ebx,%edx
c0028847:	83 c4 1c             	add    $0x1c,%esp
c002884a:	5b                   	pop    %ebx
c002884b:	5e                   	pop    %esi
c002884c:	5f                   	pop    %edi
c002884d:	5d                   	pop    %ebp
c002884e:	c3                   	ret    

c002884f <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c002884f:	57                   	push   %edi
c0028850:	56                   	push   %esi
c0028851:	53                   	push   %ebx
c0028852:	83 ec 08             	sub    $0x8,%esp
c0028855:	89 04 24             	mov    %eax,(%esp)
c0028858:	89 54 24 04          	mov    %edx,0x4(%esp)
c002885c:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028860:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028864:	85 d2                	test   %edx,%edx
c0028866:	78 2b                	js     c0028893 <sdiv64+0x44>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028868:	89 f1                	mov    %esi,%ecx
c002886a:	89 fb                	mov    %edi,%ebx
c002886c:	85 ff                	test   %edi,%edi
c002886e:	78 2c                	js     c002889c <sdiv64+0x4d>
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028870:	53                   	push   %ebx
c0028871:	51                   	push   %ecx
c0028872:	e8 4c fe ff ff       	call   c00286c3 <udiv64>
c0028877:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c002887a:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002887e:	f7 d1                	not    %ecx
c0028880:	c1 e9 1f             	shr    $0x1f,%ecx
c0028883:	89 fb                	mov    %edi,%ebx
c0028885:	c1 eb 1f             	shr    $0x1f,%ebx
c0028888:	38 d9                	cmp    %bl,%cl
c002888a:	74 19                	je     c00288a5 <sdiv64+0x56>
}
c002888c:	83 c4 08             	add    $0x8,%esp
c002888f:	5b                   	pop    %ebx
c0028890:	5e                   	pop    %esi
c0028891:	5f                   	pop    %edi
c0028892:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028893:	f7 d8                	neg    %eax
c0028895:	83 d2 00             	adc    $0x0,%edx
c0028898:	f7 da                	neg    %edx
c002889a:	eb cc                	jmp    c0028868 <sdiv64+0x19>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c002889c:	f7 d9                	neg    %ecx
c002889e:	83 d3 00             	adc    $0x0,%ebx
c00288a1:	f7 db                	neg    %ebx
c00288a3:	eb cb                	jmp    c0028870 <sdiv64+0x21>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c00288a5:	f7 d8                	neg    %eax
c00288a7:	83 d2 00             	adc    $0x0,%edx
c00288aa:	f7 da                	neg    %edx
c00288ac:	eb de                	jmp    c002888c <sdiv64+0x3d>

c00288ae <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c00288ae:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c00288b1:	ff 74 24 14          	pushl  0x14(%esp)
c00288b5:	ff 74 24 14          	pushl  0x14(%esp)
c00288b9:	8b 44 24 10          	mov    0x10(%esp),%eax
c00288bd:	8b 54 24 14          	mov    0x14(%esp),%edx
c00288c1:	e8 89 ff ff ff       	call   c002884f <sdiv64>
}
c00288c6:	83 c4 0c             	add    $0xc,%esp
c00288c9:	c3                   	ret    

c00288ca <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c00288ca:	57                   	push   %edi
c00288cb:	56                   	push   %esi
c00288cc:	53                   	push   %ebx
c00288cd:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00288d1:	8b 74 24 18          	mov    0x18(%esp),%esi
c00288d5:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c00288d9:	57                   	push   %edi
c00288da:	56                   	push   %esi
c00288db:	89 d8                	mov    %ebx,%eax
c00288dd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c00288e1:	e8 69 ff ff ff       	call   c002884f <sdiv64>
c00288e6:	83 c4 08             	add    $0x8,%esp
c00288e9:	0f af c6             	imul   %esi,%eax
c00288ec:	29 c3                	sub    %eax,%ebx
  return smod64 (n, d);
c00288ee:	89 d8                	mov    %ebx,%eax
c00288f0:	99                   	cltd   
}
c00288f1:	5b                   	pop    %ebx
c00288f2:	5e                   	pop    %esi
c00288f3:	5f                   	pop    %edi
c00288f4:	c3                   	ret    

c00288f5 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c00288f5:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c00288f8:	ff 74 24 14          	pushl  0x14(%esp)
c00288fc:	ff 74 24 14          	pushl  0x14(%esp)
c0028900:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028904:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028908:	e8 b6 fd ff ff       	call   c00286c3 <udiv64>
}
c002890d:	83 c4 0c             	add    $0xc,%esp
c0028910:	c3                   	ret    

c0028911 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0028911:	57                   	push   %edi
c0028912:	56                   	push   %esi
c0028913:	53                   	push   %ebx
c0028914:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028918:	8b 74 24 18          	mov    0x18(%esp),%esi
c002891c:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c0028920:	57                   	push   %edi
c0028921:	56                   	push   %esi
c0028922:	89 d8                	mov    %ebx,%eax
c0028924:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028928:	e8 96 fd ff ff       	call   c00286c3 <udiv64>
c002892d:	83 c4 08             	add    $0x8,%esp
c0028930:	0f af c6             	imul   %esi,%eax
c0028933:	29 c3                	sub    %eax,%ebx
  return umod64 (n, d);
c0028935:	89 d8                	mov    %ebx,%eax
c0028937:	ba 00 00 00 00       	mov    $0x0,%edx
}
c002893c:	5b                   	pop    %ebx
c002893d:	5e                   	pop    %esi
c002893e:	5f                   	pop    %edi
c002893f:	c3                   	ret    

c0028940 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0028940:	55                   	push   %ebp
c0028941:	57                   	push   %edi
c0028942:	56                   	push   %esi
c0028943:	53                   	push   %ebx
c0028944:	83 ec 04             	sub    $0x4,%esp
c0028947:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
c002894a:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0028950:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ofs = 0; ofs < size; ofs++)
c0028955:	85 d2                	test   %edx,%edx
c0028957:	74 4d                	je     c00289a6 <parse_octal_field+0x66>
      char c = s[ofs];
c0028959:	8b 04 24             	mov    (%esp),%eax
c002895c:	0f b6 18             	movzbl (%eax),%ebx
      if (c >= '0' && c <= '7')
c002895f:	8d 6b d0             	lea    -0x30(%ebx),%ebp
  for (ofs = 0; ofs < size; ofs++)
c0028962:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
c0028967:	bf 00 00 00 00       	mov    $0x0,%edi
      if (c >= '0' && c <= '7')
c002896c:	89 e8                	mov    %ebp,%eax
c002896e:	3c 07                	cmp    $0x7,%al
c0028970:	77 3c                	ja     c00289ae <parse_octal_field+0x6e>
          *value = c - '0' + *value * 8;
c0028972:	0f be db             	movsbl %bl,%ebx
c0028975:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0028979:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c002897b:	83 c6 01             	add    $0x1,%esi
c002897e:	39 f2                	cmp    %esi,%edx
c0028980:	74 1f                	je     c00289a1 <parse_octal_field+0x61>
      char c = s[ofs];
c0028982:	8b 04 24             	mov    (%esp),%eax
c0028985:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
      if (c >= '0' && c <= '7')
c0028989:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c002898c:	89 e8                	mov    %ebp,%eax
c002898e:	3c 07                	cmp    $0x7,%al
c0028990:	77 1c                	ja     c00289ae <parse_octal_field+0x6e>
          if (*value > ULONG_MAX / 8)
c0028992:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0028998:	76 d8                	jbe    c0028972 <parse_octal_field+0x32>
              return false;
c002899a:	b8 00 00 00 00       	mov    $0x0,%eax
c002899f:	eb 05                	jmp    c00289a6 <parse_octal_field+0x66>
  return false;
c00289a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00289a6:	83 c4 04             	add    $0x4,%esp
c00289a9:	5b                   	pop    %ebx
c00289aa:	5e                   	pop    %esi
c00289ab:	5f                   	pop    %edi
c00289ac:	5d                   	pop    %ebp
c00289ad:	c3                   	ret    
          return false;
c00289ae:	b8 00 00 00 00       	mov    $0x0,%eax
      else if (c == ' ' || c == '\0')
c00289b3:	f6 c3 df             	test   $0xdf,%bl
c00289b6:	75 ee                	jne    c00289a6 <parse_octal_field+0x66>
          return ofs > 0;
c00289b8:	85 f6                	test   %esi,%esi
c00289ba:	0f 95 c0             	setne  %al
c00289bd:	eb e7                	jmp    c00289a6 <parse_octal_field+0x66>

c00289bf <strip_antisocial_prefixes>:
{
c00289bf:	55                   	push   %ebp
c00289c0:	57                   	push   %edi
c00289c1:	56                   	push   %esi
c00289c2:	53                   	push   %ebx
c00289c3:	83 ec 1c             	sub    $0x1c,%esp
c00289c6:	e8 cc 4e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00289cb:	81 c3 35 1b 01 00    	add    $0x11b35,%ebx
c00289d1:	89 c5                	mov    %eax,%ebp
         || !memcmp (file_name, "./", 2)
c00289d3:	8d bb 5c 51 ff ff    	lea    -0xaea4(%ebx),%edi
         || !memcmp (file_name, "../", 3))
c00289d9:	8d 83 2d 5d ff ff    	lea    -0xa2d3(%ebx),%eax
c00289df:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (*file_name == '/'
c00289e3:	eb 11                	jmp    c00289f6 <strip_antisocial_prefixes+0x37>
    file_name = strchr (file_name, '/') + 1;
c00289e5:	83 ec 08             	sub    $0x8,%esp
c00289e8:	6a 2f                	push   $0x2f
c00289ea:	55                   	push   %ebp
c00289eb:	e8 15 f8 ff ff       	call   c0028205 <strchr>
c00289f0:	83 c4 10             	add    $0x10,%esp
c00289f3:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c00289f6:	0f b6 75 00          	movzbl 0x0(%ebp),%esi
c00289fa:	89 f0                	mov    %esi,%eax
c00289fc:	3c 2f                	cmp    $0x2f,%al
c00289fe:	74 e5                	je     c00289e5 <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "./", 2)
c0028a00:	83 ec 04             	sub    $0x4,%esp
c0028a03:	6a 02                	push   $0x2
c0028a05:	57                   	push   %edi
c0028a06:	55                   	push   %ebp
c0028a07:	e8 41 f7 ff ff       	call   c002814d <memcmp>
c0028a0c:	83 c4 10             	add    $0x10,%esp
c0028a0f:	85 c0                	test   %eax,%eax
c0028a11:	74 d2                	je     c00289e5 <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "../", 3))
c0028a13:	83 ec 04             	sub    $0x4,%esp
c0028a16:	6a 03                	push   $0x3
c0028a18:	ff 74 24 14          	pushl  0x14(%esp)
c0028a1c:	55                   	push   %ebp
c0028a1d:	e8 2b f7 ff ff       	call   c002814d <memcmp>
c0028a22:	83 c4 10             	add    $0x10,%esp
c0028a25:	85 c0                	test   %eax,%eax
c0028a27:	74 bc                	je     c00289e5 <strip_antisocial_prefixes+0x26>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0028a29:	8d 83 e3 56 ff ff    	lea    -0xa91d(%ebx),%eax
c0028a2f:	89 f2                	mov    %esi,%edx
c0028a31:	84 d2                	test   %dl,%dl
c0028a33:	74 22                	je     c0028a57 <strip_antisocial_prefixes+0x98>
c0028a35:	b9 03 00 00 00       	mov    $0x3,%ecx
c0028a3a:	8d bb e2 56 ff ff    	lea    -0xa91e(%ebx),%edi
c0028a40:	89 ee                	mov    %ebp,%esi
c0028a42:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0028a44:	0f 97 c0             	seta   %al
c0028a47:	1c 00                	sbb    $0x0,%al
c0028a49:	0f be c0             	movsbl %al,%eax
c0028a4c:	85 c0                	test   %eax,%eax
c0028a4e:	8d 83 e3 56 ff ff    	lea    -0xa91d(%ebx),%eax
c0028a54:	0f 45 c5             	cmovne %ebp,%eax
}
c0028a57:	83 c4 1c             	add    $0x1c,%esp
c0028a5a:	5b                   	pop    %ebx
c0028a5b:	5e                   	pop    %esi
c0028a5c:	5f                   	pop    %edi
c0028a5d:	5d                   	pop    %ebp
c0028a5e:	c3                   	ret    

c0028a5f <ustar_make_header>:
{
c0028a5f:	55                   	push   %ebp
c0028a60:	57                   	push   %edi
c0028a61:	56                   	push   %esi
c0028a62:	53                   	push   %ebx
c0028a63:	83 ec 1c             	sub    $0x1c,%esp
c0028a66:	e8 2c 4e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0028a6b:	81 c3 95 1a 01 00    	add    $0x11a95,%ebx
c0028a71:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028a75:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028a79:	83 fd 30             	cmp    $0x30,%ebp
c0028a7c:	0f 94 c2             	sete   %dl
c0028a7f:	83 fd 35             	cmp    $0x35,%ebp
c0028a82:	0f 94 c0             	sete   %al
c0028a85:	08 c2                	or     %al,%dl
c0028a87:	88 54 24 0f          	mov    %dl,0xf(%esp)
c0028a8b:	0f 84 77 01 00 00    	je     c0028c08 <ustar_make_header+0x1a9>
  file_name = strip_antisocial_prefixes (file_name);
c0028a91:	8b 44 24 30          	mov    0x30(%esp),%eax
c0028a95:	e8 25 ff ff ff       	call   c00289bf <strip_antisocial_prefixes>
c0028a9a:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0028a9c:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028aa1:	b8 00 00 00 00       	mov    $0x0,%eax
c0028aa6:	89 d7                	mov    %edx,%edi
c0028aa8:	f2 ae                	repnz scas %es:(%edi),%al
c0028aaa:	f7 d1                	not    %ecx
c0028aac:	83 e9 01             	sub    $0x1,%ecx
c0028aaf:	83 f9 63             	cmp    $0x63,%ecx
c0028ab2:	0f 87 76 01 00 00    	ja     c0028c2e <ustar_make_header+0x1cf>
  memset (h, 0, sizeof *h);
c0028ab8:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0028abe:	c7 86 fc 01 00 00 00 	movl   $0x0,0x1fc(%esi)
c0028ac5:	00 00 00 
c0028ac8:	8d 7e 04             	lea    0x4(%esi),%edi
c0028acb:	83 e7 fc             	and    $0xfffffffc,%edi
c0028ace:	89 f1                	mov    %esi,%ecx
c0028ad0:	29 f9                	sub    %edi,%ecx
c0028ad2:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0028ad8:	c1 e9 02             	shr    $0x2,%ecx
c0028adb:	b8 00 00 00 00       	mov    $0x0,%eax
c0028ae0:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028ae2:	83 ec 04             	sub    $0x4,%esp
c0028ae5:	6a 64                	push   $0x64
c0028ae7:	52                   	push   %edx
c0028ae8:	56                   	push   %esi
c0028ae9:	e8 38 fa ff ff       	call   c0028526 <strlcpy>
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028aee:	83 c4 10             	add    $0x10,%esp
c0028af1:	83 fd 30             	cmp    $0x30,%ebp
c0028af4:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0028af9:	ba ed 01 00 00       	mov    $0x1ed,%edx
c0028afe:	0f 45 c2             	cmovne %edx,%eax
c0028b01:	50                   	push   %eax
c0028b02:	8d 83 5b 5d ff ff    	lea    -0xa2a5(%ebx),%eax
c0028b08:	50                   	push   %eax
c0028b09:	6a 08                	push   $0x8
c0028b0b:	8d 46 64             	lea    0x64(%esi),%eax
c0028b0e:	50                   	push   %eax
c0028b0f:	e8 05 ef ff ff       	call   c0027a19 <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0028b14:	83 c4 0c             	add    $0xc,%esp
c0028b17:	6a 08                	push   $0x8
c0028b19:	8d bb 60 5d ff ff    	lea    -0xa2a0(%ebx),%edi
c0028b1f:	57                   	push   %edi
c0028b20:	8d 46 6c             	lea    0x6c(%esi),%eax
c0028b23:	50                   	push   %eax
c0028b24:	e8 fd f9 ff ff       	call   c0028526 <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0028b29:	83 c4 0c             	add    $0xc,%esp
c0028b2c:	6a 08                	push   $0x8
c0028b2e:	57                   	push   %edi
c0028b2f:	8d 46 74             	lea    0x74(%esi),%eax
c0028b32:	50                   	push   %eax
c0028b33:	e8 ee f9 ff ff       	call   c0028526 <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c0028b38:	ff 74 24 48          	pushl  0x48(%esp)
c0028b3c:	8d bb 68 5d ff ff    	lea    -0xa298(%ebx),%edi
c0028b42:	57                   	push   %edi
c0028b43:	6a 0c                	push   $0xc
c0028b45:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028b48:	50                   	push   %eax
c0028b49:	e8 cb ee ff ff       	call   c0027a19 <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0028b4e:	83 c4 20             	add    $0x20,%esp
c0028b51:	68 00 8c b7 43       	push   $0x43b78c00
c0028b56:	57                   	push   %edi
c0028b57:	6a 0c                	push   $0xc
c0028b59:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0028b5f:	50                   	push   %eax
c0028b60:	e8 b4 ee ff ff       	call   c0027a19 <snprintf>
  h->typeflag = type;
c0028b65:	89 e8                	mov    %ebp,%eax
c0028b67:	88 86 9c 00 00 00    	mov    %al,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0028b6d:	83 c4 0c             	add    $0xc,%esp
c0028b70:	6a 06                	push   $0x6
c0028b72:	8d 83 6e 5d ff ff    	lea    -0xa292(%ebx),%eax
c0028b78:	50                   	push   %eax
c0028b79:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028b7f:	50                   	push   %eax
c0028b80:	e8 a1 f9 ff ff       	call   c0028526 <strlcpy>
  h->version[0] = h->version[1] = '0';
c0028b85:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0028b8c:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c0028b93:	83 c4 0c             	add    $0xc,%esp
c0028b96:	6a 20                	push   $0x20
c0028b98:	8d bb 14 53 ff ff    	lea    -0xacec(%ebx),%edi
c0028b9e:	57                   	push   %edi
c0028b9f:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c0028ba5:	50                   	push   %eax
c0028ba6:	e8 7b f9 ff ff       	call   c0028526 <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0028bab:	83 c4 0c             	add    $0xc,%esp
c0028bae:	6a 20                	push   $0x20
c0028bb0:	57                   	push   %edi
c0028bb1:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0028bb7:	50                   	push   %eax
c0028bb8:	e8 69 f9 ff ff       	call   c0028526 <strlcpy>
c0028bbd:	83 c4 10             	add    $0x10,%esp
c0028bc0:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028bc5:	ba 00 00 00 00       	mov    $0x0,%edx
      chksum += in_chksum_field ? ' ' : header[i];
c0028bca:	bf 20 00 00 00       	mov    $0x20,%edi
c0028bcf:	83 f8 07             	cmp    $0x7,%eax
c0028bd2:	77 74                	ja     c0028c48 <ustar_make_header+0x1e9>
c0028bd4:	89 f9                	mov    %edi,%ecx
c0028bd6:	01 ca                	add    %ecx,%edx
c0028bd8:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028bdb:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028be0:	75 ed                	jne    c0028bcf <ustar_make_header+0x170>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0028be2:	52                   	push   %edx
c0028be3:	8d 83 5b 5d ff ff    	lea    -0xa2a5(%ebx),%eax
c0028be9:	50                   	push   %eax
c0028bea:	6a 08                	push   $0x8
c0028bec:	81 c6 94 00 00 00    	add    $0x94,%esi
c0028bf2:	56                   	push   %esi
c0028bf3:	e8 21 ee ff ff       	call   c0027a19 <snprintf>
  return true;
c0028bf8:	83 c4 10             	add    $0x10,%esp
}
c0028bfb:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c0028c00:	83 c4 1c             	add    $0x1c,%esp
c0028c03:	5b                   	pop    %ebx
c0028c04:	5e                   	pop    %esi
c0028c05:	5f                   	pop    %edi
c0028c06:	5d                   	pop    %ebp
c0028c07:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028c08:	83 ec 0c             	sub    $0xc,%esp
c0028c0b:	8d 83 18 5e ff ff    	lea    -0xa1e8(%ebx),%eax
c0028c11:	50                   	push   %eax
c0028c12:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0028c18:	50                   	push   %eax
c0028c19:	8d 83 5c 40 ff ff    	lea    -0xbfa4(%ebx),%eax
c0028c1f:	50                   	push   %eax
c0028c20:	6a 59                	push   $0x59
c0028c22:	8d 83 31 5d ff ff    	lea    -0xa2cf(%ebx),%eax
c0028c28:	50                   	push   %eax
c0028c29:	e8 b6 02 00 00       	call   c0028ee4 <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028c2e:	83 ec 08             	sub    $0x8,%esp
c0028c31:	52                   	push   %edx
c0028c32:	8d 83 43 5d ff ff    	lea    -0xa2bd(%ebx),%eax
c0028c38:	50                   	push   %eax
c0028c39:	e8 4a e6 ff ff       	call   c0027288 <printf>
      return false;
c0028c3e:	83 c4 10             	add    $0x10,%esp
c0028c41:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
c0028c46:	eb b3                	jmp    c0028bfb <ustar_make_header+0x19c>
      chksum += in_chksum_field ? ' ' : header[i];
c0028c48:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c0028c4f:	00 
c0028c50:	eb 84                	jmp    c0028bd6 <ustar_make_header+0x177>

c0028c52 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0028c52:	57                   	push   %edi
c0028c53:	56                   	push   %esi
c0028c54:	53                   	push   %ebx
c0028c55:	83 ec 10             	sub    $0x10,%esp
c0028c58:	e8 3a 4c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0028c5d:	81 c3 a3 18 01 00    	add    $0x118a3,%ebx
c0028c63:	8b 74 24 20          	mov    0x20(%esp),%esi
  while (cnt-- > 0)
c0028c67:	8d 96 00 02 00 00    	lea    0x200(%esi),%edx
{
c0028c6d:	89 f0                	mov    %esi,%eax
    if (*block++ != 0)
c0028c6f:	83 c0 01             	add    $0x1,%eax
c0028c72:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c0028c76:	0f 85 28 01 00 00    	jne    c0028da4 <ustar_parse_header+0x152>
  while (cnt-- > 0)
c0028c7c:	39 c2                	cmp    %eax,%edx
c0028c7e:	75 ef                	jne    c0028c6f <ustar_parse_header+0x1d>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c0028c80:	8b 44 24 24          	mov    0x24(%esp),%eax
c0028c84:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0028c8a:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028c8e:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0028c94:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0028c98:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0028c9e:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ca3:	e9 3d 01 00 00       	jmp    c0028de5 <ustar_parse_header+0x193>
  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028ca8:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c0028cac:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c0028cb2:	ba 08 00 00 00       	mov    $0x8,%edx
c0028cb7:	e8 84 fc ff ff       	call   c0028940 <parse_octal_field>
    return "corrupt chksum field";
c0028cbc:	8d 93 ee 5d ff ff    	lea    -0xa212(%ebx),%edx
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028cc2:	84 c0                	test   %al,%al
c0028cc4:	0f 84 1b 01 00 00    	je     c0028de5 <ustar_parse_header+0x193>
c0028cca:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028ccf:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0028cd4:	bf 20 00 00 00       	mov    $0x20,%edi
c0028cd9:	83 f8 07             	cmp    $0x7,%eax
c0028cdc:	0f 87 8b 00 00 00    	ja     c0028d6d <ustar_parse_header+0x11b>
c0028ce2:	89 fa                	mov    %edi,%edx
c0028ce4:	01 d1                	add    %edx,%ecx
c0028ce6:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028ce9:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028cee:	75 e9                	jne    c0028cd9 <ustar_parse_header+0x87>
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
c0028cf0:	8d 93 b1 5d ff ff    	lea    -0xa24f(%ebx),%edx
  else if (chksum != calculate_chksum (h))
c0028cf6:	39 4c 24 0c          	cmp    %ecx,0xc(%esp)
c0028cfa:	0f 85 e5 00 00 00    	jne    c0028de5 <ustar_parse_header+0x193>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
    return "file name too long";
c0028d00:	8d 93 c3 5d ff ff    	lea    -0xa23d(%ebx),%edx
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0028d06:	80 7e 63 00          	cmpb   $0x0,0x63(%esi)
c0028d0a:	0f 85 d5 00 00 00    	jne    c0028de5 <ustar_parse_header+0x193>
c0028d10:	80 be 59 01 00 00 00 	cmpb   $0x0,0x159(%esi)
c0028d17:	0f 85 c8 00 00 00    	jne    c0028de5 <ustar_parse_header+0x193>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028d1d:	0f b6 86 9c 00 00 00 	movzbl 0x9c(%esi),%eax
c0028d24:	3c 30                	cmp    $0x30,%al
c0028d26:	74 0e                	je     c0028d36 <ustar_parse_header+0xe4>
    return "unimplemented file type";
c0028d28:	8d 93 d6 5d ff ff    	lea    -0xa22a(%ebx),%edx
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028d2e:	3c 35                	cmp    $0x35,%al
c0028d30:	0f 85 af 00 00 00    	jne    c0028de5 <ustar_parse_header+0x193>
  if (h->typeflag == USTAR_REGULAR)
c0028d36:	3c 30                	cmp    $0x30,%al
c0028d38:	74 40                	je     c0028d7a <ustar_parse_header+0x128>
        return "corrupt file size field";
      else if (size_ul > INT_MAX)
        return "file too large";
    }
  else
    size_ul = 0;
c0028d3a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0028d41:	00 

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0028d42:	89 f0                	mov    %esi,%eax
c0028d44:	e8 76 fc ff ff       	call   c00289bf <strip_antisocial_prefixes>
c0028d49:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028d4d:	89 07                	mov    %eax,(%edi)
  *type = h->typeflag;
c0028d4f:	0f be 86 9c 00 00 00 	movsbl 0x9c(%esi),%eax
c0028d56:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0028d5a:	89 07                	mov    %eax,(%edi)
  *size = size_ul;
c0028d5c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028d60:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0028d64:	89 07                	mov    %eax,(%edi)
  return NULL;
c0028d66:	ba 00 00 00 00       	mov    $0x0,%edx
c0028d6b:	eb 78                	jmp    c0028de5 <ustar_parse_header+0x193>
      chksum += in_chksum_field ? ' ' : header[i];
c0028d6d:	0f b6 94 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%edx
c0028d74:	00 
c0028d75:	e9 6a ff ff ff       	jmp    c0028ce4 <ustar_parse_header+0x92>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028d7a:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0028d7e:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028d81:	ba 0c 00 00 00       	mov    $0xc,%edx
c0028d86:	e8 b5 fb ff ff       	call   c0028940 <parse_octal_field>
        return "corrupt file size field";
c0028d8b:	8d 93 74 5d ff ff    	lea    -0xa28c(%ebx),%edx
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028d91:	84 c0                	test   %al,%al
c0028d93:	74 50                	je     c0028de5 <ustar_parse_header+0x193>
        return "file too large";
c0028d95:	8d 93 8c 5d ff ff    	lea    -0xa274(%ebx),%edx
      else if (size_ul > INT_MAX)
c0028d9b:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028da0:	79 a0                	jns    c0028d42 <ustar_parse_header+0xf0>
c0028da2:	eb 41                	jmp    c0028de5 <ustar_parse_header+0x193>
  if (memcmp (h->magic, "ustar", 6))
c0028da4:	83 ec 04             	sub    $0x4,%esp
c0028da7:	6a 06                	push   $0x6
c0028da9:	8d 83 6e 5d ff ff    	lea    -0xa292(%ebx),%eax
c0028daf:	50                   	push   %eax
c0028db0:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028db6:	50                   	push   %eax
c0028db7:	e8 91 f3 ff ff       	call   c002814d <memcmp>
c0028dbc:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
c0028dbf:	8d 93 03 5e ff ff    	lea    -0xa1fd(%ebx),%edx
  if (memcmp (h->magic, "ustar", 6))
c0028dc5:	85 c0                	test   %eax,%eax
c0028dc7:	75 1c                	jne    c0028de5 <ustar_parse_header+0x193>
    return "invalid ustar version";
c0028dc9:	8d 93 9b 5d ff ff    	lea    -0xa265(%ebx),%edx
  else if (h->version[0] != '0' || h->version[1] != '0')
c0028dcf:	80 be 07 01 00 00 30 	cmpb   $0x30,0x107(%esi)
c0028dd6:	75 0d                	jne    c0028de5 <ustar_parse_header+0x193>
c0028dd8:	80 be 08 01 00 00 30 	cmpb   $0x30,0x108(%esi)
c0028ddf:	0f 84 c3 fe ff ff    	je     c0028ca8 <ustar_parse_header+0x56>
}
c0028de5:	89 d0                	mov    %edx,%eax
c0028de7:	83 c4 10             	add    $0x10,%esp
c0028dea:	5b                   	pop    %ebx
c0028deb:	5e                   	pop    %esi
c0028dec:	5f                   	pop    %edi
c0028ded:	c3                   	ret    

c0028dee <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0028dee:	55                   	push   %ebp
c0028def:	89 e5                	mov    %esp,%ebp
c0028df1:	57                   	push   %edi
c0028df2:	56                   	push   %esi
c0028df3:	53                   	push   %ebx
c0028df4:	83 ec 0c             	sub    $0xc,%esp
c0028df7:	e8 9b 4a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0028dfc:	81 c3 04 17 01 00    	add    $0x11704,%ebx
c0028e02:	8b 75 08             	mov    0x8(%ebp),%esi
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0028e05:	8b 56 04             	mov    0x4(%esi),%edx
    case THREAD_RUNNING:  
      status = "RUNNING";
      break;

    case THREAD_READY:  
      status = "READY";
c0028e08:	8d 83 51 5e ff ff    	lea    -0xa1af(%ebx),%eax
  switch (t->status) {
c0028e0e:	83 fa 01             	cmp    $0x1,%edx
c0028e11:	74 1c                	je     c0028e2f <print_stacktrace+0x41>
      status = "RUNNING";
c0028e13:	8d 83 90 49 ff ff    	lea    -0xb670(%ebx),%eax
  switch (t->status) {
c0028e19:	85 d2                	test   %edx,%edx
c0028e1b:	74 12                	je     c0028e2f <print_stacktrace+0x41>
  const char *status = "UNKNOWN";
c0028e1d:	83 fa 02             	cmp    $0x2,%edx
c0028e20:	8d 83 4a 49 ff ff    	lea    -0xb6b6(%ebx),%eax
c0028e26:	8d 93 49 5e ff ff    	lea    -0xa1b7(%ebx),%edx
c0028e2c:	0f 45 c2             	cmovne %edx,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0028e2f:	83 ec 04             	sub    $0x4,%esp
c0028e32:	50                   	push   %eax
c0028e33:	8d 46 08             	lea    0x8(%esi),%eax
c0028e36:	50                   	push   %eax
c0028e37:	8d 83 74 5e ff ff    	lea    -0xa18c(%ebx),%eax
c0028e3d:	50                   	push   %eax
c0028e3e:	e8 45 e4 ff ff       	call   c0027288 <printf>

  if (t == thread_current()) 
c0028e43:	e8 65 7f ff ff       	call   c0020dad <thread_current>
c0028e48:	83 c4 10             	add    $0x10,%esp
c0028e4b:	39 f0                	cmp    %esi,%eax
c0028e4d:	74 79                	je     c0028ec8 <print_stacktrace+0xda>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0028e4f:	8b 56 18             	mov    0x18(%esi),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0028e52:	81 c6 00 10 00 00    	add    $0x1000,%esi
c0028e58:	39 f2                	cmp    %esi,%edx
c0028e5a:	74 74                	je     c0028ed0 <print_stacktrace+0xe2>
c0028e5c:	8b 42 10             	mov    0x10(%edx),%eax
c0028e5f:	81 f8 6d 19 02 c0    	cmp    $0xc002196d,%eax
c0028e65:	74 69                	je     c0028ed0 <print_stacktrace+0xe2>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c0028e67:	8b 72 08             	mov    0x8(%edx),%esi
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c0028e6a:	83 ec 08             	sub    $0x8,%esp
c0028e6d:	50                   	push   %eax
c0028e6e:	8d 83 46 5b ff ff    	lea    -0xa4ba(%ebx),%eax
c0028e74:	50                   	push   %eax
c0028e75:	e8 0e e4 ff ff       	call   c0027288 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0028e7a:	83 c4 10             	add    $0x10,%esp
c0028e7d:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0028e83:	76 29                	jbe    c0028eae <print_stacktrace+0xc0>
c0028e85:	83 3e 00             	cmpl   $0x0,(%esi)
c0028e88:	74 24                	je     c0028eae <print_stacktrace+0xc0>
    printf (" %p", frame[1]);
c0028e8a:	8d bb 46 5b ff ff    	lea    -0xa4ba(%ebx),%edi
c0028e90:	83 ec 08             	sub    $0x8,%esp
c0028e93:	ff 76 04             	pushl  0x4(%esi)
c0028e96:	57                   	push   %edi
c0028e97:	e8 ec e3 ff ff       	call   c0027288 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0028e9c:	8b 36                	mov    (%esi),%esi
c0028e9e:	83 c4 10             	add    $0x10,%esp
c0028ea1:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0028ea7:	76 05                	jbe    c0028eae <print_stacktrace+0xc0>
c0028ea9:	83 3e 00             	cmpl   $0x0,(%esi)
c0028eac:	75 e2                	jne    c0028e90 <print_stacktrace+0xa2>
  printf (".\n");
c0028eae:	83 ec 0c             	sub    $0xc,%esp
c0028eb1:	8d 83 e3 56 ff ff    	lea    -0xa91d(%ebx),%eax
c0028eb7:	50                   	push   %eax
c0028eb8:	e8 48 1f 00 00       	call   c002ae05 <puts>
c0028ebd:	83 c4 10             	add    $0x10,%esp
}
c0028ec0:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0028ec3:	5b                   	pop    %ebx
c0028ec4:	5e                   	pop    %esi
c0028ec5:	5f                   	pop    %edi
c0028ec6:	5d                   	pop    %ebp
c0028ec7:	c3                   	ret    
      frame = __builtin_frame_address (1);
c0028ec8:	8b 75 00             	mov    0x0(%ebp),%esi
      retaddr = __builtin_return_address (0);
c0028ecb:	8b 45 04             	mov    0x4(%ebp),%eax
c0028ece:	eb 9a                	jmp    c0028e6a <print_stacktrace+0x7c>
          printf (" thread was never scheduled.\n");
c0028ed0:	83 ec 0c             	sub    $0xc,%esp
c0028ed3:	8d 83 57 5e ff ff    	lea    -0xa1a9(%ebx),%eax
c0028ed9:	50                   	push   %eax
c0028eda:	e8 26 1f 00 00       	call   c002ae05 <puts>
          return;
c0028edf:	83 c4 10             	add    $0x10,%esp
c0028ee2:	eb dc                	jmp    c0028ec0 <print_stacktrace+0xd2>

c0028ee4 <debug_panic>:
{
c0028ee4:	55                   	push   %ebp
c0028ee5:	57                   	push   %edi
c0028ee6:	56                   	push   %esi
c0028ee7:	53                   	push   %ebx
c0028ee8:	83 ec 0c             	sub    $0xc,%esp
c0028eeb:	e8 a7 49 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0028ef0:	81 c3 10 16 01 00    	add    $0x11610,%ebx
c0028ef6:	8b 74 24 20          	mov    0x20(%esp),%esi
c0028efa:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028efe:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  intr_disable ();
c0028f02:	e8 1c 8c ff ff       	call   c0021b23 <intr_disable>
  console_panic ();
c0028f07:	e8 78 1e 00 00       	call   c002ad84 <console_panic>
  level++;
c0028f0c:	8b 83 40 1c 00 00    	mov    0x1c40(%ebx),%eax
c0028f12:	83 c0 01             	add    $0x1,%eax
c0028f15:	89 83 40 1c 00 00    	mov    %eax,0x1c40(%ebx)
  if (level == 1) 
c0028f1b:	83 f8 01             	cmp    $0x1,%eax
c0028f1e:	74 11                	je     c0028f31 <debug_panic+0x4d>
  else if (level == 2)
c0028f20:	83 f8 02             	cmp    $0x2,%eax
c0028f23:	74 42                	je     c0028f67 <debug_panic+0x83>
  serial_flush ();
c0028f25:	e8 96 be ff ff       	call   c0024dc0 <serial_flush>
  shutdown ();
c0028f2a:	e8 e8 db ff ff       	call   c0026b17 <shutdown>
  for (;;);
c0028f2f:	eb fe                	jmp    c0028f2f <debug_panic+0x4b>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0028f31:	55                   	push   %ebp
c0028f32:	57                   	push   %edi
c0028f33:	56                   	push   %esi
c0028f34:	8d 83 9c 5e ff ff    	lea    -0xa164(%ebx),%eax
c0028f3a:	50                   	push   %eax
c0028f3b:	e8 48 e3 ff ff       	call   c0027288 <printf>
      va_start (args, message);
c0028f40:	8d 44 24 40          	lea    0x40(%esp),%eax
      vprintf (message, args);
c0028f44:	83 c4 08             	add    $0x8,%esp
c0028f47:	50                   	push   %eax
c0028f48:	ff 74 24 38          	pushl  0x38(%esp)
c0028f4c:	e8 71 1e 00 00       	call   c002adc2 <vprintf>
      printf ("\n");
c0028f51:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0028f58:	e8 1a 1f 00 00       	call   c002ae77 <putchar>
      debug_backtrace ();
c0028f5d:	e8 9c dc ff ff       	call   c0026bfe <debug_backtrace>
c0028f62:	83 c4 10             	add    $0x10,%esp
c0028f65:	eb be                	jmp    c0028f25 <debug_panic+0x41>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c0028f67:	55                   	push   %ebp
c0028f68:	57                   	push   %edi
c0028f69:	56                   	push   %esi
c0028f6a:	8d 83 bc 5e ff ff    	lea    -0xa144(%ebx),%eax
c0028f70:	50                   	push   %eax
c0028f71:	e8 12 e3 ff ff       	call   c0027288 <printf>
c0028f76:	83 c4 10             	add    $0x10,%esp
c0028f79:	eb aa                	jmp    c0028f25 <debug_panic+0x41>

c0028f7b <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0028f7b:	56                   	push   %esi
c0028f7c:	53                   	push   %ebx
c0028f7d:	83 ec 04             	sub    $0x4,%esp
c0028f80:	e8 12 49 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0028f85:	81 c3 7b 15 01 00    	add    $0x1157b,%ebx
  enum intr_level oldlevel = intr_disable ();
c0028f8b:	e8 93 8b ff ff       	call   c0021b23 <intr_disable>
c0028f90:	89 c6                	mov    %eax,%esi

  thread_foreach (print_stacktrace, 0);
c0028f92:	83 ec 08             	sub    $0x8,%esp
c0028f95:	6a 00                	push   $0x0
c0028f97:	8d 83 ee e8 fe ff    	lea    -0x11712(%ebx),%eax
c0028f9d:	50                   	push   %eax
c0028f9e:	e8 02 7f ff ff       	call   c0020ea5 <thread_foreach>
  intr_set_level (oldlevel);
c0028fa3:	89 34 24             	mov    %esi,(%esp)
c0028fa6:	e8 7f 8b ff ff       	call   c0021b2a <intr_set_level>
}
c0028fab:	83 c4 14             	add    $0x14,%esp
c0028fae:	5b                   	pop    %ebx
c0028faf:	5e                   	pop    %esi
c0028fb0:	c3                   	ret    

c0028fb1 <list_init>:
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
}

/* Initializes LIST as an empty list. */
void
list_init(struct list *list) {
c0028fb1:	53                   	push   %ebx
c0028fb2:	83 ec 08             	sub    $0x8,%esp
c0028fb5:	e8 dd 48 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0028fba:	81 c3 46 15 01 00    	add    $0x11546,%ebx
c0028fc0:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0028fc4:	85 c0                	test   %eax,%eax
c0028fc6:	74 1b                	je     c0028fe3 <list_init+0x32>
    list->head.prev = NULL;
c0028fc8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list->head.next = &list->tail;
c0028fce:	8d 50 08             	lea    0x8(%eax),%edx
c0028fd1:	89 50 04             	mov    %edx,0x4(%eax)
    list->tail.prev = &list->head;
c0028fd4:	89 40 08             	mov    %eax,0x8(%eax)
    list->tail.next = NULL;
c0028fd7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0028fde:	83 c4 08             	add    $0x8,%esp
c0028fe1:	5b                   	pop    %ebx
c0028fe2:	c3                   	ret    
    ASSERT (list != NULL);
c0028fe3:	83 ec 0c             	sub    $0xc,%esp
c0028fe6:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c0028fec:	50                   	push   %eax
c0028fed:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0028ff3:	50                   	push   %eax
c0028ff4:	8d 83 58 41 ff ff    	lea    -0xbea8(%ebx),%eax
c0028ffa:	50                   	push   %eax
c0028ffb:	6a 3b                	push   $0x3b
c0028ffd:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029003:	50                   	push   %eax
c0029004:	e8 db fe ff ff       	call   c0028ee4 <debug_panic>

c0029009 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin(struct list *list) {
c0029009:	53                   	push   %ebx
c002900a:	83 ec 08             	sub    $0x8,%esp
c002900d:	e8 85 48 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029012:	81 c3 ee 14 01 00    	add    $0x114ee,%ebx
c0029018:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c002901c:	85 c0                	test   %eax,%eax
c002901e:	74 08                	je     c0029028 <list_begin+0x1f>
    return list->head.next;
c0029020:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029023:	83 c4 08             	add    $0x8,%esp
c0029026:	5b                   	pop    %ebx
c0029027:	c3                   	ret    
    ASSERT (list != NULL);
c0029028:	83 ec 0c             	sub    $0xc,%esp
c002902b:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c0029031:	50                   	push   %eax
c0029032:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029038:	50                   	push   %eax
c0029039:	8d 83 4c 41 ff ff    	lea    -0xbeb4(%ebx),%eax
c002903f:	50                   	push   %eax
c0029040:	6a 45                	push   $0x45
c0029042:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029048:	50                   	push   %eax
c0029049:	e8 96 fe ff ff       	call   c0028ee4 <debug_panic>

c002904e <list_next>:

/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next(struct list_elem *elem) {
c002904e:	53                   	push   %ebx
c002904f:	83 ec 08             	sub    $0x8,%esp
c0029052:	e8 40 48 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029057:	81 c3 a9 14 01 00    	add    $0x114a9,%ebx
c002905d:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029061:	85 c0                	test   %eax,%eax
c0029063:	74 20                	je     c0029085 <list_next+0x37>
c0029065:	83 38 00             	cmpl   $0x0,(%eax)
c0029068:	74 13                	je     c002907d <list_next+0x2f>
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002906a:	83 38 00             	cmpl   $0x0,(%eax)
c002906d:	74 16                	je     c0029085 <list_next+0x37>
c002906f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029073:	74 10                	je     c0029085 <list_next+0x37>
    ASSERT (is_head(elem) || is_interior(elem));
    return elem->next;
c0029075:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029078:	83 c4 08             	add    $0x8,%esp
c002907b:	5b                   	pop    %ebx
c002907c:	c3                   	ret    
    return elem != NULL && elem->prev == NULL && elem->next != NULL;
c002907d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029081:	75 f2                	jne    c0029075 <list_next+0x27>
c0029083:	eb e5                	jmp    c002906a <list_next+0x1c>
    ASSERT (is_head(elem) || is_interior(elem));
c0029085:	83 ec 0c             	sub    $0xc,%esp
c0029088:	8d 83 a4 5f ff ff    	lea    -0xa05c(%ebx),%eax
c002908e:	50                   	push   %eax
c002908f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029095:	50                   	push   %eax
c0029096:	8d 83 40 41 ff ff    	lea    -0xbec0(%ebx),%eax
c002909c:	50                   	push   %eax
c002909d:	6a 4e                	push   $0x4e
c002909f:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c00290a5:	50                   	push   %eax
c00290a6:	e8 39 fe ff ff       	call   c0028ee4 <debug_panic>

c00290ab <list_end>:

   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end(struct list *list) {
c00290ab:	53                   	push   %ebx
c00290ac:	83 ec 08             	sub    $0x8,%esp
c00290af:	e8 e3 47 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00290b4:	81 c3 4c 14 01 00    	add    $0x1144c,%ebx
c00290ba:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c00290be:	85 c0                	test   %eax,%eax
c00290c0:	74 08                	je     c00290ca <list_end+0x1f>
    return &list->tail;
c00290c2:	83 c0 08             	add    $0x8,%eax
}
c00290c5:	83 c4 08             	add    $0x8,%esp
c00290c8:	5b                   	pop    %ebx
c00290c9:	c3                   	ret    
    ASSERT (list != NULL);
c00290ca:	83 ec 0c             	sub    $0xc,%esp
c00290cd:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c00290d3:	50                   	push   %eax
c00290d4:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00290da:	50                   	push   %eax
c00290db:	8d 83 34 41 ff ff    	lea    -0xbecc(%ebx),%eax
c00290e1:	50                   	push   %eax
c00290e2:	6a 59                	push   $0x59
c00290e4:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c00290ea:	50                   	push   %eax
c00290eb:	e8 f4 fd ff ff       	call   c0028ee4 <debug_panic>

c00290f0 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin(struct list *list) {
c00290f0:	53                   	push   %ebx
c00290f1:	83 ec 08             	sub    $0x8,%esp
c00290f4:	e8 9e 47 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00290f9:	81 c3 07 14 01 00    	add    $0x11407,%ebx
c00290ff:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029103:	85 c0                	test   %eax,%eax
c0029105:	74 08                	je     c002910f <list_rbegin+0x1f>
    return list->tail.prev;
c0029107:	8b 40 08             	mov    0x8(%eax),%eax
}
c002910a:	83 c4 08             	add    $0x8,%esp
c002910d:	5b                   	pop    %ebx
c002910e:	c3                   	ret    
    ASSERT (list != NULL);
c002910f:	83 ec 0c             	sub    $0xc,%esp
c0029112:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c0029118:	50                   	push   %eax
c0029119:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002911f:	50                   	push   %eax
c0029120:	8d 83 28 41 ff ff    	lea    -0xbed8(%ebx),%eax
c0029126:	50                   	push   %eax
c0029127:	6a 61                	push   $0x61
c0029129:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002912f:	50                   	push   %eax
c0029130:	e8 af fd ff ff       	call   c0028ee4 <debug_panic>

c0029135 <list_prev>:

/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev(struct list_elem *elem) {
c0029135:	53                   	push   %ebx
c0029136:	83 ec 08             	sub    $0x8,%esp
c0029139:	e8 59 47 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002913e:	81 c3 c2 13 01 00    	add    $0x113c2,%ebx
c0029144:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029148:	85 c0                	test   %eax,%eax
c002914a:	74 1d                	je     c0029169 <list_prev+0x34>
c002914c:	83 38 00             	cmpl   $0x0,(%eax)
c002914f:	74 0d                	je     c002915e <list_prev+0x29>
c0029151:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029155:	74 07                	je     c002915e <list_prev+0x29>
    ASSERT (is_interior(elem) || is_tail(elem));
    return elem->prev;
c0029157:	8b 00                	mov    (%eax),%eax
}
c0029159:	83 c4 08             	add    $0x8,%esp
c002915c:	5b                   	pop    %ebx
c002915d:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002915e:	83 38 00             	cmpl   $0x0,(%eax)
c0029161:	74 06                	je     c0029169 <list_prev+0x34>
c0029163:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029167:	74 ee                	je     c0029157 <list_prev+0x22>
    ASSERT (is_interior(elem) || is_tail(elem));
c0029169:	83 ec 0c             	sub    $0xc,%esp
c002916c:	8d 83 c8 5f ff ff    	lea    -0xa038(%ebx),%eax
c0029172:	50                   	push   %eax
c0029173:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029179:	50                   	push   %eax
c002917a:	8d 83 1c 41 ff ff    	lea    -0xbee4(%ebx),%eax
c0029180:	50                   	push   %eax
c0029181:	6a 6a                	push   $0x6a
c0029183:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029189:	50                   	push   %eax
c002918a:	e8 55 fd ff ff       	call   c0028ee4 <debug_panic>

c002918f <find_end_of_run>:
   given auxiliary data AUX.  Returns the (exclusive) end of the
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run(struct list_elem *a, struct list_elem *b,
                list_less_func *less, void *aux) {
c002918f:	55                   	push   %ebp
c0029190:	57                   	push   %edi
c0029191:	56                   	push   %esi
c0029192:	53                   	push   %ebx
c0029193:	83 ec 1c             	sub    $0x1c,%esp
c0029196:	e8 08 47 00 00       	call   c002d8a3 <__x86.get_pc_thunk.di>
c002919b:	81 c7 65 13 01 00    	add    $0x11365,%edi
c00291a1:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c00291a5:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    ASSERT (a != NULL);
c00291a9:	85 c0                	test   %eax,%eax
c00291ab:	74 4e                	je     c00291fb <find_end_of_run+0x6c>
c00291ad:	89 c3                	mov    %eax,%ebx
c00291af:	89 d6                	mov    %edx,%esi
c00291b1:	89 cf                	mov    %ecx,%edi
    ASSERT (b != NULL);
c00291b3:	85 d2                	test   %edx,%edx
c00291b5:	74 71                	je     c0029228 <find_end_of_run+0x99>
    ASSERT (less != NULL);
c00291b7:	85 c9                	test   %ecx,%ecx
c00291b9:	0f 84 96 00 00 00    	je     c0029255 <find_end_of_run+0xc6>
    ASSERT (a != b);
c00291bf:	39 d0                	cmp    %edx,%eax
c00291c1:	0f 84 bb 00 00 00    	je     c0029282 <find_end_of_run+0xf3>

    do {
        a = list_next(a);
c00291c7:	83 ec 0c             	sub    $0xc,%esp
c00291ca:	53                   	push   %ebx
c00291cb:	e8 7e fe ff ff       	call   c002904e <list_next>
c00291d0:	83 c4 10             	add    $0x10,%esp
c00291d3:	89 c3                	mov    %eax,%ebx
    } while (a != b && !less(a, list_prev(a), aux));
c00291d5:	39 c6                	cmp    %eax,%esi
c00291d7:	74 18                	je     c00291f1 <find_end_of_run+0x62>
c00291d9:	83 ec 0c             	sub    $0xc,%esp
c00291dc:	50                   	push   %eax
c00291dd:	e8 53 ff ff ff       	call   c0029135 <list_prev>
c00291e2:	83 c4 0c             	add    $0xc,%esp
c00291e5:	55                   	push   %ebp
c00291e6:	50                   	push   %eax
c00291e7:	53                   	push   %ebx
c00291e8:	ff d7                	call   *%edi
c00291ea:	83 c4 10             	add    $0x10,%esp
c00291ed:	84 c0                	test   %al,%al
c00291ef:	74 d6                	je     c00291c7 <find_end_of_run+0x38>
    return a;
}
c00291f1:	89 d8                	mov    %ebx,%eax
c00291f3:	83 c4 1c             	add    $0x1c,%esp
c00291f6:	5b                   	pop    %ebx
c00291f7:	5e                   	pop    %esi
c00291f8:	5f                   	pop    %edi
c00291f9:	5d                   	pop    %ebp
c00291fa:	c3                   	ret    
    ASSERT (a != NULL);
c00291fb:	83 ec 0c             	sub    $0xc,%esp
c00291fe:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029202:	8d 83 79 4d ff ff    	lea    -0xb287(%ebx),%eax
c0029208:	50                   	push   %eax
c0029209:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002920f:	50                   	push   %eax
c0029210:	8d 83 a0 40 ff ff    	lea    -0xbf60(%ebx),%eax
c0029216:	50                   	push   %eax
c0029217:	68 4d 01 00 00       	push   $0x14d
c002921c:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029222:	50                   	push   %eax
c0029223:	e8 bc fc ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (b != NULL);
c0029228:	83 ec 0c             	sub    $0xc,%esp
c002922b:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002922f:	8d 83 0b 5f ff ff    	lea    -0xa0f5(%ebx),%eax
c0029235:	50                   	push   %eax
c0029236:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002923c:	50                   	push   %eax
c002923d:	8d 83 a0 40 ff ff    	lea    -0xbf60(%ebx),%eax
c0029243:	50                   	push   %eax
c0029244:	68 4e 01 00 00       	push   $0x14e
c0029249:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002924f:	50                   	push   %eax
c0029250:	e8 8f fc ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (less != NULL);
c0029255:	83 ec 0c             	sub    $0xc,%esp
c0029258:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002925c:	8d 83 15 5f ff ff    	lea    -0xa0eb(%ebx),%eax
c0029262:	50                   	push   %eax
c0029263:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029269:	50                   	push   %eax
c002926a:	8d 83 a0 40 ff ff    	lea    -0xbf60(%ebx),%eax
c0029270:	50                   	push   %eax
c0029271:	68 4f 01 00 00       	push   $0x14f
c0029276:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002927c:	50                   	push   %eax
c002927d:	e8 62 fc ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (a != b);
c0029282:	83 ec 0c             	sub    $0xc,%esp
c0029285:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029289:	8d 83 22 5f ff ff    	lea    -0xa0de(%ebx),%eax
c002928f:	50                   	push   %eax
c0029290:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029296:	50                   	push   %eax
c0029297:	8d 83 a0 40 ff ff    	lea    -0xbf60(%ebx),%eax
c002929d:	50                   	push   %eax
c002929e:	68 50 01 00 00       	push   $0x150
c00292a3:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c00292a9:	50                   	push   %eax
c00292aa:	e8 35 fc ff ff       	call   c0028ee4 <debug_panic>

c00292af <is_sorted>:
          list_less_func *less, void *aux) {
c00292af:	55                   	push   %ebp
c00292b0:	57                   	push   %edi
c00292b1:	56                   	push   %esi
c00292b2:	53                   	push   %ebx
c00292b3:	83 ec 0c             	sub    $0xc,%esp
c00292b6:	89 c3                	mov    %eax,%ebx
c00292b8:	89 d6                	mov    %edx,%esi
c00292ba:	89 cd                	mov    %ecx,%ebp
c00292bc:	8b 7c 24 20          	mov    0x20(%esp),%edi
    if (a != b)
c00292c0:	39 d0                	cmp    %edx,%eax
c00292c2:	74 31                	je     c00292f5 <is_sorted+0x46>
        while ((a = list_next(a)) != b)
c00292c4:	83 ec 0c             	sub    $0xc,%esp
c00292c7:	53                   	push   %ebx
c00292c8:	e8 81 fd ff ff       	call   c002904e <list_next>
c00292cd:	83 c4 10             	add    $0x10,%esp
c00292d0:	89 c3                	mov    %eax,%ebx
c00292d2:	39 c6                	cmp    %eax,%esi
c00292d4:	74 26                	je     c00292fc <is_sorted+0x4d>
            if (less(a, list_prev(a), aux))
c00292d6:	83 ec 0c             	sub    $0xc,%esp
c00292d9:	53                   	push   %ebx
c00292da:	e8 56 fe ff ff       	call   c0029135 <list_prev>
c00292df:	83 c4 0c             	add    $0xc,%esp
c00292e2:	57                   	push   %edi
c00292e3:	50                   	push   %eax
c00292e4:	53                   	push   %ebx
c00292e5:	ff d5                	call   *%ebp
c00292e7:	83 c4 10             	add    $0x10,%esp
c00292ea:	84 c0                	test   %al,%al
c00292ec:	74 d6                	je     c00292c4 <is_sorted+0x15>
                return false;
c00292ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00292f3:	eb 0c                	jmp    c0029301 <is_sorted+0x52>
    return true;
c00292f5:	b8 01 00 00 00       	mov    $0x1,%eax
c00292fa:	eb 05                	jmp    c0029301 <is_sorted+0x52>
c00292fc:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0029301:	83 c4 0c             	add    $0xc,%esp
c0029304:	5b                   	pop    %ebx
c0029305:	5e                   	pop    %esi
c0029306:	5f                   	pop    %edi
c0029307:	5d                   	pop    %ebp
c0029308:	c3                   	ret    

c0029309 <list_rend>:
list_rend(struct list *list) {
c0029309:	53                   	push   %ebx
c002930a:	83 ec 08             	sub    $0x8,%esp
c002930d:	e8 85 45 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029312:	81 c3 ee 11 01 00    	add    $0x111ee,%ebx
c0029318:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c002931c:	85 c0                	test   %eax,%eax
c002931e:	74 05                	je     c0029325 <list_rend+0x1c>
}
c0029320:	83 c4 08             	add    $0x8,%esp
c0029323:	5b                   	pop    %ebx
c0029324:	c3                   	ret    
    ASSERT (list != NULL);
c0029325:	83 ec 0c             	sub    $0xc,%esp
c0029328:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c002932e:	50                   	push   %eax
c002932f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029335:	50                   	push   %eax
c0029336:	8d 83 10 41 ff ff    	lea    -0xbef0(%ebx),%eax
c002933c:	50                   	push   %eax
c002933d:	6a 7d                	push   $0x7d
c002933f:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029345:	50                   	push   %eax
c0029346:	e8 99 fb ff ff       	call   c0028ee4 <debug_panic>

c002934b <list_head>:
list_head(struct list *list) {
c002934b:	53                   	push   %ebx
c002934c:	83 ec 08             	sub    $0x8,%esp
c002934f:	e8 43 45 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029354:	81 c3 ac 11 01 00    	add    $0x111ac,%ebx
c002935a:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c002935e:	85 c0                	test   %eax,%eax
c0029360:	74 05                	je     c0029367 <list_head+0x1c>
}
c0029362:	83 c4 08             	add    $0x8,%esp
c0029365:	5b                   	pop    %ebx
c0029366:	c3                   	ret    
    ASSERT (list != NULL);
c0029367:	83 ec 0c             	sub    $0xc,%esp
c002936a:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c0029370:	50                   	push   %eax
c0029371:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029377:	50                   	push   %eax
c0029378:	8d 83 04 41 ff ff    	lea    -0xbefc(%ebx),%eax
c002937e:	50                   	push   %eax
c002937f:	68 8e 00 00 00       	push   $0x8e
c0029384:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002938a:	50                   	push   %eax
c002938b:	e8 54 fb ff ff       	call   c0028ee4 <debug_panic>

c0029390 <list_tail>:
list_tail(struct list *list) {
c0029390:	53                   	push   %ebx
c0029391:	83 ec 08             	sub    $0x8,%esp
c0029394:	e8 fe 44 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029399:	81 c3 67 11 01 00    	add    $0x11167,%ebx
c002939f:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c00293a3:	85 c0                	test   %eax,%eax
c00293a5:	74 08                	je     c00293af <list_tail+0x1f>
    return &list->tail;
c00293a7:	83 c0 08             	add    $0x8,%eax
}
c00293aa:	83 c4 08             	add    $0x8,%esp
c00293ad:	5b                   	pop    %ebx
c00293ae:	c3                   	ret    
    ASSERT (list != NULL);
c00293af:	83 ec 0c             	sub    $0xc,%esp
c00293b2:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c00293b8:	50                   	push   %eax
c00293b9:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00293bf:	50                   	push   %eax
c00293c0:	8d 83 f8 40 ff ff    	lea    -0xbf08(%ebx),%eax
c00293c6:	50                   	push   %eax
c00293c7:	68 95 00 00 00       	push   $0x95
c00293cc:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c00293d2:	50                   	push   %eax
c00293d3:	e8 0c fb ff ff       	call   c0028ee4 <debug_panic>

c00293d8 <list_insert>:
list_insert(struct list_elem *before, struct list_elem *elem) {
c00293d8:	53                   	push   %ebx
c00293d9:	83 ec 08             	sub    $0x8,%esp
c00293dc:	e8 b6 44 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00293e1:	81 c3 1f 11 01 00    	add    $0x1111f,%ebx
c00293e7:	8b 44 24 10          	mov    0x10(%esp),%eax
c00293eb:	8b 54 24 14          	mov    0x14(%esp),%edx
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00293ef:	85 c0                	test   %eax,%eax
c00293f1:	74 2d                	je     c0029420 <list_insert+0x48>
c00293f3:	83 38 00             	cmpl   $0x0,(%eax)
c00293f6:	74 1d                	je     c0029415 <list_insert+0x3d>
c00293f8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00293fc:	74 17                	je     c0029415 <list_insert+0x3d>
    ASSERT (elem != NULL);
c00293fe:	85 d2                	test   %edx,%edx
c0029400:	74 47                	je     c0029449 <list_insert+0x71>
    elem->prev = before->prev;
c0029402:	8b 08                	mov    (%eax),%ecx
c0029404:	89 0a                	mov    %ecx,(%edx)
    elem->next = before;
c0029406:	89 42 04             	mov    %eax,0x4(%edx)
    before->prev->next = elem;
c0029409:	8b 08                	mov    (%eax),%ecx
c002940b:	89 51 04             	mov    %edx,0x4(%ecx)
    before->prev = elem;
c002940e:	89 10                	mov    %edx,(%eax)
}
c0029410:	83 c4 08             	add    $0x8,%esp
c0029413:	5b                   	pop    %ebx
c0029414:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029415:	83 38 00             	cmpl   $0x0,(%eax)
c0029418:	74 06                	je     c0029420 <list_insert+0x48>
c002941a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002941e:	74 de                	je     c00293fe <list_insert+0x26>
    ASSERT (is_interior(before) || is_tail(before));
c0029420:	83 ec 0c             	sub    $0xc,%esp
c0029423:	8d 83 ec 5f ff ff    	lea    -0xa014(%ebx),%eax
c0029429:	50                   	push   %eax
c002942a:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029430:	50                   	push   %eax
c0029431:	8d 83 ec 40 ff ff    	lea    -0xbf14(%ebx),%eax
c0029437:	50                   	push   %eax
c0029438:	68 9e 00 00 00       	push   $0x9e
c002943d:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029443:	50                   	push   %eax
c0029444:	e8 9b fa ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (elem != NULL);
c0029449:	83 ec 0c             	sub    $0xc,%esp
c002944c:	8d 83 29 5f ff ff    	lea    -0xa0d7(%ebx),%eax
c0029452:	50                   	push   %eax
c0029453:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029459:	50                   	push   %eax
c002945a:	8d 83 ec 40 ff ff    	lea    -0xbf14(%ebx),%eax
c0029460:	50                   	push   %eax
c0029461:	68 9f 00 00 00       	push   $0x9f
c0029466:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002946c:	50                   	push   %eax
c002946d:	e8 72 fa ff ff       	call   c0028ee4 <debug_panic>

c0029472 <list_splice>:
            struct list_elem *first, struct list_elem *last) {
c0029472:	57                   	push   %edi
c0029473:	56                   	push   %esi
c0029474:	53                   	push   %ebx
c0029475:	e8 1d 44 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002947a:	81 c3 86 10 01 00    	add    $0x11086,%ebx
c0029480:	8b 74 24 10          	mov    0x10(%esp),%esi
c0029484:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0029488:	8b 44 24 18          	mov    0x18(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002948c:	85 f6                	test   %esi,%esi
c002948e:	74 6e                	je     c00294fe <list_splice+0x8c>
c0029490:	83 3e 00             	cmpl   $0x0,(%esi)
c0029493:	74 5e                	je     c00294f3 <list_splice+0x81>
c0029495:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029499:	74 58                	je     c00294f3 <list_splice+0x81>
    if (first == last)
c002949b:	39 c7                	cmp    %eax,%edi
c002949d:	74 50                	je     c00294ef <list_splice+0x7d>
    last = list_prev(last);
c002949f:	83 ec 0c             	sub    $0xc,%esp
c00294a2:	50                   	push   %eax
c00294a3:	e8 8d fc ff ff       	call   c0029135 <list_prev>
c00294a8:	83 c4 10             	add    $0x10,%esp
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00294ab:	85 ff                	test   %edi,%edi
c00294ad:	0f 84 9d 00 00 00    	je     c0029550 <list_splice+0xde>
c00294b3:	8b 17                	mov    (%edi),%edx
c00294b5:	85 d2                	test   %edx,%edx
c00294b7:	0f 84 93 00 00 00    	je     c0029550 <list_splice+0xde>
c00294bd:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c00294c1:	0f 84 89 00 00 00    	je     c0029550 <list_splice+0xde>
c00294c7:	85 c0                	test   %eax,%eax
c00294c9:	74 5c                	je     c0029527 <list_splice+0xb5>
c00294cb:	83 38 00             	cmpl   $0x0,(%eax)
c00294ce:	74 57                	je     c0029527 <list_splice+0xb5>
c00294d0:	8b 48 04             	mov    0x4(%eax),%ecx
c00294d3:	85 c9                	test   %ecx,%ecx
c00294d5:	74 50                	je     c0029527 <list_splice+0xb5>
    first->prev->next = last->next;
c00294d7:	89 4a 04             	mov    %ecx,0x4(%edx)
    last->next->prev = first->prev;
c00294da:	8b 50 04             	mov    0x4(%eax),%edx
c00294dd:	8b 0f                	mov    (%edi),%ecx
c00294df:	89 0a                	mov    %ecx,(%edx)
    first->prev = before->prev;
c00294e1:	8b 16                	mov    (%esi),%edx
c00294e3:	89 17                	mov    %edx,(%edi)
    last->next = before;
c00294e5:	89 70 04             	mov    %esi,0x4(%eax)
    before->prev->next = first;
c00294e8:	8b 16                	mov    (%esi),%edx
c00294ea:	89 7a 04             	mov    %edi,0x4(%edx)
    before->prev = last;
c00294ed:	89 06                	mov    %eax,(%esi)
}
c00294ef:	5b                   	pop    %ebx
c00294f0:	5e                   	pop    %esi
c00294f1:	5f                   	pop    %edi
c00294f2:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00294f3:	83 3e 00             	cmpl   $0x0,(%esi)
c00294f6:	74 06                	je     c00294fe <list_splice+0x8c>
c00294f8:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c00294fc:	74 9d                	je     c002949b <list_splice+0x29>
    ASSERT (is_interior(before) || is_tail(before));
c00294fe:	83 ec 0c             	sub    $0xc,%esp
c0029501:	8d 83 ec 5f ff ff    	lea    -0xa014(%ebx),%eax
c0029507:	50                   	push   %eax
c0029508:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002950e:	50                   	push   %eax
c002950f:	8d 83 e0 40 ff ff    	lea    -0xbf20(%ebx),%eax
c0029515:	50                   	push   %eax
c0029516:	68 ad 00 00 00       	push   $0xad
c002951b:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029521:	50                   	push   %eax
c0029522:	e8 bd f9 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (is_interior(last));
c0029527:	83 ec 0c             	sub    $0xc,%esp
c002952a:	8d 83 36 5f ff ff    	lea    -0xa0ca(%ebx),%eax
c0029530:	50                   	push   %eax
c0029531:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029537:	50                   	push   %eax
c0029538:	8d 83 e0 40 ff ff    	lea    -0xbf20(%ebx),%eax
c002953e:	50                   	push   %eax
c002953f:	68 b3 00 00 00       	push   $0xb3
c0029544:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002954a:	50                   	push   %eax
c002954b:	e8 94 f9 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (is_interior(first));
c0029550:	83 ec 0c             	sub    $0xc,%esp
c0029553:	8d 83 48 5f ff ff    	lea    -0xa0b8(%ebx),%eax
c0029559:	50                   	push   %eax
c002955a:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029560:	50                   	push   %eax
c0029561:	8d 83 e0 40 ff ff    	lea    -0xbf20(%ebx),%eax
c0029567:	50                   	push   %eax
c0029568:	68 b2 00 00 00       	push   $0xb2
c002956d:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029573:	50                   	push   %eax
c0029574:	e8 6b f9 ff ff       	call   c0028ee4 <debug_panic>

c0029579 <list_push_front>:
list_push_front(struct list *list, struct list_elem *elem) {
c0029579:	83 ec 18             	sub    $0x18,%esp
    list_insert(list_begin(list), elem);
c002957c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029580:	e8 84 fa ff ff       	call   c0029009 <list_begin>
c0029585:	83 c4 08             	add    $0x8,%esp
c0029588:	ff 74 24 1c          	pushl  0x1c(%esp)
c002958c:	50                   	push   %eax
c002958d:	e8 46 fe ff ff       	call   c00293d8 <list_insert>
}
c0029592:	83 c4 1c             	add    $0x1c,%esp
c0029595:	c3                   	ret    

c0029596 <list_push_back>:
list_push_back(struct list *list, struct list_elem *elem) {
c0029596:	83 ec 18             	sub    $0x18,%esp
    list_insert(list_end(list), elem);
c0029599:	ff 74 24 1c          	pushl  0x1c(%esp)
c002959d:	e8 09 fb ff ff       	call   c00290ab <list_end>
c00295a2:	83 c4 08             	add    $0x8,%esp
c00295a5:	ff 74 24 1c          	pushl  0x1c(%esp)
c00295a9:	50                   	push   %eax
c00295aa:	e8 29 fe ff ff       	call   c00293d8 <list_insert>
}
c00295af:	83 c4 1c             	add    $0x1c,%esp
c00295b2:	c3                   	ret    

c00295b3 <list_remove>:
list_remove(struct list_elem *elem) {
c00295b3:	53                   	push   %ebx
c00295b4:	83 ec 08             	sub    $0x8,%esp
c00295b7:	e8 db 42 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00295bc:	81 c3 44 0f 01 00    	add    $0x10f44,%ebx
c00295c2:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00295c6:	85 c0                	test   %eax,%eax
c00295c8:	74 1f                	je     c00295e9 <list_remove+0x36>
c00295ca:	8b 10                	mov    (%eax),%edx
c00295cc:	85 d2                	test   %edx,%edx
c00295ce:	74 19                	je     c00295e9 <list_remove+0x36>
c00295d0:	8b 48 04             	mov    0x4(%eax),%ecx
c00295d3:	85 c9                	test   %ecx,%ecx
c00295d5:	74 12                	je     c00295e9 <list_remove+0x36>
    elem->prev->next = elem->next;
c00295d7:	89 4a 04             	mov    %ecx,0x4(%edx)
    elem->next->prev = elem->prev;
c00295da:	8b 50 04             	mov    0x4(%eax),%edx
c00295dd:	8b 08                	mov    (%eax),%ecx
c00295df:	89 0a                	mov    %ecx,(%edx)
    return elem->next;
c00295e1:	8b 40 04             	mov    0x4(%eax),%eax
}
c00295e4:	83 c4 08             	add    $0x8,%esp
c00295e7:	5b                   	pop    %ebx
c00295e8:	c3                   	ret    
    ASSERT (is_interior(elem));
c00295e9:	83 ec 0c             	sub    $0xc,%esp
c00295ec:	8d 83 5b 5f ff ff    	lea    -0xa0a5(%ebx),%eax
c00295f2:	50                   	push   %eax
c00295f3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00295f9:	50                   	push   %eax
c00295fa:	8d 83 d4 40 ff ff    	lea    -0xbf2c(%ebx),%eax
c0029600:	50                   	push   %eax
c0029601:	68 ea 00 00 00       	push   $0xea
c0029606:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002960c:	50                   	push   %eax
c002960d:	e8 d2 f8 ff ff       	call   c0028ee4 <debug_panic>

c0029612 <list_size>:
list_size(struct list *list) {
c0029612:	57                   	push   %edi
c0029613:	56                   	push   %esi
c0029614:	53                   	push   %ebx
c0029615:	8b 7c 24 10          	mov    0x10(%esp),%edi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029619:	83 ec 0c             	sub    $0xc,%esp
c002961c:	57                   	push   %edi
c002961d:	e8 e7 f9 ff ff       	call   c0029009 <list_begin>
c0029622:	83 c4 10             	add    $0x10,%esp
c0029625:	89 c3                	mov    %eax,%ebx
    size_t cnt = 0;
c0029627:	be 00 00 00 00       	mov    $0x0,%esi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c002962c:	83 ec 0c             	sub    $0xc,%esp
c002962f:	57                   	push   %edi
c0029630:	e8 76 fa ff ff       	call   c00290ab <list_end>
c0029635:	83 c4 10             	add    $0x10,%esp
c0029638:	39 d8                	cmp    %ebx,%eax
c002963a:	74 13                	je     c002964f <list_size+0x3d>
        cnt++;
c002963c:	83 c6 01             	add    $0x1,%esi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c002963f:	83 ec 0c             	sub    $0xc,%esp
c0029642:	53                   	push   %ebx
c0029643:	e8 06 fa ff ff       	call   c002904e <list_next>
c0029648:	83 c4 10             	add    $0x10,%esp
c002964b:	89 c3                	mov    %eax,%ebx
c002964d:	eb dd                	jmp    c002962c <list_size+0x1a>
}
c002964f:	89 f0                	mov    %esi,%eax
c0029651:	5b                   	pop    %ebx
c0029652:	5e                   	pop    %esi
c0029653:	5f                   	pop    %edi
c0029654:	c3                   	ret    

c0029655 <list_empty>:
list_empty(struct list *list) {
c0029655:	56                   	push   %esi
c0029656:	53                   	push   %ebx
c0029657:	83 ec 10             	sub    $0x10,%esp
c002965a:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    return list_begin(list) == list_end(list);
c002965e:	53                   	push   %ebx
c002965f:	e8 a5 f9 ff ff       	call   c0029009 <list_begin>
c0029664:	89 c6                	mov    %eax,%esi
c0029666:	89 1c 24             	mov    %ebx,(%esp)
c0029669:	e8 3d fa ff ff       	call   c00290ab <list_end>
c002966e:	39 c6                	cmp    %eax,%esi
c0029670:	0f 94 c0             	sete   %al
}
c0029673:	83 c4 14             	add    $0x14,%esp
c0029676:	5b                   	pop    %ebx
c0029677:	5e                   	pop    %esi
c0029678:	c3                   	ret    

c0029679 <list_front>:
list_front(struct list *list) {
c0029679:	56                   	push   %esi
c002967a:	53                   	push   %ebx
c002967b:	83 ec 10             	sub    $0x10,%esp
c002967e:	e8 14 42 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029683:	81 c3 7d 0e 01 00    	add    $0x10e7d,%ebx
c0029689:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    ASSERT (!list_empty(list));
c002968d:	56                   	push   %esi
c002968e:	e8 c2 ff ff ff       	call   c0029655 <list_empty>
c0029693:	83 c4 10             	add    $0x10,%esp
c0029696:	84 c0                	test   %al,%al
c0029698:	75 09                	jne    c00296a3 <list_front+0x2a>
    return list->head.next;
c002969a:	8b 46 04             	mov    0x4(%esi),%eax
}
c002969d:	83 c4 04             	add    $0x4,%esp
c00296a0:	5b                   	pop    %ebx
c00296a1:	5e                   	pop    %esi
c00296a2:	c3                   	ret    
    ASSERT (!list_empty(list));
c00296a3:	83 ec 0c             	sub    $0xc,%esp
c00296a6:	8d 83 6d 5f ff ff    	lea    -0xa093(%ebx),%eax
c00296ac:	50                   	push   %eax
c00296ad:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00296b3:	50                   	push   %eax
c00296b4:	8d 83 c8 40 ff ff    	lea    -0xbf38(%ebx),%eax
c00296ba:	50                   	push   %eax
c00296bb:	68 06 01 00 00       	push   $0x106
c00296c0:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c00296c6:	50                   	push   %eax
c00296c7:	e8 18 f8 ff ff       	call   c0028ee4 <debug_panic>

c00296cc <list_pop_front>:
list_pop_front(struct list *list) {
c00296cc:	53                   	push   %ebx
c00296cd:	83 ec 14             	sub    $0x14,%esp
    struct list_elem *front = list_front(list);
c00296d0:	ff 74 24 1c          	pushl  0x1c(%esp)
c00296d4:	e8 a0 ff ff ff       	call   c0029679 <list_front>
c00296d9:	89 c3                	mov    %eax,%ebx
    list_remove(front);
c00296db:	89 04 24             	mov    %eax,(%esp)
c00296de:	e8 d0 fe ff ff       	call   c00295b3 <list_remove>
}
c00296e3:	89 d8                	mov    %ebx,%eax
c00296e5:	83 c4 18             	add    $0x18,%esp
c00296e8:	5b                   	pop    %ebx
c00296e9:	c3                   	ret    

c00296ea <list_back>:
list_back(struct list *list) {
c00296ea:	56                   	push   %esi
c00296eb:	53                   	push   %ebx
c00296ec:	83 ec 10             	sub    $0x10,%esp
c00296ef:	e8 a3 41 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c00296f4:	81 c3 0c 0e 01 00    	add    $0x10e0c,%ebx
c00296fa:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    ASSERT (!list_empty(list));
c00296fe:	56                   	push   %esi
c00296ff:	e8 51 ff ff ff       	call   c0029655 <list_empty>
c0029704:	83 c4 10             	add    $0x10,%esp
c0029707:	84 c0                	test   %al,%al
c0029709:	75 09                	jne    c0029714 <list_back+0x2a>
    return list->tail.prev;
c002970b:	8b 46 08             	mov    0x8(%esi),%eax
}
c002970e:	83 c4 04             	add    $0x4,%esp
c0029711:	5b                   	pop    %ebx
c0029712:	5e                   	pop    %esi
c0029713:	c3                   	ret    
    ASSERT (!list_empty(list));
c0029714:	83 ec 0c             	sub    $0xc,%esp
c0029717:	8d 83 6d 5f ff ff    	lea    -0xa093(%ebx),%eax
c002971d:	50                   	push   %eax
c002971e:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029724:	50                   	push   %eax
c0029725:	8d 83 bc 40 ff ff    	lea    -0xbf44(%ebx),%eax
c002972b:	50                   	push   %eax
c002972c:	68 0e 01 00 00       	push   $0x10e
c0029731:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029737:	50                   	push   %eax
c0029738:	e8 a7 f7 ff ff       	call   c0028ee4 <debug_panic>

c002973d <list_pop_back>:
list_pop_back(struct list *list) {
c002973d:	53                   	push   %ebx
c002973e:	83 ec 14             	sub    $0x14,%esp
    struct list_elem *back = list_back(list);
c0029741:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029745:	e8 a0 ff ff ff       	call   c00296ea <list_back>
c002974a:	89 c3                	mov    %eax,%ebx
    list_remove(back);
c002974c:	89 04 24             	mov    %eax,(%esp)
c002974f:	e8 5f fe ff ff       	call   c00295b3 <list_remove>
}
c0029754:	89 d8                	mov    %ebx,%eax
c0029756:	83 c4 18             	add    $0x18,%esp
c0029759:	5b                   	pop    %ebx
c002975a:	c3                   	ret    

c002975b <list_reverse>:
list_reverse(struct list *list) {
c002975b:	56                   	push   %esi
c002975c:	53                   	push   %ebx
c002975d:	83 ec 10             	sub    $0x10,%esp
c0029760:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    if (!list_empty(list)) {
c0029764:	56                   	push   %esi
c0029765:	e8 eb fe ff ff       	call   c0029655 <list_empty>
c002976a:	83 c4 10             	add    $0x10,%esp
c002976d:	84 c0                	test   %al,%al
c002976f:	74 06                	je     c0029777 <list_reverse+0x1c>
}
c0029771:	83 c4 04             	add    $0x4,%esp
c0029774:	5b                   	pop    %ebx
c0029775:	5e                   	pop    %esi
c0029776:	c3                   	ret    
        for (e = list_begin(list); e != list_end(list); e = e->prev)
c0029777:	83 ec 0c             	sub    $0xc,%esp
c002977a:	56                   	push   %esi
c002977b:	e8 89 f8 ff ff       	call   c0029009 <list_begin>
c0029780:	83 c4 10             	add    $0x10,%esp
c0029783:	89 c3                	mov    %eax,%ebx
c0029785:	83 ec 0c             	sub    $0xc,%esp
c0029788:	56                   	push   %esi
c0029789:	e8 1d f9 ff ff       	call   c00290ab <list_end>
c002978e:	83 c4 10             	add    $0x10,%esp
c0029791:	39 d8                	cmp    %ebx,%eax
c0029793:	74 0e                	je     c00297a3 <list_reverse+0x48>
    struct list_elem *t = *a;
c0029795:	8b 13                	mov    (%ebx),%edx
    *a = *b;
c0029797:	8b 43 04             	mov    0x4(%ebx),%eax
c002979a:	89 03                	mov    %eax,(%ebx)
    *b = t;
c002979c:	89 53 04             	mov    %edx,0x4(%ebx)
        for (e = list_begin(list); e != list_end(list); e = e->prev)
c002979f:	89 c3                	mov    %eax,%ebx
c00297a1:	eb e2                	jmp    c0029785 <list_reverse+0x2a>
    struct list_elem *t = *a;
c00297a3:	8b 46 04             	mov    0x4(%esi),%eax
    *a = *b;
c00297a6:	8b 56 08             	mov    0x8(%esi),%edx
c00297a9:	89 56 04             	mov    %edx,0x4(%esi)
    *b = t;
c00297ac:	89 46 08             	mov    %eax,0x8(%esi)
    struct list_elem *t = *a;
c00297af:	8b 0a                	mov    (%edx),%ecx
    *a = *b;
c00297b1:	8b 58 04             	mov    0x4(%eax),%ebx
c00297b4:	89 1a                	mov    %ebx,(%edx)
    *b = t;
c00297b6:	89 48 04             	mov    %ecx,0x4(%eax)
}
c00297b9:	eb b6                	jmp    c0029771 <list_reverse+0x16>

c00297bb <list_sort>:

/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort(struct list *list, list_less_func *less, void *aux) {
c00297bb:	55                   	push   %ebp
c00297bc:	57                   	push   %edi
c00297bd:	56                   	push   %esi
c00297be:	53                   	push   %ebx
c00297bf:	83 ec 1c             	sub    $0x1c,%esp
c00297c2:	e8 d4 40 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c00297c7:	05 39 0d 01 00       	add    $0x10d39,%eax
c00297cc:	89 44 24 0c          	mov    %eax,0xc(%esp)
c00297d0:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c00297d4:	8b 7c 24 38          	mov    0x38(%esp),%edi
    size_t output_run_cnt;        /* Number of runs output in current pass. */

    ASSERT (list != NULL);
c00297d8:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c00297dd:	74 35                	je     c0029814 <list_sort+0x59>
    ASSERT (less != NULL);
c00297df:	85 ed                	test   %ebp,%ebp
c00297e1:	0f 85 41 02 00 00    	jne    c0029a28 <list_sort+0x26d>
c00297e7:	83 ec 0c             	sub    $0xc,%esp
c00297ea:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00297ee:	8d 83 15 5f ff ff    	lea    -0xa0eb(%ebx),%eax
c00297f4:	50                   	push   %eax
c00297f5:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00297fb:	50                   	push   %eax
c00297fc:	8d 83 b0 40 ff ff    	lea    -0xbf50(%ebx),%eax
c0029802:	50                   	push   %eax
c0029803:	68 79 01 00 00       	push   $0x179
c0029808:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002980e:	50                   	push   %eax
c002980f:	e8 d0 f6 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (list != NULL);
c0029814:	83 ec 0c             	sub    $0xc,%esp
c0029817:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002981b:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c0029821:	50                   	push   %eax
c0029822:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029828:	50                   	push   %eax
c0029829:	8d 83 b0 40 ff ff    	lea    -0xbf50(%ebx),%eax
c002982f:	50                   	push   %eax
c0029830:	68 78 01 00 00       	push   $0x178
c0029835:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c002983b:	50                   	push   %eax
c002983c:	e8 a3 f6 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (a0 != NULL);
c0029841:	83 ec 0c             	sub    $0xc,%esp
c0029844:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029848:	8d 83 7f 5f ff ff    	lea    -0xa081(%ebx),%eax
c002984e:	50                   	push   %eax
c002984f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029855:	50                   	push   %eax
c0029856:	8d 83 90 40 ff ff    	lea    -0xbf70(%ebx),%eax
c002985c:	50                   	push   %eax
c002985d:	68 61 01 00 00       	push   $0x161
c0029862:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029868:	50                   	push   %eax
c0029869:	e8 76 f6 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (a1b0 != NULL);
c002986e:	83 ec 0c             	sub    $0xc,%esp
c0029871:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029875:	8d 83 8a 5f ff ff    	lea    -0xa076(%ebx),%eax
c002987b:	50                   	push   %eax
c002987c:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029882:	50                   	push   %eax
c0029883:	8d 83 90 40 ff ff    	lea    -0xbf70(%ebx),%eax
c0029889:	50                   	push   %eax
c002988a:	68 62 01 00 00       	push   $0x162
c002988f:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029895:	50                   	push   %eax
c0029896:	e8 49 f6 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (b1 != NULL);
c002989b:	83 ec 0c             	sub    $0xc,%esp
c002989e:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00298a2:	8d 83 97 5f ff ff    	lea    -0xa069(%ebx),%eax
c00298a8:	50                   	push   %eax
c00298a9:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00298af:	50                   	push   %eax
c00298b0:	8d 83 90 40 ff ff    	lea    -0xbf70(%ebx),%eax
c00298b6:	50                   	push   %eax
c00298b7:	68 63 01 00 00       	push   $0x163
c00298bc:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c00298c2:	50                   	push   %eax
c00298c3:	e8 1c f6 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (is_sorted(a0, a1b0, less, aux));
c00298c8:	83 ec 0c             	sub    $0xc,%esp
c00298cb:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00298cf:	8d 83 14 60 ff ff    	lea    -0x9fec(%ebx),%eax
c00298d5:	50                   	push   %eax
c00298d6:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c00298dc:	50                   	push   %eax
c00298dd:	8d 83 90 40 ff ff    	lea    -0xbf70(%ebx),%eax
c00298e3:	50                   	push   %eax
c00298e4:	68 65 01 00 00       	push   $0x165
c00298e9:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c00298ef:	50                   	push   %eax
c00298f0:	e8 ef f5 ff ff       	call   c0028ee4 <debug_panic>
            a1b0 = list_next(a1b0);
c00298f5:	83 ec 0c             	sub    $0xc,%esp
c00298f8:	53                   	push   %ebx
c00298f9:	e8 50 f7 ff ff       	call   c002904e <list_next>
c00298fe:	89 c3                	mov    %eax,%ebx
            list_splice(a0, list_prev(a1b0), a1b0);
c0029900:	89 04 24             	mov    %eax,(%esp)
c0029903:	e8 2d f8 ff ff       	call   c0029135 <list_prev>
c0029908:	83 c4 0c             	add    $0xc,%esp
c002990b:	53                   	push   %ebx
c002990c:	50                   	push   %eax
c002990d:	56                   	push   %esi
c002990e:	e8 5f fb ff ff       	call   c0029472 <list_splice>
c0029913:	83 c4 10             	add    $0x10,%esp
    while (a0 != a1b0 && a1b0 != b1)
c0029916:	39 f3                	cmp    %esi,%ebx
c0029918:	0f 95 c2             	setne  %dl
c002991b:	39 5c 24 04          	cmp    %ebx,0x4(%esp)
c002991f:	0f 95 c0             	setne  %al
c0029922:	84 c2                	test   %al,%dl
c0029924:	74 1f                	je     c0029945 <list_sort+0x18a>
        if (!less(a1b0, a0, aux))
c0029926:	83 ec 04             	sub    $0x4,%esp
c0029929:	57                   	push   %edi
c002992a:	56                   	push   %esi
c002992b:	53                   	push   %ebx
c002992c:	ff d5                	call   *%ebp
c002992e:	83 c4 10             	add    $0x10,%esp
c0029931:	84 c0                	test   %al,%al
c0029933:	75 c0                	jne    c00298f5 <list_sort+0x13a>
            a0 = list_next(a0);
c0029935:	83 ec 0c             	sub    $0xc,%esp
c0029938:	56                   	push   %esi
c0029939:	e8 10 f7 ff ff       	call   c002904e <list_next>
c002993e:	83 c4 10             	add    $0x10,%esp
c0029941:	89 c6                	mov    %eax,%esi
c0029943:	eb d1                	jmp    c0029916 <list_sort+0x15b>
        struct list_elem *a0;     /* Start of first run. */
        struct list_elem *a1b0;   /* End of first run, start of second. */
        struct list_elem *b1;     /* End of second run. */

        output_run_cnt = 0;
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029945:	8b 74 24 04          	mov    0x4(%esp),%esi
c0029949:	83 ec 0c             	sub    $0xc,%esp
c002994c:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029950:	e8 56 f7 ff ff       	call   c00290ab <list_end>
c0029955:	83 c4 10             	add    $0x10,%esp
c0029958:	39 f0                	cmp    %esi,%eax
c002995a:	0f 84 c1 00 00 00    	je     c0029a21 <list_sort+0x266>
            /* Each iteration produces one output run. */
            output_run_cnt++;
c0029960:	83 44 24 08 01       	addl   $0x1,0x8(%esp)

            /* Locate two adjacent runs of nondecreasing elements
               A0...A1B0 and A1B0...B1. */
            a1b0 = find_end_of_run(a0, list_end(list), less, aux);
c0029965:	83 ec 0c             	sub    $0xc,%esp
c0029968:	57                   	push   %edi
c0029969:	89 e9                	mov    %ebp,%ecx
c002996b:	89 c2                	mov    %eax,%edx
c002996d:	89 f0                	mov    %esi,%eax
c002996f:	e8 1b f8 ff ff       	call   c002918f <find_end_of_run>
c0029974:	89 c3                	mov    %eax,%ebx
            if (a1b0 == list_end(list))
c0029976:	83 c4 04             	add    $0x4,%esp
c0029979:	ff 74 24 3c          	pushl  0x3c(%esp)
c002997d:	e8 29 f7 ff ff       	call   c00290ab <list_end>
c0029982:	83 c4 10             	add    $0x10,%esp
c0029985:	39 d8                	cmp    %ebx,%eax
c0029987:	0f 84 94 00 00 00    	je     c0029a21 <list_sort+0x266>
                break;
            b1 = find_end_of_run(a1b0, list_end(list), less, aux);
c002998d:	83 ec 0c             	sub    $0xc,%esp
c0029990:	57                   	push   %edi
c0029991:	89 e9                	mov    %ebp,%ecx
c0029993:	89 c2                	mov    %eax,%edx
c0029995:	89 d8                	mov    %ebx,%eax
c0029997:	e8 f3 f7 ff ff       	call   c002918f <find_end_of_run>
c002999c:	89 44 24 14          	mov    %eax,0x14(%esp)
    ASSERT (a0 != NULL);
c00299a0:	83 c4 10             	add    $0x10,%esp
c00299a3:	85 f6                	test   %esi,%esi
c00299a5:	0f 84 96 fe ff ff    	je     c0029841 <list_sort+0x86>
    ASSERT (a1b0 != NULL);
c00299ab:	85 db                	test   %ebx,%ebx
c00299ad:	0f 84 bb fe ff ff    	je     c002986e <list_sort+0xb3>
    ASSERT (b1 != NULL);
c00299b3:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c00299b8:	0f 84 dd fe ff ff    	je     c002989b <list_sort+0xe0>
    ASSERT (is_sorted(a0, a1b0, less, aux));
c00299be:	83 ec 0c             	sub    $0xc,%esp
c00299c1:	57                   	push   %edi
c00299c2:	89 e9                	mov    %ebp,%ecx
c00299c4:	89 da                	mov    %ebx,%edx
c00299c6:	89 f0                	mov    %esi,%eax
c00299c8:	e8 e2 f8 ff ff       	call   c00292af <is_sorted>
c00299cd:	83 c4 10             	add    $0x10,%esp
c00299d0:	84 c0                	test   %al,%al
c00299d2:	0f 84 f0 fe ff ff    	je     c00298c8 <list_sort+0x10d>
    ASSERT (is_sorted(a1b0, b1, less, aux));
c00299d8:	83 ec 0c             	sub    $0xc,%esp
c00299db:	57                   	push   %edi
c00299dc:	89 e9                	mov    %ebp,%ecx
c00299de:	8b 54 24 14          	mov    0x14(%esp),%edx
c00299e2:	89 d8                	mov    %ebx,%eax
c00299e4:	e8 c6 f8 ff ff       	call   c00292af <is_sorted>
c00299e9:	83 c4 10             	add    $0x10,%esp
c00299ec:	84 c0                	test   %al,%al
c00299ee:	0f 85 22 ff ff ff    	jne    c0029916 <list_sort+0x15b>
c00299f4:	83 ec 0c             	sub    $0xc,%esp
c00299f7:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00299fb:	8d 83 34 60 ff ff    	lea    -0x9fcc(%ebx),%eax
c0029a01:	50                   	push   %eax
c0029a02:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029a08:	50                   	push   %eax
c0029a09:	8d 83 90 40 ff ff    	lea    -0xbf70(%ebx),%eax
c0029a0f:	50                   	push   %eax
c0029a10:	68 66 01 00 00       	push   $0x166
c0029a15:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029a1b:	50                   	push   %eax
c0029a1c:	e8 c3 f4 ff ff       	call   c0028ee4 <debug_panic>

            /* Merge the runs. */
            inplace_merge(a0, a1b0, b1, less, aux);
        }
    } while (output_run_cnt > 1);
c0029a21:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
c0029a26:	76 1e                	jbe    c0029a46 <list_sort+0x28b>
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029a28:	83 ec 0c             	sub    $0xc,%esp
c0029a2b:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029a2f:	e8 d5 f5 ff ff       	call   c0029009 <list_begin>
c0029a34:	83 c4 10             	add    $0x10,%esp
c0029a37:	89 c6                	mov    %eax,%esi
        output_run_cnt = 0;
c0029a39:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0029a40:	00 
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029a41:	e9 03 ff ff ff       	jmp    c0029949 <list_sort+0x18e>

    ASSERT (is_sorted(list_begin(list), list_end(list), less, aux));
c0029a46:	83 ec 0c             	sub    $0xc,%esp
c0029a49:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029a4d:	e8 59 f6 ff ff       	call   c00290ab <list_end>
c0029a52:	83 c4 04             	add    $0x4,%esp
c0029a55:	89 c3                	mov    %eax,%ebx
c0029a57:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029a5b:	e8 a9 f5 ff ff       	call   c0029009 <list_begin>
c0029a60:	89 3c 24             	mov    %edi,(%esp)
c0029a63:	89 e9                	mov    %ebp,%ecx
c0029a65:	89 da                	mov    %ebx,%edx
c0029a67:	e8 43 f8 ff ff       	call   c00292af <is_sorted>
c0029a6c:	83 c4 10             	add    $0x10,%esp
c0029a6f:	84 c0                	test   %al,%al
c0029a71:	74 08                	je     c0029a7b <list_sort+0x2c0>
}
c0029a73:	83 c4 1c             	add    $0x1c,%esp
c0029a76:	5b                   	pop    %ebx
c0029a77:	5e                   	pop    %esi
c0029a78:	5f                   	pop    %edi
c0029a79:	5d                   	pop    %ebp
c0029a7a:	c3                   	ret    
    ASSERT (is_sorted(list_begin(list), list_end(list), less, aux));
c0029a7b:	83 ec 0c             	sub    $0xc,%esp
c0029a7e:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a82:	8d 83 54 60 ff ff    	lea    -0x9fac(%ebx),%eax
c0029a88:	50                   	push   %eax
c0029a89:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029a8f:	50                   	push   %eax
c0029a90:	8d 83 b0 40 ff ff    	lea    -0xbf50(%ebx),%eax
c0029a96:	50                   	push   %eax
c0029a97:	68 93 01 00 00       	push   $0x193
c0029a9c:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029aa2:	50                   	push   %eax
c0029aa3:	e8 3c f4 ff ff       	call   c0028ee4 <debug_panic>

c0029aa8 <list_insert_ordered>:
/* Inserts ELEM in the proper position in LIST, which must be
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered(struct list *list, struct list_elem *elem,
                    list_less_func *less, void *aux) {
c0029aa8:	55                   	push   %ebp
c0029aa9:	57                   	push   %edi
c0029aaa:	56                   	push   %esi
c0029aab:	53                   	push   %ebx
c0029aac:	83 ec 0c             	sub    $0xc,%esp
c0029aaf:	e8 e3 3d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029ab4:	81 c3 4c 0a 01 00    	add    $0x10a4c,%ebx
c0029aba:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029abe:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029ac2:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    struct list_elem *e;

    ASSERT (list != NULL);
c0029ac6:	85 f6                	test   %esi,%esi
c0029ac8:	74 54                	je     c0029b1e <list_insert_ordered+0x76>
    ASSERT (elem != NULL);
c0029aca:	85 ff                	test   %edi,%edi
c0029acc:	74 79                	je     c0029b47 <list_insert_ordered+0x9f>
    ASSERT (less != NULL);
c0029ace:	85 ed                	test   %ebp,%ebp
c0029ad0:	0f 84 9a 00 00 00    	je     c0029b70 <list_insert_ordered+0xc8>

    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029ad6:	83 ec 0c             	sub    $0xc,%esp
c0029ad9:	56                   	push   %esi
c0029ada:	e8 2a f5 ff ff       	call   c0029009 <list_begin>
c0029adf:	83 c4 10             	add    $0x10,%esp
c0029ae2:	89 c3                	mov    %eax,%ebx
c0029ae4:	83 ec 0c             	sub    $0xc,%esp
c0029ae7:	56                   	push   %esi
c0029ae8:	e8 be f5 ff ff       	call   c00290ab <list_end>
c0029aed:	83 c4 10             	add    $0x10,%esp
c0029af0:	39 d8                	cmp    %ebx,%eax
c0029af2:	0f 84 a1 00 00 00    	je     c0029b99 <list_insert_ordered+0xf1>
        if (less(elem, e, aux))
c0029af8:	83 ec 04             	sub    $0x4,%esp
c0029afb:	ff 74 24 30          	pushl  0x30(%esp)
c0029aff:	53                   	push   %ebx
c0029b00:	57                   	push   %edi
c0029b01:	ff d5                	call   *%ebp
c0029b03:	83 c4 10             	add    $0x10,%esp
c0029b06:	84 c0                	test   %al,%al
c0029b08:	0f 85 8b 00 00 00    	jne    c0029b99 <list_insert_ordered+0xf1>
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029b0e:	83 ec 0c             	sub    $0xc,%esp
c0029b11:	53                   	push   %ebx
c0029b12:	e8 37 f5 ff ff       	call   c002904e <list_next>
c0029b17:	83 c4 10             	add    $0x10,%esp
c0029b1a:	89 c3                	mov    %eax,%ebx
c0029b1c:	eb c6                	jmp    c0029ae4 <list_insert_ordered+0x3c>
    ASSERT (list != NULL);
c0029b1e:	83 ec 0c             	sub    $0xc,%esp
c0029b21:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c0029b27:	50                   	push   %eax
c0029b28:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029b2e:	50                   	push   %eax
c0029b2f:	8d 83 7c 40 ff ff    	lea    -0xbf84(%ebx),%eax
c0029b35:	50                   	push   %eax
c0029b36:	68 9e 01 00 00       	push   $0x19e
c0029b3b:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029b41:	50                   	push   %eax
c0029b42:	e8 9d f3 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (elem != NULL);
c0029b47:	83 ec 0c             	sub    $0xc,%esp
c0029b4a:	8d 83 29 5f ff ff    	lea    -0xa0d7(%ebx),%eax
c0029b50:	50                   	push   %eax
c0029b51:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029b57:	50                   	push   %eax
c0029b58:	8d 83 7c 40 ff ff    	lea    -0xbf84(%ebx),%eax
c0029b5e:	50                   	push   %eax
c0029b5f:	68 9f 01 00 00       	push   $0x19f
c0029b64:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029b6a:	50                   	push   %eax
c0029b6b:	e8 74 f3 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (less != NULL);
c0029b70:	83 ec 0c             	sub    $0xc,%esp
c0029b73:	8d 83 15 5f ff ff    	lea    -0xa0eb(%ebx),%eax
c0029b79:	50                   	push   %eax
c0029b7a:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029b80:	50                   	push   %eax
c0029b81:	8d 83 7c 40 ff ff    	lea    -0xbf84(%ebx),%eax
c0029b87:	50                   	push   %eax
c0029b88:	68 a0 01 00 00       	push   $0x1a0
c0029b8d:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029b93:	50                   	push   %eax
c0029b94:	e8 4b f3 ff ff       	call   c0028ee4 <debug_panic>
            break;
    return list_insert(e, elem);
c0029b99:	83 ec 08             	sub    $0x8,%esp
c0029b9c:	57                   	push   %edi
c0029b9d:	53                   	push   %ebx
c0029b9e:	e8 35 f8 ff ff       	call   c00293d8 <list_insert>
}
c0029ba3:	83 c4 1c             	add    $0x1c,%esp
c0029ba6:	5b                   	pop    %ebx
c0029ba7:	5e                   	pop    %esi
c0029ba8:	5f                   	pop    %edi
c0029ba9:	5d                   	pop    %ebp
c0029baa:	c3                   	ret    

c0029bab <list_unique>:
   set of adjacent elements that are equal according to LESS
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique(struct list *list, struct list *duplicates,
            list_less_func *less, void *aux) {
c0029bab:	55                   	push   %ebp
c0029bac:	57                   	push   %edi
c0029bad:	56                   	push   %esi
c0029bae:	53                   	push   %ebx
c0029baf:	83 ec 0c             	sub    $0xc,%esp
c0029bb2:	e8 e0 3c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029bb7:	81 c3 49 09 01 00    	add    $0x10949,%ebx
c0029bbd:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0029bc1:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    struct list_elem *elem, *next;

    ASSERT (list != NULL);
c0029bc5:	85 ff                	test   %edi,%edi
c0029bc7:	74 1c                	je     c0029be5 <list_unique+0x3a>
    ASSERT (less != NULL);
c0029bc9:	85 ed                	test   %ebp,%ebp
c0029bcb:	74 41                	je     c0029c0e <list_unique+0x63>
    if (list_empty(list))
c0029bcd:	83 ec 0c             	sub    $0xc,%esp
c0029bd0:	57                   	push   %edi
c0029bd1:	e8 7f fa ff ff       	call   c0029655 <list_empty>
c0029bd6:	83 c4 10             	add    $0x10,%esp
c0029bd9:	84 c0                	test   %al,%al
c0029bdb:	74 5a                	je     c0029c37 <list_unique+0x8c>
            list_remove(next);
            if (duplicates != NULL)
                list_push_back(duplicates, next);
        } else
            elem = next;
}
c0029bdd:	83 c4 0c             	add    $0xc,%esp
c0029be0:	5b                   	pop    %ebx
c0029be1:	5e                   	pop    %esi
c0029be2:	5f                   	pop    %edi
c0029be3:	5d                   	pop    %ebp
c0029be4:	c3                   	ret    
    ASSERT (list != NULL);
c0029be5:	83 ec 0c             	sub    $0xc,%esp
c0029be8:	8d 83 e6 5e ff ff    	lea    -0xa11a(%ebx),%eax
c0029bee:	50                   	push   %eax
c0029bef:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029bf5:	50                   	push   %eax
c0029bf6:	8d 83 70 40 ff ff    	lea    -0xbf90(%ebx),%eax
c0029bfc:	50                   	push   %eax
c0029bfd:	68 b1 01 00 00       	push   $0x1b1
c0029c02:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029c08:	50                   	push   %eax
c0029c09:	e8 d6 f2 ff ff       	call   c0028ee4 <debug_panic>
    ASSERT (less != NULL);
c0029c0e:	83 ec 0c             	sub    $0xc,%esp
c0029c11:	8d 83 15 5f ff ff    	lea    -0xa0eb(%ebx),%eax
c0029c17:	50                   	push   %eax
c0029c18:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029c1e:	50                   	push   %eax
c0029c1f:	8d 83 70 40 ff ff    	lea    -0xbf90(%ebx),%eax
c0029c25:	50                   	push   %eax
c0029c26:	68 b2 01 00 00       	push   $0x1b2
c0029c2b:	8d 83 f3 5e ff ff    	lea    -0xa10d(%ebx),%eax
c0029c31:	50                   	push   %eax
c0029c32:	e8 ad f2 ff ff       	call   c0028ee4 <debug_panic>
    elem = list_begin(list);
c0029c37:	83 ec 0c             	sub    $0xc,%esp
c0029c3a:	57                   	push   %edi
c0029c3b:	e8 c9 f3 ff ff       	call   c0029009 <list_begin>
c0029c40:	83 c4 10             	add    $0x10,%esp
c0029c43:	89 c6                	mov    %eax,%esi
    while ((next = list_next(elem)) != list_end(list))
c0029c45:	eb 04                	jmp    c0029c4b <list_unique+0xa0>
c0029c47:	89 f3                	mov    %esi,%ebx
c0029c49:	89 de                	mov    %ebx,%esi
c0029c4b:	83 ec 0c             	sub    $0xc,%esp
c0029c4e:	56                   	push   %esi
c0029c4f:	e8 fa f3 ff ff       	call   c002904e <list_next>
c0029c54:	89 c3                	mov    %eax,%ebx
c0029c56:	89 3c 24             	mov    %edi,(%esp)
c0029c59:	e8 4d f4 ff ff       	call   c00290ab <list_end>
c0029c5e:	83 c4 10             	add    $0x10,%esp
c0029c61:	39 d8                	cmp    %ebx,%eax
c0029c63:	0f 84 74 ff ff ff    	je     c0029bdd <list_unique+0x32>
        if (!less(elem, next, aux) && !less(next, elem, aux)) {
c0029c69:	83 ec 04             	sub    $0x4,%esp
c0029c6c:	ff 74 24 30          	pushl  0x30(%esp)
c0029c70:	53                   	push   %ebx
c0029c71:	56                   	push   %esi
c0029c72:	ff d5                	call   *%ebp
c0029c74:	83 c4 10             	add    $0x10,%esp
c0029c77:	84 c0                	test   %al,%al
c0029c79:	75 ce                	jne    c0029c49 <list_unique+0x9e>
c0029c7b:	83 ec 04             	sub    $0x4,%esp
c0029c7e:	ff 74 24 30          	pushl  0x30(%esp)
c0029c82:	56                   	push   %esi
c0029c83:	53                   	push   %ebx
c0029c84:	ff d5                	call   *%ebp
c0029c86:	83 c4 10             	add    $0x10,%esp
c0029c89:	84 c0                	test   %al,%al
c0029c8b:	75 bc                	jne    c0029c49 <list_unique+0x9e>
            list_remove(next);
c0029c8d:	83 ec 0c             	sub    $0xc,%esp
c0029c90:	53                   	push   %ebx
c0029c91:	e8 1d f9 ff ff       	call   c00295b3 <list_remove>
            if (duplicates != NULL)
c0029c96:	83 c4 10             	add    $0x10,%esp
c0029c99:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0029c9e:	74 a7                	je     c0029c47 <list_unique+0x9c>
                list_push_back(duplicates, next);
c0029ca0:	83 ec 08             	sub    $0x8,%esp
c0029ca3:	53                   	push   %ebx
c0029ca4:	ff 74 24 30          	pushl  0x30(%esp)
c0029ca8:	e8 e9 f8 ff ff       	call   c0029596 <list_push_back>
c0029cad:	83 c4 10             	add    $0x10,%esp
c0029cb0:	89 f3                	mov    %esi,%ebx
c0029cb2:	eb 95                	jmp    c0029c49 <list_unique+0x9e>

c0029cb4 <list_max>:
/* Returns the element in LIST with the largest value according
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max(struct list *list, list_less_func *less, void *aux) {
c0029cb4:	55                   	push   %ebp
c0029cb5:	57                   	push   %edi
c0029cb6:	56                   	push   %esi
c0029cb7:	53                   	push   %ebx
c0029cb8:	83 ec 18             	sub    $0x18,%esp
c0029cbb:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029cbf:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    struct list_elem *max = list_begin(list);
c0029cc3:	57                   	push   %edi
c0029cc4:	e8 40 f3 ff ff       	call   c0029009 <list_begin>
c0029cc9:	89 c6                	mov    %eax,%esi
    if (max != list_end(list)) {
c0029ccb:	89 3c 24             	mov    %edi,(%esp)
c0029cce:	e8 d8 f3 ff ff       	call   c00290ab <list_end>
c0029cd3:	83 c4 10             	add    $0x10,%esp
c0029cd6:	39 f0                	cmp    %esi,%eax
c0029cd8:	74 3c                	je     c0029d16 <list_max+0x62>
        struct list_elem *e;

        for (e = list_next(max); e != list_end(list); e = list_next(e))
c0029cda:	83 ec 0c             	sub    $0xc,%esp
c0029cdd:	56                   	push   %esi
c0029cde:	e8 6b f3 ff ff       	call   c002904e <list_next>
c0029ce3:	83 c4 10             	add    $0x10,%esp
c0029ce6:	89 c3                	mov    %eax,%ebx
c0029ce8:	83 ec 0c             	sub    $0xc,%esp
c0029ceb:	57                   	push   %edi
c0029cec:	e8 ba f3 ff ff       	call   c00290ab <list_end>
c0029cf1:	83 c4 10             	add    $0x10,%esp
c0029cf4:	39 d8                	cmp    %ebx,%eax
c0029cf6:	74 1e                	je     c0029d16 <list_max+0x62>
            if (less(max, e, aux))
c0029cf8:	83 ec 04             	sub    $0x4,%esp
c0029cfb:	55                   	push   %ebp
c0029cfc:	53                   	push   %ebx
c0029cfd:	56                   	push   %esi
c0029cfe:	ff 54 24 34          	call   *0x34(%esp)
c0029d02:	84 c0                	test   %al,%al
                max = e;
c0029d04:	0f 45 f3             	cmovne %ebx,%esi
        for (e = list_next(max); e != list_end(list); e = list_next(e))
c0029d07:	89 1c 24             	mov    %ebx,(%esp)
c0029d0a:	e8 3f f3 ff ff       	call   c002904e <list_next>
c0029d0f:	83 c4 10             	add    $0x10,%esp
c0029d12:	89 c3                	mov    %eax,%ebx
c0029d14:	eb d2                	jmp    c0029ce8 <list_max+0x34>
    }
    return max;
}
c0029d16:	89 f0                	mov    %esi,%eax
c0029d18:	83 c4 0c             	add    $0xc,%esp
c0029d1b:	5b                   	pop    %ebx
c0029d1c:	5e                   	pop    %esi
c0029d1d:	5f                   	pop    %edi
c0029d1e:	5d                   	pop    %ebp
c0029d1f:	c3                   	ret    

c0029d20 <list_min>:
/* Returns the element in LIST with the smallest value according
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min(struct list *list, list_less_func *less, void *aux) {
c0029d20:	55                   	push   %ebp
c0029d21:	57                   	push   %edi
c0029d22:	56                   	push   %esi
c0029d23:	53                   	push   %ebx
c0029d24:	83 ec 18             	sub    $0x18,%esp
c0029d27:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029d2b:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    struct list_elem *min = list_begin(list);
c0029d2f:	57                   	push   %edi
c0029d30:	e8 d4 f2 ff ff       	call   c0029009 <list_begin>
c0029d35:	89 c6                	mov    %eax,%esi
    if (min != list_end(list)) {
c0029d37:	89 3c 24             	mov    %edi,(%esp)
c0029d3a:	e8 6c f3 ff ff       	call   c00290ab <list_end>
c0029d3f:	83 c4 10             	add    $0x10,%esp
c0029d42:	39 f0                	cmp    %esi,%eax
c0029d44:	74 3c                	je     c0029d82 <list_min+0x62>
        struct list_elem *e;

        for (e = list_next(min); e != list_end(list); e = list_next(e))
c0029d46:	83 ec 0c             	sub    $0xc,%esp
c0029d49:	56                   	push   %esi
c0029d4a:	e8 ff f2 ff ff       	call   c002904e <list_next>
c0029d4f:	83 c4 10             	add    $0x10,%esp
c0029d52:	89 c3                	mov    %eax,%ebx
c0029d54:	83 ec 0c             	sub    $0xc,%esp
c0029d57:	57                   	push   %edi
c0029d58:	e8 4e f3 ff ff       	call   c00290ab <list_end>
c0029d5d:	83 c4 10             	add    $0x10,%esp
c0029d60:	39 d8                	cmp    %ebx,%eax
c0029d62:	74 1e                	je     c0029d82 <list_min+0x62>
            if (less(e, min, aux))
c0029d64:	83 ec 04             	sub    $0x4,%esp
c0029d67:	55                   	push   %ebp
c0029d68:	56                   	push   %esi
c0029d69:	53                   	push   %ebx
c0029d6a:	ff 54 24 34          	call   *0x34(%esp)
c0029d6e:	84 c0                	test   %al,%al
                min = e;
c0029d70:	0f 45 f3             	cmovne %ebx,%esi
        for (e = list_next(min); e != list_end(list); e = list_next(e))
c0029d73:	89 1c 24             	mov    %ebx,(%esp)
c0029d76:	e8 d3 f2 ff ff       	call   c002904e <list_next>
c0029d7b:	83 c4 10             	add    $0x10,%esp
c0029d7e:	89 c3                	mov    %eax,%ebx
c0029d80:	eb d2                	jmp    c0029d54 <list_min+0x34>
    }
    return min;
}
c0029d82:	89 f0                	mov    %esi,%eax
c0029d84:	83 c4 0c             	add    $0xc,%esp
c0029d87:	5b                   	pop    %ebx
c0029d88:	5e                   	pop    %esi
c0029d89:	5f                   	pop    %edi
c0029d8a:	5d                   	pop    %ebp
c0029d8b:	c3                   	ret    

c0029d8c <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029d8c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029d90:	83 c0 1f             	add    $0x1f,%eax
c0029d93:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c0029d96:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c0029d9d:	c3                   	ret    

c0029d9e <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c0029d9e:	56                   	push   %esi
c0029d9f:	53                   	push   %ebx
c0029da0:	83 ec 04             	sub    $0x4,%esp
c0029da3:	e8 ef 3a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029da8:	81 c3 58 07 01 00    	add    $0x10758,%ebx
c0029dae:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (b != NULL) 
c0029db2:	85 f6                	test   %esi,%esi
c0029db4:	74 16                	je     c0029dcc <bitmap_destroy+0x2e>
    {
      free (b->bits);
c0029db6:	83 ec 0c             	sub    $0xc,%esp
c0029db9:	ff 76 04             	pushl  0x4(%esi)
c0029dbc:	e8 01 a0 ff ff       	call   c0023dc2 <free>
      free (b);
c0029dc1:	89 34 24             	mov    %esi,(%esp)
c0029dc4:	e8 f9 9f ff ff       	call   c0023dc2 <free>
c0029dc9:	83 c4 10             	add    $0x10,%esp
    }
}
c0029dcc:	83 c4 04             	add    $0x4,%esp
c0029dcf:	5b                   	pop    %ebx
c0029dd0:	5e                   	pop    %esi
c0029dd1:	c3                   	ret    

c0029dd2 <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c0029dd2:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029dd6:	8b 00                	mov    (%eax),%eax
}
c0029dd8:	c3                   	ret    

c0029dd9 <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c0029dd9:	53                   	push   %ebx
c0029dda:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029dde:	89 cb                	mov    %ecx,%ebx
c0029de0:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029de3:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029de7:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029dea:	b8 01 00 00 00       	mov    $0x1,%eax
c0029def:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029df1:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c0029df4:	5b                   	pop    %ebx
c0029df5:	c3                   	ret    

c0029df6 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c0029df6:	53                   	push   %ebx
c0029df7:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029dfb:	89 cb                	mov    %ecx,%ebx
c0029dfd:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0029e00:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029e04:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029e07:	b8 01 00 00 00       	mov    $0x1,%eax
c0029e0c:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0029e0e:	f7 d0                	not    %eax
c0029e10:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c0029e13:	5b                   	pop    %ebx
c0029e14:	c3                   	ret    

c0029e15 <bitmap_set>:
{
c0029e15:	53                   	push   %ebx
c0029e16:	83 ec 08             	sub    $0x8,%esp
c0029e19:	e8 79 3a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029e1e:	81 c3 e2 06 01 00    	add    $0x106e2,%ebx
c0029e24:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029e28:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029e2c:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c0029e30:	85 c0                	test   %eax,%eax
c0029e32:	74 1a                	je     c0029e4e <bitmap_set+0x39>
  ASSERT (idx < b->bit_cnt);
c0029e34:	39 10                	cmp    %edx,(%eax)
c0029e36:	76 3f                	jbe    c0029e77 <bitmap_set+0x62>
  if (value)
c0029e38:	84 c9                	test   %cl,%cl
c0029e3a:	74 64                	je     c0029ea0 <bitmap_set+0x8b>
    bitmap_mark (b, idx);
c0029e3c:	83 ec 08             	sub    $0x8,%esp
c0029e3f:	52                   	push   %edx
c0029e40:	50                   	push   %eax
c0029e41:	e8 93 ff ff ff       	call   c0029dd9 <bitmap_mark>
c0029e46:	83 c4 10             	add    $0x10,%esp
}
c0029e49:	83 c4 08             	add    $0x8,%esp
c0029e4c:	5b                   	pop    %ebx
c0029e4d:	c3                   	ret    
  ASSERT (b != NULL);
c0029e4e:	83 ec 0c             	sub    $0xc,%esp
c0029e51:	8d 83 0b 5f ff ff    	lea    -0xa0f5(%ebx),%eax
c0029e57:	50                   	push   %eax
c0029e58:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029e5e:	50                   	push   %eax
c0029e5f:	8d 83 c0 41 ff ff    	lea    -0xbe40(%ebx),%eax
c0029e65:	50                   	push   %eax
c0029e66:	68 93 00 00 00       	push   $0x93
c0029e6b:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c0029e71:	50                   	push   %eax
c0029e72:	e8 6d f0 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c0029e77:	83 ec 0c             	sub    $0xc,%esp
c0029e7a:	8d 83 a5 60 ff ff    	lea    -0x9f5b(%ebx),%eax
c0029e80:	50                   	push   %eax
c0029e81:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029e87:	50                   	push   %eax
c0029e88:	8d 83 c0 41 ff ff    	lea    -0xbe40(%ebx),%eax
c0029e8e:	50                   	push   %eax
c0029e8f:	68 94 00 00 00       	push   $0x94
c0029e94:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c0029e9a:	50                   	push   %eax
c0029e9b:	e8 44 f0 ff ff       	call   c0028ee4 <debug_panic>
    bitmap_reset (b, idx);
c0029ea0:	83 ec 08             	sub    $0x8,%esp
c0029ea3:	52                   	push   %edx
c0029ea4:	50                   	push   %eax
c0029ea5:	e8 4c ff ff ff       	call   c0029df6 <bitmap_reset>
c0029eaa:	83 c4 10             	add    $0x10,%esp
}
c0029ead:	eb 9a                	jmp    c0029e49 <bitmap_set+0x34>

c0029eaf <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c0029eaf:	53                   	push   %ebx
c0029eb0:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029eb4:	89 cb                	mov    %ecx,%ebx
c0029eb6:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029eb9:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029ebd:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029ec0:	b8 01 00 00 00       	mov    $0x1,%eax
c0029ec5:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029ec7:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c0029eca:	5b                   	pop    %ebx
c0029ecb:	c3                   	ret    

c0029ecc <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c0029ecc:	53                   	push   %ebx
c0029ecd:	83 ec 08             	sub    $0x8,%esp
c0029ed0:	e8 c2 39 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c0029ed5:	81 c3 2b 06 01 00    	add    $0x1062b,%ebx
c0029edb:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029edf:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c0029ee3:	85 c0                	test   %eax,%eax
c0029ee5:	74 1e                	je     c0029f05 <bitmap_test+0x39>
  ASSERT (idx < b->bit_cnt);
c0029ee7:	39 08                	cmp    %ecx,(%eax)
c0029ee9:	76 43                	jbe    c0029f2e <bitmap_test+0x62>
  return bit_idx / ELEM_BITS;
c0029eeb:	89 cb                	mov    %ecx,%ebx
c0029eed:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0029ef0:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029ef3:	b8 01 00 00 00       	mov    $0x1,%eax
c0029ef8:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0029efa:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c0029efd:	0f 95 c0             	setne  %al
}
c0029f00:	83 c4 08             	add    $0x8,%esp
c0029f03:	5b                   	pop    %ebx
c0029f04:	c3                   	ret    
  ASSERT (b != NULL);
c0029f05:	83 ec 0c             	sub    $0xc,%esp
c0029f08:	8d 83 0b 5f ff ff    	lea    -0xa0f5(%ebx),%eax
c0029f0e:	50                   	push   %eax
c0029f0f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029f15:	50                   	push   %eax
c0029f16:	8d 83 b4 41 ff ff    	lea    -0xbe4c(%ebx),%eax
c0029f1c:	50                   	push   %eax
c0029f1d:	68 c8 00 00 00       	push   $0xc8
c0029f22:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c0029f28:	50                   	push   %eax
c0029f29:	e8 b6 ef ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c0029f2e:	83 ec 0c             	sub    $0xc,%esp
c0029f31:	8d 83 a5 60 ff ff    	lea    -0x9f5b(%ebx),%eax
c0029f37:	50                   	push   %eax
c0029f38:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c0029f3e:	50                   	push   %eax
c0029f3f:	8d 83 b4 41 ff ff    	lea    -0xbe4c(%ebx),%eax
c0029f45:	50                   	push   %eax
c0029f46:	68 c9 00 00 00       	push   $0xc9
c0029f4b:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c0029f51:	50                   	push   %eax
c0029f52:	e8 8d ef ff ff       	call   c0028ee4 <debug_panic>

c0029f57 <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0029f57:	55                   	push   %ebp
c0029f58:	57                   	push   %edi
c0029f59:	56                   	push   %esi
c0029f5a:	53                   	push   %ebx
c0029f5b:	83 ec 0c             	sub    $0xc,%esp
c0029f5e:	e8 48 39 00 00       	call   c002d8ab <__x86.get_pc_thunk.cx>
c0029f63:	81 c1 9d 05 01 00    	add    $0x1059d,%ecx
c0029f69:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0029f6d:	8b 74 24 24          	mov    0x24(%esp),%esi
c0029f71:	8b 44 24 28          	mov    0x28(%esp),%eax
c0029f75:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c0029f7a:	85 ff                	test   %edi,%edi
c0029f7c:	74 31                	je     c0029faf <bitmap_set_multiple+0x58>
  ASSERT (start <= b->bit_cnt);
c0029f7e:	8b 17                	mov    (%edi),%edx
c0029f80:	39 f2                	cmp    %esi,%edx
c0029f82:	72 56                	jb     c0029fda <bitmap_set_multiple+0x83>
  ASSERT (start + cnt <= b->bit_cnt);
c0029f84:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c0029f87:	39 ea                	cmp    %ebp,%edx
c0029f89:	72 7a                	jb     c002a005 <bitmap_set_multiple+0xae>

  for (i = 0; i < cnt; i++)
    bitmap_set (b, start + i, value);
c0029f8b:	0f b6 db             	movzbl %bl,%ebx
  for (i = 0; i < cnt; i++)
c0029f8e:	85 c0                	test   %eax,%eax
c0029f90:	74 15                	je     c0029fa7 <bitmap_set_multiple+0x50>
    bitmap_set (b, start + i, value);
c0029f92:	83 ec 04             	sub    $0x4,%esp
c0029f95:	53                   	push   %ebx
c0029f96:	56                   	push   %esi
c0029f97:	57                   	push   %edi
c0029f98:	e8 78 fe ff ff       	call   c0029e15 <bitmap_set>
c0029f9d:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c0029fa0:	83 c4 10             	add    $0x10,%esp
c0029fa3:	39 f5                	cmp    %esi,%ebp
c0029fa5:	75 eb                	jne    c0029f92 <bitmap_set_multiple+0x3b>
}
c0029fa7:	83 c4 0c             	add    $0xc,%esp
c0029faa:	5b                   	pop    %ebx
c0029fab:	5e                   	pop    %esi
c0029fac:	5f                   	pop    %edi
c0029fad:	5d                   	pop    %ebp
c0029fae:	c3                   	ret    
  ASSERT (b != NULL);
c0029faf:	83 ec 0c             	sub    $0xc,%esp
c0029fb2:	8d 81 0b 5f ff ff    	lea    -0xa0f5(%ecx),%eax
c0029fb8:	50                   	push   %eax
c0029fb9:	8d 81 96 44 ff ff    	lea    -0xbb6a(%ecx),%eax
c0029fbf:	50                   	push   %eax
c0029fc0:	8d 81 90 41 ff ff    	lea    -0xbe70(%ecx),%eax
c0029fc6:	50                   	push   %eax
c0029fc7:	68 de 00 00 00       	push   $0xde
c0029fcc:	8d 81 8b 60 ff ff    	lea    -0x9f75(%ecx),%eax
c0029fd2:	50                   	push   %eax
c0029fd3:	89 cb                	mov    %ecx,%ebx
c0029fd5:	e8 0a ef ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0029fda:	83 ec 0c             	sub    $0xc,%esp
c0029fdd:	8d 81 b6 60 ff ff    	lea    -0x9f4a(%ecx),%eax
c0029fe3:	50                   	push   %eax
c0029fe4:	8d 81 96 44 ff ff    	lea    -0xbb6a(%ecx),%eax
c0029fea:	50                   	push   %eax
c0029feb:	8d 81 90 41 ff ff    	lea    -0xbe70(%ecx),%eax
c0029ff1:	50                   	push   %eax
c0029ff2:	68 df 00 00 00       	push   $0xdf
c0029ff7:	8d 81 8b 60 ff ff    	lea    -0x9f75(%ecx),%eax
c0029ffd:	50                   	push   %eax
c0029ffe:	89 cb                	mov    %ecx,%ebx
c002a000:	e8 df ee ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a005:	83 ec 0c             	sub    $0xc,%esp
c002a008:	8d 81 ca 60 ff ff    	lea    -0x9f36(%ecx),%eax
c002a00e:	50                   	push   %eax
c002a00f:	8d 81 96 44 ff ff    	lea    -0xbb6a(%ecx),%eax
c002a015:	50                   	push   %eax
c002a016:	8d 81 90 41 ff ff    	lea    -0xbe70(%ecx),%eax
c002a01c:	50                   	push   %eax
c002a01d:	68 e0 00 00 00       	push   $0xe0
c002a022:	8d 81 8b 60 ff ff    	lea    -0x9f75(%ecx),%eax
c002a028:	50                   	push   %eax
c002a029:	89 cb                	mov    %ecx,%ebx
c002a02b:	e8 b4 ee ff ff       	call   c0028ee4 <debug_panic>

c002a030 <bitmap_set_all>:
{
c002a030:	53                   	push   %ebx
c002a031:	83 ec 08             	sub    $0x8,%esp
c002a034:	e8 5e 38 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a039:	81 c3 c7 04 01 00    	add    $0x104c7,%ebx
c002a03f:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a043:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c002a047:	85 c0                	test   %eax,%eax
c002a049:	74 13                	je     c002a05e <bitmap_set_all+0x2e>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a04b:	0f b6 d2             	movzbl %dl,%edx
c002a04e:	52                   	push   %edx
c002a04f:	ff 30                	pushl  (%eax)
c002a051:	6a 00                	push   $0x0
c002a053:	50                   	push   %eax
c002a054:	e8 fe fe ff ff       	call   c0029f57 <bitmap_set_multiple>
}
c002a059:	83 c4 18             	add    $0x18,%esp
c002a05c:	5b                   	pop    %ebx
c002a05d:	c3                   	ret    
  ASSERT (b != NULL);
c002a05e:	83 ec 0c             	sub    $0xc,%esp
c002a061:	8d 83 0b 5f ff ff    	lea    -0xa0f5(%ebx),%eax
c002a067:	50                   	push   %eax
c002a068:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002a06e:	50                   	push   %eax
c002a06f:	8d 83 a4 41 ff ff    	lea    -0xbe5c(%ebx),%eax
c002a075:	50                   	push   %eax
c002a076:	68 d3 00 00 00       	push   $0xd3
c002a07b:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c002a081:	50                   	push   %eax
c002a082:	e8 5d ee ff ff       	call   c0028ee4 <debug_panic>

c002a087 <bitmap_create>:
{
c002a087:	57                   	push   %edi
c002a088:	56                   	push   %esi
c002a089:	53                   	push   %ebx
c002a08a:	e8 08 38 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a08f:	81 c3 71 04 01 00    	add    $0x10471,%ebx
c002a095:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct bitmap *b = malloc (sizeof *b);
c002a099:	83 ec 0c             	sub    $0xc,%esp
c002a09c:	6a 08                	push   $0x8
c002a09e:	e8 71 9b ff ff       	call   c0023c14 <malloc>
c002a0a3:	89 c6                	mov    %eax,%esi
  if (b != NULL)
c002a0a5:	83 c4 10             	add    $0x10,%esp
c002a0a8:	85 c0                	test   %eax,%eax
c002a0aa:	74 30                	je     c002a0dc <bitmap_create+0x55>
      b->bit_cnt = bit_cnt;
c002a0ac:	89 38                	mov    %edi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a0ae:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a0b1:	8d 47 1f             	lea    0x1f(%edi),%eax
c002a0b4:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a0b7:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c002a0ba:	50                   	push   %eax
c002a0bb:	e8 54 9b ff ff       	call   c0023c14 <malloc>
c002a0c0:	89 46 04             	mov    %eax,0x4(%esi)
      if (b->bits != NULL || bit_cnt == 0)
c002a0c3:	83 c4 10             	add    $0x10,%esp
c002a0c6:	85 ff                	test   %edi,%edi
c002a0c8:	74 04                	je     c002a0ce <bitmap_create+0x47>
c002a0ca:	85 c0                	test   %eax,%eax
c002a0cc:	74 14                	je     c002a0e2 <bitmap_create+0x5b>
          bitmap_set_all (b, false);
c002a0ce:	83 ec 08             	sub    $0x8,%esp
c002a0d1:	6a 00                	push   $0x0
c002a0d3:	56                   	push   %esi
c002a0d4:	e8 57 ff ff ff       	call   c002a030 <bitmap_set_all>
          return b;
c002a0d9:	83 c4 10             	add    $0x10,%esp
}
c002a0dc:	89 f0                	mov    %esi,%eax
c002a0de:	5b                   	pop    %ebx
c002a0df:	5e                   	pop    %esi
c002a0e0:	5f                   	pop    %edi
c002a0e1:	c3                   	ret    
      free (b);
c002a0e2:	83 ec 0c             	sub    $0xc,%esp
c002a0e5:	56                   	push   %esi
c002a0e6:	e8 d7 9c ff ff       	call   c0023dc2 <free>
c002a0eb:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002a0ee:	be 00 00 00 00       	mov    $0x0,%esi
c002a0f3:	eb e7                	jmp    c002a0dc <bitmap_create+0x55>

c002a0f5 <bitmap_create_in_buf>:
{
c002a0f5:	57                   	push   %edi
c002a0f6:	56                   	push   %esi
c002a0f7:	53                   	push   %ebx
c002a0f8:	e8 9a 37 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a0fd:	81 c3 03 04 01 00    	add    $0x10403,%ebx
c002a103:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002a107:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a10b:	57                   	push   %edi
c002a10c:	e8 7b fc ff ff       	call   c0029d8c <bitmap_buf_size>
c002a111:	83 c4 04             	add    $0x4,%esp
c002a114:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002a118:	77 1c                	ja     c002a136 <bitmap_create_in_buf+0x41>
  b->bit_cnt = bit_cnt;
c002a11a:	89 3e                	mov    %edi,(%esi)
  b->bits = (elem_type *) (b + 1);
c002a11c:	8d 46 08             	lea    0x8(%esi),%eax
c002a11f:	89 46 04             	mov    %eax,0x4(%esi)
  bitmap_set_all (b, false);
c002a122:	83 ec 08             	sub    $0x8,%esp
c002a125:	6a 00                	push   $0x0
c002a127:	56                   	push   %esi
c002a128:	e8 03 ff ff ff       	call   c002a030 <bitmap_set_all>
  return b;
c002a12d:	83 c4 10             	add    $0x10,%esp
}
c002a130:	89 f0                	mov    %esi,%eax
c002a132:	5b                   	pop    %ebx
c002a133:	5e                   	pop    %esi
c002a134:	5f                   	pop    %edi
c002a135:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a136:	83 ec 0c             	sub    $0xc,%esp
c002a139:	8d 83 e4 60 ff ff    	lea    -0x9f1c(%ebx),%eax
c002a13f:	50                   	push   %eax
c002a140:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002a146:	50                   	push   %eax
c002a147:	8d 83 cc 41 ff ff    	lea    -0xbe34(%ebx),%eax
c002a14d:	50                   	push   %eax
c002a14e:	6a 68                	push   $0x68
c002a150:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c002a156:	50                   	push   %eax
c002a157:	e8 88 ed ff ff       	call   c0028ee4 <debug_panic>

c002a15c <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a15c:	55                   	push   %ebp
c002a15d:	57                   	push   %edi
c002a15e:	56                   	push   %esi
c002a15f:	53                   	push   %ebx
c002a160:	83 ec 1c             	sub    $0x1c,%esp
c002a163:	e8 2f 37 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a168:	81 c3 98 03 01 00    	add    $0x10398,%ebx
c002a16e:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a172:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a176:	8b 44 24 38          	mov    0x38(%esp),%eax
c002a17a:	0f b6 54 24 3c       	movzbl 0x3c(%esp),%edx
c002a17f:	88 54 24 0f          	mov    %dl,0xf(%esp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002a183:	85 ff                	test   %edi,%edi
c002a185:	74 44                	je     c002a1cb <bitmap_count+0x6f>
  ASSERT (start <= b->bit_cnt);
c002a187:	8b 17                	mov    (%edi),%edx
c002a189:	39 f2                	cmp    %esi,%edx
c002a18b:	72 67                	jb     c002a1f4 <bitmap_count+0x98>
  ASSERT (start + cnt <= b->bit_cnt);
c002a18d:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a190:	39 ea                	cmp    %ebp,%edx
c002a192:	0f 82 89 00 00 00    	jb     c002a221 <bitmap_count+0xc5>

  value_cnt = 0;
c002a198:	bb 00 00 00 00       	mov    $0x0,%ebx
  for (i = 0; i < cnt; i++)
c002a19d:	85 c0                	test   %eax,%eax
c002a19f:	74 7c                	je     c002a21d <bitmap_count+0xc1>
    if (bitmap_test (b, start + i) == value)
c002a1a1:	83 ec 08             	sub    $0x8,%esp
c002a1a4:	56                   	push   %esi
c002a1a5:	57                   	push   %edi
c002a1a6:	e8 21 fd ff ff       	call   c0029ecc <bitmap_test>
c002a1ab:	83 c4 10             	add    $0x10,%esp
      value_cnt++;
c002a1ae:	3a 44 24 0f          	cmp    0xf(%esp),%al
c002a1b2:	0f 94 c0             	sete   %al
c002a1b5:	0f b6 c0             	movzbl %al,%eax
c002a1b8:	01 c3                	add    %eax,%ebx
c002a1ba:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a1bd:	39 f5                	cmp    %esi,%ebp
c002a1bf:	75 e0                	jne    c002a1a1 <bitmap_count+0x45>
  return value_cnt;
}
c002a1c1:	89 d8                	mov    %ebx,%eax
c002a1c3:	83 c4 1c             	add    $0x1c,%esp
c002a1c6:	5b                   	pop    %ebx
c002a1c7:	5e                   	pop    %esi
c002a1c8:	5f                   	pop    %edi
c002a1c9:	5d                   	pop    %ebp
c002a1ca:	c3                   	ret    
  ASSERT (b != NULL);
c002a1cb:	83 ec 0c             	sub    $0xc,%esp
c002a1ce:	8d 83 0b 5f ff ff    	lea    -0xa0f5(%ebx),%eax
c002a1d4:	50                   	push   %eax
c002a1d5:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002a1db:	50                   	push   %eax
c002a1dc:	8d 83 80 41 ff ff    	lea    -0xbe80(%ebx),%eax
c002a1e2:	50                   	push   %eax
c002a1e3:	68 ed 00 00 00       	push   $0xed
c002a1e8:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c002a1ee:	50                   	push   %eax
c002a1ef:	e8 f0 ec ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a1f4:	83 ec 0c             	sub    $0xc,%esp
c002a1f7:	8d 83 b6 60 ff ff    	lea    -0x9f4a(%ebx),%eax
c002a1fd:	50                   	push   %eax
c002a1fe:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002a204:	50                   	push   %eax
c002a205:	8d 83 80 41 ff ff    	lea    -0xbe80(%ebx),%eax
c002a20b:	50                   	push   %eax
c002a20c:	68 ee 00 00 00       	push   $0xee
c002a211:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c002a217:	50                   	push   %eax
c002a218:	e8 c7 ec ff ff       	call   c0028ee4 <debug_panic>
  value_cnt = 0;
c002a21d:	89 c3                	mov    %eax,%ebx
c002a21f:	eb a0                	jmp    c002a1c1 <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c002a221:	83 ec 0c             	sub    $0xc,%esp
c002a224:	8d 83 ca 60 ff ff    	lea    -0x9f36(%ebx),%eax
c002a22a:	50                   	push   %eax
c002a22b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002a231:	50                   	push   %eax
c002a232:	8d 83 80 41 ff ff    	lea    -0xbe80(%ebx),%eax
c002a238:	50                   	push   %eax
c002a239:	68 ef 00 00 00       	push   $0xef
c002a23e:	8d 83 8b 60 ff ff    	lea    -0x9f75(%ebx),%eax
c002a244:	50                   	push   %eax
c002a245:	e8 9a ec ff ff       	call   c0028ee4 <debug_panic>

c002a24a <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a24a:	55                   	push   %ebp
c002a24b:	57                   	push   %edi
c002a24c:	56                   	push   %esi
c002a24d:	53                   	push   %ebx
c002a24e:	83 ec 0c             	sub    $0xc,%esp
c002a251:	e8 55 36 00 00       	call   c002d8ab <__x86.get_pc_thunk.cx>
c002a256:	81 c1 aa 02 01 00    	add    $0x102aa,%ecx
c002a25c:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a260:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a264:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a268:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a26d:	85 ff                	test   %edi,%edi
c002a26f:	74 3f                	je     c002a2b0 <bitmap_contains+0x66>
  ASSERT (start <= b->bit_cnt);
c002a271:	8b 17                	mov    (%edi),%edx
c002a273:	39 f2                	cmp    %esi,%edx
c002a275:	72 64                	jb     c002a2db <bitmap_contains+0x91>
  ASSERT (start + cnt <= b->bit_cnt);
c002a277:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a27a:	39 ea                	cmp    %ebp,%edx
c002a27c:	0f 82 84 00 00 00    	jb     c002a306 <bitmap_contains+0xbc>

  for (i = 0; i < cnt; i++)
c002a282:	85 c0                	test   %eax,%eax
c002a284:	0f 84 ac 00 00 00    	je     c002a336 <bitmap_contains+0xec>
    if (bitmap_test (b, start + i) == value)
c002a28a:	83 ec 08             	sub    $0x8,%esp
c002a28d:	56                   	push   %esi
c002a28e:	57                   	push   %edi
c002a28f:	e8 38 fc ff ff       	call   c0029ecc <bitmap_test>
c002a294:	83 c4 10             	add    $0x10,%esp
c002a297:	38 d8                	cmp    %bl,%al
c002a299:	0f 84 92 00 00 00    	je     c002a331 <bitmap_contains+0xe7>
c002a29f:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a2a2:	39 f5                	cmp    %esi,%ebp
c002a2a4:	75 e4                	jne    c002a28a <bitmap_contains+0x40>
      return true;
  return false;
c002a2a6:	b8 00 00 00 00       	mov    $0x0,%eax
c002a2ab:	e9 86 00 00 00       	jmp    c002a336 <bitmap_contains+0xec>
  ASSERT (b != NULL);
c002a2b0:	83 ec 0c             	sub    $0xc,%esp
c002a2b3:	8d 81 0b 5f ff ff    	lea    -0xa0f5(%ecx),%eax
c002a2b9:	50                   	push   %eax
c002a2ba:	8d 81 96 44 ff ff    	lea    -0xbb6a(%ecx),%eax
c002a2c0:	50                   	push   %eax
c002a2c1:	8d 81 70 41 ff ff    	lea    -0xbe90(%ecx),%eax
c002a2c7:	50                   	push   %eax
c002a2c8:	68 ff 00 00 00       	push   $0xff
c002a2cd:	8d 81 8b 60 ff ff    	lea    -0x9f75(%ecx),%eax
c002a2d3:	50                   	push   %eax
c002a2d4:	89 cb                	mov    %ecx,%ebx
c002a2d6:	e8 09 ec ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a2db:	83 ec 0c             	sub    $0xc,%esp
c002a2de:	8d 81 b6 60 ff ff    	lea    -0x9f4a(%ecx),%eax
c002a2e4:	50                   	push   %eax
c002a2e5:	8d 81 96 44 ff ff    	lea    -0xbb6a(%ecx),%eax
c002a2eb:	50                   	push   %eax
c002a2ec:	8d 81 70 41 ff ff    	lea    -0xbe90(%ecx),%eax
c002a2f2:	50                   	push   %eax
c002a2f3:	68 00 01 00 00       	push   $0x100
c002a2f8:	8d 81 8b 60 ff ff    	lea    -0x9f75(%ecx),%eax
c002a2fe:	50                   	push   %eax
c002a2ff:	89 cb                	mov    %ecx,%ebx
c002a301:	e8 de eb ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a306:	83 ec 0c             	sub    $0xc,%esp
c002a309:	8d 81 ca 60 ff ff    	lea    -0x9f36(%ecx),%eax
c002a30f:	50                   	push   %eax
c002a310:	8d 81 96 44 ff ff    	lea    -0xbb6a(%ecx),%eax
c002a316:	50                   	push   %eax
c002a317:	8d 81 70 41 ff ff    	lea    -0xbe90(%ecx),%eax
c002a31d:	50                   	push   %eax
c002a31e:	68 01 01 00 00       	push   $0x101
c002a323:	8d 81 8b 60 ff ff    	lea    -0x9f75(%ecx),%eax
c002a329:	50                   	push   %eax
c002a32a:	89 cb                	mov    %ecx,%ebx
c002a32c:	e8 b3 eb ff ff       	call   c0028ee4 <debug_panic>
      return true;
c002a331:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a336:	83 c4 0c             	add    $0xc,%esp
c002a339:	5b                   	pop    %ebx
c002a33a:	5e                   	pop    %esi
c002a33b:	5f                   	pop    %edi
c002a33c:	5d                   	pop    %ebp
c002a33d:	c3                   	ret    

c002a33e <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a33e:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c002a341:	6a 01                	push   $0x1
c002a343:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a347:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a34b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a34f:	e8 f6 fe ff ff       	call   c002a24a <bitmap_contains>
}
c002a354:	83 c4 1c             	add    $0x1c,%esp
c002a357:	c3                   	ret    

c002a358 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a358:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c002a35b:	6a 01                	push   $0x1
c002a35d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a361:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a365:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a369:	e8 dc fe ff ff       	call   c002a24a <bitmap_contains>
c002a36e:	83 f0 01             	xor    $0x1,%eax
}
c002a371:	83 c4 1c             	add    $0x1c,%esp
c002a374:	c3                   	ret    

c002a375 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a375:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c002a378:	6a 00                	push   $0x0
c002a37a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a37e:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a382:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a386:	e8 bf fe ff ff       	call   c002a24a <bitmap_contains>
c002a38b:	83 f0 01             	xor    $0x1,%eax
}
c002a38e:	83 c4 1c             	add    $0x1c,%esp
c002a391:	c3                   	ret    

c002a392 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a392:	55                   	push   %ebp
c002a393:	57                   	push   %edi
c002a394:	56                   	push   %esi
c002a395:	53                   	push   %ebx
c002a396:	83 ec 1c             	sub    $0x1c,%esp
c002a399:	e8 fd 34 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c002a39e:	05 62 01 01 00       	add    $0x10162,%eax
c002a3a3:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a3a7:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a3ab:	8b 6c 24 38          	mov    0x38(%esp),%ebp
c002a3af:	0f b6 5c 24 3c       	movzbl 0x3c(%esp),%ebx
  ASSERT (b != NULL);
c002a3b4:	85 ff                	test   %edi,%edi
c002a3b6:	74 43                	je     c002a3fb <bitmap_scan+0x69>
  ASSERT (start <= b->bit_cnt);
c002a3b8:	8b 17                	mov    (%edi),%edx
c002a3ba:	39 f2                	cmp    %esi,%edx
c002a3bc:	72 68                	jb     c002a426 <bitmap_scan+0x94>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002a3be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  if (cnt <= b->bit_cnt) 
c002a3c3:	39 ea                	cmp    %ebp,%edx
c002a3c5:	0f 82 8f 00 00 00    	jb     c002a45a <bitmap_scan+0xc8>
      size_t last = b->bit_cnt - cnt;
c002a3cb:	29 ea                	sub    %ebp,%edx
c002a3cd:	89 54 24 0c          	mov    %edx,0xc(%esp)
      for (i = start; i <= last; i++)
c002a3d1:	39 d6                	cmp    %edx,%esi
c002a3d3:	77 7c                	ja     c002a451 <bitmap_scan+0xbf>
        if (!bitmap_contains (b, i, cnt, !value))
c002a3d5:	83 f3 01             	xor    $0x1,%ebx
c002a3d8:	0f b6 db             	movzbl %bl,%ebx
c002a3db:	53                   	push   %ebx
c002a3dc:	55                   	push   %ebp
c002a3dd:	56                   	push   %esi
c002a3de:	57                   	push   %edi
c002a3df:	e8 66 fe ff ff       	call   c002a24a <bitmap_contains>
c002a3e4:	83 c4 10             	add    $0x10,%esp
c002a3e7:	84 c0                	test   %al,%al
c002a3e9:	74 6d                	je     c002a458 <bitmap_scan+0xc6>
      for (i = start; i <= last; i++)
c002a3eb:	83 c6 01             	add    $0x1,%esi
c002a3ee:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c002a3f2:	73 e7                	jae    c002a3db <bitmap_scan+0x49>
  return BITMAP_ERROR;
c002a3f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a3f9:	eb 5f                	jmp    c002a45a <bitmap_scan+0xc8>
  ASSERT (b != NULL);
c002a3fb:	83 ec 0c             	sub    $0xc,%esp
c002a3fe:	8d 90 0b 5f ff ff    	lea    -0xa0f5(%eax),%edx
c002a404:	52                   	push   %edx
c002a405:	8d 90 96 44 ff ff    	lea    -0xbb6a(%eax),%edx
c002a40b:	52                   	push   %edx
c002a40c:	8d 90 64 41 ff ff    	lea    -0xbe9c(%eax),%edx
c002a412:	52                   	push   %edx
c002a413:	68 2a 01 00 00       	push   $0x12a
c002a418:	8d 90 8b 60 ff ff    	lea    -0x9f75(%eax),%edx
c002a41e:	52                   	push   %edx
c002a41f:	89 c3                	mov    %eax,%ebx
c002a421:	e8 be ea ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a426:	83 ec 0c             	sub    $0xc,%esp
c002a429:	8d 90 b6 60 ff ff    	lea    -0x9f4a(%eax),%edx
c002a42f:	52                   	push   %edx
c002a430:	8d 90 96 44 ff ff    	lea    -0xbb6a(%eax),%edx
c002a436:	52                   	push   %edx
c002a437:	8d 90 64 41 ff ff    	lea    -0xbe9c(%eax),%edx
c002a43d:	52                   	push   %edx
c002a43e:	68 2b 01 00 00       	push   $0x12b
c002a443:	8d 90 8b 60 ff ff    	lea    -0x9f75(%eax),%edx
c002a449:	52                   	push   %edx
c002a44a:	89 c3                	mov    %eax,%ebx
c002a44c:	e8 93 ea ff ff       	call   c0028ee4 <debug_panic>
  return BITMAP_ERROR;
c002a451:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a456:	eb 02                	jmp    c002a45a <bitmap_scan+0xc8>
c002a458:	89 f0                	mov    %esi,%eax
}
c002a45a:	83 c4 1c             	add    $0x1c,%esp
c002a45d:	5b                   	pop    %ebx
c002a45e:	5e                   	pop    %esi
c002a45f:	5f                   	pop    %edi
c002a460:	5d                   	pop    %ebp
c002a461:	c3                   	ret    

c002a462 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002a462:	55                   	push   %ebp
c002a463:	57                   	push   %edi
c002a464:	56                   	push   %esi
c002a465:	53                   	push   %ebx
c002a466:	83 ec 0c             	sub    $0xc,%esp
c002a469:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a46d:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002a471:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c002a475:	0f b6 c3             	movzbl %bl,%eax
c002a478:	50                   	push   %eax
c002a479:	55                   	push   %ebp
c002a47a:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a47e:	57                   	push   %edi
c002a47f:	e8 0e ff ff ff       	call   c002a392 <bitmap_scan>
c002a484:	83 c4 10             	add    $0x10,%esp
c002a487:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c002a489:	83 f8 ff             	cmp    $0xffffffff,%eax
c002a48c:	75 0a                	jne    c002a498 <bitmap_scan_and_flip+0x36>
    bitmap_set_multiple (b, idx, cnt, !value);
  return idx;
}
c002a48e:	89 f0                	mov    %esi,%eax
c002a490:	83 c4 0c             	add    $0xc,%esp
c002a493:	5b                   	pop    %ebx
c002a494:	5e                   	pop    %esi
c002a495:	5f                   	pop    %edi
c002a496:	5d                   	pop    %ebp
c002a497:	c3                   	ret    
    bitmap_set_multiple (b, idx, cnt, !value);
c002a498:	83 f3 01             	xor    $0x1,%ebx
c002a49b:	0f b6 db             	movzbl %bl,%ebx
c002a49e:	53                   	push   %ebx
c002a49f:	55                   	push   %ebp
c002a4a0:	50                   	push   %eax
c002a4a1:	57                   	push   %edi
c002a4a2:	e8 b0 fa ff ff       	call   c0029f57 <bitmap_set_multiple>
c002a4a7:	83 c4 10             	add    $0x10,%esp
  return idx;
c002a4aa:	eb e2                	jmp    c002a48e <bitmap_scan_and_flip+0x2c>

c002a4ac <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002a4ac:	53                   	push   %ebx
c002a4ad:	83 ec 08             	sub    $0x8,%esp
c002a4b0:	e8 e2 33 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a4b5:	81 c3 4b 00 01 00    	add    $0x1004b,%ebx
c002a4bb:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a4bf:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a4c1:	8b 02                	mov    (%edx),%eax
c002a4c3:	83 c0 1f             	add    $0x1f,%eax
c002a4c6:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a4c9:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a4cc:	50                   	push   %eax
c002a4cd:	ff 72 04             	pushl  0x4(%edx)
c002a4d0:	6a 00                	push   $0x0
c002a4d2:	e8 5f d5 ff ff       	call   c0027a36 <hex_dump>
}
c002a4d7:	83 c4 18             	add    $0x18,%esp
c002a4da:	5b                   	pop    %ebx
c002a4db:	c3                   	ret    

c002a4dc <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002a4dc:	53                   	push   %ebx
c002a4dd:	83 ec 10             	sub    $0x10,%esp
c002a4e0:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002a4e2:	ff 70 14             	pushl  0x14(%eax)
c002a4e5:	52                   	push   %edx
c002a4e6:	ff 50 0c             	call   *0xc(%eax)
c002a4e9:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002a4ec:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002a4ef:	21 c2                	and    %eax,%edx
  return &h->buckets[bucket_idx];
c002a4f1:	c1 e2 04             	shl    $0x4,%edx
c002a4f4:	89 d0                	mov    %edx,%eax
c002a4f6:	03 43 08             	add    0x8(%ebx),%eax
}
c002a4f9:	83 c4 18             	add    $0x18,%esp
c002a4fc:	5b                   	pop    %ebx
c002a4fd:	c3                   	ret    

c002a4fe <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002a4fe:	55                   	push   %ebp
c002a4ff:	57                   	push   %edi
c002a500:	56                   	push   %esi
c002a501:	53                   	push   %ebx
c002a502:	83 ec 28             	sub    $0x28,%esp
c002a505:	e8 8d 33 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a50a:	81 c3 f6 ff 00 00    	add    $0xfff6,%ebx
c002a510:	89 c7                	mov    %eax,%edi
c002a512:	89 54 24 18          	mov    %edx,0x18(%esp)
c002a516:	89 cd                	mov    %ecx,%ebp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002a518:	52                   	push   %edx
c002a519:	e8 eb ea ff ff       	call   c0029009 <list_begin>
c002a51e:	89 c6                	mov    %eax,%esi
c002a520:	83 c4 10             	add    $0x10,%esp
c002a523:	eb 0e                	jmp    c002a533 <find_elem+0x35>
c002a525:	83 ec 0c             	sub    $0xc,%esp
c002a528:	56                   	push   %esi
c002a529:	e8 20 eb ff ff       	call   c002904e <list_next>
c002a52e:	89 c6                	mov    %eax,%esi
c002a530:	83 c4 10             	add    $0x10,%esp
c002a533:	83 ec 0c             	sub    $0xc,%esp
c002a536:	ff 74 24 18          	pushl  0x18(%esp)
c002a53a:	e8 6c eb ff ff       	call   c00290ab <list_end>
c002a53f:	83 c4 10             	add    $0x10,%esp
c002a542:	39 f0                	cmp    %esi,%eax
c002a544:	74 26                	je     c002a56c <find_elem+0x6e>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002a546:	83 ec 04             	sub    $0x4,%esp
c002a549:	ff 77 14             	pushl  0x14(%edi)
c002a54c:	55                   	push   %ebp
c002a54d:	56                   	push   %esi
c002a54e:	ff 57 10             	call   *0x10(%edi)
c002a551:	83 c4 10             	add    $0x10,%esp
c002a554:	84 c0                	test   %al,%al
c002a556:	75 cd                	jne    c002a525 <find_elem+0x27>
c002a558:	83 ec 04             	sub    $0x4,%esp
c002a55b:	ff 77 14             	pushl  0x14(%edi)
c002a55e:	56                   	push   %esi
c002a55f:	55                   	push   %ebp
c002a560:	ff 57 10             	call   *0x10(%edi)
c002a563:	83 c4 10             	add    $0x10,%esp
c002a566:	84 c0                	test   %al,%al
c002a568:	75 bb                	jne    c002a525 <find_elem+0x27>
c002a56a:	eb 05                	jmp    c002a571 <find_elem+0x73>
        return hi; 
    }
  return NULL;
c002a56c:	be 00 00 00 00       	mov    $0x0,%esi
}
c002a571:	89 f0                	mov    %esi,%eax
c002a573:	83 c4 1c             	add    $0x1c,%esp
c002a576:	5b                   	pop    %ebx
c002a577:	5e                   	pop    %esi
c002a578:	5f                   	pop    %edi
c002a579:	5d                   	pop    %ebp
c002a57a:	c3                   	ret    

c002a57b <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002a57b:	55                   	push   %ebp
c002a57c:	57                   	push   %edi
c002a57d:	56                   	push   %esi
c002a57e:	53                   	push   %ebx
c002a57f:	83 ec 2c             	sub    $0x2c,%esp
c002a582:	e8 10 33 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a587:	81 c3 79 ff 00 00    	add    $0xff79,%ebx
c002a58d:	89 44 24 10          	mov    %eax,0x10(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002a591:	85 c0                	test   %eax,%eax
c002a593:	74 1e                	je     c002a5b3 <rehash+0x38>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c002a595:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a599:	8b 48 04             	mov    0x4(%eax),%ecx
c002a59c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002a5a0:	8b 00                	mov    (%eax),%eax
c002a5a2:	89 c6                	mov    %eax,%esi
c002a5a4:	d1 ee                	shr    %esi
c002a5a6:	83 f8 07             	cmp    $0x7,%eax
c002a5a9:	b8 04 00 00 00       	mov    $0x4,%eax
c002a5ae:	0f 46 f0             	cmovbe %eax,%esi
c002a5b1:	eb 2e                	jmp    c002a5e1 <rehash+0x66>
  ASSERT (h != NULL);
c002a5b3:	83 ec 0c             	sub    $0xc,%esp
c002a5b6:	8d 83 0c 61 ff ff    	lea    -0x9ef4(%ebx),%eax
c002a5bc:	50                   	push   %eax
c002a5bd:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002a5c3:	50                   	push   %eax
c002a5c4:	8d 83 20 42 ff ff    	lea    -0xbde0(%ebx),%eax
c002a5ca:	50                   	push   %eax
c002a5cb:	68 66 01 00 00       	push   $0x166
c002a5d0:	8d 83 16 61 ff ff    	lea    -0x9eea(%ebx),%eax
c002a5d6:	50                   	push   %eax
c002a5d7:	e8 08 e9 ff ff       	call   c0028ee4 <debug_panic>
  return x & (x - 1);
c002a5dc:	8d 46 ff             	lea    -0x1(%esi),%eax
c002a5df:	21 c6                	and    %eax,%esi
  return x != 0 && turn_off_least_1bit (x) == 0;
c002a5e1:	85 f6                	test   %esi,%esi
c002a5e3:	74 f7                	je     c002a5dc <rehash+0x61>
  return x & (x - 1);
c002a5e5:	8d 46 ff             	lea    -0x1(%esi),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002a5e8:	85 f0                	test   %esi,%eax
c002a5ea:	75 f0                	jne    c002a5dc <rehash+0x61>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002a5ec:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c002a5f0:	0f 84 df 00 00 00    	je     c002a6d5 <rehash+0x15a>
  old_buckets = h->buckets;
c002a5f6:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a5fa:	8b 40 08             	mov    0x8(%eax),%eax
c002a5fd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002a601:	89 f5                	mov    %esi,%ebp
c002a603:	c1 e5 04             	shl    $0x4,%ebp
c002a606:	83 ec 0c             	sub    $0xc,%esp
c002a609:	55                   	push   %ebp
c002a60a:	e8 05 96 ff ff       	call   c0023c14 <malloc>
c002a60f:	89 44 24 24          	mov    %eax,0x24(%esp)
  if (new_buckets == NULL) 
c002a613:	83 c4 10             	add    $0x10,%esp
c002a616:	85 c0                	test   %eax,%eax
c002a618:	0f 84 b7 00 00 00    	je     c002a6d5 <rehash+0x15a>
c002a61e:	89 c7                	mov    %eax,%edi
c002a620:	01 c5                	add    %eax,%ebp
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c002a622:	83 ec 0c             	sub    $0xc,%esp
c002a625:	57                   	push   %edi
c002a626:	e8 86 e9 ff ff       	call   c0028fb1 <list_init>
c002a62b:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < new_bucket_cnt; i++) 
c002a62e:	83 c4 10             	add    $0x10,%esp
c002a631:	39 fd                	cmp    %edi,%ebp
c002a633:	75 ed                	jne    c002a622 <rehash+0xa7>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002a635:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a639:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002a63d:	89 48 08             	mov    %ecx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002a640:	89 70 04             	mov    %esi,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002a643:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a647:	85 c0                	test   %eax,%eax
c002a649:	74 7b                	je     c002a6c6 <rehash+0x14b>
c002a64b:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002a64f:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002a653:	c1 e0 04             	shl    $0x4,%eax
c002a656:	01 c8                	add    %ecx,%eax
c002a658:	89 44 24 18          	mov    %eax,0x18(%esp)
c002a65c:	eb 0f                	jmp    c002a66d <rehash+0xf2>
c002a65e:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c002a663:	8b 44 24 14          	mov    0x14(%esp),%eax
c002a667:	39 44 24 18          	cmp    %eax,0x18(%esp)
c002a66b:	74 59                	je     c002a6c6 <rehash+0x14b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002a66d:	8b 44 24 14          	mov    0x14(%esp),%eax
c002a671:	89 c7                	mov    %eax,%edi
      for (elem = list_begin (old_bucket);
c002a673:	83 ec 0c             	sub    $0xc,%esp
c002a676:	50                   	push   %eax
c002a677:	e8 8d e9 ff ff       	call   c0029009 <list_begin>
c002a67c:	89 c6                	mov    %eax,%esi
c002a67e:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002a681:	83 ec 0c             	sub    $0xc,%esp
c002a684:	57                   	push   %edi
c002a685:	e8 21 ea ff ff       	call   c00290ab <list_end>
      for (elem = list_begin (old_bucket);
c002a68a:	83 c4 10             	add    $0x10,%esp
c002a68d:	39 f0                	cmp    %esi,%eax
c002a68f:	74 cd                	je     c002a65e <rehash+0xe3>
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002a691:	89 f2                	mov    %esi,%edx
c002a693:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a697:	e8 40 fe ff ff       	call   c002a4dc <find_bucket>
c002a69c:	89 c5                	mov    %eax,%ebp
          next = list_next (elem);
c002a69e:	83 ec 0c             	sub    $0xc,%esp
c002a6a1:	56                   	push   %esi
c002a6a2:	e8 a7 e9 ff ff       	call   c002904e <list_next>
c002a6a7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          list_remove (elem);
c002a6ab:	89 34 24             	mov    %esi,(%esp)
c002a6ae:	e8 00 ef ff ff       	call   c00295b3 <list_remove>
          list_push_front (new_bucket, elem);
c002a6b3:	83 c4 08             	add    $0x8,%esp
c002a6b6:	56                   	push   %esi
c002a6b7:	55                   	push   %ebp
c002a6b8:	e8 bc ee ff ff       	call   c0029579 <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c002a6bd:	83 c4 10             	add    $0x10,%esp
c002a6c0:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002a6c4:	eb bb                	jmp    c002a681 <rehash+0x106>
        }
    }

  free (old_buckets);
c002a6c6:	83 ec 0c             	sub    $0xc,%esp
c002a6c9:	ff 74 24 28          	pushl  0x28(%esp)
c002a6cd:	e8 f0 96 ff ff       	call   c0023dc2 <free>
c002a6d2:	83 c4 10             	add    $0x10,%esp
}
c002a6d5:	83 c4 2c             	add    $0x2c,%esp
c002a6d8:	5b                   	pop    %ebx
c002a6d9:	5e                   	pop    %esi
c002a6da:	5f                   	pop    %edi
c002a6db:	5d                   	pop    %ebp
c002a6dc:	c3                   	ret    

c002a6dd <hash_clear>:
{
c002a6dd:	55                   	push   %ebp
c002a6de:	57                   	push   %edi
c002a6df:	56                   	push   %esi
c002a6e0:	53                   	push   %ebx
c002a6e1:	83 ec 1c             	sub    $0x1c,%esp
c002a6e4:	e8 ae 31 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a6e9:	81 c3 17 fe 00 00    	add    $0xfe17,%ebx
c002a6ef:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a6f3:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  for (i = 0; i < h->bucket_cnt; i++) 
c002a6f7:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c002a6fb:	74 59                	je     c002a756 <hash_clear+0x79>
c002a6fd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002a704:	00 
c002a705:	eb 1a                	jmp    c002a721 <hash_clear+0x44>
      list_init (bucket); 
c002a707:	83 ec 0c             	sub    $0xc,%esp
c002a70a:	56                   	push   %esi
c002a70b:	e8 a1 e8 ff ff       	call   c0028fb1 <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c002a710:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
c002a715:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a719:	83 c4 10             	add    $0x10,%esp
c002a71c:	39 47 04             	cmp    %eax,0x4(%edi)
c002a71f:	76 35                	jbe    c002a756 <hash_clear+0x79>
      struct list *bucket = &h->buckets[i];
c002a721:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002a725:	c1 e6 04             	shl    $0x4,%esi
c002a728:	03 77 08             	add    0x8(%edi),%esi
      if (destructor != NULL) 
c002a72b:	85 ed                	test   %ebp,%ebp
c002a72d:	74 d8                	je     c002a707 <hash_clear+0x2a>
        while (!list_empty (bucket)) 
c002a72f:	83 ec 0c             	sub    $0xc,%esp
c002a732:	56                   	push   %esi
c002a733:	e8 1d ef ff ff       	call   c0029655 <list_empty>
c002a738:	83 c4 10             	add    $0x10,%esp
c002a73b:	84 c0                	test   %al,%al
c002a73d:	75 c8                	jne    c002a707 <hash_clear+0x2a>
            struct list_elem *list_elem = list_pop_front (bucket);
c002a73f:	83 ec 0c             	sub    $0xc,%esp
c002a742:	56                   	push   %esi
c002a743:	e8 84 ef ff ff       	call   c00296cc <list_pop_front>
            destructor (hash_elem, h->aux);
c002a748:	83 c4 08             	add    $0x8,%esp
c002a74b:	ff 77 14             	pushl  0x14(%edi)
c002a74e:	50                   	push   %eax
c002a74f:	ff d5                	call   *%ebp
c002a751:	83 c4 10             	add    $0x10,%esp
c002a754:	eb d9                	jmp    c002a72f <hash_clear+0x52>
  h->elem_cnt = 0;
c002a756:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
c002a75c:	83 c4 1c             	add    $0x1c,%esp
c002a75f:	5b                   	pop    %ebx
c002a760:	5e                   	pop    %esi
c002a761:	5f                   	pop    %edi
c002a762:	5d                   	pop    %ebp
c002a763:	c3                   	ret    

c002a764 <hash_init>:
{
c002a764:	56                   	push   %esi
c002a765:	53                   	push   %ebx
c002a766:	83 ec 10             	sub    $0x10,%esp
c002a769:	e8 29 31 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a76e:	81 c3 92 fd 00 00    	add    $0xfd92,%ebx
c002a774:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  h->elem_cnt = 0;
c002a778:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  h->bucket_cnt = 4;
c002a77e:	c7 46 04 04 00 00 00 	movl   $0x4,0x4(%esi)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002a785:	6a 40                	push   $0x40
c002a787:	e8 88 94 ff ff       	call   c0023c14 <malloc>
c002a78c:	89 c2                	mov    %eax,%edx
c002a78e:	89 46 08             	mov    %eax,0x8(%esi)
  h->hash = hash;
c002a791:	8b 44 24 24          	mov    0x24(%esp),%eax
c002a795:	89 46 0c             	mov    %eax,0xc(%esi)
  h->less = less;
c002a798:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a79c:	89 46 10             	mov    %eax,0x10(%esi)
  h->aux = aux;
c002a79f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002a7a3:	89 46 14             	mov    %eax,0x14(%esi)
  if (h->buckets != NULL) 
c002a7a6:	83 c4 10             	add    $0x10,%esp
    return false;
c002a7a9:	b8 00 00 00 00       	mov    $0x0,%eax
  if (h->buckets != NULL) 
c002a7ae:	85 d2                	test   %edx,%edx
c002a7b0:	74 13                	je     c002a7c5 <hash_init+0x61>
      hash_clear (h, NULL);
c002a7b2:	83 ec 08             	sub    $0x8,%esp
c002a7b5:	6a 00                	push   $0x0
c002a7b7:	56                   	push   %esi
c002a7b8:	e8 20 ff ff ff       	call   c002a6dd <hash_clear>
      return true;
c002a7bd:	83 c4 10             	add    $0x10,%esp
c002a7c0:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a7c5:	83 c4 04             	add    $0x4,%esp
c002a7c8:	5b                   	pop    %ebx
c002a7c9:	5e                   	pop    %esi
c002a7ca:	c3                   	ret    

c002a7cb <hash_destroy>:
{
c002a7cb:	56                   	push   %esi
c002a7cc:	53                   	push   %ebx
c002a7cd:	83 ec 04             	sub    $0x4,%esp
c002a7d0:	e8 c2 30 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a7d5:	81 c3 2b fd 00 00    	add    $0xfd2b,%ebx
c002a7db:	8b 74 24 10          	mov    0x10(%esp),%esi
c002a7df:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c002a7e3:	85 c0                	test   %eax,%eax
c002a7e5:	74 0d                	je     c002a7f4 <hash_destroy+0x29>
    hash_clear (h, destructor);
c002a7e7:	83 ec 08             	sub    $0x8,%esp
c002a7ea:	50                   	push   %eax
c002a7eb:	56                   	push   %esi
c002a7ec:	e8 ec fe ff ff       	call   c002a6dd <hash_clear>
c002a7f1:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002a7f4:	83 ec 0c             	sub    $0xc,%esp
c002a7f7:	ff 76 08             	pushl  0x8(%esi)
c002a7fa:	e8 c3 95 ff ff       	call   c0023dc2 <free>
}
c002a7ff:	83 c4 14             	add    $0x14,%esp
c002a802:	5b                   	pop    %ebx
c002a803:	5e                   	pop    %esi
c002a804:	c3                   	ret    

c002a805 <hash_insert>:
{
c002a805:	55                   	push   %ebp
c002a806:	57                   	push   %edi
c002a807:	56                   	push   %esi
c002a808:	53                   	push   %ebx
c002a809:	83 ec 0c             	sub    $0xc,%esp
c002a80c:	e8 86 30 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a811:	81 c3 ef fc 00 00    	add    $0xfcef,%ebx
c002a817:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002a81b:	8b 54 24 24          	mov    0x24(%esp),%edx
c002a81f:	89 f0                	mov    %esi,%eax
c002a821:	e8 b6 fc ff ff       	call   c002a4dc <find_bucket>
c002a826:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002a828:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002a82c:	89 c2                	mov    %eax,%edx
c002a82e:	89 f0                	mov    %esi,%eax
c002a830:	e8 c9 fc ff ff       	call   c002a4fe <find_elem>
c002a835:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c002a837:	85 c0                	test   %eax,%eax
c002a839:	74 11                	je     c002a84c <hash_insert+0x47>
  rehash (h);
c002a83b:	89 f0                	mov    %esi,%eax
c002a83d:	e8 39 fd ff ff       	call   c002a57b <rehash>
}
c002a842:	89 f8                	mov    %edi,%eax
c002a844:	83 c4 0c             	add    $0xc,%esp
c002a847:	5b                   	pop    %ebx
c002a848:	5e                   	pop    %esi
c002a849:	5f                   	pop    %edi
c002a84a:	5d                   	pop    %ebp
c002a84b:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c002a84c:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002a84f:	83 ec 08             	sub    $0x8,%esp
c002a852:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a856:	55                   	push   %ebp
c002a857:	e8 1d ed ff ff       	call   c0029579 <list_push_front>
c002a85c:	83 c4 10             	add    $0x10,%esp
c002a85f:	eb da                	jmp    c002a83b <hash_insert+0x36>

c002a861 <hash_replace>:
{
c002a861:	55                   	push   %ebp
c002a862:	57                   	push   %edi
c002a863:	56                   	push   %esi
c002a864:	53                   	push   %ebx
c002a865:	83 ec 0c             	sub    $0xc,%esp
c002a868:	e8 2a 30 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a86d:	81 c3 93 fc 00 00    	add    $0xfc93,%ebx
c002a873:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002a877:	8b 54 24 24          	mov    0x24(%esp),%edx
c002a87b:	89 f0                	mov    %esi,%eax
c002a87d:	e8 5a fc ff ff       	call   c002a4dc <find_bucket>
c002a882:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002a884:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002a888:	89 c2                	mov    %eax,%edx
c002a88a:	89 f0                	mov    %esi,%eax
c002a88c:	e8 6d fc ff ff       	call   c002a4fe <find_elem>
c002a891:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c002a893:	85 c0                	test   %eax,%eax
c002a895:	74 0f                	je     c002a8a6 <hash_replace+0x45>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c002a897:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002a89a:	83 ec 0c             	sub    $0xc,%esp
c002a89d:	50                   	push   %eax
c002a89e:	e8 10 ed ff ff       	call   c00295b3 <list_remove>
c002a8a3:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c002a8a6:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002a8a9:	83 ec 08             	sub    $0x8,%esp
c002a8ac:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a8b0:	55                   	push   %ebp
c002a8b1:	e8 c3 ec ff ff       	call   c0029579 <list_push_front>
  rehash (h);
c002a8b6:	89 f0                	mov    %esi,%eax
c002a8b8:	e8 be fc ff ff       	call   c002a57b <rehash>
}
c002a8bd:	89 f8                	mov    %edi,%eax
c002a8bf:	83 c4 1c             	add    $0x1c,%esp
c002a8c2:	5b                   	pop    %ebx
c002a8c3:	5e                   	pop    %esi
c002a8c4:	5f                   	pop    %edi
c002a8c5:	5d                   	pop    %ebp
c002a8c6:	c3                   	ret    

c002a8c7 <hash_find>:
{
c002a8c7:	56                   	push   %esi
c002a8c8:	53                   	push   %ebx
c002a8c9:	83 ec 04             	sub    $0x4,%esp
c002a8cc:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002a8d0:	8b 74 24 14          	mov    0x14(%esp),%esi
  return find_elem (h, find_bucket (h, e), e);
c002a8d4:	89 f2                	mov    %esi,%edx
c002a8d6:	89 d8                	mov    %ebx,%eax
c002a8d8:	e8 ff fb ff ff       	call   c002a4dc <find_bucket>
c002a8dd:	89 f1                	mov    %esi,%ecx
c002a8df:	89 c2                	mov    %eax,%edx
c002a8e1:	89 d8                	mov    %ebx,%eax
c002a8e3:	e8 16 fc ff ff       	call   c002a4fe <find_elem>
}
c002a8e8:	83 c4 04             	add    $0x4,%esp
c002a8eb:	5b                   	pop    %ebx
c002a8ec:	5e                   	pop    %esi
c002a8ed:	c3                   	ret    

c002a8ee <hash_delete>:
{
c002a8ee:	57                   	push   %edi
c002a8ef:	56                   	push   %esi
c002a8f0:	53                   	push   %ebx
c002a8f1:	e8 a1 2f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a8f6:	81 c3 0a fc 00 00    	add    $0xfc0a,%ebx
c002a8fc:	8b 74 24 10          	mov    0x10(%esp),%esi
c002a900:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002a904:	89 fa                	mov    %edi,%edx
c002a906:	89 f0                	mov    %esi,%eax
c002a908:	e8 cf fb ff ff       	call   c002a4dc <find_bucket>
c002a90d:	89 f9                	mov    %edi,%ecx
c002a90f:	89 c2                	mov    %eax,%edx
c002a911:	89 f0                	mov    %esi,%eax
c002a913:	e8 e6 fb ff ff       	call   c002a4fe <find_elem>
c002a918:	89 c7                	mov    %eax,%edi
  if (found != NULL) 
c002a91a:	85 c0                	test   %eax,%eax
c002a91c:	74 16                	je     c002a934 <hash_delete+0x46>
  h->elem_cnt--;
c002a91e:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002a921:	83 ec 0c             	sub    $0xc,%esp
c002a924:	50                   	push   %eax
c002a925:	e8 89 ec ff ff       	call   c00295b3 <list_remove>
      rehash (h); 
c002a92a:	89 f0                	mov    %esi,%eax
c002a92c:	e8 4a fc ff ff       	call   c002a57b <rehash>
c002a931:	83 c4 10             	add    $0x10,%esp
}
c002a934:	89 f8                	mov    %edi,%eax
c002a936:	5b                   	pop    %ebx
c002a937:	5e                   	pop    %esi
c002a938:	5f                   	pop    %edi
c002a939:	c3                   	ret    

c002a93a <hash_apply>:
{
c002a93a:	55                   	push   %ebp
c002a93b:	57                   	push   %edi
c002a93c:	56                   	push   %esi
c002a93d:	53                   	push   %ebx
c002a93e:	83 ec 1c             	sub    $0x1c,%esp
c002a941:	e8 51 2f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a946:	81 c3 ba fb 00 00    	add    $0xfbba,%ebx
c002a94c:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c002a950:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c002a955:	74 16                	je     c002a96d <hash_apply+0x33>
  for (i = 0; i < h->bucket_cnt; i++) 
c002a957:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002a95e:	00 
c002a95f:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c002a963:	75 3f                	jne    c002a9a4 <hash_apply+0x6a>
}
c002a965:	83 c4 1c             	add    $0x1c,%esp
c002a968:	5b                   	pop    %ebx
c002a969:	5e                   	pop    %esi
c002a96a:	5f                   	pop    %edi
c002a96b:	5d                   	pop    %ebp
c002a96c:	c3                   	ret    
  ASSERT (action != NULL);
c002a96d:	83 ec 0c             	sub    $0xc,%esp
c002a970:	8d 83 2e 61 ff ff    	lea    -0x9ed2(%ebx),%eax
c002a976:	50                   	push   %eax
c002a977:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002a97d:	50                   	push   %eax
c002a97e:	8d 83 14 42 ff ff    	lea    -0xbdec(%ebx),%eax
c002a984:	50                   	push   %eax
c002a985:	68 a7 00 00 00       	push   $0xa7
c002a98a:	8d 83 16 61 ff ff    	lea    -0x9eea(%ebx),%eax
c002a990:	50                   	push   %eax
c002a991:	e8 4e e5 ff ff       	call   c0028ee4 <debug_panic>
  for (i = 0; i < h->bucket_cnt; i++) 
c002a996:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
c002a99b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a99f:	39 45 04             	cmp    %eax,0x4(%ebp)
c002a9a2:	76 c1                	jbe    c002a965 <hash_apply+0x2b>
      struct list *bucket = &h->buckets[i];
c002a9a4:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002a9a8:	c1 e7 04             	shl    $0x4,%edi
c002a9ab:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002a9ae:	83 ec 0c             	sub    $0xc,%esp
c002a9b1:	57                   	push   %edi
c002a9b2:	e8 52 e6 ff ff       	call   c0029009 <list_begin>
c002a9b7:	89 c6                	mov    %eax,%esi
c002a9b9:	83 c4 10             	add    $0x10,%esp
c002a9bc:	83 ec 0c             	sub    $0xc,%esp
c002a9bf:	57                   	push   %edi
c002a9c0:	e8 e6 e6 ff ff       	call   c00290ab <list_end>
c002a9c5:	83 c4 10             	add    $0x10,%esp
c002a9c8:	39 f0                	cmp    %esi,%eax
c002a9ca:	74 ca                	je     c002a996 <hash_apply+0x5c>
          next = list_next (elem);
c002a9cc:	83 ec 0c             	sub    $0xc,%esp
c002a9cf:	56                   	push   %esi
c002a9d0:	e8 79 e6 ff ff       	call   c002904e <list_next>
c002a9d5:	89 44 24 18          	mov    %eax,0x18(%esp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002a9d9:	83 c4 08             	add    $0x8,%esp
c002a9dc:	ff 75 14             	pushl  0x14(%ebp)
c002a9df:	56                   	push   %esi
c002a9e0:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002a9e4:	83 c4 10             	add    $0x10,%esp
c002a9e7:	8b 74 24 08          	mov    0x8(%esp),%esi
c002a9eb:	eb cf                	jmp    c002a9bc <hash_apply+0x82>

c002a9ed <hash_first>:
{
c002a9ed:	56                   	push   %esi
c002a9ee:	53                   	push   %ebx
c002a9ef:	83 ec 04             	sub    $0x4,%esp
c002a9f2:	e8 a0 2e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002a9f7:	81 c3 09 fb 00 00    	add    $0xfb09,%ebx
c002a9fd:	8b 74 24 10          	mov    0x10(%esp),%esi
c002aa01:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c002aa05:	85 f6                	test   %esi,%esi
c002aa07:	74 1e                	je     c002aa27 <hash_first+0x3a>
  ASSERT (h != NULL);
c002aa09:	85 c0                	test   %eax,%eax
c002aa0b:	74 43                	je     c002aa50 <hash_first+0x63>
  i->hash = h;
c002aa0d:	89 06                	mov    %eax,(%esi)
  i->bucket = i->hash->buckets;
c002aa0f:	8b 40 08             	mov    0x8(%eax),%eax
c002aa12:	89 46 04             	mov    %eax,0x4(%esi)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002aa15:	83 ec 0c             	sub    $0xc,%esp
c002aa18:	50                   	push   %eax
c002aa19:	e8 2d e9 ff ff       	call   c002934b <list_head>
c002aa1e:	89 46 08             	mov    %eax,0x8(%esi)
}
c002aa21:	83 c4 14             	add    $0x14,%esp
c002aa24:	5b                   	pop    %ebx
c002aa25:	5e                   	pop    %esi
c002aa26:	c3                   	ret    
  ASSERT (i != NULL);
c002aa27:	83 ec 0c             	sub    $0xc,%esp
c002aa2a:	8d 83 3d 61 ff ff    	lea    -0x9ec3(%ebx),%eax
c002aa30:	50                   	push   %eax
c002aa31:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002aa37:	50                   	push   %eax
c002aa38:	8d 83 08 42 ff ff    	lea    -0xbdf8(%ebx),%eax
c002aa3e:	50                   	push   %eax
c002aa3f:	68 ca 00 00 00       	push   $0xca
c002aa44:	8d 83 16 61 ff ff    	lea    -0x9eea(%ebx),%eax
c002aa4a:	50                   	push   %eax
c002aa4b:	e8 94 e4 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (h != NULL);
c002aa50:	83 ec 0c             	sub    $0xc,%esp
c002aa53:	8d 83 0c 61 ff ff    	lea    -0x9ef4(%ebx),%eax
c002aa59:	50                   	push   %eax
c002aa5a:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002aa60:	50                   	push   %eax
c002aa61:	8d 83 08 42 ff ff    	lea    -0xbdf8(%ebx),%eax
c002aa67:	50                   	push   %eax
c002aa68:	68 cb 00 00 00       	push   $0xcb
c002aa6d:	8d 83 16 61 ff ff    	lea    -0x9eea(%ebx),%eax
c002aa73:	50                   	push   %eax
c002aa74:	e8 6b e4 ff ff       	call   c0028ee4 <debug_panic>

c002aa79 <hash_next>:
{
c002aa79:	57                   	push   %edi
c002aa7a:	56                   	push   %esi
c002aa7b:	53                   	push   %ebx
c002aa7c:	e8 16 2e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002aa81:	81 c3 7f fa 00 00    	add    $0xfa7f,%ebx
c002aa87:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (i != NULL);
c002aa8b:	85 f6                	test   %esi,%esi
c002aa8d:	74 4f                	je     c002aade <hash_next+0x65>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002aa8f:	83 ec 0c             	sub    $0xc,%esp
c002aa92:	ff 76 08             	pushl  0x8(%esi)
c002aa95:	e8 b4 e5 ff ff       	call   c002904e <list_next>
c002aa9a:	89 46 08             	mov    %eax,0x8(%esi)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002aa9d:	83 c4 10             	add    $0x10,%esp
c002aaa0:	8b 7e 08             	mov    0x8(%esi),%edi
c002aaa3:	83 ec 0c             	sub    $0xc,%esp
c002aaa6:	ff 76 04             	pushl  0x4(%esi)
c002aaa9:	e8 fd e5 ff ff       	call   c00290ab <list_end>
c002aaae:	83 c4 10             	add    $0x10,%esp
c002aab1:	39 c7                	cmp    %eax,%edi
c002aab3:	75 59                	jne    c002ab0e <hash_next+0x95>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002aab5:	8b 46 04             	mov    0x4(%esi),%eax
c002aab8:	8d 50 10             	lea    0x10(%eax),%edx
c002aabb:	89 56 04             	mov    %edx,0x4(%esi)
c002aabe:	8b 0e                	mov    (%esi),%ecx
c002aac0:	8b 41 04             	mov    0x4(%ecx),%eax
c002aac3:	c1 e0 04             	shl    $0x4,%eax
c002aac6:	03 41 08             	add    0x8(%ecx),%eax
c002aac9:	39 c2                	cmp    %eax,%edx
c002aacb:	73 3a                	jae    c002ab07 <hash_next+0x8e>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002aacd:	83 ec 0c             	sub    $0xc,%esp
c002aad0:	52                   	push   %edx
c002aad1:	e8 33 e5 ff ff       	call   c0029009 <list_begin>
c002aad6:	89 46 08             	mov    %eax,0x8(%esi)
c002aad9:	83 c4 10             	add    $0x10,%esp
c002aadc:	eb c2                	jmp    c002aaa0 <hash_next+0x27>
  ASSERT (i != NULL);
c002aade:	83 ec 0c             	sub    $0xc,%esp
c002aae1:	8d 83 3d 61 ff ff    	lea    -0x9ec3(%ebx),%eax
c002aae7:	50                   	push   %eax
c002aae8:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002aaee:	50                   	push   %eax
c002aaef:	8d 83 fc 41 ff ff    	lea    -0xbe04(%ebx),%eax
c002aaf5:	50                   	push   %eax
c002aaf6:	68 dd 00 00 00       	push   $0xdd
c002aafb:	8d 83 16 61 ff ff    	lea    -0x9eea(%ebx),%eax
c002ab01:	50                   	push   %eax
c002ab02:	e8 dd e3 ff ff       	call   c0028ee4 <debug_panic>
          i->elem = NULL;
c002ab07:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  return i->elem;
c002ab0e:	8b 46 08             	mov    0x8(%esi),%eax
}
c002ab11:	5b                   	pop    %ebx
c002ab12:	5e                   	pop    %esi
c002ab13:	5f                   	pop    %edi
c002ab14:	c3                   	ret    

c002ab15 <hash_cur>:
  return i->elem;
c002ab15:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ab19:	8b 40 08             	mov    0x8(%eax),%eax
}
c002ab1c:	c3                   	ret    

c002ab1d <hash_size>:
  return h->elem_cnt;
c002ab1d:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ab21:	8b 00                	mov    (%eax),%eax
}
c002ab23:	c3                   	ret    

c002ab24 <hash_empty>:
  return h->elem_cnt == 0;
c002ab24:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ab28:	83 38 00             	cmpl   $0x0,(%eax)
c002ab2b:	0f 94 c0             	sete   %al
}
c002ab2e:	c3                   	ret    

c002ab2f <hash_bytes>:
{
c002ab2f:	53                   	push   %ebx
c002ab30:	83 ec 08             	sub    $0x8,%esp
c002ab33:	e8 5f 2d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ab38:	81 c3 c8 f9 00 00    	add    $0xf9c8,%ebx
c002ab3e:	8b 54 24 10          	mov    0x10(%esp),%edx
c002ab42:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (buf != NULL);
c002ab46:	85 d2                	test   %edx,%edx
c002ab48:	74 24                	je     c002ab6e <hash_bytes+0x3f>
c002ab4a:	8d 1c 0a             	lea    (%edx,%ecx,1),%ebx
  hash = FNV_32_BASIS;
c002ab4d:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (size-- > 0)
c002ab52:	85 c9                	test   %ecx,%ecx
c002ab54:	74 13                	je     c002ab69 <hash_bytes+0x3a>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002ab56:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002ab5c:	83 c2 01             	add    $0x1,%edx
c002ab5f:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
c002ab63:	31 c8                	xor    %ecx,%eax
  while (size-- > 0)
c002ab65:	39 da                	cmp    %ebx,%edx
c002ab67:	75 ed                	jne    c002ab56 <hash_bytes+0x27>
} 
c002ab69:	83 c4 08             	add    $0x8,%esp
c002ab6c:	5b                   	pop    %ebx
c002ab6d:	c3                   	ret    
  ASSERT (buf != NULL);
c002ab6e:	83 ec 0c             	sub    $0xc,%esp
c002ab71:	8d 83 47 61 ff ff    	lea    -0x9eb9(%ebx),%eax
c002ab77:	50                   	push   %eax
c002ab78:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002ab7e:	50                   	push   %eax
c002ab7f:	8d 83 f0 41 ff ff    	lea    -0xbe10(%ebx),%eax
c002ab85:	50                   	push   %eax
c002ab86:	68 10 01 00 00       	push   $0x110
c002ab8b:	8d 83 16 61 ff ff    	lea    -0x9eea(%ebx),%eax
c002ab91:	50                   	push   %eax
c002ab92:	e8 4d e3 ff ff       	call   c0028ee4 <debug_panic>

c002ab97 <hash_string>:
{
c002ab97:	56                   	push   %esi
c002ab98:	53                   	push   %ebx
c002ab99:	83 ec 04             	sub    $0x4,%esp
c002ab9c:	e8 f6 2c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002aba1:	81 c3 5f f9 00 00    	add    $0xf95f,%ebx
c002aba7:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (s != NULL);
c002abab:	85 f6                	test   %esi,%esi
c002abad:	74 27                	je     c002abd6 <hash_string+0x3f>
  while (*s != '\0')
c002abaf:	0f b6 16             	movzbl (%esi),%edx
  hash = FNV_32_BASIS;
c002abb2:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (*s != '\0')
c002abb7:	84 d2                	test   %dl,%dl
c002abb9:	74 15                	je     c002abd0 <hash_string+0x39>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002abbb:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002abc1:	83 c6 01             	add    $0x1,%esi
c002abc4:	0f b6 c2             	movzbl %dl,%eax
c002abc7:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c002abc9:	0f b6 16             	movzbl (%esi),%edx
c002abcc:	84 d2                	test   %dl,%dl
c002abce:	75 eb                	jne    c002abbb <hash_string+0x24>
}
c002abd0:	83 c4 04             	add    $0x4,%esp
c002abd3:	5b                   	pop    %ebx
c002abd4:	5e                   	pop    %esi
c002abd5:	c3                   	ret    
  ASSERT (s != NULL);
c002abd6:	83 ec 0c             	sub    $0xc,%esp
c002abd9:	8d 93 e7 5c ff ff    	lea    -0xa319(%ebx),%edx
c002abdf:	52                   	push   %edx
c002abe0:	8d 93 96 44 ff ff    	lea    -0xbb6a(%ebx),%edx
c002abe6:	52                   	push   %edx
c002abe7:	8d 93 e4 41 ff ff    	lea    -0xbe1c(%ebx),%edx
c002abed:	52                   	push   %edx
c002abee:	68 20 01 00 00       	push   $0x120
c002abf3:	8d 93 16 61 ff ff    	lea    -0x9eea(%ebx),%edx
c002abf9:	52                   	push   %edx
c002abfa:	e8 e5 e2 ff ff       	call   c0028ee4 <debug_panic>

c002abff <hash_int>:
{
c002abff:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c002ac02:	6a 04                	push   $0x4
c002ac04:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002ac08:	50                   	push   %eax
c002ac09:	e8 21 ff ff ff       	call   c002ab2f <hash_bytes>
}
c002ac0e:	83 c4 1c             	add    $0x1c,%esp
c002ac11:	c3                   	ret    

c002ac12 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002ac12:	56                   	push   %esi
c002ac13:	53                   	push   %ebx
c002ac14:	83 ec 04             	sub    $0x4,%esp
c002ac17:	e8 7b 2c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ac1c:	81 c3 e4 f8 00 00    	add    $0xf8e4,%ebx
c002ac22:	89 c6                	mov    %eax,%esi
  return (intr_context ()
c002ac24:	e8 a0 71 ff ff       	call   c0021dc9 <intr_context>
          || lock_held_by_current_thread (&console_lock));
c002ac29:	84 c0                	test   %al,%al
c002ac2b:	75 09                	jne    c002ac36 <putchar_have_lock+0x24>
          || !use_console_lock
c002ac2d:	80 bb 6c 1c 00 00 00 	cmpb   $0x0,0x1c6c(%ebx)
c002ac34:	75 2a                	jne    c002ac60 <putchar_have_lock+0x4e>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c002ac36:	83 83 60 1c 00 00 01 	addl   $0x1,0x1c60(%ebx)
c002ac3d:	83 93 64 1c 00 00 00 	adcl   $0x0,0x1c64(%ebx)
  serial_putc (c);
c002ac44:	89 f0                	mov    %esi,%eax
c002ac46:	0f b6 f0             	movzbl %al,%esi
c002ac49:	83 ec 0c             	sub    $0xc,%esp
c002ac4c:	56                   	push   %esi
c002ac4d:	e8 d0 a0 ff ff       	call   c0024d22 <serial_putc>
  vga_putc (c);
c002ac52:	89 34 24             	mov    %esi,(%esp)
c002ac55:	e8 92 9c ff ff       	call   c00248ec <vga_putc>
}
c002ac5a:	83 c4 14             	add    $0x14,%esp
c002ac5d:	5b                   	pop    %ebx
c002ac5e:	5e                   	pop    %esi
c002ac5f:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c002ac60:	83 ec 0c             	sub    $0xc,%esp
c002ac63:	8d 83 80 1c 00 00    	lea    0x1c80(%ebx),%eax
c002ac69:	50                   	push   %eax
c002ac6a:	e8 60 83 ff ff       	call   c0022fcf <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c002ac6f:	83 c4 10             	add    $0x10,%esp
c002ac72:	84 c0                	test   %al,%al
c002ac74:	75 c0                	jne    c002ac36 <putchar_have_lock+0x24>
c002ac76:	83 ec 0c             	sub    $0xc,%esp
c002ac79:	8d 83 54 61 ff ff    	lea    -0x9eac(%ebx),%eax
c002ac7f:	50                   	push   %eax
c002ac80:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002ac86:	50                   	push   %eax
c002ac87:	8d 83 28 42 ff ff    	lea    -0xbdd8(%ebx),%eax
c002ac8d:	50                   	push   %eax
c002ac8e:	68 bb 00 00 00       	push   $0xbb
c002ac93:	8d 83 99 61 ff ff    	lea    -0x9e67(%ebx),%eax
c002ac99:	50                   	push   %eax
c002ac9a:	e8 45 e2 ff ff       	call   c0028ee4 <debug_panic>

c002ac9f <vprintf_helper>:
{
c002ac9f:	83 ec 0c             	sub    $0xc,%esp
c002aca2:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002aca6:	83 00 01             	addl   $0x1,(%eax)
  putchar_have_lock (c);
c002aca9:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002acae:	e8 5f ff ff ff       	call   c002ac12 <putchar_have_lock>
}
c002acb3:	83 c4 0c             	add    $0xc,%esp
c002acb6:	c3                   	ret    

c002acb7 <acquire_console>:
{
c002acb7:	53                   	push   %ebx
c002acb8:	83 ec 08             	sub    $0x8,%esp
c002acbb:	e8 d7 2b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002acc0:	81 c3 40 f8 00 00    	add    $0xf840,%ebx
  if (!intr_context () && use_console_lock) 
c002acc6:	e8 fe 70 ff ff       	call   c0021dc9 <intr_context>
c002accb:	84 c0                	test   %al,%al
c002accd:	75 09                	jne    c002acd8 <acquire_console+0x21>
c002accf:	80 bb 6c 1c 00 00 00 	cmpb   $0x0,0x1c6c(%ebx)
c002acd6:	75 05                	jne    c002acdd <acquire_console+0x26>
}
c002acd8:	83 c4 08             	add    $0x8,%esp
c002acdb:	5b                   	pop    %ebx
c002acdc:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c002acdd:	83 ec 0c             	sub    $0xc,%esp
c002ace0:	8d 83 80 1c 00 00    	lea    0x1c80(%ebx),%eax
c002ace6:	50                   	push   %eax
c002ace7:	e8 e3 82 ff ff       	call   c0022fcf <lock_held_by_current_thread>
c002acec:	83 c4 10             	add    $0x10,%esp
c002acef:	84 c0                	test   %al,%al
c002acf1:	74 09                	je     c002acfc <acquire_console+0x45>
        console_lock_depth++; 
c002acf3:	83 83 68 1c 00 00 01 	addl   $0x1,0x1c68(%ebx)
c002acfa:	eb dc                	jmp    c002acd8 <acquire_console+0x21>
        lock_acquire (&console_lock); 
c002acfc:	83 ec 0c             	sub    $0xc,%esp
c002acff:	8d 83 80 1c 00 00    	lea    0x1c80(%ebx),%eax
c002ad05:	50                   	push   %eax
c002ad06:	e8 17 83 ff ff       	call   c0023022 <lock_acquire>
c002ad0b:	83 c4 10             	add    $0x10,%esp
}
c002ad0e:	eb c8                	jmp    c002acd8 <acquire_console+0x21>

c002ad10 <release_console>:
{
c002ad10:	53                   	push   %ebx
c002ad11:	83 ec 08             	sub    $0x8,%esp
c002ad14:	e8 7e 2b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ad19:	81 c3 e7 f7 00 00    	add    $0xf7e7,%ebx
  if (!intr_context () && use_console_lock) 
c002ad1f:	e8 a5 70 ff ff       	call   c0021dc9 <intr_context>
c002ad24:	84 c0                	test   %al,%al
c002ad26:	75 1c                	jne    c002ad44 <release_console+0x34>
c002ad28:	80 bb 6c 1c 00 00 00 	cmpb   $0x0,0x1c6c(%ebx)
c002ad2f:	74 13                	je     c002ad44 <release_console+0x34>
      if (console_lock_depth > 0)
c002ad31:	8b 83 68 1c 00 00    	mov    0x1c68(%ebx),%eax
c002ad37:	85 c0                	test   %eax,%eax
c002ad39:	7e 0e                	jle    c002ad49 <release_console+0x39>
        console_lock_depth--;
c002ad3b:	83 e8 01             	sub    $0x1,%eax
c002ad3e:	89 83 68 1c 00 00    	mov    %eax,0x1c68(%ebx)
}
c002ad44:	83 c4 08             	add    $0x8,%esp
c002ad47:	5b                   	pop    %ebx
c002ad48:	c3                   	ret    
        lock_release (&console_lock); 
c002ad49:	83 ec 0c             	sub    $0xc,%esp
c002ad4c:	8d 83 80 1c 00 00    	lea    0x1c80(%ebx),%eax
c002ad52:	50                   	push   %eax
c002ad53:	e8 cb 84 ff ff       	call   c0023223 <lock_release>
c002ad58:	83 c4 10             	add    $0x10,%esp
}
c002ad5b:	eb e7                	jmp    c002ad44 <release_console+0x34>

c002ad5d <console_init>:
{
c002ad5d:	53                   	push   %ebx
c002ad5e:	83 ec 14             	sub    $0x14,%esp
c002ad61:	e8 31 2b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ad66:	81 c3 9a f7 00 00    	add    $0xf79a,%ebx
  lock_init (&console_lock);
c002ad6c:	8d 83 80 1c 00 00    	lea    0x1c80(%ebx),%eax
c002ad72:	50                   	push   %eax
c002ad73:	e8 fe 81 ff ff       	call   c0022f76 <lock_init>
  use_console_lock = true;
c002ad78:	c6 83 6c 1c 00 00 01 	movb   $0x1,0x1c6c(%ebx)
}
c002ad7f:	83 c4 18             	add    $0x18,%esp
c002ad82:	5b                   	pop    %ebx
c002ad83:	c3                   	ret    

c002ad84 <console_panic>:
{
c002ad84:	e8 12 2b 00 00       	call   c002d89b <__x86.get_pc_thunk.ax>
c002ad89:	05 77 f7 00 00       	add    $0xf777,%eax
  use_console_lock = false;
c002ad8e:	c6 80 6c 1c 00 00 00 	movb   $0x0,0x1c6c(%eax)
}
c002ad95:	c3                   	ret    

c002ad96 <console_print_stats>:
{
c002ad96:	53                   	push   %ebx
c002ad97:	83 ec 0c             	sub    $0xc,%esp
c002ad9a:	e8 f8 2a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ad9f:	81 c3 61 f7 00 00    	add    $0xf761,%ebx
  printf ("Console: %lld characters output\n", write_cnt);
c002ada5:	ff b3 64 1c 00 00    	pushl  0x1c64(%ebx)
c002adab:	ff b3 60 1c 00 00    	pushl  0x1c60(%ebx)
c002adb1:	8d 83 78 61 ff ff    	lea    -0x9e88(%ebx),%eax
c002adb7:	50                   	push   %eax
c002adb8:	e8 cb c4 ff ff       	call   c0027288 <printf>
}
c002adbd:	83 c4 18             	add    $0x18,%esp
c002adc0:	5b                   	pop    %ebx
c002adc1:	c3                   	ret    

c002adc2 <vprintf>:
{
c002adc2:	53                   	push   %ebx
c002adc3:	83 ec 18             	sub    $0x18,%esp
c002adc6:	e8 cc 2a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002adcb:	81 c3 35 f7 00 00    	add    $0xf735,%ebx
  int char_cnt = 0;
c002add1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002add8:	00 
  acquire_console ();
c002add9:	e8 d9 fe ff ff       	call   c002acb7 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002adde:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002ade2:	50                   	push   %eax
c002ade3:	8d 83 9f 07 ff ff    	lea    -0xf861(%ebx),%eax
c002ade9:	50                   	push   %eax
c002adea:	ff 74 24 2c          	pushl  0x2c(%esp)
c002adee:	ff 74 24 2c          	pushl  0x2c(%esp)
c002adf2:	e8 d3 c4 ff ff       	call   c00272ca <__vprintf>
  release_console ();
c002adf7:	e8 14 ff ff ff       	call   c002ad10 <release_console>
}
c002adfc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ae00:	83 c4 28             	add    $0x28,%esp
c002ae03:	5b                   	pop    %ebx
c002ae04:	c3                   	ret    

c002ae05 <puts>:
{
c002ae05:	53                   	push   %ebx
c002ae06:	83 ec 08             	sub    $0x8,%esp
c002ae09:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002ae0d:	e8 a5 fe ff ff       	call   c002acb7 <acquire_console>
  while (*s != '\0')
c002ae12:	0f b6 03             	movzbl (%ebx),%eax
c002ae15:	84 c0                	test   %al,%al
c002ae17:	74 12                	je     c002ae2b <puts+0x26>
    putchar_have_lock (*s++);
c002ae19:	83 c3 01             	add    $0x1,%ebx
c002ae1c:	0f b6 c0             	movzbl %al,%eax
c002ae1f:	e8 ee fd ff ff       	call   c002ac12 <putchar_have_lock>
  while (*s != '\0')
c002ae24:	0f b6 03             	movzbl (%ebx),%eax
c002ae27:	84 c0                	test   %al,%al
c002ae29:	75 ee                	jne    c002ae19 <puts+0x14>
  putchar_have_lock ('\n');
c002ae2b:	b8 0a 00 00 00       	mov    $0xa,%eax
c002ae30:	e8 dd fd ff ff       	call   c002ac12 <putchar_have_lock>
  release_console ();
c002ae35:	e8 d6 fe ff ff       	call   c002ad10 <release_console>
}
c002ae3a:	b8 00 00 00 00       	mov    $0x0,%eax
c002ae3f:	83 c4 08             	add    $0x8,%esp
c002ae42:	5b                   	pop    %ebx
c002ae43:	c3                   	ret    

c002ae44 <putbuf>:
{
c002ae44:	56                   	push   %esi
c002ae45:	53                   	push   %ebx
c002ae46:	83 ec 04             	sub    $0x4,%esp
c002ae49:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002ae4d:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c002ae51:	e8 61 fe ff ff       	call   c002acb7 <acquire_console>
  while (n-- > 0)
c002ae56:	85 f6                	test   %esi,%esi
c002ae58:	74 12                	je     c002ae6c <putbuf+0x28>
c002ae5a:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c002ae5c:	83 c3 01             	add    $0x1,%ebx
c002ae5f:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002ae63:	e8 aa fd ff ff       	call   c002ac12 <putchar_have_lock>
  while (n-- > 0)
c002ae68:	39 de                	cmp    %ebx,%esi
c002ae6a:	75 f0                	jne    c002ae5c <putbuf+0x18>
  release_console ();
c002ae6c:	e8 9f fe ff ff       	call   c002ad10 <release_console>
}
c002ae71:	83 c4 04             	add    $0x4,%esp
c002ae74:	5b                   	pop    %ebx
c002ae75:	5e                   	pop    %esi
c002ae76:	c3                   	ret    

c002ae77 <putchar>:
{
c002ae77:	53                   	push   %ebx
c002ae78:	83 ec 08             	sub    $0x8,%esp
c002ae7b:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002ae7f:	e8 33 fe ff ff       	call   c002acb7 <acquire_console>
  putchar_have_lock (c);
c002ae84:	0f b6 c3             	movzbl %bl,%eax
c002ae87:	e8 86 fd ff ff       	call   c002ac12 <putchar_have_lock>
  release_console ();
c002ae8c:	e8 7f fe ff ff       	call   c002ad10 <release_console>
}
c002ae91:	89 d8                	mov    %ebx,%eax
c002ae93:	83 c4 08             	add    $0x8,%esp
c002ae96:	5b                   	pop    %ebx
c002ae97:	c3                   	ret    

c002ae98 <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002ae98:	53                   	push   %ebx
c002ae99:	83 ec 10             	sub    $0x10,%esp
c002ae9c:	e8 f6 29 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002aea1:	81 c3 5f f6 00 00    	add    $0xf65f,%ebx
  va_list args;
  
  printf ("(%s) ", test_name);
c002aea7:	ff b3 a4 1c 00 00    	pushl  0x1ca4(%ebx)
c002aead:	8d 83 b4 61 ff ff    	lea    -0x9e4c(%ebx),%eax
c002aeb3:	50                   	push   %eax
c002aeb4:	e8 cf c3 ff ff       	call   c0027288 <printf>
  va_start (args, format);
c002aeb9:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c002aebd:	83 c4 08             	add    $0x8,%esp
c002aec0:	50                   	push   %eax
c002aec1:	ff 74 24 1c          	pushl  0x1c(%esp)
c002aec5:	e8 f8 fe ff ff       	call   c002adc2 <vprintf>
  va_end (args);
  putchar ('\n');
c002aeca:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c002aed1:	e8 a1 ff ff ff       	call   c002ae77 <putchar>
}
c002aed6:	83 c4 18             	add    $0x18,%esp
c002aed9:	5b                   	pop    %ebx
c002aeda:	c3                   	ret    

c002aedb <run_test>:
{
c002aedb:	55                   	push   %ebp
c002aedc:	57                   	push   %edi
c002aedd:	56                   	push   %esi
c002aede:	53                   	push   %ebx
c002aedf:	83 ec 0c             	sub    $0xc,%esp
c002aee2:	e8 b0 29 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002aee7:	81 c3 19 f6 00 00    	add    $0xf619,%ebx
c002aeed:	8b 7c 24 20          	mov    0x20(%esp),%edi
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002aef1:	8d b3 a0 76 ff ff    	lea    -0x8960(%ebx),%esi
c002aef7:	8d ab 78 77 ff ff    	lea    -0x8888(%ebx),%ebp
    if (!strcmp (name, t->name))
c002aefd:	83 ec 08             	sub    $0x8,%esp
c002af00:	ff 36                	pushl  (%esi)
c002af02:	57                   	push   %edi
c002af03:	e8 92 d2 ff ff       	call   c002819a <strcmp>
c002af08:	83 c4 10             	add    $0x10,%esp
c002af0b:	85 c0                	test   %eax,%eax
c002af0d:	74 27                	je     c002af36 <run_test+0x5b>
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002af0f:	83 c6 08             	add    $0x8,%esi
c002af12:	39 ee                	cmp    %ebp,%esi
c002af14:	75 e7                	jne    c002aefd <run_test+0x22>
  PANIC ("no test named \"%s\"", name);
c002af16:	83 ec 0c             	sub    $0xc,%esp
c002af19:	57                   	push   %edi
c002af1a:	8d 83 c4 61 ff ff    	lea    -0x9e3c(%ebx),%eax
c002af20:	50                   	push   %eax
c002af21:	8d 83 44 42 ff ff    	lea    -0xbdbc(%ebx),%eax
c002af27:	50                   	push   %eax
c002af28:	6a 3c                	push   $0x3c
c002af2a:	8d 83 d7 61 ff ff    	lea    -0x9e29(%ebx),%eax
c002af30:	50                   	push   %eax
c002af31:	e8 ae df ff ff       	call   c0028ee4 <debug_panic>
        test_name = name;
c002af36:	89 bb a4 1c 00 00    	mov    %edi,0x1ca4(%ebx)
        msg ("begin");
c002af3c:	83 ec 0c             	sub    $0xc,%esp
c002af3f:	8d 83 ba 61 ff ff    	lea    -0x9e46(%ebx),%eax
c002af45:	50                   	push   %eax
c002af46:	e8 4d ff ff ff       	call   c002ae98 <msg>
        t->function ();
c002af4b:	ff 56 04             	call   *0x4(%esi)
        msg ("end");
c002af4e:	8d 83 c0 61 ff ff    	lea    -0x9e40(%ebx),%eax
c002af54:	89 04 24             	mov    %eax,(%esp)
c002af57:	e8 3c ff ff ff       	call   c002ae98 <msg>
}
c002af5c:	83 c4 1c             	add    $0x1c,%esp
c002af5f:	5b                   	pop    %ebx
c002af60:	5e                   	pop    %esi
c002af61:	5f                   	pop    %edi
c002af62:	5d                   	pop    %ebp
c002af63:	c3                   	ret    

c002af64 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002af64:	53                   	push   %ebx
c002af65:	83 ec 10             	sub    $0x10,%esp
c002af68:	e8 2a 29 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002af6d:	81 c3 93 f5 00 00    	add    $0xf593,%ebx
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002af73:	ff b3 a4 1c 00 00    	pushl  0x1ca4(%ebx)
c002af79:	8d 83 f3 61 ff ff    	lea    -0x9e0d(%ebx),%eax
c002af7f:	50                   	push   %eax
c002af80:	e8 03 c3 ff ff       	call   c0027288 <printf>
  va_start (args, format);
c002af85:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c002af89:	83 c4 08             	add    $0x8,%esp
c002af8c:	50                   	push   %eax
c002af8d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002af91:	e8 2c fe ff ff       	call   c002adc2 <vprintf>
  va_end (args);
  putchar ('\n');
c002af96:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c002af9d:	e8 d5 fe ff ff       	call   c002ae77 <putchar>

  PANIC ("test failed");
c002afa2:	8d 83 ff 61 ff ff    	lea    -0x9e01(%ebx),%eax
c002afa8:	50                   	push   %eax
c002afa9:	8d 83 3c 42 ff ff    	lea    -0xbdc4(%ebx),%eax
c002afaf:	50                   	push   %eax
c002afb0:	6a 5d                	push   $0x5d
c002afb2:	8d 83 d7 61 ff ff    	lea    -0x9e29(%ebx),%eax
c002afb8:	50                   	push   %eax
c002afb9:	e8 26 df ff ff       	call   c0028ee4 <debug_panic>

c002afbe <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002afbe:	53                   	push   %ebx
c002afbf:	83 ec 10             	sub    $0x10,%esp
c002afc2:	e8 d0 28 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002afc7:	81 c3 39 f5 00 00    	add    $0xf539,%ebx
  printf ("(%s) PASS\n", test_name);
c002afcd:	ff b3 a4 1c 00 00    	pushl  0x1ca4(%ebx)
c002afd3:	8d 83 0b 62 ff ff    	lea    -0x9df5(%ebx),%eax
c002afd9:	50                   	push   %eax
c002afda:	e8 a9 c2 ff ff       	call   c0027288 <printf>
}
c002afdf:	83 c4 18             	add    $0x18,%esp
c002afe2:	5b                   	pop    %ebx
c002afe3:	c3                   	ret    

c002afe4 <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002afe4:	55                   	push   %ebp
c002afe5:	57                   	push   %edi
c002afe6:	56                   	push   %esi
c002afe7:	53                   	push   %ebx
c002afe8:	83 ec 1c             	sub    $0x1c,%esp
c002afeb:	e8 a7 28 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002aff0:	81 c3 10 f5 00 00    	add    $0xf510,%ebx
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
c002aff6:	8b 44 24 30          	mov    0x30(%esp),%eax
c002affa:	8b 28                	mov    (%eax),%ebp
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002affc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b000:	7e 71                	jle    c002b073 <sleeper+0x8f>
c002b002:	be 01 00 00 00       	mov    $0x1,%esi
    {
      int64_t sleep_until = test->start + i * t->duration;
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
c002b007:	8d 45 0c             	lea    0xc(%ebp),%eax
c002b00a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002b00e:	89 74 24 08          	mov    %esi,0x8(%esp)
      int64_t sleep_until = test->start + i * t->duration;
c002b012:	8b 44 24 08          	mov    0x8(%esp),%eax
c002b016:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002b01a:	0f af 47 08          	imul   0x8(%edi),%eax
c002b01e:	99                   	cltd   
c002b01f:	03 45 00             	add    0x0(%ebp),%eax
c002b022:	13 55 04             	adc    0x4(%ebp),%edx
c002b025:	89 c6                	mov    %eax,%esi
c002b027:	89 d7                	mov    %edx,%edi
      timer_sleep (sleep_until - timer_ticks ());
c002b029:	e8 53 93 ff ff       	call   c0024381 <timer_ticks>
c002b02e:	83 ec 08             	sub    $0x8,%esp
c002b031:	29 c6                	sub    %eax,%esi
c002b033:	19 d7                	sbb    %edx,%edi
c002b035:	57                   	push   %edi
c002b036:	56                   	push   %esi
c002b037:	e8 94 93 ff ff       	call   c00243d0 <timer_sleep>
      lock_acquire (&test->output_lock);
c002b03c:	8b 74 24 1c          	mov    0x1c(%esp),%esi
c002b040:	89 34 24             	mov    %esi,(%esp)
c002b043:	e8 da 7f ff ff       	call   c0023022 <lock_acquire>
      *test->output_pos++ = t->id;
c002b048:	8b 45 30             	mov    0x30(%ebp),%eax
c002b04b:	8d 50 04             	lea    0x4(%eax),%edx
c002b04e:	89 55 30             	mov    %edx,0x30(%ebp)
c002b051:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c002b055:	8b 51 04             	mov    0x4(%ecx),%edx
c002b058:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002b05a:	89 34 24             	mov    %esi,(%esp)
c002b05d:	e8 c1 81 ff ff       	call   c0023223 <lock_release>
  for (i = 1; i <= test->iterations; i++) 
c002b062:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
c002b067:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b06b:	83 c4 10             	add    $0x10,%esp
c002b06e:	39 45 08             	cmp    %eax,0x8(%ebp)
c002b071:	7d 9f                	jge    c002b012 <sleeper+0x2e>
    }
}
c002b073:	83 c4 1c             	add    $0x1c,%esp
c002b076:	5b                   	pop    %ebx
c002b077:	5e                   	pop    %esi
c002b078:	5f                   	pop    %edi
c002b079:	5d                   	pop    %ebp
c002b07a:	c3                   	ret    

c002b07b <test_sleep>:
{
c002b07b:	55                   	push   %ebp
c002b07c:	57                   	push   %edi
c002b07d:	56                   	push   %esi
c002b07e:	53                   	push   %ebx
c002b07f:	83 ec 7c             	sub    $0x7c,%esp
c002b082:	e8 10 28 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b087:	81 c3 79 f4 00 00    	add    $0xf479,%ebx
c002b08d:	89 44 24 08          	mov    %eax,0x8(%esp)
c002b091:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  ASSERT (!thread_mlfqs);
c002b095:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002b09b:	80 38 00             	cmpb   $0x0,(%eax)
c002b09e:	0f 85 9f 01 00 00    	jne    c002b243 <test_sleep+0x1c8>
  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002b0a4:	83 ec 04             	sub    $0x4,%esp
c002b0a7:	8b 74 24 20          	mov    0x20(%esp),%esi
c002b0ab:	56                   	push   %esi
c002b0ac:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002b0b0:	57                   	push   %edi
c002b0b1:	8d 83 30 64 ff ff    	lea    -0x9bd0(%ebx),%eax
c002b0b7:	50                   	push   %eax
c002b0b8:	e8 db fd ff ff       	call   c002ae98 <msg>
  msg ("Thread 0 sleeps 10 ticks each time,");
c002b0bd:	8d 83 5c 64 ff ff    	lea    -0x9ba4(%ebx),%eax
c002b0c3:	89 04 24             	mov    %eax,(%esp)
c002b0c6:	e8 cd fd ff ff       	call   c002ae98 <msg>
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002b0cb:	8d 83 80 64 ff ff    	lea    -0x9b80(%ebx),%eax
c002b0d1:	89 04 24             	mov    %eax,(%esp)
c002b0d4:	e8 bf fd ff ff       	call   c002ae98 <msg>
  msg ("If successful, product of iteration count and");
c002b0d9:	8d 83 b0 64 ff ff    	lea    -0x9b50(%ebx),%eax
c002b0df:	89 04 24             	mov    %eax,(%esp)
c002b0e2:	e8 b1 fd ff ff       	call   c002ae98 <msg>
  msg ("sleep duration will appear in nondescending order.");
c002b0e7:	8d 83 e0 64 ff ff    	lea    -0x9b20(%ebx),%eax
c002b0ed:	89 04 24             	mov    %eax,(%esp)
c002b0f0:	e8 a3 fd ff ff       	call   c002ae98 <msg>
  threads = malloc (sizeof *threads * thread_cnt);
c002b0f5:	89 f8                	mov    %edi,%eax
c002b0f7:	c1 e0 04             	shl    $0x4,%eax
c002b0fa:	89 04 24             	mov    %eax,(%esp)
c002b0fd:	e8 12 8b ff ff       	call   c0023c14 <malloc>
c002b102:	89 c5                	mov    %eax,%ebp
c002b104:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002b108:	0f af f7             	imul   %edi,%esi
c002b10b:	89 f0                	mov    %esi,%eax
c002b10d:	c1 e0 03             	shl    $0x3,%eax
c002b110:	89 04 24             	mov    %eax,(%esp)
c002b113:	e8 fc 8a ff ff       	call   c0023c14 <malloc>
c002b118:	89 44 24 28          	mov    %eax,0x28(%esp)
  if (threads == NULL || output == NULL)
c002b11c:	83 c4 10             	add    $0x10,%esp
c002b11f:	85 ed                	test   %ebp,%ebp
c002b121:	0f 84 42 01 00 00    	je     c002b269 <test_sleep+0x1ee>
c002b127:	85 c0                	test   %eax,%eax
c002b129:	0f 84 3a 01 00 00    	je     c002b269 <test_sleep+0x1ee>
  test.start = timer_ticks () + 100;
c002b12f:	e8 4d 92 ff ff       	call   c0024381 <timer_ticks>
c002b134:	83 c0 64             	add    $0x64,%eax
c002b137:	83 d2 00             	adc    $0x0,%edx
c002b13a:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c002b13e:	89 54 24 40          	mov    %edx,0x40(%esp)
  test.iterations = iterations;
c002b142:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b146:	89 44 24 44          	mov    %eax,0x44(%esp)
  lock_init (&test.output_lock);
c002b14a:	83 ec 0c             	sub    $0xc,%esp
c002b14d:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b151:	50                   	push   %eax
c002b152:	e8 1f 7e ff ff       	call   c0022f76 <lock_init>
  test.output_pos = output;
c002b157:	8b 44 24 28          	mov    0x28(%esp),%eax
c002b15b:	89 44 24 7c          	mov    %eax,0x7c(%esp)
  for (i = 0; i < thread_cnt; i++)
c002b15f:	83 c4 10             	add    $0x10,%esp
c002b162:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002b167:	0f 8e e7 01 00 00    	jle    c002b354 <test_sleep+0x2d9>
c002b16d:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002b171:	b8 00 00 00 00       	mov    $0x0,%eax
      t->test = &test;
c002b176:	8d 4c 24 3c          	lea    0x3c(%esp),%ecx
c002b17a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
      snprintf (name, sizeof name, "thread %d", i);
c002b17e:	8d 8b e2 63 ff ff    	lea    -0x9c1e(%ebx),%ecx
c002b184:	89 4c 24 10          	mov    %ecx,0x10(%esp)
      t->test = &test;
c002b188:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002b18c:	89 0e                	mov    %ecx,(%esi)
      t->id = i;
c002b18e:	89 46 04             	mov    %eax,0x4(%esi)
      t->duration = (i + 1) * 10;
c002b191:	8d 78 01             	lea    0x1(%eax),%edi
c002b194:	8d 14 bf             	lea    (%edi,%edi,4),%edx
c002b197:	01 d2                	add    %edx,%edx
c002b199:	89 56 08             	mov    %edx,0x8(%esi)
      t->iterations = 0;
c002b19c:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
      snprintf (name, sizeof name, "thread %d", i);
c002b1a3:	50                   	push   %eax
c002b1a4:	ff 74 24 14          	pushl  0x14(%esp)
c002b1a8:	6a 10                	push   $0x10
c002b1aa:	8d 6c 24 38          	lea    0x38(%esp),%ebp
c002b1ae:	55                   	push   %ebp
c002b1af:	e8 65 c8 ff ff       	call   c0027a19 <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002b1b4:	56                   	push   %esi
c002b1b5:	8d 83 e4 0a ff ff    	lea    -0xf51c(%ebx),%eax
c002b1bb:	50                   	push   %eax
c002b1bc:	6a 1f                	push   $0x1f
c002b1be:	55                   	push   %ebp
c002b1bf:	e8 98 63 ff ff       	call   c002155c <thread_create>
c002b1c4:	83 c6 10             	add    $0x10,%esi
  for (i = 0; i < thread_cnt; i++)
c002b1c7:	89 f8                	mov    %edi,%eax
c002b1c9:	83 c4 20             	add    $0x20,%esp
c002b1cc:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002b1d0:	75 b6                	jne    c002b188 <test_sleep+0x10d>
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002b1d2:	83 ec 08             	sub    $0x8,%esp
c002b1d5:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b1d9:	0f af 44 24 24       	imul   0x24(%esp),%eax
c002b1de:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002b1e1:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c002b1e8:	99                   	cltd   
c002b1e9:	52                   	push   %edx
c002b1ea:	50                   	push   %eax
c002b1eb:	e8 e0 91 ff ff       	call   c00243d0 <timer_sleep>
  lock_acquire (&test.output_lock);
c002b1f0:	83 c4 04             	add    $0x4,%esp
c002b1f3:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b1f7:	50                   	push   %eax
c002b1f8:	e8 25 7e ff ff       	call   c0023022 <lock_acquire>
  for (op = output; op < test.output_pos; op++) 
c002b1fd:	83 c4 10             	add    $0x10,%esp
c002b200:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b204:	3b 44 24 6c          	cmp    0x6c(%esp),%eax
c002b208:	0f 83 06 01 00 00    	jae    c002b314 <test_sleep+0x299>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002b20e:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b212:	8b 30                	mov    (%eax),%esi
c002b214:	39 74 24 08          	cmp    %esi,0x8(%esp)
c002b218:	7e 6b                	jle    c002b285 <test_sleep+0x20a>
c002b21a:	85 f6                	test   %esi,%esi
c002b21c:	78 67                	js     c002b285 <test_sleep+0x20a>
  for (op = output; op < test.output_pos; op++) 
c002b21e:	8b 7c 24 18          	mov    0x18(%esp),%edi
  product = 0;
c002b222:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002b229:	00 
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002b22a:	8d 83 38 65 ff ff    	lea    -0x9ac8(%ebx),%eax
c002b230:	89 44 24 10          	mov    %eax,0x10(%esp)
        fail ("thread %d woke up out of order (%d > %d)!",
c002b234:	8d 83 6c 65 ff ff    	lea    -0x9a94(%ebx),%eax
c002b23a:	89 44 24 14          	mov    %eax,0x14(%esp)
c002b23e:	e9 91 00 00 00       	jmp    c002b2d4 <test_sleep+0x259>
  ASSERT (!thread_mlfqs);
c002b243:	83 ec 0c             	sub    $0xc,%esp
c002b246:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002b24c:	50                   	push   %eax
c002b24d:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002b253:	50                   	push   %eax
c002b254:	8d 83 50 42 ff ff    	lea    -0xbdb0(%ebx),%eax
c002b25a:	50                   	push   %eax
c002b25b:	6a 3c                	push   $0x3c
c002b25d:	8d 83 0c 64 ff ff    	lea    -0x9bf4(%ebx),%eax
c002b263:	50                   	push   %eax
c002b264:	e8 7b dc ff ff       	call   c0028ee4 <debug_panic>
    PANIC ("couldn't allocate memory for test");
c002b269:	8d 83 14 65 ff ff    	lea    -0x9aec(%ebx),%eax
c002b26f:	50                   	push   %eax
c002b270:	8d 83 50 42 ff ff    	lea    -0xbdb0(%ebx),%eax
c002b276:	50                   	push   %eax
c002b277:	6a 48                	push   $0x48
c002b279:	8d 83 0c 64 ff ff    	lea    -0x9bf4(%ebx),%eax
c002b27f:	50                   	push   %eax
c002b280:	e8 5f dc ff ff       	call   c0028ee4 <debug_panic>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002b285:	83 ec 0c             	sub    $0xc,%esp
c002b288:	8d 83 ec 63 ff ff    	lea    -0x9c14(%ebx),%eax
c002b28e:	50                   	push   %eax
c002b28f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002b295:	50                   	push   %eax
c002b296:	8d 83 50 42 ff ff    	lea    -0xbdb0(%ebx),%eax
c002b29c:	50                   	push   %eax
c002b29d:	6a 6e                	push   $0x6e
c002b29f:	8d 83 0c 64 ff ff    	lea    -0x9bf4(%ebx),%eax
c002b2a5:	50                   	push   %eax
c002b2a6:	e8 39 dc ff ff       	call   c0028ee4 <debug_panic>
        fail ("thread %d woke up out of order (%d > %d)!",
c002b2ab:	55                   	push   %ebp
c002b2ac:	ff 74 24 08          	pushl  0x8(%esp)
c002b2b0:	ff 76 04             	pushl  0x4(%esi)
c002b2b3:	ff 74 24 20          	pushl  0x20(%esp)
c002b2b7:	e8 a8 fc ff ff       	call   c002af64 <fail>
c002b2bc:	83 c4 10             	add    $0x10,%esp
  for (op = output; op < test.output_pos; op++) 
c002b2bf:	83 c7 04             	add    $0x4,%edi
c002b2c2:	39 7c 24 6c          	cmp    %edi,0x6c(%esp)
c002b2c6:	76 45                	jbe    c002b30d <test_sleep+0x292>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002b2c8:	8b 37                	mov    (%edi),%esi
c002b2ca:	3b 74 24 08          	cmp    0x8(%esp),%esi
c002b2ce:	7d b5                	jge    c002b285 <test_sleep+0x20a>
c002b2d0:	85 f6                	test   %esi,%esi
c002b2d2:	78 b1                	js     c002b285 <test_sleep+0x20a>
      t = threads + *op;
c002b2d4:	c1 e6 04             	shl    $0x4,%esi
c002b2d7:	03 74 24 0c          	add    0xc(%esp),%esi
      new_prod = ++t->iterations * t->duration;
c002b2db:	8b 46 0c             	mov    0xc(%esi),%eax
c002b2de:	83 c0 01             	add    $0x1,%eax
c002b2e1:	89 46 0c             	mov    %eax,0xc(%esi)
c002b2e4:	8b 56 08             	mov    0x8(%esi),%edx
c002b2e7:	89 c5                	mov    %eax,%ebp
c002b2e9:	0f af ea             	imul   %edx,%ebp
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002b2ec:	83 ec 0c             	sub    $0xc,%esp
c002b2ef:	55                   	push   %ebp
c002b2f0:	50                   	push   %eax
c002b2f1:	52                   	push   %edx
c002b2f2:	ff 76 04             	pushl  0x4(%esi)
c002b2f5:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b2f9:	e8 9a fb ff ff       	call   c002ae98 <msg>
      if (new_prod >= product)
c002b2fe:	83 c4 20             	add    $0x20,%esp
c002b301:	3b 6c 24 04          	cmp    0x4(%esp),%ebp
c002b305:	7c a4                	jl     c002b2ab <test_sleep+0x230>
        product = new_prod;
c002b307:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002b30b:	eb b2                	jmp    c002b2bf <test_sleep+0x244>
  for (i = 0; i < thread_cnt; i++)
c002b30d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002b312:	7e 7c                	jle    c002b390 <test_sleep+0x315>
        product = new_prod;
c002b314:	be 00 00 00 00       	mov    $0x0,%esi
      fail ("thread %d woke up %d times instead of %d",
c002b319:	8d bb 98 65 ff ff    	lea    -0x9a68(%ebx),%edi
c002b31f:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
c002b323:	89 7c 24 04          	mov    %edi,0x4(%esp)
c002b327:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002b32b:	eb 18                	jmp    c002b345 <test_sleep+0x2ca>
c002b32d:	55                   	push   %ebp
c002b32e:	50                   	push   %eax
c002b32f:	56                   	push   %esi
c002b330:	ff 74 24 10          	pushl  0x10(%esp)
c002b334:	e8 2b fc ff ff       	call   c002af64 <fail>
c002b339:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002b33c:	83 c6 01             	add    $0x1,%esi
c002b33f:	39 74 24 08          	cmp    %esi,0x8(%esp)
c002b343:	7e 4b                	jle    c002b390 <test_sleep+0x315>
    if (threads[i].iterations != iterations)
c002b345:	89 f0                	mov    %esi,%eax
c002b347:	c1 e0 04             	shl    $0x4,%eax
c002b34a:	8b 44 07 0c          	mov    0xc(%edi,%eax,1),%eax
c002b34e:	39 e8                	cmp    %ebp,%eax
c002b350:	74 ea                	je     c002b33c <test_sleep+0x2c1>
c002b352:	eb d9                	jmp    c002b32d <test_sleep+0x2b2>
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002b354:	83 ec 08             	sub    $0x8,%esp
c002b357:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b35b:	0f af 44 24 24       	imul   0x24(%esp),%eax
c002b360:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002b363:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c002b36a:	99                   	cltd   
c002b36b:	52                   	push   %edx
c002b36c:	50                   	push   %eax
c002b36d:	e8 5e 90 ff ff       	call   c00243d0 <timer_sleep>
  lock_acquire (&test.output_lock);
c002b372:	83 c4 04             	add    $0x4,%esp
c002b375:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b379:	50                   	push   %eax
c002b37a:	e8 a3 7c ff ff       	call   c0023022 <lock_acquire>
  for (op = output; op < test.output_pos; op++) 
c002b37f:	83 c4 10             	add    $0x10,%esp
c002b382:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b386:	3b 44 24 6c          	cmp    0x6c(%esp),%eax
c002b38a:	0f 82 7e fe ff ff    	jb     c002b20e <test_sleep+0x193>
  lock_release (&test.output_lock);
c002b390:	83 ec 0c             	sub    $0xc,%esp
c002b393:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b397:	50                   	push   %eax
c002b398:	e8 86 7e ff ff       	call   c0023223 <lock_release>
  free (output);
c002b39d:	83 c4 04             	add    $0x4,%esp
c002b3a0:	ff 74 24 24          	pushl  0x24(%esp)
c002b3a4:	e8 19 8a ff ff       	call   c0023dc2 <free>
  free (threads);
c002b3a9:	83 c4 04             	add    $0x4,%esp
c002b3ac:	ff 74 24 18          	pushl  0x18(%esp)
c002b3b0:	e8 0d 8a ff ff       	call   c0023dc2 <free>
}
c002b3b5:	81 c4 8c 00 00 00    	add    $0x8c,%esp
c002b3bb:	5b                   	pop    %ebx
c002b3bc:	5e                   	pop    %esi
c002b3bd:	5f                   	pop    %edi
c002b3be:	5d                   	pop    %ebp
c002b3bf:	c3                   	ret    

c002b3c0 <test_alarm_single>:
{
c002b3c0:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 1);
c002b3c3:	ba 01 00 00 00       	mov    $0x1,%edx
c002b3c8:	b8 05 00 00 00       	mov    $0x5,%eax
c002b3cd:	e8 a9 fc ff ff       	call   c002b07b <test_sleep>
}
c002b3d2:	83 c4 0c             	add    $0xc,%esp
c002b3d5:	c3                   	ret    

c002b3d6 <test_alarm_multiple>:
{
c002b3d6:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 7);
c002b3d9:	ba 07 00 00 00       	mov    $0x7,%edx
c002b3de:	b8 05 00 00 00       	mov    $0x5,%eax
c002b3e3:	e8 93 fc ff ff       	call   c002b07b <test_sleep>
}
c002b3e8:	83 c4 0c             	add    $0xc,%esp
c002b3eb:	c3                   	ret    

c002b3ec <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002b3ec:	55                   	push   %ebp
c002b3ed:	57                   	push   %edi
c002b3ee:	56                   	push   %esi
c002b3ef:	53                   	push   %ebx
c002b3f0:	83 ec 24             	sub    $0x24,%esp
c002b3f3:	e8 9f 24 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b3f8:	81 c3 08 f1 00 00    	add    $0xf108,%ebx
c002b3fe:	8b 6c 24 38          	mov    0x38(%esp),%ebp
  struct sleep_test *test = test_;
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002b402:	6a 00                	push   $0x0
c002b404:	6a 01                	push   $0x1
c002b406:	e8 c5 8f ff ff       	call   c00243d0 <timer_sleep>

  for (i = 1; i <= test->iterations; i++) 
c002b40b:	83 c4 10             	add    $0x10,%esp
c002b40e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b412:	7e 71                	jle    c002b485 <sleeper+0x99>
c002b414:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
c002b41b:	00 
c002b41c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002b423:	00 
c002b424:	be 01 00 00 00       	mov    $0x1,%esi
c002b429:	89 74 24 04          	mov    %esi,0x4(%esp)
    {
      int64_t sleep_until = test->start + i * 10;
c002b42d:	8b 44 24 08          	mov    0x8(%esp),%eax
c002b431:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002b435:	03 45 00             	add    0x0(%ebp),%eax
c002b438:	13 55 04             	adc    0x4(%ebp),%edx
c002b43b:	89 c6                	mov    %eax,%esi
c002b43d:	89 d7                	mov    %edx,%edi
      timer_sleep (sleep_until - timer_ticks ());
c002b43f:	e8 3d 8f ff ff       	call   c0024381 <timer_ticks>
c002b444:	83 ec 08             	sub    $0x8,%esp
c002b447:	29 c6                	sub    %eax,%esi
c002b449:	19 d7                	sbb    %edx,%edi
c002b44b:	57                   	push   %edi
c002b44c:	56                   	push   %esi
c002b44d:	e8 7e 8f ff ff       	call   c00243d0 <timer_sleep>
      *test->output_pos++ = timer_ticks () - test->start;
c002b452:	e8 2a 8f ff ff       	call   c0024381 <timer_ticks>
c002b457:	2b 45 00             	sub    0x0(%ebp),%eax
c002b45a:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b45d:	8d 4a 04             	lea    0x4(%edx),%ecx
c002b460:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c002b463:	89 02                	mov    %eax,(%edx)
      thread_yield ();
c002b465:	e8 61 60 ff ff       	call   c00214cb <thread_yield>
  for (i = 1; i <= test->iterations; i++) 
c002b46a:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
c002b46f:	8b 44 24 14          	mov    0x14(%esp),%eax
c002b473:	83 44 24 18 0a       	addl   $0xa,0x18(%esp)
c002b478:	83 54 24 1c 00       	adcl   $0x0,0x1c(%esp)
c002b47d:	83 c4 10             	add    $0x10,%esp
c002b480:	39 45 08             	cmp    %eax,0x8(%ebp)
c002b483:	7d a8                	jge    c002b42d <sleeper+0x41>
    }
}
c002b485:	83 c4 1c             	add    $0x1c,%esp
c002b488:	5b                   	pop    %ebx
c002b489:	5e                   	pop    %esi
c002b48a:	5f                   	pop    %edi
c002b48b:	5d                   	pop    %ebp
c002b48c:	c3                   	ret    

c002b48d <test_alarm_simultaneous>:
{
c002b48d:	55                   	push   %ebp
c002b48e:	57                   	push   %edi
c002b48f:	56                   	push   %esi
c002b490:	53                   	push   %ebx
c002b491:	83 ec 3c             	sub    $0x3c,%esp
c002b494:	e8 fe 23 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b499:	81 c3 67 f0 00 00    	add    $0xf067,%ebx
  ASSERT (!thread_mlfqs);
c002b49f:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002b4a5:	80 38 00             	cmpb   $0x0,(%eax)
c002b4a8:	0f 85 28 01 00 00    	jne    c002b5d6 <test_alarm_simultaneous+0x149>
  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002b4ae:	83 ec 04             	sub    $0x4,%esp
c002b4b1:	6a 05                	push   $0x5
c002b4b3:	6a 03                	push   $0x3
c002b4b5:	8d 83 30 64 ff ff    	lea    -0x9bd0(%ebx),%eax
c002b4bb:	50                   	push   %eax
c002b4bc:	e8 d7 f9 ff ff       	call   c002ae98 <msg>
  msg ("Each thread sleeps 10 ticks each time.");
c002b4c1:	8d 83 f0 65 ff ff    	lea    -0x9a10(%ebx),%eax
c002b4c7:	89 04 24             	mov    %eax,(%esp)
c002b4ca:	e8 c9 f9 ff ff       	call   c002ae98 <msg>
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002b4cf:	8d 83 18 66 ff ff    	lea    -0x99e8(%ebx),%eax
c002b4d5:	89 04 24             	mov    %eax,(%esp)
c002b4d8:	e8 bb f9 ff ff       	call   c002ae98 <msg>
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002b4dd:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
c002b4e4:	e8 2b 87 ff ff       	call   c0023c14 <malloc>
c002b4e9:	89 c6                	mov    %eax,%esi
  if (output == NULL)
c002b4eb:	83 c4 10             	add    $0x10,%esp
c002b4ee:	85 c0                	test   %eax,%eax
c002b4f0:	0f 84 06 01 00 00    	je     c002b5fc <test_alarm_simultaneous+0x16f>
  test.start = timer_ticks () + 100;
c002b4f6:	e8 86 8e ff ff       	call   c0024381 <timer_ticks>
c002b4fb:	83 c0 64             	add    $0x64,%eax
c002b4fe:	83 d2 00             	adc    $0x0,%edx
c002b501:	89 44 24 10          	mov    %eax,0x10(%esp)
c002b505:	89 54 24 14          	mov    %edx,0x14(%esp)
  test.iterations = iterations;
c002b509:	c7 44 24 18 05 00 00 	movl   $0x5,0x18(%esp)
c002b510:	00 
  test.output_pos = output;
c002b511:	89 74 24 1c          	mov    %esi,0x1c(%esp)
  for (i = 0; i < thread_cnt; i++)
c002b515:	bf 00 00 00 00       	mov    $0x0,%edi
      snprintf (name, sizeof name, "thread %d", i);
c002b51a:	8d 83 e2 63 ff ff    	lea    -0x9c1e(%ebx),%eax
c002b520:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002b524:	8d 6c 24 20          	lea    0x20(%esp),%ebp
c002b528:	57                   	push   %edi
c002b529:	ff 74 24 10          	pushl  0x10(%esp)
c002b52d:	6a 10                	push   $0x10
c002b52f:	55                   	push   %ebp
c002b530:	e8 e4 c4 ff ff       	call   c0027a19 <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002b535:	8d 44 24 20          	lea    0x20(%esp),%eax
c002b539:	50                   	push   %eax
c002b53a:	8d 83 ec 0e ff ff    	lea    -0xf114(%ebx),%eax
c002b540:	50                   	push   %eax
c002b541:	6a 1f                	push   $0x1f
c002b543:	55                   	push   %ebp
c002b544:	e8 13 60 ff ff       	call   c002155c <thread_create>
  for (i = 0; i < thread_cnt; i++)
c002b549:	83 c7 01             	add    $0x1,%edi
c002b54c:	83 c4 20             	add    $0x20,%esp
c002b54f:	83 ff 03             	cmp    $0x3,%edi
c002b552:	75 d4                	jne    c002b528 <test_alarm_simultaneous+0x9b>
  timer_sleep (100 + iterations * 10 + 100);
c002b554:	83 ec 08             	sub    $0x8,%esp
c002b557:	6a 00                	push   $0x0
c002b559:	68 fa 00 00 00       	push   $0xfa
c002b55e:	e8 6d 8e ff ff       	call   c00243d0 <timer_sleep>
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002b563:	83 c4 08             	add    $0x8,%esp
c002b566:	ff 36                	pushl  (%esi)
c002b568:	8d 83 5c 66 ff ff    	lea    -0x99a4(%ebx),%eax
c002b56e:	50                   	push   %eax
c002b56f:	e8 24 f9 ff ff       	call   c002ae98 <msg>
  for (i = 1; i < test.output_pos - output; i++) 
c002b574:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002b578:	29 f0                	sub    %esi,%eax
c002b57a:	83 c4 10             	add    $0x10,%esp
c002b57d:	83 f8 04             	cmp    $0x4,%eax
c002b580:	7e 43                	jle    c002b5c5 <test_alarm_simultaneous+0x138>
c002b582:	bf 01 00 00 00       	mov    $0x1,%edi
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002b587:	8d ab 8c 66 ff ff    	lea    -0x9974(%ebx),%ebp
c002b58d:	8b 04 be             	mov    (%esi,%edi,4),%eax
c002b590:	2b 44 be fc          	sub    -0x4(%esi,%edi,4),%eax
c002b594:	50                   	push   %eax
c002b595:	b8 56 55 55 55       	mov    $0x55555556,%eax
c002b59a:	f7 ef                	imul   %edi
c002b59c:	89 f8                	mov    %edi,%eax
c002b59e:	c1 f8 1f             	sar    $0x1f,%eax
c002b5a1:	29 c2                	sub    %eax,%edx
c002b5a3:	8d 04 52             	lea    (%edx,%edx,2),%eax
c002b5a6:	89 f9                	mov    %edi,%ecx
c002b5a8:	29 c1                	sub    %eax,%ecx
c002b5aa:	51                   	push   %ecx
c002b5ab:	52                   	push   %edx
c002b5ac:	55                   	push   %ebp
c002b5ad:	e8 e6 f8 ff ff       	call   c002ae98 <msg>
  for (i = 1; i < test.output_pos - output; i++) 
c002b5b2:	83 c7 01             	add    $0x1,%edi
c002b5b5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002b5b9:	29 f0                	sub    %esi,%eax
c002b5bb:	c1 f8 02             	sar    $0x2,%eax
c002b5be:	83 c4 10             	add    $0x10,%esp
c002b5c1:	39 c7                	cmp    %eax,%edi
c002b5c3:	7c c8                	jl     c002b58d <test_alarm_simultaneous+0x100>
  free (output);
c002b5c5:	83 ec 0c             	sub    $0xc,%esp
c002b5c8:	56                   	push   %esi
c002b5c9:	e8 f4 87 ff ff       	call   c0023dc2 <free>
}
c002b5ce:	83 c4 4c             	add    $0x4c,%esp
c002b5d1:	5b                   	pop    %ebx
c002b5d2:	5e                   	pop    %esi
c002b5d3:	5f                   	pop    %edi
c002b5d4:	5d                   	pop    %ebp
c002b5d5:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b5d6:	83 ec 0c             	sub    $0xc,%esp
c002b5d9:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002b5df:	50                   	push   %eax
c002b5e0:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002b5e6:	50                   	push   %eax
c002b5e7:	8d 83 5c 42 ff ff    	lea    -0xbda4(%ebx),%eax
c002b5ed:	50                   	push   %eax
c002b5ee:	6a 28                	push   $0x28
c002b5f0:	8d 83 c4 65 ff ff    	lea    -0x9a3c(%ebx),%eax
c002b5f6:	50                   	push   %eax
c002b5f7:	e8 e8 d8 ff ff       	call   c0028ee4 <debug_panic>
    PANIC ("couldn't allocate memory for test");
c002b5fc:	8d 83 14 65 ff ff    	lea    -0x9aec(%ebx),%eax
c002b602:	50                   	push   %eax
c002b603:	8d 83 5c 42 ff ff    	lea    -0xbda4(%ebx),%eax
c002b609:	50                   	push   %eax
c002b60a:	6a 31                	push   $0x31
c002b60c:	8d 83 c4 65 ff ff    	lea    -0x9a3c(%ebx),%eax
c002b612:	50                   	push   %eax
c002b613:	e8 cc d8 ff ff       	call   c0028ee4 <debug_panic>

c002b618 <alarm_priority_thread>:
    sema_down (&wait_sema);
}

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002b618:	57                   	push   %edi
c002b619:	56                   	push   %esi
c002b61a:	53                   	push   %ebx
c002b61b:	e8 77 22 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b620:	81 c3 e0 ee 00 00    	add    $0xeee0,%ebx
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002b626:	e8 56 8d ff ff       	call   c0024381 <timer_ticks>
c002b62b:	89 c6                	mov    %eax,%esi
c002b62d:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) == 0)
c002b62f:	83 ec 08             	sub    $0x8,%esp
c002b632:	57                   	push   %edi
c002b633:	56                   	push   %esi
c002b634:	e8 7b 8d ff ff       	call   c00243b4 <timer_elapsed>
c002b639:	83 c4 10             	add    $0x10,%esp
c002b63c:	09 c2                	or     %eax,%edx
c002b63e:	74 ef                	je     c002b62f <alarm_priority_thread+0x17>
    continue;

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002b640:	8b b3 c0 1c 00 00    	mov    0x1cc0(%ebx),%esi
c002b646:	8b bb c4 1c 00 00    	mov    0x1cc4(%ebx),%edi
c002b64c:	e8 30 8d ff ff       	call   c0024381 <timer_ticks>
c002b651:	83 ec 08             	sub    $0x8,%esp
c002b654:	29 c6                	sub    %eax,%esi
c002b656:	19 d7                	sbb    %edx,%edi
c002b658:	57                   	push   %edi
c002b659:	56                   	push   %esi
c002b65a:	e8 71 8d ff ff       	call   c00243d0 <timer_sleep>

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002b65f:	e8 24 58 ff ff       	call   c0020e88 <thread_name>
c002b664:	83 c4 08             	add    $0x8,%esp
c002b667:	50                   	push   %eax
c002b668:	8d 83 bc 66 ff ff    	lea    -0x9944(%ebx),%eax
c002b66e:	50                   	push   %eax
c002b66f:	e8 24 f8 ff ff       	call   c002ae98 <msg>

  sema_up (&wait_sema);
c002b674:	8d 83 a8 1c 00 00    	lea    0x1ca8(%ebx),%eax
c002b67a:	89 04 24             	mov    %eax,(%esp)
c002b67d:	e8 9d 77 ff ff       	call   c0022e1f <sema_up>
}
c002b682:	83 c4 10             	add    $0x10,%esp
c002b685:	5b                   	pop    %ebx
c002b686:	5e                   	pop    %esi
c002b687:	5f                   	pop    %edi
c002b688:	c3                   	ret    

c002b689 <test_alarm_priority>:
{
c002b689:	55                   	push   %ebp
c002b68a:	57                   	push   %edi
c002b68b:	56                   	push   %esi
c002b68c:	53                   	push   %ebx
c002b68d:	83 ec 1c             	sub    $0x1c,%esp
c002b690:	e8 02 22 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b695:	81 c3 6b ee 00 00    	add    $0xee6b,%ebx
  ASSERT (!thread_mlfqs);
c002b69b:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002b6a1:	80 38 00             	cmpb   $0x0,(%eax)
c002b6a4:	0f 85 b3 00 00 00    	jne    c002b75d <test_alarm_priority+0xd4>
  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002b6aa:	e8 d2 8c ff ff       	call   c0024381 <timer_ticks>
c002b6af:	05 f4 01 00 00       	add    $0x1f4,%eax
c002b6b4:	83 d2 00             	adc    $0x0,%edx
c002b6b7:	89 83 c0 1c 00 00    	mov    %eax,0x1cc0(%ebx)
c002b6bd:	89 93 c4 1c 00 00    	mov    %edx,0x1cc4(%ebx)
  sema_init (&wait_sema, 0);
c002b6c3:	83 ec 08             	sub    $0x8,%esp
c002b6c6:	6a 00                	push   $0x0
c002b6c8:	8d 83 a8 1c 00 00    	lea    0x1ca8(%ebx),%eax
c002b6ce:	50                   	push   %eax
c002b6cf:	e8 cc 75 ff ff       	call   c0022ca0 <sema_init>
c002b6d4:	83 c4 10             	add    $0x10,%esp
c002b6d7:	be 05 00 00 00       	mov    $0x5,%esi
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002b6dc:	b8 67 66 66 66       	mov    $0x66666667,%eax
c002b6e1:	f7 ee                	imul   %esi
c002b6e3:	c1 fa 02             	sar    $0x2,%edx
c002b6e6:	89 f0                	mov    %esi,%eax
c002b6e8:	c1 f8 1f             	sar    $0x1f,%eax
c002b6eb:	29 c2                	sub    %eax,%edx
c002b6ed:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002b6f0:	01 c0                	add    %eax,%eax
c002b6f2:	89 f1                	mov    %esi,%ecx
c002b6f4:	29 c1                	sub    %eax,%ecx
c002b6f6:	bd 1e 00 00 00       	mov    $0x1e,%ebp
c002b6fb:	29 cd                	sub    %ecx,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002b6fd:	55                   	push   %ebp
c002b6fe:	8d 83 cf 66 ff ff    	lea    -0x9931(%ebx),%eax
c002b704:	50                   	push   %eax
c002b705:	6a 10                	push   $0x10
c002b707:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002b70b:	57                   	push   %edi
c002b70c:	e8 08 c3 ff ff       	call   c0027a19 <snprintf>
      thread_create (name, priority, alarm_priority_thread, NULL);
c002b711:	6a 00                	push   $0x0
c002b713:	8d 83 18 11 ff ff    	lea    -0xeee8(%ebx),%eax
c002b719:	50                   	push   %eax
c002b71a:	55                   	push   %ebp
c002b71b:	57                   	push   %edi
c002b71c:	e8 3b 5e ff ff       	call   c002155c <thread_create>
c002b721:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < 10; i++) 
c002b724:	83 c4 20             	add    $0x20,%esp
c002b727:	83 fe 0f             	cmp    $0xf,%esi
c002b72a:	75 b0                	jne    c002b6dc <test_alarm_priority+0x53>
  thread_set_priority (PRI_MIN);
c002b72c:	83 ec 0c             	sub    $0xc,%esp
c002b72f:	6a 00                	push   $0x0
c002b731:	e8 d7 5f ff ff       	call   c002170d <thread_set_priority>
c002b736:	83 c4 10             	add    $0x10,%esp
c002b739:	be 0a 00 00 00       	mov    $0xa,%esi
    sema_down (&wait_sema);
c002b73e:	8d bb a8 1c 00 00    	lea    0x1ca8(%ebx),%edi
c002b744:	83 ec 0c             	sub    $0xc,%esp
c002b747:	57                   	push   %edi
c002b748:	e8 a7 75 ff ff       	call   c0022cf4 <sema_down>
  for (i = 0; i < 10; i++)
c002b74d:	83 c4 10             	add    $0x10,%esp
c002b750:	83 ee 01             	sub    $0x1,%esi
c002b753:	75 ef                	jne    c002b744 <test_alarm_priority+0xbb>
}
c002b755:	83 c4 1c             	add    $0x1c,%esp
c002b758:	5b                   	pop    %ebx
c002b759:	5e                   	pop    %esi
c002b75a:	5f                   	pop    %edi
c002b75b:	5d                   	pop    %ebp
c002b75c:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b75d:	83 ec 0c             	sub    $0xc,%esp
c002b760:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002b766:	50                   	push   %eax
c002b767:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002b76d:	50                   	push   %eax
c002b76e:	8d 83 68 42 ff ff    	lea    -0xbd98(%ebx),%eax
c002b774:	50                   	push   %eax
c002b775:	6a 16                	push   $0x16
c002b777:	8d 83 dc 66 ff ff    	lea    -0x9924(%ebx),%eax
c002b77d:	50                   	push   %eax
c002b77e:	e8 61 d7 ff ff       	call   c0028ee4 <debug_panic>

c002b783 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002b783:	53                   	push   %ebx
c002b784:	83 ec 10             	sub    $0x10,%esp
c002b787:	e8 0b 21 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b78c:	81 c3 74 ed 00 00    	add    $0xed74,%ebx
  timer_sleep (0);
c002b792:	6a 00                	push   $0x0
c002b794:	6a 00                	push   $0x0
c002b796:	e8 35 8c ff ff       	call   c00243d0 <timer_sleep>
  pass ();
c002b79b:	e8 1e f8 ff ff       	call   c002afbe <pass>
}
c002b7a0:	83 c4 18             	add    $0x18,%esp
c002b7a3:	5b                   	pop    %ebx
c002b7a4:	c3                   	ret    

c002b7a5 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002b7a5:	53                   	push   %ebx
c002b7a6:	83 ec 10             	sub    $0x10,%esp
c002b7a9:	e8 e9 20 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b7ae:	81 c3 52 ed 00 00    	add    $0xed52,%ebx
  timer_sleep (-100);
c002b7b4:	6a ff                	push   $0xffffffff
c002b7b6:	6a 9c                	push   $0xffffff9c
c002b7b8:	e8 13 8c ff ff       	call   c00243d0 <timer_sleep>
  pass ();
c002b7bd:	e8 fc f7 ff ff       	call   c002afbe <pass>
}
c002b7c2:	83 c4 18             	add    $0x18,%esp
c002b7c5:	5b                   	pop    %ebx
c002b7c6:	c3                   	ret    

c002b7c7 <changing_thread>:
  msg ("Thread 2 should have just exited.");
}

static void
changing_thread (void *aux UNUSED) 
{
c002b7c7:	53                   	push   %ebx
c002b7c8:	83 ec 14             	sub    $0x14,%esp
c002b7cb:	e8 c7 20 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b7d0:	81 c3 30 ed 00 00    	add    $0xed30,%ebx
  msg ("Thread 2 now lowering priority.");
c002b7d6:	8d 83 04 67 ff ff    	lea    -0x98fc(%ebx),%eax
c002b7dc:	50                   	push   %eax
c002b7dd:	e8 b6 f6 ff ff       	call   c002ae98 <msg>
  thread_set_priority (PRI_DEFAULT - 1);
c002b7e2:	c7 04 24 1e 00 00 00 	movl   $0x1e,(%esp)
c002b7e9:	e8 1f 5f ff ff       	call   c002170d <thread_set_priority>
  msg ("Thread 2 exiting.");
c002b7ee:	8d 83 c2 67 ff ff    	lea    -0x983e(%ebx),%eax
c002b7f4:	89 04 24             	mov    %eax,(%esp)
c002b7f7:	e8 9c f6 ff ff       	call   c002ae98 <msg>
}
c002b7fc:	83 c4 18             	add    $0x18,%esp
c002b7ff:	5b                   	pop    %ebx
c002b800:	c3                   	ret    

c002b801 <test_priority_change>:
{
c002b801:	53                   	push   %ebx
c002b802:	83 ec 08             	sub    $0x8,%esp
c002b805:	e8 8d 20 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b80a:	81 c3 f6 ec 00 00    	add    $0xecf6,%ebx
  ASSERT (!thread_mlfqs);
c002b810:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002b816:	80 38 00             	cmpb   $0x0,(%eax)
c002b819:	75 54                	jne    c002b86f <test_priority_change+0x6e>
  msg ("Creating a high-priority thread 2.");
c002b81b:	83 ec 0c             	sub    $0xc,%esp
c002b81e:	8d 83 4c 67 ff ff    	lea    -0x98b4(%ebx),%eax
c002b824:	50                   	push   %eax
c002b825:	e8 6e f6 ff ff       	call   c002ae98 <msg>
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002b82a:	6a 00                	push   $0x0
c002b82c:	8d 83 c7 12 ff ff    	lea    -0xed39(%ebx),%eax
c002b832:	50                   	push   %eax
c002b833:	6a 20                	push   $0x20
c002b835:	8d 83 d4 67 ff ff    	lea    -0x982c(%ebx),%eax
c002b83b:	50                   	push   %eax
c002b83c:	e8 1b 5d ff ff       	call   c002155c <thread_create>
  msg ("Thread 2 should have just lowered its priority.");
c002b841:	83 c4 14             	add    $0x14,%esp
c002b844:	8d 83 70 67 ff ff    	lea    -0x9890(%ebx),%eax
c002b84a:	50                   	push   %eax
c002b84b:	e8 48 f6 ff ff       	call   c002ae98 <msg>
  thread_set_priority (PRI_DEFAULT - 2);
c002b850:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
c002b857:	e8 b1 5e ff ff       	call   c002170d <thread_set_priority>
  msg ("Thread 2 should have just exited.");
c002b85c:	8d 83 a0 67 ff ff    	lea    -0x9860(%ebx),%eax
c002b862:	89 04 24             	mov    %eax,(%esp)
c002b865:	e8 2e f6 ff ff       	call   c002ae98 <msg>
}
c002b86a:	83 c4 18             	add    $0x18,%esp
c002b86d:	5b                   	pop    %ebx
c002b86e:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b86f:	83 ec 0c             	sub    $0xc,%esp
c002b872:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002b878:	50                   	push   %eax
c002b879:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002b87f:	50                   	push   %eax
c002b880:	8d 83 7c 42 ff ff    	lea    -0xbd84(%ebx),%eax
c002b886:	50                   	push   %eax
c002b887:	6a 10                	push   $0x10
c002b889:	8d 83 24 67 ff ff    	lea    -0x98dc(%ebx),%eax
c002b88f:	50                   	push   %eax
c002b890:	e8 4f d6 ff ff       	call   c0028ee4 <debug_panic>

c002b895 <acquire2_thread_func>:
  msg ("acquire1: done");
}

static void
acquire2_thread_func (void *lock_) 
{
c002b895:	56                   	push   %esi
c002b896:	53                   	push   %ebx
c002b897:	83 ec 10             	sub    $0x10,%esp
c002b89a:	e8 f8 1f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b89f:	81 c3 61 ec 00 00    	add    $0xec61,%ebx
c002b8a5:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002b8a9:	56                   	push   %esi
c002b8aa:	e8 73 77 ff ff       	call   c0023022 <lock_acquire>
  msg ("acquire2: got the lock");
c002b8af:	8d 83 dd 67 ff ff    	lea    -0x9823(%ebx),%eax
c002b8b5:	89 04 24             	mov    %eax,(%esp)
c002b8b8:	e8 db f5 ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002b8bd:	89 34 24             	mov    %esi,(%esp)
c002b8c0:	e8 5e 79 ff ff       	call   c0023223 <lock_release>
  msg ("acquire2: done");
c002b8c5:	8d 83 f4 67 ff ff    	lea    -0x980c(%ebx),%eax
c002b8cb:	89 04 24             	mov    %eax,(%esp)
c002b8ce:	e8 c5 f5 ff ff       	call   c002ae98 <msg>
}
c002b8d3:	83 c4 14             	add    $0x14,%esp
c002b8d6:	5b                   	pop    %ebx
c002b8d7:	5e                   	pop    %esi
c002b8d8:	c3                   	ret    

c002b8d9 <acquire1_thread_func>:
{
c002b8d9:	56                   	push   %esi
c002b8da:	53                   	push   %ebx
c002b8db:	83 ec 10             	sub    $0x10,%esp
c002b8de:	e8 b4 1f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b8e3:	81 c3 1d ec 00 00    	add    $0xec1d,%ebx
c002b8e9:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002b8ed:	56                   	push   %esi
c002b8ee:	e8 2f 77 ff ff       	call   c0023022 <lock_acquire>
  msg ("acquire1: got the lock");
c002b8f3:	8d 83 03 68 ff ff    	lea    -0x97fd(%ebx),%eax
c002b8f9:	89 04 24             	mov    %eax,(%esp)
c002b8fc:	e8 97 f5 ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002b901:	89 34 24             	mov    %esi,(%esp)
c002b904:	e8 1a 79 ff ff       	call   c0023223 <lock_release>
  msg ("acquire1: done");
c002b909:	8d 83 1a 68 ff ff    	lea    -0x97e6(%ebx),%eax
c002b90f:	89 04 24             	mov    %eax,(%esp)
c002b912:	e8 81 f5 ff ff       	call   c002ae98 <msg>
}
c002b917:	83 c4 14             	add    $0x14,%esp
c002b91a:	5b                   	pop    %ebx
c002b91b:	5e                   	pop    %esi
c002b91c:	c3                   	ret    

c002b91d <test_priority_donate_one>:
{
c002b91d:	57                   	push   %edi
c002b91e:	56                   	push   %esi
c002b91f:	53                   	push   %ebx
c002b920:	83 ec 30             	sub    $0x30,%esp
c002b923:	e8 6f 1f 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002b928:	81 c3 d8 eb 00 00    	add    $0xebd8,%ebx
  ASSERT (!thread_mlfqs);
c002b92e:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002b934:	80 38 00             	cmpb   $0x0,(%eax)
c002b937:	0f 85 a8 00 00 00    	jne    c002b9e5 <test_priority_donate_one+0xc8>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002b93d:	e8 fb 55 ff ff       	call   c0020f3d <thread_get_priority>
c002b942:	83 f8 1f             	cmp    $0x1f,%eax
c002b945:	0f 85 c0 00 00 00    	jne    c002ba0b <test_priority_donate_one+0xee>
  lock_init (&lock);
c002b94b:	83 ec 0c             	sub    $0xc,%esp
c002b94e:	8d 74 24 18          	lea    0x18(%esp),%esi
c002b952:	56                   	push   %esi
c002b953:	e8 1e 76 ff ff       	call   c0022f76 <lock_init>
  lock_acquire (&lock);
c002b958:	89 34 24             	mov    %esi,(%esp)
c002b95b:	e8 c2 76 ff ff       	call   c0023022 <lock_acquire>
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002b960:	56                   	push   %esi
c002b961:	8d 83 d9 13 ff ff    	lea    -0xec27(%ebx),%eax
c002b967:	50                   	push   %eax
c002b968:	6a 20                	push   $0x20
c002b96a:	8d 83 29 68 ff ff    	lea    -0x97d7(%ebx),%eax
c002b970:	50                   	push   %eax
c002b971:	e8 e6 5b ff ff       	call   c002155c <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002b976:	83 c4 20             	add    $0x20,%esp
c002b979:	e8 bf 55 ff ff       	call   c0020f3d <thread_get_priority>
c002b97e:	83 ec 04             	sub    $0x4,%esp
c002b981:	50                   	push   %eax
c002b982:	6a 20                	push   $0x20
c002b984:	8d bb 90 68 ff ff    	lea    -0x9770(%ebx),%edi
c002b98a:	57                   	push   %edi
c002b98b:	e8 08 f5 ff ff       	call   c002ae98 <msg>
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002b990:	56                   	push   %esi
c002b991:	8d 83 95 13 ff ff    	lea    -0xec6b(%ebx),%eax
c002b997:	50                   	push   %eax
c002b998:	6a 21                	push   $0x21
c002b99a:	8d 83 32 68 ff ff    	lea    -0x97ce(%ebx),%eax
c002b9a0:	50                   	push   %eax
c002b9a1:	e8 b6 5b ff ff       	call   c002155c <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002b9a6:	83 c4 20             	add    $0x20,%esp
c002b9a9:	e8 8f 55 ff ff       	call   c0020f3d <thread_get_priority>
c002b9ae:	83 ec 04             	sub    $0x4,%esp
c002b9b1:	50                   	push   %eax
c002b9b2:	6a 21                	push   $0x21
c002b9b4:	57                   	push   %edi
c002b9b5:	e8 de f4 ff ff       	call   c002ae98 <msg>
  lock_release (&lock);
c002b9ba:	89 34 24             	mov    %esi,(%esp)
c002b9bd:	e8 61 78 ff ff       	call   c0023223 <lock_release>
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002b9c2:	8d 83 cc 68 ff ff    	lea    -0x9734(%ebx),%eax
c002b9c8:	89 04 24             	mov    %eax,(%esp)
c002b9cb:	e8 c8 f4 ff ff       	call   c002ae98 <msg>
  msg ("This should be the last line before finishing this test.");
c002b9d0:	8d 83 0c 69 ff ff    	lea    -0x96f4(%ebx),%eax
c002b9d6:	89 04 24             	mov    %eax,(%esp)
c002b9d9:	e8 ba f4 ff ff       	call   c002ae98 <msg>
}
c002b9de:	83 c4 40             	add    $0x40,%esp
c002b9e1:	5b                   	pop    %ebx
c002b9e2:	5e                   	pop    %esi
c002b9e3:	5f                   	pop    %edi
c002b9e4:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b9e5:	83 ec 0c             	sub    $0xc,%esp
c002b9e8:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002b9ee:	50                   	push   %eax
c002b9ef:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002b9f5:	50                   	push   %eax
c002b9f6:	8d 83 94 42 ff ff    	lea    -0xbd6c(%ebx),%eax
c002b9fc:	50                   	push   %eax
c002b9fd:	6a 1b                	push   $0x1b
c002b9ff:	8d 83 3c 68 ff ff    	lea    -0x97c4(%ebx),%eax
c002ba05:	50                   	push   %eax
c002ba06:	e8 d9 d4 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ba0b:	83 ec 0c             	sub    $0xc,%esp
c002ba0e:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002ba14:	50                   	push   %eax
c002ba15:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002ba1b:	50                   	push   %eax
c002ba1c:	8d 83 94 42 ff ff    	lea    -0xbd6c(%ebx),%eax
c002ba22:	50                   	push   %eax
c002ba23:	6a 1e                	push   $0x1e
c002ba25:	8d 83 3c 68 ff ff    	lea    -0x97c4(%ebx),%eax
c002ba2b:	50                   	push   %eax
c002ba2c:	e8 b3 d4 ff ff       	call   c0028ee4 <debug_panic>

c002ba31 <b_thread_func>:
  msg ("Thread a finished.");
}

static void
b_thread_func (void *lock_) 
{
c002ba31:	56                   	push   %esi
c002ba32:	53                   	push   %ebx
c002ba33:	83 ec 10             	sub    $0x10,%esp
c002ba36:	e8 5c 1e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ba3b:	81 c3 c5 ea 00 00    	add    $0xeac5,%ebx
c002ba41:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002ba45:	56                   	push   %esi
c002ba46:	e8 d7 75 ff ff       	call   c0023022 <lock_acquire>
  msg ("Thread b acquired lock b.");
c002ba4b:	8d 83 45 69 ff ff    	lea    -0x96bb(%ebx),%eax
c002ba51:	89 04 24             	mov    %eax,(%esp)
c002ba54:	e8 3f f4 ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002ba59:	89 34 24             	mov    %esi,(%esp)
c002ba5c:	e8 c2 77 ff ff       	call   c0023223 <lock_release>
  msg ("Thread b finished.");
c002ba61:	8d 83 5f 69 ff ff    	lea    -0x96a1(%ebx),%eax
c002ba67:	89 04 24             	mov    %eax,(%esp)
c002ba6a:	e8 29 f4 ff ff       	call   c002ae98 <msg>
}
c002ba6f:	83 c4 14             	add    $0x14,%esp
c002ba72:	5b                   	pop    %ebx
c002ba73:	5e                   	pop    %esi
c002ba74:	c3                   	ret    

c002ba75 <a_thread_func>:
{
c002ba75:	56                   	push   %esi
c002ba76:	53                   	push   %ebx
c002ba77:	83 ec 10             	sub    $0x10,%esp
c002ba7a:	e8 18 1e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ba7f:	81 c3 81 ea 00 00    	add    $0xea81,%ebx
c002ba85:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002ba89:	56                   	push   %esi
c002ba8a:	e8 93 75 ff ff       	call   c0023022 <lock_acquire>
  msg ("Thread a acquired lock a.");
c002ba8f:	8d 83 72 69 ff ff    	lea    -0x968e(%ebx),%eax
c002ba95:	89 04 24             	mov    %eax,(%esp)
c002ba98:	e8 fb f3 ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002ba9d:	89 34 24             	mov    %esi,(%esp)
c002baa0:	e8 7e 77 ff ff       	call   c0023223 <lock_release>
  msg ("Thread a finished.");
c002baa5:	8d 83 8c 69 ff ff    	lea    -0x9674(%ebx),%eax
c002baab:	89 04 24             	mov    %eax,(%esp)
c002baae:	e8 e5 f3 ff ff       	call   c002ae98 <msg>
}
c002bab3:	83 c4 14             	add    $0x14,%esp
c002bab6:	5b                   	pop    %ebx
c002bab7:	5e                   	pop    %esi
c002bab8:	c3                   	ret    

c002bab9 <test_priority_donate_multiple>:
{
c002bab9:	55                   	push   %ebp
c002baba:	57                   	push   %edi
c002babb:	56                   	push   %esi
c002babc:	53                   	push   %ebx
c002babd:	83 ec 5c             	sub    $0x5c,%esp
c002bac0:	e8 d2 1d 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002bac5:	81 c3 3b ea 00 00    	add    $0xea3b,%ebx
  ASSERT (!thread_mlfqs);
c002bacb:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002bad1:	80 38 00             	cmpb   $0x0,(%eax)
c002bad4:	0f 85 e8 00 00 00    	jne    c002bbc2 <test_priority_donate_multiple+0x109>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bada:	e8 5e 54 ff ff       	call   c0020f3d <thread_get_priority>
c002badf:	83 f8 1f             	cmp    $0x1f,%eax
c002bae2:	0f 85 00 01 00 00    	jne    c002bbe8 <test_priority_donate_multiple+0x12f>
  lock_init (&a);
c002bae8:	83 ec 0c             	sub    $0xc,%esp
c002baeb:	8d 7c 24 38          	lea    0x38(%esp),%edi
c002baef:	57                   	push   %edi
c002baf0:	e8 81 74 ff ff       	call   c0022f76 <lock_init>
  lock_init (&b);
c002baf5:	83 c4 04             	add    $0x4,%esp
c002baf8:	8d 6c 24 14          	lea    0x14(%esp),%ebp
c002bafc:	55                   	push   %ebp
c002bafd:	e8 74 74 ff ff       	call   c0022f76 <lock_init>
  lock_acquire (&a);
c002bb02:	89 3c 24             	mov    %edi,(%esp)
c002bb05:	e8 18 75 ff ff       	call   c0023022 <lock_acquire>
  lock_acquire (&b);
c002bb0a:	89 2c 24             	mov    %ebp,(%esp)
c002bb0d:	e8 10 75 ff ff       	call   c0023022 <lock_acquire>
  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002bb12:	57                   	push   %edi
c002bb13:	8d 83 75 15 ff ff    	lea    -0xea8b(%ebx),%eax
c002bb19:	50                   	push   %eax
c002bb1a:	6a 20                	push   $0x20
c002bb1c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bb22:	50                   	push   %eax
c002bb23:	e8 34 5a ff ff       	call   c002155c <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bb28:	83 c4 20             	add    $0x20,%esp
c002bb2b:	e8 0d 54 ff ff       	call   c0020f3d <thread_get_priority>
c002bb30:	83 ec 04             	sub    $0x4,%esp
c002bb33:	50                   	push   %eax
c002bb34:	6a 20                	push   $0x20
c002bb36:	8d b3 d0 69 ff ff    	lea    -0x9630(%ebx),%esi
c002bb3c:	56                   	push   %esi
c002bb3d:	e8 56 f3 ff ff       	call   c002ae98 <msg>
  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002bb42:	55                   	push   %ebp
c002bb43:	8d 83 31 15 ff ff    	lea    -0xeacf(%ebx),%eax
c002bb49:	50                   	push   %eax
c002bb4a:	6a 21                	push   $0x21
c002bb4c:	8d 83 27 5f ff ff    	lea    -0xa0d9(%ebx),%eax
c002bb52:	50                   	push   %eax
c002bb53:	e8 04 5a ff ff       	call   c002155c <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bb58:	83 c4 20             	add    $0x20,%esp
c002bb5b:	e8 dd 53 ff ff       	call   c0020f3d <thread_get_priority>
c002bb60:	83 ec 04             	sub    $0x4,%esp
c002bb63:	50                   	push   %eax
c002bb64:	6a 21                	push   $0x21
c002bb66:	56                   	push   %esi
c002bb67:	e8 2c f3 ff ff       	call   c002ae98 <msg>
  lock_release (&b);
c002bb6c:	89 2c 24             	mov    %ebp,(%esp)
c002bb6f:	e8 af 76 ff ff       	call   c0023223 <lock_release>
  msg ("Thread b should have just finished.");
c002bb74:	8d 83 0c 6a ff ff    	lea    -0x95f4(%ebx),%eax
c002bb7a:	89 04 24             	mov    %eax,(%esp)
c002bb7d:	e8 16 f3 ff ff       	call   c002ae98 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bb82:	e8 b6 53 ff ff       	call   c0020f3d <thread_get_priority>
c002bb87:	83 c4 0c             	add    $0xc,%esp
c002bb8a:	50                   	push   %eax
c002bb8b:	6a 20                	push   $0x20
c002bb8d:	56                   	push   %esi
c002bb8e:	e8 05 f3 ff ff       	call   c002ae98 <msg>
  lock_release (&a);
c002bb93:	89 3c 24             	mov    %edi,(%esp)
c002bb96:	e8 88 76 ff ff       	call   c0023223 <lock_release>
  msg ("Thread a should have just finished.");
c002bb9b:	8d 83 30 6a ff ff    	lea    -0x95d0(%ebx),%eax
c002bba1:	89 04 24             	mov    %eax,(%esp)
c002bba4:	e8 ef f2 ff ff       	call   c002ae98 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bba9:	e8 8f 53 ff ff       	call   c0020f3d <thread_get_priority>
c002bbae:	83 c4 0c             	add    $0xc,%esp
c002bbb1:	50                   	push   %eax
c002bbb2:	6a 1f                	push   $0x1f
c002bbb4:	56                   	push   %esi
c002bbb5:	e8 de f2 ff ff       	call   c002ae98 <msg>
}
c002bbba:	83 c4 6c             	add    $0x6c,%esp
c002bbbd:	5b                   	pop    %ebx
c002bbbe:	5e                   	pop    %esi
c002bbbf:	5f                   	pop    %edi
c002bbc0:	5d                   	pop    %ebp
c002bbc1:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002bbc2:	83 ec 0c             	sub    $0xc,%esp
c002bbc5:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002bbcb:	50                   	push   %eax
c002bbcc:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002bbd2:	50                   	push   %eax
c002bbd3:	8d 83 b0 42 ff ff    	lea    -0xbd50(%ebx),%eax
c002bbd9:	50                   	push   %eax
c002bbda:	6a 1b                	push   $0x1b
c002bbdc:	8d 83 a0 69 ff ff    	lea    -0x9660(%ebx),%eax
c002bbe2:	50                   	push   %eax
c002bbe3:	e8 fc d2 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bbe8:	83 ec 0c             	sub    $0xc,%esp
c002bbeb:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002bbf1:	50                   	push   %eax
c002bbf2:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002bbf8:	50                   	push   %eax
c002bbf9:	8d 83 b0 42 ff ff    	lea    -0xbd50(%ebx),%eax
c002bbff:	50                   	push   %eax
c002bc00:	6a 1e                	push   $0x1e
c002bc02:	8d 83 a0 69 ff ff    	lea    -0x9660(%ebx),%eax
c002bc08:	50                   	push   %eax
c002bc09:	e8 d6 d2 ff ff       	call   c0028ee4 <debug_panic>

c002bc0e <c_thread_func>:
  msg ("Thread b finished.");
}

static void
c_thread_func (void *a_ UNUSED) 
{
c002bc0e:	53                   	push   %ebx
c002bc0f:	83 ec 14             	sub    $0x14,%esp
c002bc12:	e8 80 1c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002bc17:	81 c3 e9 e8 00 00    	add    $0xe8e9,%ebx
  msg ("Thread c finished.");
c002bc1d:	8d 83 54 6a ff ff    	lea    -0x95ac(%ebx),%eax
c002bc23:	50                   	push   %eax
c002bc24:	e8 6f f2 ff ff       	call   c002ae98 <msg>
}
c002bc29:	83 c4 18             	add    $0x18,%esp
c002bc2c:	5b                   	pop    %ebx
c002bc2d:	c3                   	ret    

c002bc2e <b_thread_func>:
{
c002bc2e:	56                   	push   %esi
c002bc2f:	53                   	push   %ebx
c002bc30:	83 ec 10             	sub    $0x10,%esp
c002bc33:	e8 5f 1c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002bc38:	81 c3 c8 e8 00 00    	add    $0xe8c8,%ebx
c002bc3e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002bc42:	56                   	push   %esi
c002bc43:	e8 da 73 ff ff       	call   c0023022 <lock_acquire>
  msg ("Thread b acquired lock b.");
c002bc48:	8d 83 45 69 ff ff    	lea    -0x96bb(%ebx),%eax
c002bc4e:	89 04 24             	mov    %eax,(%esp)
c002bc51:	e8 42 f2 ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002bc56:	89 34 24             	mov    %esi,(%esp)
c002bc59:	e8 c5 75 ff ff       	call   c0023223 <lock_release>
  msg ("Thread b finished.");
c002bc5e:	8d 83 5f 69 ff ff    	lea    -0x96a1(%ebx),%eax
c002bc64:	89 04 24             	mov    %eax,(%esp)
c002bc67:	e8 2c f2 ff ff       	call   c002ae98 <msg>
}
c002bc6c:	83 c4 14             	add    $0x14,%esp
c002bc6f:	5b                   	pop    %ebx
c002bc70:	5e                   	pop    %esi
c002bc71:	c3                   	ret    

c002bc72 <a_thread_func>:
{
c002bc72:	56                   	push   %esi
c002bc73:	53                   	push   %ebx
c002bc74:	83 ec 10             	sub    $0x10,%esp
c002bc77:	e8 1b 1c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002bc7c:	81 c3 84 e8 00 00    	add    $0xe884,%ebx
c002bc82:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002bc86:	56                   	push   %esi
c002bc87:	e8 96 73 ff ff       	call   c0023022 <lock_acquire>
  msg ("Thread a acquired lock a.");
c002bc8c:	8d 83 72 69 ff ff    	lea    -0x968e(%ebx),%eax
c002bc92:	89 04 24             	mov    %eax,(%esp)
c002bc95:	e8 fe f1 ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002bc9a:	89 34 24             	mov    %esi,(%esp)
c002bc9d:	e8 81 75 ff ff       	call   c0023223 <lock_release>
  msg ("Thread a finished.");
c002bca2:	8d 83 8c 69 ff ff    	lea    -0x9674(%ebx),%eax
c002bca8:	89 04 24             	mov    %eax,(%esp)
c002bcab:	e8 e8 f1 ff ff       	call   c002ae98 <msg>
}
c002bcb0:	83 c4 14             	add    $0x14,%esp
c002bcb3:	5b                   	pop    %ebx
c002bcb4:	5e                   	pop    %esi
c002bcb5:	c3                   	ret    

c002bcb6 <test_priority_donate_multiple2>:
{
c002bcb6:	55                   	push   %ebp
c002bcb7:	57                   	push   %edi
c002bcb8:	56                   	push   %esi
c002bcb9:	53                   	push   %ebx
c002bcba:	83 ec 5c             	sub    $0x5c,%esp
c002bcbd:	e8 d5 1b 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002bcc2:	81 c3 3e e8 00 00    	add    $0xe83e,%ebx
  ASSERT (!thread_mlfqs);
c002bcc8:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002bcce:	80 38 00             	cmpb   $0x0,(%eax)
c002bcd1:	0f 85 f1 00 00 00    	jne    c002bdc8 <test_priority_donate_multiple2+0x112>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bcd7:	e8 61 52 ff ff       	call   c0020f3d <thread_get_priority>
c002bcdc:	83 f8 1f             	cmp    $0x1f,%eax
c002bcdf:	0f 85 09 01 00 00    	jne    c002bdee <test_priority_donate_multiple2+0x138>
  lock_init (&a);
c002bce5:	83 ec 0c             	sub    $0xc,%esp
c002bce8:	8d 6c 24 38          	lea    0x38(%esp),%ebp
c002bcec:	55                   	push   %ebp
c002bced:	e8 84 72 ff ff       	call   c0022f76 <lock_init>
  lock_init (&b);
c002bcf2:	83 c4 04             	add    $0x4,%esp
c002bcf5:	8d 7c 24 14          	lea    0x14(%esp),%edi
c002bcf9:	57                   	push   %edi
c002bcfa:	e8 77 72 ff ff       	call   c0022f76 <lock_init>
  lock_acquire (&a);
c002bcff:	89 2c 24             	mov    %ebp,(%esp)
c002bd02:	e8 1b 73 ff ff       	call   c0023022 <lock_acquire>
  lock_acquire (&b);
c002bd07:	89 3c 24             	mov    %edi,(%esp)
c002bd0a:	e8 13 73 ff ff       	call   c0023022 <lock_acquire>
  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002bd0f:	55                   	push   %ebp
c002bd10:	8d 83 72 17 ff ff    	lea    -0xe88e(%ebx),%eax
c002bd16:	50                   	push   %eax
c002bd17:	6a 22                	push   $0x22
c002bd19:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bd1f:	50                   	push   %eax
c002bd20:	e8 37 58 ff ff       	call   c002155c <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bd25:	83 c4 20             	add    $0x20,%esp
c002bd28:	e8 10 52 ff ff       	call   c0020f3d <thread_get_priority>
c002bd2d:	83 ec 04             	sub    $0x4,%esp
c002bd30:	50                   	push   %eax
c002bd31:	6a 22                	push   $0x22
c002bd33:	8d b3 d0 69 ff ff    	lea    -0x9630(%ebx),%esi
c002bd39:	56                   	push   %esi
c002bd3a:	e8 59 f1 ff ff       	call   c002ae98 <msg>
  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002bd3f:	6a 00                	push   $0x0
c002bd41:	8d 83 0e 17 ff ff    	lea    -0xe8f2(%ebx),%eax
c002bd47:	50                   	push   %eax
c002bd48:	6a 20                	push   $0x20
c002bd4a:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c002bd50:	50                   	push   %eax
c002bd51:	e8 06 58 ff ff       	call   c002155c <thread_create>
  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002bd56:	83 c4 20             	add    $0x20,%esp
c002bd59:	57                   	push   %edi
c002bd5a:	8d 83 2e 17 ff ff    	lea    -0xe8d2(%ebx),%eax
c002bd60:	50                   	push   %eax
c002bd61:	6a 24                	push   $0x24
c002bd63:	8d 83 27 5f ff ff    	lea    -0xa0d9(%ebx),%eax
c002bd69:	50                   	push   %eax
c002bd6a:	e8 ed 57 ff ff       	call   c002155c <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bd6f:	e8 c9 51 ff ff       	call   c0020f3d <thread_get_priority>
c002bd74:	83 c4 0c             	add    $0xc,%esp
c002bd77:	50                   	push   %eax
c002bd78:	6a 24                	push   $0x24
c002bd7a:	56                   	push   %esi
c002bd7b:	e8 18 f1 ff ff       	call   c002ae98 <msg>
  lock_release (&a);
c002bd80:	89 2c 24             	mov    %ebp,(%esp)
c002bd83:	e8 9b 74 ff ff       	call   c0023223 <lock_release>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bd88:	e8 b0 51 ff ff       	call   c0020f3d <thread_get_priority>
c002bd8d:	83 c4 0c             	add    $0xc,%esp
c002bd90:	50                   	push   %eax
c002bd91:	6a 24                	push   $0x24
c002bd93:	56                   	push   %esi
c002bd94:	e8 ff f0 ff ff       	call   c002ae98 <msg>
  lock_release (&b);
c002bd99:	89 3c 24             	mov    %edi,(%esp)
c002bd9c:	e8 82 74 ff ff       	call   c0023223 <lock_release>
  msg ("Threads b, a, c should have just finished, in that order.");
c002bda1:	8d 83 98 6a ff ff    	lea    -0x9568(%ebx),%eax
c002bda7:	89 04 24             	mov    %eax,(%esp)
c002bdaa:	e8 e9 f0 ff ff       	call   c002ae98 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bdaf:	e8 89 51 ff ff       	call   c0020f3d <thread_get_priority>
c002bdb4:	83 c4 0c             	add    $0xc,%esp
c002bdb7:	50                   	push   %eax
c002bdb8:	6a 1f                	push   $0x1f
c002bdba:	56                   	push   %esi
c002bdbb:	e8 d8 f0 ff ff       	call   c002ae98 <msg>
}
c002bdc0:	83 c4 6c             	add    $0x6c,%esp
c002bdc3:	5b                   	pop    %ebx
c002bdc4:	5e                   	pop    %esi
c002bdc5:	5f                   	pop    %edi
c002bdc6:	5d                   	pop    %ebp
c002bdc7:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002bdc8:	83 ec 0c             	sub    $0xc,%esp
c002bdcb:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002bdd1:	50                   	push   %eax
c002bdd2:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002bdd8:	50                   	push   %eax
c002bdd9:	8d 83 d0 42 ff ff    	lea    -0xbd30(%ebx),%eax
c002bddf:	50                   	push   %eax
c002bde0:	6a 21                	push   $0x21
c002bde2:	8d 83 68 6a ff ff    	lea    -0x9598(%ebx),%eax
c002bde8:	50                   	push   %eax
c002bde9:	e8 f6 d0 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bdee:	83 ec 0c             	sub    $0xc,%esp
c002bdf1:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002bdf7:	50                   	push   %eax
c002bdf8:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002bdfe:	50                   	push   %eax
c002bdff:	8d 83 d0 42 ff ff    	lea    -0xbd30(%ebx),%eax
c002be05:	50                   	push   %eax
c002be06:	6a 24                	push   $0x24
c002be08:	8d 83 68 6a ff ff    	lea    -0x9598(%ebx),%eax
c002be0e:	50                   	push   %eax
c002be0f:	e8 d0 d0 ff ff       	call   c0028ee4 <debug_panic>

c002be14 <high_thread_func>:
  msg ("Middle thread finished.");
}

static void
high_thread_func (void *lock_) 
{
c002be14:	56                   	push   %esi
c002be15:	53                   	push   %ebx
c002be16:	83 ec 10             	sub    $0x10,%esp
c002be19:	e8 79 1a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002be1e:	81 c3 e2 e6 00 00    	add    $0xe6e2,%ebx
c002be24:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002be28:	56                   	push   %esi
c002be29:	e8 f4 71 ff ff       	call   c0023022 <lock_acquire>
  msg ("High thread got the lock.");
c002be2e:	8d 83 d2 6a ff ff    	lea    -0x952e(%ebx),%eax
c002be34:	89 04 24             	mov    %eax,(%esp)
c002be37:	e8 5c f0 ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002be3c:	89 34 24             	mov    %esi,(%esp)
c002be3f:	e8 df 73 ff ff       	call   c0023223 <lock_release>
  msg ("High thread finished.");
c002be44:	8d 83 ec 6a ff ff    	lea    -0x9514(%ebx),%eax
c002be4a:	89 04 24             	mov    %eax,(%esp)
c002be4d:	e8 46 f0 ff ff       	call   c002ae98 <msg>
}
c002be52:	83 c4 14             	add    $0x14,%esp
c002be55:	5b                   	pop    %ebx
c002be56:	5e                   	pop    %esi
c002be57:	c3                   	ret    

c002be58 <medium_thread_func>:
{
c002be58:	56                   	push   %esi
c002be59:	53                   	push   %ebx
c002be5a:	83 ec 10             	sub    $0x10,%esp
c002be5d:	e8 35 1a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002be62:	81 c3 9e e6 00 00    	add    $0xe69e,%ebx
c002be68:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (locks->b);
c002be6c:	ff 76 04             	pushl  0x4(%esi)
c002be6f:	e8 ae 71 ff ff       	call   c0023022 <lock_acquire>
  lock_acquire (locks->a);
c002be74:	83 c4 04             	add    $0x4,%esp
c002be77:	ff 36                	pushl  (%esi)
c002be79:	e8 a4 71 ff ff       	call   c0023022 <lock_acquire>
  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002be7e:	e8 ba 50 ff ff       	call   c0020f3d <thread_get_priority>
c002be83:	83 c4 0c             	add    $0xc,%esp
c002be86:	50                   	push   %eax
c002be87:	6a 21                	push   $0x21
c002be89:	8d 83 44 6b ff ff    	lea    -0x94bc(%ebx),%eax
c002be8f:	50                   	push   %eax
c002be90:	e8 03 f0 ff ff       	call   c002ae98 <msg>
  msg ("Medium thread got the lock.");
c002be95:	8d 83 02 6b ff ff    	lea    -0x94fe(%ebx),%eax
c002be9b:	89 04 24             	mov    %eax,(%esp)
c002be9e:	e8 f5 ef ff ff       	call   c002ae98 <msg>
  lock_release (locks->a);
c002bea3:	83 c4 04             	add    $0x4,%esp
c002bea6:	ff 36                	pushl  (%esi)
c002bea8:	e8 76 73 ff ff       	call   c0023223 <lock_release>
  thread_yield ();
c002bead:	e8 19 56 ff ff       	call   c00214cb <thread_yield>
  lock_release (locks->b);
c002beb2:	83 c4 04             	add    $0x4,%esp
c002beb5:	ff 76 04             	pushl  0x4(%esi)
c002beb8:	e8 66 73 ff ff       	call   c0023223 <lock_release>
  thread_yield ();
c002bebd:	e8 09 56 ff ff       	call   c00214cb <thread_yield>
  msg ("High thread should have just finished.");
c002bec2:	8d 83 84 6b ff ff    	lea    -0x947c(%ebx),%eax
c002bec8:	89 04 24             	mov    %eax,(%esp)
c002becb:	e8 c8 ef ff ff       	call   c002ae98 <msg>
  msg ("Middle thread finished.");
c002bed0:	8d 83 1e 6b ff ff    	lea    -0x94e2(%ebx),%eax
c002bed6:	89 04 24             	mov    %eax,(%esp)
c002bed9:	e8 ba ef ff ff       	call   c002ae98 <msg>
}
c002bede:	83 c4 14             	add    $0x14,%esp
c002bee1:	5b                   	pop    %ebx
c002bee2:	5e                   	pop    %esi
c002bee3:	c3                   	ret    

c002bee4 <test_priority_donate_nest>:
{
c002bee4:	55                   	push   %ebp
c002bee5:	57                   	push   %edi
c002bee6:	56                   	push   %esi
c002bee7:	53                   	push   %ebx
c002bee8:	83 ec 5c             	sub    $0x5c,%esp
c002beeb:	e8 a7 19 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002bef0:	81 c3 10 e6 00 00    	add    $0xe610,%ebx
  ASSERT (!thread_mlfqs);
c002bef6:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002befc:	80 38 00             	cmpb   $0x0,(%eax)
c002beff:	0f 85 d4 00 00 00    	jne    c002bfd9 <test_priority_donate_nest+0xf5>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bf05:	e8 33 50 ff ff       	call   c0020f3d <thread_get_priority>
c002bf0a:	83 f8 1f             	cmp    $0x1f,%eax
c002bf0d:	0f 85 ec 00 00 00    	jne    c002bfff <test_priority_donate_nest+0x11b>
  lock_init (&a);
c002bf13:	83 ec 0c             	sub    $0xc,%esp
c002bf16:	8d 74 24 38          	lea    0x38(%esp),%esi
c002bf1a:	56                   	push   %esi
c002bf1b:	e8 56 70 ff ff       	call   c0022f76 <lock_init>
  lock_init (&b);
c002bf20:	83 c4 04             	add    $0x4,%esp
c002bf23:	8d 6c 24 14          	lea    0x14(%esp),%ebp
c002bf27:	55                   	push   %ebp
c002bf28:	e8 49 70 ff ff       	call   c0022f76 <lock_init>
  lock_acquire (&a);
c002bf2d:	89 34 24             	mov    %esi,(%esp)
c002bf30:	e8 ed 70 ff ff       	call   c0023022 <lock_acquire>
  locks.a = &a;
c002bf35:	89 74 24 10          	mov    %esi,0x10(%esp)
  locks.b = &b;
c002bf39:	89 6c 24 14          	mov    %ebp,0x14(%esp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002bf3d:	8d 44 24 10          	lea    0x10(%esp),%eax
c002bf41:	50                   	push   %eax
c002bf42:	8d 83 58 19 ff ff    	lea    -0xe6a8(%ebx),%eax
c002bf48:	50                   	push   %eax
c002bf49:	6a 20                	push   $0x20
c002bf4b:	8d 83 36 6b ff ff    	lea    -0x94ca(%ebx),%eax
c002bf51:	50                   	push   %eax
c002bf52:	e8 05 56 ff ff       	call   c002155c <thread_create>
  thread_yield ();
c002bf57:	83 c4 20             	add    $0x20,%esp
c002bf5a:	e8 6c 55 ff ff       	call   c00214cb <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002bf5f:	e8 d9 4f ff ff       	call   c0020f3d <thread_get_priority>
c002bf64:	83 ec 04             	sub    $0x4,%esp
c002bf67:	50                   	push   %eax
c002bf68:	6a 20                	push   $0x20
c002bf6a:	8d bb d8 6b ff ff    	lea    -0x9428(%ebx),%edi
c002bf70:	57                   	push   %edi
c002bf71:	e8 22 ef ff ff       	call   c002ae98 <msg>
  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002bf76:	55                   	push   %ebp
c002bf77:	8d 83 14 19 ff ff    	lea    -0xe6ec(%ebx),%eax
c002bf7d:	50                   	push   %eax
c002bf7e:	6a 21                	push   $0x21
c002bf80:	8d 83 3d 6b ff ff    	lea    -0x94c3(%ebx),%eax
c002bf86:	50                   	push   %eax
c002bf87:	e8 d0 55 ff ff       	call   c002155c <thread_create>
  thread_yield ();
c002bf8c:	83 c4 20             	add    $0x20,%esp
c002bf8f:	e8 37 55 ff ff       	call   c00214cb <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002bf94:	e8 a4 4f ff ff       	call   c0020f3d <thread_get_priority>
c002bf99:	83 ec 04             	sub    $0x4,%esp
c002bf9c:	50                   	push   %eax
c002bf9d:	6a 21                	push   $0x21
c002bf9f:	57                   	push   %edi
c002bfa0:	e8 f3 ee ff ff       	call   c002ae98 <msg>
  lock_release (&a);
c002bfa5:	89 34 24             	mov    %esi,(%esp)
c002bfa8:	e8 76 72 ff ff       	call   c0023223 <lock_release>
  thread_yield ();
c002bfad:	e8 19 55 ff ff       	call   c00214cb <thread_yield>
  msg ("Medium thread should just have finished.");
c002bfb2:	8d 83 14 6c ff ff    	lea    -0x93ec(%ebx),%eax
c002bfb8:	89 04 24             	mov    %eax,(%esp)
c002bfbb:	e8 d8 ee ff ff       	call   c002ae98 <msg>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002bfc0:	e8 78 4f ff ff       	call   c0020f3d <thread_get_priority>
c002bfc5:	83 c4 0c             	add    $0xc,%esp
c002bfc8:	50                   	push   %eax
c002bfc9:	6a 1f                	push   $0x1f
c002bfcb:	57                   	push   %edi
c002bfcc:	e8 c7 ee ff ff       	call   c002ae98 <msg>
}
c002bfd1:	83 c4 6c             	add    $0x6c,%esp
c002bfd4:	5b                   	pop    %ebx
c002bfd5:	5e                   	pop    %esi
c002bfd6:	5f                   	pop    %edi
c002bfd7:	5d                   	pop    %ebp
c002bfd8:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002bfd9:	83 ec 0c             	sub    $0xc,%esp
c002bfdc:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002bfe2:	50                   	push   %eax
c002bfe3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002bfe9:	50                   	push   %eax
c002bfea:	8d 83 f0 42 ff ff    	lea    -0xbd10(%ebx),%eax
c002bff0:	50                   	push   %eax
c002bff1:	6a 22                	push   $0x22
c002bff3:	8d 83 ac 6b ff ff    	lea    -0x9454(%ebx),%eax
c002bff9:	50                   	push   %eax
c002bffa:	e8 e5 ce ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bfff:	83 ec 0c             	sub    $0xc,%esp
c002c002:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002c008:	50                   	push   %eax
c002c009:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c00f:	50                   	push   %eax
c002c010:	8d 83 f0 42 ff ff    	lea    -0xbd10(%ebx),%eax
c002c016:	50                   	push   %eax
c002c017:	6a 25                	push   $0x25
c002c019:	8d 83 ac 6b ff ff    	lea    -0x9454(%ebx),%eax
c002c01f:	50                   	push   %eax
c002c020:	e8 bf ce ff ff       	call   c0028ee4 <debug_panic>

c002c025 <h_thread_func>:
  msg ("Thread M finished.");
}

static void
h_thread_func (void *ls_) 
{
c002c025:	56                   	push   %esi
c002c026:	53                   	push   %ebx
c002c027:	83 ec 10             	sub    $0x10,%esp
c002c02a:	e8 68 18 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c02f:	81 c3 d1 e4 00 00    	add    $0xe4d1,%ebx
c002c035:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock_and_sema *ls = ls_;

  lock_acquire (&ls->lock);
c002c039:	56                   	push   %esi
c002c03a:	e8 e3 6f ff ff       	call   c0023022 <lock_acquire>
  msg ("Thread H acquired lock.");
c002c03f:	8d 83 3d 6c ff ff    	lea    -0x93c3(%ebx),%eax
c002c045:	89 04 24             	mov    %eax,(%esp)
c002c048:	e8 4b ee ff ff       	call   c002ae98 <msg>

  sema_up (&ls->sema);
c002c04d:	8d 46 24             	lea    0x24(%esi),%eax
c002c050:	89 04 24             	mov    %eax,(%esp)
c002c053:	e8 c7 6d ff ff       	call   c0022e1f <sema_up>
  lock_release (&ls->lock);
c002c058:	89 34 24             	mov    %esi,(%esp)
c002c05b:	e8 c3 71 ff ff       	call   c0023223 <lock_release>
  msg ("Thread H finished.");
c002c060:	8d 83 55 6c ff ff    	lea    -0x93ab(%ebx),%eax
c002c066:	89 04 24             	mov    %eax,(%esp)
c002c069:	e8 2a ee ff ff       	call   c002ae98 <msg>
}
c002c06e:	83 c4 14             	add    $0x14,%esp
c002c071:	5b                   	pop    %ebx
c002c072:	5e                   	pop    %esi
c002c073:	c3                   	ret    

c002c074 <m_thread_func>:
{
c002c074:	53                   	push   %ebx
c002c075:	83 ec 14             	sub    $0x14,%esp
c002c078:	e8 1a 18 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c07d:	81 c3 83 e4 00 00    	add    $0xe483,%ebx
  sema_down (&ls->sema);
c002c083:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002c087:	83 c0 24             	add    $0x24,%eax
c002c08a:	50                   	push   %eax
c002c08b:	e8 64 6c ff ff       	call   c0022cf4 <sema_down>
  msg ("Thread M finished.");
c002c090:	8d 83 68 6c ff ff    	lea    -0x9398(%ebx),%eax
c002c096:	89 04 24             	mov    %eax,(%esp)
c002c099:	e8 fa ed ff ff       	call   c002ae98 <msg>
}
c002c09e:	83 c4 18             	add    $0x18,%esp
c002c0a1:	5b                   	pop    %ebx
c002c0a2:	c3                   	ret    

c002c0a3 <l_thread_func>:
{
c002c0a3:	56                   	push   %esi
c002c0a4:	53                   	push   %ebx
c002c0a5:	83 ec 10             	sub    $0x10,%esp
c002c0a8:	e8 ea 17 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c0ad:	81 c3 53 e4 00 00    	add    $0xe453,%ebx
c002c0b3:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (&ls->lock);
c002c0b7:	56                   	push   %esi
c002c0b8:	e8 65 6f ff ff       	call   c0023022 <lock_acquire>
  msg ("Thread L acquired lock.");
c002c0bd:	8d 83 7b 6c ff ff    	lea    -0x9385(%ebx),%eax
c002c0c3:	89 04 24             	mov    %eax,(%esp)
c002c0c6:	e8 cd ed ff ff       	call   c002ae98 <msg>
  sema_down (&ls->sema);
c002c0cb:	8d 46 24             	lea    0x24(%esi),%eax
c002c0ce:	89 04 24             	mov    %eax,(%esp)
c002c0d1:	e8 1e 6c ff ff       	call   c0022cf4 <sema_down>
  msg ("Thread L downed semaphore.");
c002c0d6:	8d 83 93 6c ff ff    	lea    -0x936d(%ebx),%eax
c002c0dc:	89 04 24             	mov    %eax,(%esp)
c002c0df:	e8 b4 ed ff ff       	call   c002ae98 <msg>
  lock_release (&ls->lock);
c002c0e4:	89 34 24             	mov    %esi,(%esp)
c002c0e7:	e8 37 71 ff ff       	call   c0023223 <lock_release>
  msg ("Thread L finished.");
c002c0ec:	8d 83 ae 6c ff ff    	lea    -0x9352(%ebx),%eax
c002c0f2:	89 04 24             	mov    %eax,(%esp)
c002c0f5:	e8 9e ed ff ff       	call   c002ae98 <msg>
}
c002c0fa:	83 c4 14             	add    $0x14,%esp
c002c0fd:	5b                   	pop    %ebx
c002c0fe:	5e                   	pop    %esi
c002c0ff:	c3                   	ret    

c002c100 <test_priority_donate_sema>:
{
c002c100:	57                   	push   %edi
c002c101:	56                   	push   %esi
c002c102:	53                   	push   %ebx
c002c103:	83 ec 40             	sub    $0x40,%esp
c002c106:	e8 8c 17 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c10b:	81 c3 f5 e3 00 00    	add    $0xe3f5,%ebx
  ASSERT (!thread_mlfqs);
c002c111:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002c117:	80 38 00             	cmpb   $0x0,(%eax)
c002c11a:	0f 85 8d 00 00 00    	jne    c002c1ad <test_priority_donate_sema+0xad>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c120:	e8 18 4e ff ff       	call   c0020f3d <thread_get_priority>
c002c125:	83 f8 1f             	cmp    $0x1f,%eax
c002c128:	0f 85 a5 00 00 00    	jne    c002c1d3 <test_priority_donate_sema+0xd3>
  lock_init (&ls.lock);
c002c12e:	83 ec 0c             	sub    $0xc,%esp
c002c131:	8d 74 24 14          	lea    0x14(%esp),%esi
c002c135:	56                   	push   %esi
c002c136:	e8 3b 6e ff ff       	call   c0022f76 <lock_init>
  sema_init (&ls.sema, 0);
c002c13b:	83 c4 08             	add    $0x8,%esp
c002c13e:	6a 00                	push   $0x0
c002c140:	8d 7c 24 38          	lea    0x38(%esp),%edi
c002c144:	57                   	push   %edi
c002c145:	e8 56 6b ff ff       	call   c0022ca0 <sema_init>
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002c14a:	56                   	push   %esi
c002c14b:	8d 83 a3 1b ff ff    	lea    -0xe45d(%ebx),%eax
c002c151:	50                   	push   %eax
c002c152:	6a 20                	push   $0x20
c002c154:	8d 83 c1 6c ff ff    	lea    -0x933f(%ebx),%eax
c002c15a:	50                   	push   %eax
c002c15b:	e8 fc 53 ff ff       	call   c002155c <thread_create>
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002c160:	83 c4 20             	add    $0x20,%esp
c002c163:	56                   	push   %esi
c002c164:	8d 83 74 1b ff ff    	lea    -0xe48c(%ebx),%eax
c002c16a:	50                   	push   %eax
c002c16b:	6a 22                	push   $0x22
c002c16d:	8d 83 c5 6c ff ff    	lea    -0x933b(%ebx),%eax
c002c173:	50                   	push   %eax
c002c174:	e8 e3 53 ff ff       	call   c002155c <thread_create>
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002c179:	56                   	push   %esi
c002c17a:	8d 83 25 1b ff ff    	lea    -0xe4db(%ebx),%eax
c002c180:	50                   	push   %eax
c002c181:	6a 24                	push   $0x24
c002c183:	8d 83 3d 6b ff ff    	lea    -0x94c3(%ebx),%eax
c002c189:	50                   	push   %eax
c002c18a:	e8 cd 53 ff ff       	call   c002155c <thread_create>
  sema_up (&ls.sema);
c002c18f:	83 c4 14             	add    $0x14,%esp
c002c192:	57                   	push   %edi
c002c193:	e8 87 6c ff ff       	call   c0022e1f <sema_up>
  msg ("Main thread finished.");
c002c198:	8d 83 c9 6c ff ff    	lea    -0x9337(%ebx),%eax
c002c19e:	89 04 24             	mov    %eax,(%esp)
c002c1a1:	e8 f2 ec ff ff       	call   c002ae98 <msg>
}
c002c1a6:	83 c4 50             	add    $0x50,%esp
c002c1a9:	5b                   	pop    %ebx
c002c1aa:	5e                   	pop    %esi
c002c1ab:	5f                   	pop    %edi
c002c1ac:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c1ad:	83 ec 0c             	sub    $0xc,%esp
c002c1b0:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002c1b6:	50                   	push   %eax
c002c1b7:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c1bd:	50                   	push   %eax
c002c1be:	8d 83 0c 43 ff ff    	lea    -0xbcf4(%ebx),%eax
c002c1c4:	50                   	push   %eax
c002c1c5:	6a 23                	push   $0x23
c002c1c7:	8d 83 e0 6c ff ff    	lea    -0x9320(%ebx),%eax
c002c1cd:	50                   	push   %eax
c002c1ce:	e8 11 cd ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c1d3:	83 ec 0c             	sub    $0xc,%esp
c002c1d6:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002c1dc:	50                   	push   %eax
c002c1dd:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c1e3:	50                   	push   %eax
c002c1e4:	8d 83 0c 43 ff ff    	lea    -0xbcf4(%ebx),%eax
c002c1ea:	50                   	push   %eax
c002c1eb:	6a 26                	push   $0x26
c002c1ed:	8d 83 e0 6c ff ff    	lea    -0x9320(%ebx),%eax
c002c1f3:	50                   	push   %eax
c002c1f4:	e8 eb cc ff ff       	call   c0028ee4 <debug_panic>

c002c1f9 <acquire_thread_func>:
       PRI_DEFAULT - 10, thread_get_priority ());
}

static void
acquire_thread_func (void *lock_) 
{
c002c1f9:	56                   	push   %esi
c002c1fa:	53                   	push   %ebx
c002c1fb:	83 ec 10             	sub    $0x10,%esp
c002c1fe:	e8 94 16 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c203:	81 c3 fd e2 00 00    	add    $0xe2fd,%ebx
c002c209:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002c20d:	56                   	push   %esi
c002c20e:	e8 0f 6e ff ff       	call   c0023022 <lock_acquire>
  msg ("acquire: got the lock");
c002c213:	8d 83 0b 6d ff ff    	lea    -0x92f5(%ebx),%eax
c002c219:	89 04 24             	mov    %eax,(%esp)
c002c21c:	e8 77 ec ff ff       	call   c002ae98 <msg>
  lock_release (lock);
c002c221:	89 34 24             	mov    %esi,(%esp)
c002c224:	e8 fa 6f ff ff       	call   c0023223 <lock_release>
  msg ("acquire: done");
c002c229:	8d 83 21 6d ff ff    	lea    -0x92df(%ebx),%eax
c002c22f:	89 04 24             	mov    %eax,(%esp)
c002c232:	e8 61 ec ff ff       	call   c002ae98 <msg>
}
c002c237:	83 c4 14             	add    $0x14,%esp
c002c23a:	5b                   	pop    %ebx
c002c23b:	5e                   	pop    %esi
c002c23c:	c3                   	ret    

c002c23d <test_priority_donate_lower>:
{
c002c23d:	57                   	push   %edi
c002c23e:	56                   	push   %esi
c002c23f:	53                   	push   %ebx
c002c240:	83 ec 30             	sub    $0x30,%esp
c002c243:	e8 4f 16 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c248:	81 c3 b8 e2 00 00    	add    $0xe2b8,%ebx
  ASSERT (!thread_mlfqs);
c002c24e:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002c254:	80 38 00             	cmpb   $0x0,(%eax)
c002c257:	0f 85 ac 00 00 00    	jne    c002c309 <test_priority_donate_lower+0xcc>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c25d:	e8 db 4c ff ff       	call   c0020f3d <thread_get_priority>
c002c262:	83 f8 1f             	cmp    $0x1f,%eax
c002c265:	0f 85 c4 00 00 00    	jne    c002c32f <test_priority_donate_lower+0xf2>
  lock_init (&lock);
c002c26b:	83 ec 0c             	sub    $0xc,%esp
c002c26e:	8d 74 24 18          	lea    0x18(%esp),%esi
c002c272:	56                   	push   %esi
c002c273:	e8 fe 6c ff ff       	call   c0022f76 <lock_init>
  lock_acquire (&lock);
c002c278:	89 34 24             	mov    %esi,(%esp)
c002c27b:	e8 a2 6d ff ff       	call   c0023022 <lock_acquire>
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002c280:	56                   	push   %esi
c002c281:	8d 83 f9 1c ff ff    	lea    -0xe307(%ebx),%eax
c002c287:	50                   	push   %eax
c002c288:	6a 29                	push   $0x29
c002c28a:	8d 83 2f 6d ff ff    	lea    -0x92d1(%ebx),%eax
c002c290:	50                   	push   %eax
c002c291:	e8 c6 52 ff ff       	call   c002155c <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c296:	83 c4 20             	add    $0x20,%esp
c002c299:	e8 9f 4c ff ff       	call   c0020f3d <thread_get_priority>
c002c29e:	83 ec 04             	sub    $0x4,%esp
c002c2a1:	50                   	push   %eax
c002c2a2:	6a 29                	push   $0x29
c002c2a4:	8d bb d0 69 ff ff    	lea    -0x9630(%ebx),%edi
c002c2aa:	57                   	push   %edi
c002c2ab:	e8 e8 eb ff ff       	call   c002ae98 <msg>
  msg ("Lowering base priority...");
c002c2b0:	8d 83 37 6d ff ff    	lea    -0x92c9(%ebx),%eax
c002c2b6:	89 04 24             	mov    %eax,(%esp)
c002c2b9:	e8 da eb ff ff       	call   c002ae98 <msg>
  thread_set_priority (PRI_DEFAULT - 10);
c002c2be:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c002c2c5:	e8 43 54 ff ff       	call   c002170d <thread_set_priority>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c2ca:	e8 6e 4c ff ff       	call   c0020f3d <thread_get_priority>
c002c2cf:	83 c4 0c             	add    $0xc,%esp
c002c2d2:	50                   	push   %eax
c002c2d3:	6a 29                	push   $0x29
c002c2d5:	57                   	push   %edi
c002c2d6:	e8 bd eb ff ff       	call   c002ae98 <msg>
  lock_release (&lock);
c002c2db:	89 34 24             	mov    %esi,(%esp)
c002c2de:	e8 40 6f ff ff       	call   c0023223 <lock_release>
  msg ("acquire must already have finished.");
c002c2e3:	8d 83 80 6d ff ff    	lea    -0x9280(%ebx),%eax
c002c2e9:	89 04 24             	mov    %eax,(%esp)
c002c2ec:	e8 a7 eb ff ff       	call   c002ae98 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c2f1:	e8 47 4c ff ff       	call   c0020f3d <thread_get_priority>
c002c2f6:	83 c4 0c             	add    $0xc,%esp
c002c2f9:	50                   	push   %eax
c002c2fa:	6a 15                	push   $0x15
c002c2fc:	57                   	push   %edi
c002c2fd:	e8 96 eb ff ff       	call   c002ae98 <msg>
}
c002c302:	83 c4 40             	add    $0x40,%esp
c002c305:	5b                   	pop    %ebx
c002c306:	5e                   	pop    %esi
c002c307:	5f                   	pop    %edi
c002c308:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c309:	83 ec 0c             	sub    $0xc,%esp
c002c30c:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002c312:	50                   	push   %eax
c002c313:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c319:	50                   	push   %eax
c002c31a:	8d 83 28 43 ff ff    	lea    -0xbcd8(%ebx),%eax
c002c320:	50                   	push   %eax
c002c321:	6a 15                	push   $0x15
c002c323:	8d 83 54 6d ff ff    	lea    -0x92ac(%ebx),%eax
c002c329:	50                   	push   %eax
c002c32a:	e8 b5 cb ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c32f:	83 ec 0c             	sub    $0xc,%esp
c002c332:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002c338:	50                   	push   %eax
c002c339:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c33f:	50                   	push   %eax
c002c340:	8d 83 28 43 ff ff    	lea    -0xbcd8(%ebx),%eax
c002c346:	50                   	push   %eax
c002c347:	6a 18                	push   $0x18
c002c349:	8d 83 54 6d ff ff    	lea    -0x92ac(%ebx),%eax
c002c34f:	50                   	push   %eax
c002c350:	e8 8f cb ff ff       	call   c0028ee4 <debug_panic>

c002c355 <simple_thread_func>:
    }
}

static void 
simple_thread_func (void *data_) 
{
c002c355:	57                   	push   %edi
c002c356:	56                   	push   %esi
c002c357:	53                   	push   %ebx
c002c358:	e8 3a 15 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c35d:	81 c3 a3 e1 00 00    	add    $0xe1a3,%ebx
c002c363:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c367:	bf 10 00 00 00       	mov    $0x10,%edi
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
    {
      lock_acquire (data->lock);
c002c36c:	83 ec 0c             	sub    $0xc,%esp
c002c36f:	ff 76 08             	pushl  0x8(%esi)
c002c372:	e8 ab 6c ff ff       	call   c0023022 <lock_acquire>
      *(*data->op)++ = data->id;
c002c377:	8b 56 0c             	mov    0xc(%esi),%edx
c002c37a:	8b 02                	mov    (%edx),%eax
c002c37c:	8d 48 04             	lea    0x4(%eax),%ecx
c002c37f:	89 0a                	mov    %ecx,(%edx)
c002c381:	8b 16                	mov    (%esi),%edx
c002c383:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002c385:	83 c4 04             	add    $0x4,%esp
c002c388:	ff 76 08             	pushl  0x8(%esi)
c002c38b:	e8 93 6e ff ff       	call   c0023223 <lock_release>
      thread_yield ();
c002c390:	e8 36 51 ff ff       	call   c00214cb <thread_yield>
  for (i = 0; i < ITER_CNT; i++) 
c002c395:	83 c4 10             	add    $0x10,%esp
c002c398:	83 ef 01             	sub    $0x1,%edi
c002c39b:	75 cf                	jne    c002c36c <simple_thread_func+0x17>
    }
}
c002c39d:	5b                   	pop    %ebx
c002c39e:	5e                   	pop    %esi
c002c39f:	5f                   	pop    %edi
c002c3a0:	c3                   	ret    

c002c3a1 <test_priority_fifo>:
{
c002c3a1:	55                   	push   %ebp
c002c3a2:	57                   	push   %edi
c002c3a3:	56                   	push   %esi
c002c3a4:	53                   	push   %ebx
c002c3a5:	81 ec 5c 01 00 00    	sub    $0x15c,%esp
c002c3ab:	e8 e7 14 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c3b0:	81 c3 50 e1 00 00    	add    $0xe150,%ebx
  ASSERT (!thread_mlfqs);
c002c3b6:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002c3bc:	80 38 00             	cmpb   $0x0,(%eax)
c002c3bf:	0f 85 15 01 00 00    	jne    c002c4da <test_priority_fifo+0x139>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c3c5:	e8 73 4b ff ff       	call   c0020f3d <thread_get_priority>
c002c3ca:	83 f8 1f             	cmp    $0x1f,%eax
c002c3cd:	0f 85 2d 01 00 00    	jne    c002c500 <test_priority_fifo+0x15f>
  msg ("%d threads will iterate %d times in the same order each time.",
c002c3d3:	83 ec 04             	sub    $0x4,%esp
c002c3d6:	6a 10                	push   $0x10
c002c3d8:	6a 10                	push   $0x10
c002c3da:	8d 83 08 6e ff ff    	lea    -0x91f8(%ebx),%eax
c002c3e0:	50                   	push   %eax
c002c3e1:	e8 b2 ea ff ff       	call   c002ae98 <msg>
  msg ("If the order varies then there is a bug.");
c002c3e6:	8d 83 48 6e ff ff    	lea    -0x91b8(%ebx),%eax
c002c3ec:	89 04 24             	mov    %eax,(%esp)
c002c3ef:	e8 a4 ea ff ff       	call   c002ae98 <msg>
  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002c3f4:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
c002c3fb:	e8 14 78 ff ff       	call   c0023c14 <malloc>
c002c400:	89 c5                	mov    %eax,%ebp
c002c402:	89 44 24 38          	mov    %eax,0x38(%esp)
  ASSERT (output != NULL);
c002c406:	83 c4 10             	add    $0x10,%esp
c002c409:	85 c0                	test   %eax,%eax
c002c40b:	0f 84 15 01 00 00    	je     c002c526 <test_priority_fifo+0x185>
  lock_init (&lock);
c002c411:	83 ec 0c             	sub    $0xc,%esp
c002c414:	8d 44 24 38          	lea    0x38(%esp),%eax
c002c418:	50                   	push   %eax
c002c419:	e8 58 6b ff ff       	call   c0022f76 <lock_init>
  thread_set_priority (PRI_DEFAULT + 2);
c002c41e:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c002c425:	e8 e3 52 ff ff       	call   c002170d <thread_set_priority>
  for (i = 0; i < THREAD_CNT; i++) 
c002c42a:	8d 74 24 60          	lea    0x60(%esp),%esi
c002c42e:	83 c4 10             	add    $0x10,%esp
c002c431:	bf 00 00 00 00       	mov    $0x0,%edi
      snprintf (name, sizeof name, "%d", i);
c002c436:	8d 83 e9 63 ff ff    	lea    -0x9c17(%ebx),%eax
c002c43c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002c440:	8d 44 24 18          	lea    0x18(%esp),%eax
c002c444:	89 44 24 08          	mov    %eax,0x8(%esp)
c002c448:	57                   	push   %edi
c002c449:	ff 74 24 10          	pushl  0x10(%esp)
c002c44d:	6a 10                	push   $0x10
c002c44f:	ff 74 24 14          	pushl  0x14(%esp)
c002c453:	e8 c1 b5 ff ff       	call   c0027a19 <snprintf>
      d->id = i;
c002c458:	89 3e                	mov    %edi,(%esi)
      d->iterations = 0;
c002c45a:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
      d->lock = &lock;
c002c461:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c002c465:	89 46 08             	mov    %eax,0x8(%esi)
      d->op = &op;
c002c468:	8d 44 24 38          	lea    0x38(%esp),%eax
c002c46c:	89 46 0c             	mov    %eax,0xc(%esi)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002c46f:	56                   	push   %esi
c002c470:	8d 83 55 1e ff ff    	lea    -0xe1ab(%ebx),%eax
c002c476:	50                   	push   %eax
c002c477:	6a 20                	push   $0x20
c002c479:	ff 74 24 24          	pushl  0x24(%esp)
c002c47d:	e8 da 50 ff ff       	call   c002155c <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002c482:	83 c7 01             	add    $0x1,%edi
c002c485:	83 c6 10             	add    $0x10,%esi
c002c488:	83 c4 20             	add    $0x20,%esp
c002c48b:	83 ff 10             	cmp    $0x10,%edi
c002c48e:	75 b8                	jne    c002c448 <test_priority_fifo+0xa7>
  thread_set_priority (PRI_DEFAULT);
c002c490:	83 ec 0c             	sub    $0xc,%esp
c002c493:	6a 1f                	push   $0x1f
c002c495:	e8 73 52 ff ff       	call   c002170d <thread_set_priority>
  ASSERT (lock.holder == NULL);
c002c49a:	83 c4 10             	add    $0x10,%esp
c002c49d:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c002c4a2:	0f 85 a4 00 00 00    	jne    c002c54c <test_priority_fifo+0x1ab>
  for (; output < op; output++) 
c002c4a8:	3b 6c 24 28          	cmp    0x28(%esp),%ebp
c002c4ac:	0f 83 49 01 00 00    	jae    c002c5fb <test_priority_fifo+0x25a>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002c4b2:	8b 75 00             	mov    0x0(%ebp),%esi
c002c4b5:	83 fe 0f             	cmp    $0xf,%esi
c002c4b8:	0f 87 b4 00 00 00    	ja     c002c572 <test_priority_fifo+0x1d1>
  cnt = 0;
c002c4be:	bf 00 00 00 00       	mov    $0x0,%edi
      d = data + *output;
c002c4c3:	8d 44 24 50          	lea    0x50(%esp),%eax
c002c4c7:	89 44 24 08          	mov    %eax,0x8(%esp)
        printf ("(priority-fifo) iteration:");
c002c4cb:	8d 83 c7 6d ff ff    	lea    -0x9239(%ebx),%eax
c002c4d1:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002c4d5:	e9 f1 00 00 00       	jmp    c002c5cb <test_priority_fifo+0x22a>
  ASSERT (!thread_mlfqs);
c002c4da:	83 ec 0c             	sub    $0xc,%esp
c002c4dd:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002c4e3:	50                   	push   %eax
c002c4e4:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c4ea:	50                   	push   %eax
c002c4eb:	8d 83 44 43 ff ff    	lea    -0xbcbc(%ebx),%eax
c002c4f1:	50                   	push   %eax
c002c4f2:	6a 28                	push   $0x28
c002c4f4:	8d 83 e4 6d ff ff    	lea    -0x921c(%ebx),%eax
c002c4fa:	50                   	push   %eax
c002c4fb:	e8 e4 c9 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c500:	83 ec 0c             	sub    $0xc,%esp
c002c503:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002c509:	50                   	push   %eax
c002c50a:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c510:	50                   	push   %eax
c002c511:	8d 83 44 43 ff ff    	lea    -0xbcbc(%ebx),%eax
c002c517:	50                   	push   %eax
c002c518:	6a 2b                	push   $0x2b
c002c51a:	8d 83 e4 6d ff ff    	lea    -0x921c(%ebx),%eax
c002c520:	50                   	push   %eax
c002c521:	e8 be c9 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (output != NULL);
c002c526:	83 ec 0c             	sub    $0xc,%esp
c002c529:	8d 83 a4 6d ff ff    	lea    -0x925c(%ebx),%eax
c002c52f:	50                   	push   %eax
c002c530:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c536:	50                   	push   %eax
c002c537:	8d 83 44 43 ff ff    	lea    -0xbcbc(%ebx),%eax
c002c53d:	50                   	push   %eax
c002c53e:	6a 32                	push   $0x32
c002c540:	8d 83 e4 6d ff ff    	lea    -0x921c(%ebx),%eax
c002c546:	50                   	push   %eax
c002c547:	e8 98 c9 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (lock.holder == NULL);
c002c54c:	83 ec 0c             	sub    $0xc,%esp
c002c54f:	8d 83 b3 6d ff ff    	lea    -0x924d(%ebx),%eax
c002c555:	50                   	push   %eax
c002c556:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c55c:	50                   	push   %eax
c002c55d:	8d 83 44 43 ff ff    	lea    -0xbcbc(%ebx),%eax
c002c563:	50                   	push   %eax
c002c564:	6a 44                	push   $0x44
c002c566:	8d 83 e4 6d ff ff    	lea    -0x921c(%ebx),%eax
c002c56c:	50                   	push   %eax
c002c56d:	e8 72 c9 ff ff       	call   c0028ee4 <debug_panic>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002c572:	83 ec 0c             	sub    $0xc,%esp
c002c575:	8d 83 74 6e ff ff    	lea    -0x918c(%ebx),%eax
c002c57b:	50                   	push   %eax
c002c57c:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c582:	50                   	push   %eax
c002c583:	8d 83 44 43 ff ff    	lea    -0xbcbc(%ebx),%eax
c002c589:	50                   	push   %eax
c002c58a:	6a 4b                	push   $0x4b
c002c58c:	8d 83 e4 6d ff ff    	lea    -0x921c(%ebx),%eax
c002c592:	50                   	push   %eax
c002c593:	e8 4c c9 ff ff       	call   c0028ee4 <debug_panic>
        printf ("(priority-fifo) iteration:");
c002c598:	83 ec 0c             	sub    $0xc,%esp
c002c59b:	ff 74 24 18          	pushl  0x18(%esp)
c002c59f:	e8 e4 ac ff ff       	call   c0027288 <printf>
c002c5a4:	83 c4 10             	add    $0x10,%esp
c002c5a7:	eb 31                	jmp    c002c5da <test_priority_fifo+0x239>
        printf ("\n");
c002c5a9:	83 ec 0c             	sub    $0xc,%esp
c002c5ac:	6a 0a                	push   $0xa
c002c5ae:	e8 c4 e8 ff ff       	call   c002ae77 <putchar>
c002c5b3:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002c5b6:	83 46 04 01          	addl   $0x1,0x4(%esi)
  for (; output < op; output++) 
c002c5ba:	83 c5 04             	add    $0x4,%ebp
c002c5bd:	39 6c 24 28          	cmp    %ebp,0x28(%esp)
c002c5c1:	76 38                	jbe    c002c5fb <test_priority_fifo+0x25a>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002c5c3:	8b 75 00             	mov    0x0(%ebp),%esi
c002c5c6:	83 fe 0f             	cmp    $0xf,%esi
c002c5c9:	77 a7                	ja     c002c572 <test_priority_fifo+0x1d1>
      d = data + *output;
c002c5cb:	c1 e6 04             	shl    $0x4,%esi
c002c5ce:	03 74 24 08          	add    0x8(%esp),%esi
      if (cnt % THREAD_CNT == 0)
c002c5d2:	f7 c7 0f 00 00 00    	test   $0xf,%edi
c002c5d8:	74 be                	je     c002c598 <test_priority_fifo+0x1f7>
      printf (" %d", d->id);
c002c5da:	83 ec 08             	sub    $0x8,%esp
c002c5dd:	ff 36                	pushl  (%esi)
c002c5df:	8d 83 e8 63 ff ff    	lea    -0x9c18(%ebx),%eax
c002c5e5:	50                   	push   %eax
c002c5e6:	e8 9d ac ff ff       	call   c0027288 <printf>
      if (++cnt % THREAD_CNT == 0)
c002c5eb:	83 c7 01             	add    $0x1,%edi
c002c5ee:	83 c4 10             	add    $0x10,%esp
c002c5f1:	f7 c7 0f 00 00 00    	test   $0xf,%edi
c002c5f7:	75 bd                	jne    c002c5b6 <test_priority_fifo+0x215>
c002c5f9:	eb ae                	jmp    c002c5a9 <test_priority_fifo+0x208>
}
c002c5fb:	81 c4 5c 01 00 00    	add    $0x15c,%esp
c002c601:	5b                   	pop    %ebx
c002c602:	5e                   	pop    %esi
c002c603:	5f                   	pop    %edi
c002c604:	5d                   	pop    %ebp
c002c605:	c3                   	ret    

c002c606 <simple_thread_func>:
  msg ("The high-priority thread should have already completed.");
}

static void 
simple_thread_func (void *aux UNUSED) 
{
c002c606:	57                   	push   %edi
c002c607:	56                   	push   %esi
c002c608:	53                   	push   %ebx
c002c609:	e8 89 12 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c60e:	81 c3 f2 de 00 00    	add    $0xdef2,%ebx
  int i;
  
  for (i = 0; i < 5; i++) 
c002c614:	be 00 00 00 00       	mov    $0x0,%esi
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002c619:	8d bb 99 6e ff ff    	lea    -0x9167(%ebx),%edi
c002c61f:	e8 64 48 ff ff       	call   c0020e88 <thread_name>
c002c624:	83 ec 04             	sub    $0x4,%esp
c002c627:	56                   	push   %esi
c002c628:	50                   	push   %eax
c002c629:	57                   	push   %edi
c002c62a:	e8 69 e8 ff ff       	call   c002ae98 <msg>
      thread_yield ();
c002c62f:	e8 97 4e ff ff       	call   c00214cb <thread_yield>
  for (i = 0; i < 5; i++) 
c002c634:	83 c6 01             	add    $0x1,%esi
c002c637:	83 c4 10             	add    $0x10,%esp
c002c63a:	83 fe 05             	cmp    $0x5,%esi
c002c63d:	75 e0                	jne    c002c61f <simple_thread_func+0x19>
    }
  msg ("Thread %s done!", thread_name ());
c002c63f:	e8 44 48 ff ff       	call   c0020e88 <thread_name>
c002c644:	83 ec 08             	sub    $0x8,%esp
c002c647:	50                   	push   %eax
c002c648:	8d 83 b0 6e ff ff    	lea    -0x9150(%ebx),%eax
c002c64e:	50                   	push   %eax
c002c64f:	e8 44 e8 ff ff       	call   c002ae98 <msg>
}
c002c654:	83 c4 10             	add    $0x10,%esp
c002c657:	5b                   	pop    %ebx
c002c658:	5e                   	pop    %esi
c002c659:	5f                   	pop    %edi
c002c65a:	c3                   	ret    

c002c65b <test_priority_preempt>:
{
c002c65b:	53                   	push   %ebx
c002c65c:	83 ec 08             	sub    $0x8,%esp
c002c65f:	e8 33 12 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c664:	81 c3 9c de 00 00    	add    $0xde9c,%ebx
  ASSERT (!thread_mlfqs);
c002c66a:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002c670:	80 38 00             	cmpb   $0x0,(%eax)
c002c673:	75 34                	jne    c002c6a9 <test_priority_preempt+0x4e>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c675:	e8 c3 48 ff ff       	call   c0020f3d <thread_get_priority>
c002c67a:	83 f8 1f             	cmp    $0x1f,%eax
c002c67d:	75 50                	jne    c002c6cf <test_priority_preempt+0x74>
  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002c67f:	6a 00                	push   $0x0
c002c681:	8d 83 06 21 ff ff    	lea    -0xdefa(%ebx),%eax
c002c687:	50                   	push   %eax
c002c688:	6a 20                	push   $0x20
c002c68a:	8d 83 c0 6e ff ff    	lea    -0x9140(%ebx),%eax
c002c690:	50                   	push   %eax
c002c691:	e8 c6 4e ff ff       	call   c002155c <thread_create>
  msg ("The high-priority thread should have already completed.");
c002c696:	8d 83 f8 6e ff ff    	lea    -0x9108(%ebx),%eax
c002c69c:	89 04 24             	mov    %eax,(%esp)
c002c69f:	e8 f4 e7 ff ff       	call   c002ae98 <msg>
}
c002c6a4:	83 c4 18             	add    $0x18,%esp
c002c6a7:	5b                   	pop    %ebx
c002c6a8:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c6a9:	83 ec 0c             	sub    $0xc,%esp
c002c6ac:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002c6b2:	50                   	push   %eax
c002c6b3:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c6b9:	50                   	push   %eax
c002c6ba:	8d 83 58 43 ff ff    	lea    -0xbca8(%ebx),%eax
c002c6c0:	50                   	push   %eax
c002c6c1:	6a 15                	push   $0x15
c002c6c3:	8d 83 d0 6e ff ff    	lea    -0x9130(%ebx),%eax
c002c6c9:	50                   	push   %eax
c002c6ca:	e8 15 c8 ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c6cf:	83 ec 0c             	sub    $0xc,%esp
c002c6d2:	8d 83 68 68 ff ff    	lea    -0x9798(%ebx),%eax
c002c6d8:	50                   	push   %eax
c002c6d9:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c6df:	50                   	push   %eax
c002c6e0:	8d 83 58 43 ff ff    	lea    -0xbca8(%ebx),%eax
c002c6e6:	50                   	push   %eax
c002c6e7:	6a 18                	push   $0x18
c002c6e9:	8d 83 d0 6e ff ff    	lea    -0x9130(%ebx),%eax
c002c6ef:	50                   	push   %eax
c002c6f0:	e8 ef c7 ff ff       	call   c0028ee4 <debug_panic>

c002c6f5 <priority_sema_thread>:
    }
}

static void
priority_sema_thread (void *aux UNUSED) 
{
c002c6f5:	53                   	push   %ebx
c002c6f6:	83 ec 14             	sub    $0x14,%esp
c002c6f9:	e8 99 11 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c6fe:	81 c3 02 de 00 00    	add    $0xde02,%ebx
  sema_down (&sema);
c002c704:	8d 83 c8 1c 00 00    	lea    0x1cc8(%ebx),%eax
c002c70a:	50                   	push   %eax
c002c70b:	e8 e4 65 ff ff       	call   c0022cf4 <sema_down>
  msg ("Thread %s woke up.", thread_name ());
c002c710:	e8 73 47 ff ff       	call   c0020e88 <thread_name>
c002c715:	83 c4 08             	add    $0x8,%esp
c002c718:	50                   	push   %eax
c002c719:	8d 83 bc 66 ff ff    	lea    -0x9944(%ebx),%eax
c002c71f:	50                   	push   %eax
c002c720:	e8 73 e7 ff ff       	call   c002ae98 <msg>
}
c002c725:	83 c4 18             	add    $0x18,%esp
c002c728:	5b                   	pop    %ebx
c002c729:	c3                   	ret    

c002c72a <test_priority_sema>:
{
c002c72a:	55                   	push   %ebp
c002c72b:	57                   	push   %edi
c002c72c:	56                   	push   %esi
c002c72d:	53                   	push   %ebx
c002c72e:	83 ec 1c             	sub    $0x1c,%esp
c002c731:	e8 61 11 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c736:	81 c3 ca dd 00 00    	add    $0xddca,%ebx
  ASSERT (!thread_mlfqs);
c002c73c:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002c742:	80 38 00             	cmpb   $0x0,(%eax)
c002c745:	0f 85 a7 00 00 00    	jne    c002c7f2 <test_priority_sema+0xc8>
  sema_init (&sema, 0);
c002c74b:	83 ec 08             	sub    $0x8,%esp
c002c74e:	6a 00                	push   $0x0
c002c750:	8d 83 c8 1c 00 00    	lea    0x1cc8(%ebx),%eax
c002c756:	50                   	push   %eax
c002c757:	e8 44 65 ff ff       	call   c0022ca0 <sema_init>
  thread_set_priority (PRI_MIN);
c002c75c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002c763:	e8 a5 4f ff ff       	call   c002170d <thread_set_priority>
c002c768:	83 c4 10             	add    $0x10,%esp
c002c76b:	be 03 00 00 00       	mov    $0x3,%esi
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002c770:	b8 67 66 66 66       	mov    $0x66666667,%eax
c002c775:	f7 ee                	imul   %esi
c002c777:	c1 fa 02             	sar    $0x2,%edx
c002c77a:	89 f0                	mov    %esi,%eax
c002c77c:	c1 f8 1f             	sar    $0x1f,%eax
c002c77f:	29 c2                	sub    %eax,%edx
c002c781:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002c784:	01 c0                	add    %eax,%eax
c002c786:	89 f1                	mov    %esi,%ecx
c002c788:	29 c1                	sub    %eax,%ecx
c002c78a:	bd 1e 00 00 00       	mov    $0x1e,%ebp
c002c78f:	29 cd                	sub    %ecx,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002c791:	55                   	push   %ebp
c002c792:	8d 83 cf 66 ff ff    	lea    -0x9931(%ebx),%eax
c002c798:	50                   	push   %eax
c002c799:	6a 10                	push   $0x10
c002c79b:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002c79f:	57                   	push   %edi
c002c7a0:	e8 74 b2 ff ff       	call   c0027a19 <snprintf>
      thread_create (name, priority, priority_sema_thread, NULL);
c002c7a5:	6a 00                	push   $0x0
c002c7a7:	8d 83 f5 21 ff ff    	lea    -0xde0b(%ebx),%eax
c002c7ad:	50                   	push   %eax
c002c7ae:	55                   	push   %ebp
c002c7af:	57                   	push   %edi
c002c7b0:	e8 a7 4d ff ff       	call   c002155c <thread_create>
c002c7b5:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < 10; i++) 
c002c7b8:	83 c4 20             	add    $0x20,%esp
c002c7bb:	83 fe 0d             	cmp    $0xd,%esi
c002c7be:	75 b0                	jne    c002c770 <test_priority_sema+0x46>
c002c7c0:	be 0a 00 00 00       	mov    $0xa,%esi
      sema_up (&sema);
c002c7c5:	8d ab c8 1c 00 00    	lea    0x1cc8(%ebx),%ebp
      msg ("Back in main thread."); 
c002c7cb:	8d bb 30 6f ff ff    	lea    -0x90d0(%ebx),%edi
      sema_up (&sema);
c002c7d1:	83 ec 0c             	sub    $0xc,%esp
c002c7d4:	55                   	push   %ebp
c002c7d5:	e8 45 66 ff ff       	call   c0022e1f <sema_up>
      msg ("Back in main thread."); 
c002c7da:	89 3c 24             	mov    %edi,(%esp)
c002c7dd:	e8 b6 e6 ff ff       	call   c002ae98 <msg>
  for (i = 0; i < 10; i++) 
c002c7e2:	83 c4 10             	add    $0x10,%esp
c002c7e5:	83 ee 01             	sub    $0x1,%esi
c002c7e8:	75 e7                	jne    c002c7d1 <test_priority_sema+0xa7>
}
c002c7ea:	83 c4 1c             	add    $0x1c,%esp
c002c7ed:	5b                   	pop    %ebx
c002c7ee:	5e                   	pop    %esi
c002c7ef:	5f                   	pop    %edi
c002c7f0:	5d                   	pop    %ebp
c002c7f1:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c7f2:	83 ec 0c             	sub    $0xc,%esp
c002c7f5:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002c7fb:	50                   	push   %eax
c002c7fc:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c802:	50                   	push   %eax
c002c803:	8d 83 70 43 ff ff    	lea    -0xbc90(%ebx),%eax
c002c809:	50                   	push   %eax
c002c80a:	6a 15                	push   $0x15
c002c80c:	8d 83 48 6f ff ff    	lea    -0x90b8(%ebx),%eax
c002c812:	50                   	push   %eax
c002c813:	e8 cc c6 ff ff       	call   c0028ee4 <debug_panic>

c002c818 <priority_condvar_thread>:
    }
}

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002c818:	56                   	push   %esi
c002c819:	53                   	push   %ebx
c002c81a:	83 ec 04             	sub    $0x4,%esp
c002c81d:	e8 75 10 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c822:	81 c3 de dc 00 00    	add    $0xdcde,%ebx
  msg ("Thread %s starting.", thread_name ());
c002c828:	e8 5b 46 ff ff       	call   c0020e88 <thread_name>
c002c82d:	83 ec 08             	sub    $0x8,%esp
c002c830:	50                   	push   %eax
c002c831:	8d 83 6c 6f ff ff    	lea    -0x9094(%ebx),%eax
c002c837:	50                   	push   %eax
c002c838:	e8 5b e6 ff ff       	call   c002ae98 <msg>
  lock_acquire (&lock);
c002c83d:	8d b3 00 1d 00 00    	lea    0x1d00(%ebx),%esi
c002c843:	89 34 24             	mov    %esi,(%esp)
c002c846:	e8 d7 67 ff ff       	call   c0023022 <lock_acquire>
  cond_wait (&condition, &lock);
c002c84b:	83 c4 08             	add    $0x8,%esp
c002c84e:	56                   	push   %esi
c002c84f:	8d 83 e0 1c 00 00    	lea    0x1ce0(%ebx),%eax
c002c855:	50                   	push   %eax
c002c856:	e8 c1 6a ff ff       	call   c002331c <cond_wait>
  msg ("Thread %s woke up.", thread_name ());
c002c85b:	e8 28 46 ff ff       	call   c0020e88 <thread_name>
c002c860:	83 c4 08             	add    $0x8,%esp
c002c863:	50                   	push   %eax
c002c864:	8d 83 bc 66 ff ff    	lea    -0x9944(%ebx),%eax
c002c86a:	50                   	push   %eax
c002c86b:	e8 28 e6 ff ff       	call   c002ae98 <msg>
  lock_release (&lock);
c002c870:	89 34 24             	mov    %esi,(%esp)
c002c873:	e8 ab 69 ff ff       	call   c0023223 <lock_release>
}
c002c878:	83 c4 14             	add    $0x14,%esp
c002c87b:	5b                   	pop    %ebx
c002c87c:	5e                   	pop    %esi
c002c87d:	c3                   	ret    

c002c87e <test_priority_condvar>:
{
c002c87e:	55                   	push   %ebp
c002c87f:	57                   	push   %edi
c002c880:	56                   	push   %esi
c002c881:	53                   	push   %ebx
c002c882:	83 ec 1c             	sub    $0x1c,%esp
c002c885:	e8 0d 10 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c88a:	81 c3 76 dc 00 00    	add    $0xdc76,%ebx
  ASSERT (!thread_mlfqs);
c002c890:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002c896:	80 38 00             	cmpb   $0x0,(%eax)
c002c899:	0f 85 cb 00 00 00    	jne    c002c96a <test_priority_condvar+0xec>
  lock_init (&lock);
c002c89f:	83 ec 0c             	sub    $0xc,%esp
c002c8a2:	8d 83 00 1d 00 00    	lea    0x1d00(%ebx),%eax
c002c8a8:	50                   	push   %eax
c002c8a9:	e8 c8 66 ff ff       	call   c0022f76 <lock_init>
  cond_init (&condition);
c002c8ae:	8d 83 e0 1c 00 00    	lea    0x1ce0(%ebx),%eax
c002c8b4:	89 04 24             	mov    %eax,(%esp)
c002c8b7:	e8 12 6a ff ff       	call   c00232ce <cond_init>
  thread_set_priority (PRI_MIN);
c002c8bc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002c8c3:	e8 45 4e ff ff       	call   c002170d <thread_set_priority>
c002c8c8:	83 c4 10             	add    $0x10,%esp
c002c8cb:	be 07 00 00 00       	mov    $0x7,%esi
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1; // 23->22->21->30->29...
c002c8d0:	b8 67 66 66 66       	mov    $0x66666667,%eax
c002c8d5:	f7 ee                	imul   %esi
c002c8d7:	c1 fa 02             	sar    $0x2,%edx
c002c8da:	89 f0                	mov    %esi,%eax
c002c8dc:	c1 f8 1f             	sar    $0x1f,%eax
c002c8df:	29 c2                	sub    %eax,%edx
c002c8e1:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002c8e4:	01 c0                	add    %eax,%eax
c002c8e6:	89 f1                	mov    %esi,%ecx
c002c8e8:	29 c1                	sub    %eax,%ecx
c002c8ea:	bd 1e 00 00 00       	mov    $0x1e,%ebp
c002c8ef:	29 cd                	sub    %ecx,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002c8f1:	55                   	push   %ebp
c002c8f2:	8d 83 cf 66 ff ff    	lea    -0x9931(%ebx),%eax
c002c8f8:	50                   	push   %eax
c002c8f9:	6a 10                	push   $0x10
c002c8fb:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002c8ff:	57                   	push   %edi
c002c900:	e8 14 b1 ff ff       	call   c0027a19 <snprintf>
      thread_create (name, priority, priority_condvar_thread, NULL);
c002c905:	6a 00                	push   $0x0
c002c907:	8d 83 18 23 ff ff    	lea    -0xdce8(%ebx),%eax
c002c90d:	50                   	push   %eax
c002c90e:	55                   	push   %ebp
c002c90f:	57                   	push   %edi
c002c910:	e8 47 4c ff ff       	call   c002155c <thread_create>
c002c915:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < 10; i++) 
c002c918:	83 c4 20             	add    $0x20,%esp
c002c91b:	83 fe 11             	cmp    $0x11,%esi
c002c91e:	75 b0                	jne    c002c8d0 <test_priority_condvar+0x52>
c002c920:	bf 0a 00 00 00       	mov    $0xa,%edi
      lock_acquire (&lock);
c002c925:	8d b3 00 1d 00 00    	lea    0x1d00(%ebx),%esi
      msg ("Signaling...");
c002c92b:	8d ab 80 6f ff ff    	lea    -0x9080(%ebx),%ebp
      lock_acquire (&lock);
c002c931:	83 ec 0c             	sub    $0xc,%esp
c002c934:	56                   	push   %esi
c002c935:	e8 e8 66 ff ff       	call   c0023022 <lock_acquire>
      msg ("Signaling...");
c002c93a:	89 2c 24             	mov    %ebp,(%esp)
c002c93d:	e8 56 e5 ff ff       	call   c002ae98 <msg>
      cond_signal (&condition, &lock);
c002c942:	83 c4 08             	add    $0x8,%esp
c002c945:	56                   	push   %esi
c002c946:	8d 83 e0 1c 00 00    	lea    0x1ce0(%ebx),%eax
c002c94c:	50                   	push   %eax
c002c94d:	e8 fc 6a ff ff       	call   c002344e <cond_signal>
      lock_release (&lock);
c002c952:	89 34 24             	mov    %esi,(%esp)
c002c955:	e8 c9 68 ff ff       	call   c0023223 <lock_release>
  for (i = 0; i < 10; i++) 
c002c95a:	83 c4 10             	add    $0x10,%esp
c002c95d:	83 ef 01             	sub    $0x1,%edi
c002c960:	75 cf                	jne    c002c931 <test_priority_condvar+0xb3>
}
c002c962:	83 c4 1c             	add    $0x1c,%esp
c002c965:	5b                   	pop    %ebx
c002c966:	5e                   	pop    %esi
c002c967:	5f                   	pop    %edi
c002c968:	5d                   	pop    %ebp
c002c969:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c96a:	83 ec 0c             	sub    $0xc,%esp
c002c96d:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002c973:	50                   	push   %eax
c002c974:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002c97a:	50                   	push   %eax
c002c97b:	8d 83 84 43 ff ff    	lea    -0xbc7c(%ebx),%eax
c002c981:	50                   	push   %eax
c002c982:	6a 16                	push   $0x16
c002c984:	8d 83 90 6f ff ff    	lea    -0x9070(%ebx),%eax
c002c98a:	50                   	push   %eax
c002c98b:	e8 54 c5 ff ff       	call   c0028ee4 <debug_panic>

c002c990 <interloper_thread_func>:
                                         thread_get_priority ());
}

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002c990:	53                   	push   %ebx
c002c991:	83 ec 08             	sub    $0x8,%esp
c002c994:	e8 fe 0e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c999:	81 c3 67 db 00 00    	add    $0xdb67,%ebx
  msg ("%s finished.", thread_name ());
c002c99f:	e8 e4 44 ff ff       	call   c0020e88 <thread_name>
c002c9a4:	83 ec 08             	sub    $0x8,%esp
c002c9a7:	50                   	push   %eax
c002c9a8:	8d 83 b7 6f ff ff    	lea    -0x9049(%ebx),%eax
c002c9ae:	50                   	push   %eax
c002c9af:	e8 e4 e4 ff ff       	call   c002ae98 <msg>
}
c002c9b4:	83 c4 18             	add    $0x18,%esp
c002c9b7:	5b                   	pop    %ebx
c002c9b8:	c3                   	ret    

c002c9b9 <donor_thread_func>:
{
c002c9b9:	57                   	push   %edi
c002c9ba:	56                   	push   %esi
c002c9bb:	53                   	push   %ebx
c002c9bc:	e8 d6 0e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002c9c1:	81 c3 3f db 00 00    	add    $0xdb3f,%ebx
c002c9c7:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (locks->first)
c002c9cb:	8b 46 04             	mov    0x4(%esi),%eax
c002c9ce:	85 c0                	test   %eax,%eax
c002c9d0:	74 0c                	je     c002c9de <donor_thread_func+0x25>
    lock_acquire (locks->first);
c002c9d2:	83 ec 0c             	sub    $0xc,%esp
c002c9d5:	50                   	push   %eax
c002c9d6:	e8 47 66 ff ff       	call   c0023022 <lock_acquire>
c002c9db:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->second);
c002c9de:	83 ec 0c             	sub    $0xc,%esp
c002c9e1:	ff 36                	pushl  (%esi)
c002c9e3:	e8 3a 66 ff ff       	call   c0023022 <lock_acquire>
  msg ("%s got lock", thread_name ());
c002c9e8:	e8 9b 44 ff ff       	call   c0020e88 <thread_name>
c002c9ed:	83 c4 08             	add    $0x8,%esp
c002c9f0:	50                   	push   %eax
c002c9f1:	8d 83 c4 6f ff ff    	lea    -0x903c(%ebx),%eax
c002c9f7:	50                   	push   %eax
c002c9f8:	e8 9b e4 ff ff       	call   c002ae98 <msg>
  lock_release (locks->second);
c002c9fd:	83 c4 04             	add    $0x4,%esp
c002ca00:	ff 36                	pushl  (%esi)
c002ca02:	e8 1c 68 ff ff       	call   c0023223 <lock_release>
  msg ("%s should have priority %d. Actual priority: %d", 
c002ca07:	e8 31 45 ff ff       	call   c0020f3d <thread_get_priority>
c002ca0c:	89 c7                	mov    %eax,%edi
c002ca0e:	e8 75 44 ff ff       	call   c0020e88 <thread_name>
c002ca13:	57                   	push   %edi
c002ca14:	6a 15                	push   $0x15
c002ca16:	50                   	push   %eax
c002ca17:	8d 83 ec 6f ff ff    	lea    -0x9014(%ebx),%eax
c002ca1d:	50                   	push   %eax
c002ca1e:	e8 75 e4 ff ff       	call   c002ae98 <msg>
  if (locks->first)
c002ca23:	8b 46 04             	mov    0x4(%esi),%eax
c002ca26:	83 c4 20             	add    $0x20,%esp
c002ca29:	85 c0                	test   %eax,%eax
c002ca2b:	74 0c                	je     c002ca39 <donor_thread_func+0x80>
    lock_release (locks->first);
c002ca2d:	83 ec 0c             	sub    $0xc,%esp
c002ca30:	50                   	push   %eax
c002ca31:	e8 ed 67 ff ff       	call   c0023223 <lock_release>
c002ca36:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002ca39:	e8 ff 44 ff ff       	call   c0020f3d <thread_get_priority>
c002ca3e:	89 c6                	mov    %eax,%esi
c002ca40:	e8 43 44 ff ff       	call   c0020e88 <thread_name>
c002ca45:	83 ec 04             	sub    $0x4,%esp
c002ca48:	56                   	push   %esi
c002ca49:	50                   	push   %eax
c002ca4a:	8d 83 1c 70 ff ff    	lea    -0x8fe4(%ebx),%eax
c002ca50:	50                   	push   %eax
c002ca51:	e8 42 e4 ff ff       	call   c002ae98 <msg>
}
c002ca56:	83 c4 10             	add    $0x10,%esp
c002ca59:	5b                   	pop    %ebx
c002ca5a:	5e                   	pop    %esi
c002ca5b:	5f                   	pop    %edi
c002ca5c:	c3                   	ret    

c002ca5d <test_priority_donate_chain>:
{
c002ca5d:	55                   	push   %ebp
c002ca5e:	57                   	push   %edi
c002ca5f:	56                   	push   %esi
c002ca60:	53                   	push   %ebx
c002ca61:	81 ec 6c 01 00 00    	sub    $0x16c,%esp
c002ca67:	e8 2b 0e 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ca6c:	81 c3 94 da 00 00    	add    $0xda94,%ebx
  ASSERT (!thread_mlfqs);
c002ca72:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002ca78:	80 38 00             	cmpb   $0x0,(%eax)
c002ca7b:	0f 85 8c 01 00 00    	jne    c002cc0d <test_priority_donate_chain+0x1b0>
  thread_set_priority (PRI_MIN);
c002ca81:	83 ec 0c             	sub    $0xc,%esp
c002ca84:	6a 00                	push   $0x0
c002ca86:	e8 82 4c ff ff       	call   c002170d <thread_set_priority>
    lock_init (&locks[i]);
c002ca8b:	83 c4 04             	add    $0x4,%esp
c002ca8e:	8d 74 24 70          	lea    0x70(%esp),%esi
c002ca92:	56                   	push   %esi
c002ca93:	e8 de 64 ff ff       	call   c0022f76 <lock_init>
c002ca98:	83 c4 04             	add    $0x4,%esp
c002ca9b:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c002caa2:	50                   	push   %eax
c002caa3:	e8 ce 64 ff ff       	call   c0022f76 <lock_init>
c002caa8:	83 c4 04             	add    $0x4,%esp
c002caab:	8d 84 24 b8 00 00 00 	lea    0xb8(%esp),%eax
c002cab2:	50                   	push   %eax
c002cab3:	e8 be 64 ff ff       	call   c0022f76 <lock_init>
c002cab8:	83 c4 04             	add    $0x4,%esp
c002cabb:	8d 84 24 dc 00 00 00 	lea    0xdc(%esp),%eax
c002cac2:	50                   	push   %eax
c002cac3:	e8 ae 64 ff ff       	call   c0022f76 <lock_init>
c002cac8:	83 c4 04             	add    $0x4,%esp
c002cacb:	8d 84 24 00 01 00 00 	lea    0x100(%esp),%eax
c002cad2:	50                   	push   %eax
c002cad3:	e8 9e 64 ff ff       	call   c0022f76 <lock_init>
c002cad8:	83 c4 04             	add    $0x4,%esp
c002cadb:	8d 84 24 24 01 00 00 	lea    0x124(%esp),%eax
c002cae2:	50                   	push   %eax
c002cae3:	e8 8e 64 ff ff       	call   c0022f76 <lock_init>
c002cae8:	83 c4 04             	add    $0x4,%esp
c002caeb:	8d 84 24 48 01 00 00 	lea    0x148(%esp),%eax
c002caf2:	50                   	push   %eax
c002caf3:	e8 7e 64 ff ff       	call   c0022f76 <lock_init>
  lock_acquire (&locks[0]);
c002caf8:	89 34 24             	mov    %esi,(%esp)
c002cafb:	e8 22 65 ff ff       	call   c0023022 <lock_acquire>
  msg ("%s got lock.", thread_name ());
c002cb00:	e8 83 43 ff ff       	call   c0020e88 <thread_name>
c002cb05:	83 c4 08             	add    $0x8,%esp
c002cb08:	50                   	push   %eax
c002cb09:	8d 83 d0 6f ff ff    	lea    -0x9030(%ebx),%eax
c002cb0f:	50                   	push   %eax
c002cb10:	e8 83 e3 ff ff       	call   c002ae98 <msg>
  for (i = 1; i < NESTING_DEPTH; i++)
c002cb15:	89 74 24 14          	mov    %esi,0x14(%esp)
c002cb19:	8d 6c 24 3c          	lea    0x3c(%esp),%ebp
c002cb1d:	83 c4 10             	add    $0x10,%esp
c002cb20:	be 01 00 00 00       	mov    $0x1,%esi
      snprintf (name, sizeof name, "thread %d", i);
c002cb25:	8d 83 e2 63 ff ff    	lea    -0x9c1e(%ebx),%eax
c002cb2b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002cb2f:	8d 7c 24 14          	lea    0x14(%esp),%edi
c002cb33:	56                   	push   %esi
c002cb34:	ff 74 24 10          	pushl  0x10(%esp)
c002cb38:	6a 10                	push   $0x10
c002cb3a:	57                   	push   %edi
c002cb3b:	e8 d9 ae ff ff       	call   c0027a19 <snprintf>
      thread_priority = PRI_MIN + i * 3;
c002cb40:	8d 04 76             	lea    (%esi,%esi,2),%eax
c002cb43:	89 44 24 10          	mov    %eax,0x10(%esp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002cb47:	83 c4 10             	add    $0x10,%esp
c002cb4a:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002cb4e:	8d 41 24             	lea    0x24(%ecx),%eax
c002cb51:	83 fe 07             	cmp    $0x7,%esi
c002cb54:	ba 00 00 00 00       	mov    $0x0,%edx
c002cb59:	0f 4d c2             	cmovge %edx,%eax
c002cb5c:	89 45 04             	mov    %eax,0x4(%ebp)
      lock_pairs[i].second = locks + i - 1;
c002cb5f:	89 4d 00             	mov    %ecx,0x0(%ebp)
      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002cb62:	55                   	push   %ebp
c002cb63:	8d 83 b9 24 ff ff    	lea    -0xdb47(%ebx),%eax
c002cb69:	50                   	push   %eax
c002cb6a:	ff 74 24 08          	pushl  0x8(%esp)
c002cb6e:	57                   	push   %edi
c002cb6f:	e8 e8 49 ff ff       	call   c002155c <thread_create>
      msg ("%s should have priority %d.  Actual priority: %d.",
c002cb74:	e8 c4 43 ff ff       	call   c0020f3d <thread_get_priority>
c002cb79:	89 44 24 18          	mov    %eax,0x18(%esp)
c002cb7d:	e8 06 43 ff ff       	call   c0020e88 <thread_name>
c002cb82:	ff 74 24 18          	pushl  0x18(%esp)
c002cb86:	ff 74 24 14          	pushl  0x14(%esp)
c002cb8a:	50                   	push   %eax
c002cb8b:	8d 83 68 70 ff ff    	lea    -0x8f98(%ebx),%eax
c002cb91:	50                   	push   %eax
c002cb92:	e8 01 e3 ff ff       	call   c002ae98 <msg>
      snprintf (name, sizeof name, "interloper %d", i);
c002cb97:	83 c4 20             	add    $0x20,%esp
c002cb9a:	56                   	push   %esi
c002cb9b:	8d 83 dd 6f ff ff    	lea    -0x9023(%ebx),%eax
c002cba1:	50                   	push   %eax
c002cba2:	6a 10                	push   $0x10
c002cba4:	57                   	push   %edi
c002cba5:	e8 6f ae ff ff       	call   c0027a19 <snprintf>
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002cbaa:	6a 00                	push   $0x0
c002cbac:	8d 83 90 24 ff ff    	lea    -0xdb70(%ebx),%eax
c002cbb2:	50                   	push   %eax
c002cbb3:	8b 44 24 18          	mov    0x18(%esp),%eax
c002cbb7:	83 e8 01             	sub    $0x1,%eax
c002cbba:	50                   	push   %eax
c002cbbb:	57                   	push   %edi
c002cbbc:	e8 9b 49 ff ff       	call   c002155c <thread_create>
  for (i = 1; i < NESTING_DEPTH; i++)
c002cbc1:	83 c6 01             	add    $0x1,%esi
c002cbc4:	83 44 24 24 24       	addl   $0x24,0x24(%esp)
c002cbc9:	83 c5 08             	add    $0x8,%ebp
c002cbcc:	83 c4 20             	add    $0x20,%esp
c002cbcf:	83 fe 08             	cmp    $0x8,%esi
c002cbd2:	0f 85 5b ff ff ff    	jne    c002cb33 <test_priority_donate_chain+0xd6>
  lock_release (&locks[0]);
c002cbd8:	83 ec 0c             	sub    $0xc,%esp
c002cbdb:	8d 44 24 70          	lea    0x70(%esp),%eax
c002cbdf:	50                   	push   %eax
c002cbe0:	e8 3e 66 ff ff       	call   c0023223 <lock_release>
  msg ("%s finishing with priority %d.", thread_name (),
c002cbe5:	e8 53 43 ff ff       	call   c0020f3d <thread_get_priority>
c002cbea:	89 c6                	mov    %eax,%esi
c002cbec:	e8 97 42 ff ff       	call   c0020e88 <thread_name>
c002cbf1:	83 c4 0c             	add    $0xc,%esp
c002cbf4:	56                   	push   %esi
c002cbf5:	50                   	push   %eax
c002cbf6:	8d 83 1c 70 ff ff    	lea    -0x8fe4(%ebx),%eax
c002cbfc:	50                   	push   %eax
c002cbfd:	e8 96 e2 ff ff       	call   c002ae98 <msg>
}
c002cc02:	81 c4 7c 01 00 00    	add    $0x17c,%esp
c002cc08:	5b                   	pop    %ebx
c002cc09:	5e                   	pop    %esi
c002cc0a:	5f                   	pop    %edi
c002cc0b:	5d                   	pop    %ebp
c002cc0c:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002cc0d:	83 ec 0c             	sub    $0xc,%esp
c002cc10:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002cc16:	50                   	push   %eax
c002cc17:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002cc1d:	50                   	push   %eax
c002cc1e:	8d 83 9c 43 ff ff    	lea    -0xbc64(%ebx),%eax
c002cc24:	50                   	push   %eax
c002cc25:	6a 34                	push   $0x34
c002cc27:	8d 83 3c 70 ff ff    	lea    -0x8fc4(%ebx),%eax
c002cc2d:	50                   	push   %eax
c002cc2e:	e8 b1 c2 ff ff       	call   c0028ee4 <debug_panic>

c002cc33 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002cc33:	55                   	push   %ebp
c002cc34:	57                   	push   %edi
c002cc35:	56                   	push   %esi
c002cc36:	53                   	push   %ebx
c002cc37:	83 ec 1c             	sub    $0x1c,%esp
c002cc3a:	e8 58 0c 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002cc3f:	81 c3 c1 d8 00 00    	add    $0xd8c1,%ebx
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002cc45:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002cc4b:	80 38 00             	cmpb   $0x0,(%eax)
c002cc4e:	74 27                	je     c002cc77 <test_mlfqs_load_1+0x44>

  msg ("spinning for up to 45 seconds, please wait...");
c002cc50:	83 ec 0c             	sub    $0xc,%esp
c002cc53:	8d 83 e8 70 ff ff    	lea    -0x8f18(%ebx),%eax
c002cc59:	50                   	push   %eax
c002cc5a:	e8 39 e2 ff ff       	call   c002ae98 <msg>

  start_time = timer_ticks ();
c002cc5f:	e8 1d 77 ff ff       	call   c0024381 <timer_ticks>
c002cc64:	89 c6                	mov    %eax,%esi
c002cc66:	89 d7                	mov    %edx,%edi
c002cc68:	83 c4 10             	add    $0x10,%esp
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
        break;
      else if (elapsed > 45)
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002cc6b:	8d 83 64 71 ff ff    	lea    -0x8e9c(%ebx),%eax
c002cc71:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002cc75:	eb 74                	jmp    c002cceb <test_mlfqs_load_1+0xb8>
  ASSERT (thread_mlfqs);
c002cc77:	83 ec 0c             	sub    $0xc,%esp
c002cc7a:	8d 83 d5 63 ff ff    	lea    -0x9c2b(%ebx),%eax
c002cc80:	50                   	push   %eax
c002cc81:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002cc87:	50                   	push   %eax
c002cc88:	8d 83 b8 43 ff ff    	lea    -0xbc48(%ebx),%eax
c002cc8e:	50                   	push   %eax
c002cc8f:	6a 18                	push   $0x18
c002cc91:	8d 83 c4 70 ff ff    	lea    -0x8f3c(%ebx),%eax
c002cc97:	50                   	push   %eax
c002cc98:	e8 47 c2 ff ff       	call   c0028ee4 <debug_panic>
      ASSERT (load_avg >= 0);
c002cc9d:	83 ec 0c             	sub    $0xc,%esp
c002cca0:	8d 83 9a 70 ff ff    	lea    -0x8f66(%ebx),%eax
c002cca6:	50                   	push   %eax
c002cca7:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002ccad:	50                   	push   %eax
c002ccae:	8d 83 b8 43 ff ff    	lea    -0xbc48(%ebx),%eax
c002ccb4:	50                   	push   %eax
c002ccb5:	6a 20                	push   $0x20
c002ccb7:	8d 83 c4 70 ff ff    	lea    -0x8f3c(%ebx),%eax
c002ccbd:	50                   	push   %eax
c002ccbe:	e8 21 c2 ff ff       	call   c0028ee4 <debug_panic>
        fail ("load average is %d.%02d "
c002ccc3:	50                   	push   %eax
c002ccc4:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002ccc9:	f7 ed                	imul   %ebp
c002cccb:	c1 fa 05             	sar    $0x5,%edx
c002ccce:	89 e8                	mov    %ebp,%eax
c002ccd0:	c1 f8 1f             	sar    $0x1f,%eax
c002ccd3:	29 c2                	sub    %eax,%edx
c002ccd5:	6b c2 64             	imul   $0x64,%edx,%eax
c002ccd8:	29 c5                	sub    %eax,%ebp
c002ccda:	55                   	push   %ebp
c002ccdb:	52                   	push   %edx
c002ccdc:	8d 83 18 71 ff ff    	lea    -0x8ee8(%ebx),%eax
c002cce2:	50                   	push   %eax
c002cce3:	e8 7c e2 ff ff       	call   c002af64 <fail>
c002cce8:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002cceb:	e8 ca 43 ff ff       	call   c00210ba <thread_get_load_avg>
c002ccf0:	89 c5                	mov    %eax,%ebp
      ASSERT (load_avg >= 0);
c002ccf2:	85 c0                	test   %eax,%eax
c002ccf4:	78 a7                	js     c002cc9d <test_mlfqs_load_1+0x6a>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002ccf6:	83 ec 08             	sub    $0x8,%esp
c002ccf9:	57                   	push   %edi
c002ccfa:	56                   	push   %esi
c002ccfb:	e8 b4 76 ff ff       	call   c00243b4 <timer_elapsed>
c002cd00:	6a 00                	push   $0x0
c002cd02:	6a 64                	push   $0x64
c002cd04:	52                   	push   %edx
c002cd05:	50                   	push   %eax
c002cd06:	e8 a3 bb ff ff       	call   c00288ae <__divdi3>
      if (load_avg > 100)
c002cd0b:	83 c4 20             	add    $0x20,%esp
c002cd0e:	83 fd 64             	cmp    $0x64,%ebp
c002cd11:	7f b0                	jg     c002ccc3 <test_mlfqs_load_1+0x90>
      else if (load_avg > 50)
c002cd13:	83 fd 32             	cmp    $0x32,%ebp
c002cd16:	7f 16                	jg     c002cd2e <test_mlfqs_load_1+0xfb>
      else if (elapsed > 45)
c002cd18:	83 f8 2d             	cmp    $0x2d,%eax
c002cd1b:	7e ce                	jle    c002cceb <test_mlfqs_load_1+0xb8>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002cd1d:	83 ec 0c             	sub    $0xc,%esp
c002cd20:	ff 74 24 18          	pushl  0x18(%esp)
c002cd24:	e8 3b e2 ff ff       	call   c002af64 <fail>
c002cd29:	83 c4 10             	add    $0x10,%esp
c002cd2c:	eb bd                	jmp    c002cceb <test_mlfqs_load_1+0xb8>
c002cd2e:	89 c7                	mov    %eax,%edi
    }

  if (elapsed < 38)
c002cd30:	83 f8 25             	cmp    $0x25,%eax
c002cd33:	7e 76                	jle    c002cdab <test_mlfqs_load_1+0x178>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002cd35:	83 ec 08             	sub    $0x8,%esp
c002cd38:	57                   	push   %edi
c002cd39:	8d 83 d0 71 ff ff    	lea    -0x8e30(%ebx),%eax
c002cd3f:	50                   	push   %eax
c002cd40:	e8 53 e1 ff ff       	call   c002ae98 <msg>

  msg ("sleeping for another 10 seconds, please wait...");
c002cd45:	8d 83 fc 71 ff ff    	lea    -0x8e04(%ebx),%eax
c002cd4b:	89 04 24             	mov    %eax,(%esp)
c002cd4e:	e8 45 e1 ff ff       	call   c002ae98 <msg>
  timer_sleep (TIMER_FREQ * 10);
c002cd53:	83 c4 08             	add    $0x8,%esp
c002cd56:	6a 00                	push   $0x0
c002cd58:	68 e8 03 00 00       	push   $0x3e8
c002cd5d:	e8 6e 76 ff ff       	call   c00243d0 <timer_sleep>

  load_avg = thread_get_load_avg ();
c002cd62:	e8 53 43 ff ff       	call   c00210ba <thread_get_load_avg>
c002cd67:	89 c6                	mov    %eax,%esi
  if (load_avg < 0)
c002cd69:	83 c4 10             	add    $0x10,%esp
c002cd6c:	85 c0                	test   %eax,%eax
c002cd6e:	78 53                	js     c002cdc3 <test_mlfqs_load_1+0x190>
    fail ("load average fell below 0");
  if (load_avg > 50)
c002cd70:	83 f8 32             	cmp    $0x32,%eax
c002cd73:	7f 62                	jg     c002cdd7 <test_mlfqs_load_1+0x1a4>
    fail ("load average stayed above 0.5 for more than 10 seconds");
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002cd75:	83 ec 04             	sub    $0x4,%esp
c002cd78:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002cd7d:	89 f0                	mov    %esi,%eax
c002cd7f:	f7 ea                	imul   %edx
c002cd81:	c1 fa 05             	sar    $0x5,%edx
c002cd84:	89 f0                	mov    %esi,%eax
c002cd86:	c1 f8 1f             	sar    $0x1f,%eax
c002cd89:	29 c2                	sub    %eax,%edx
c002cd8b:	6b c2 64             	imul   $0x64,%edx,%eax
c002cd8e:	29 c6                	sub    %eax,%esi
c002cd90:	56                   	push   %esi
c002cd91:	52                   	push   %edx
c002cd92:	8d 83 64 72 ff ff    	lea    -0x8d9c(%ebx),%eax
c002cd98:	50                   	push   %eax
c002cd99:	e8 fa e0 ff ff       	call   c002ae98 <msg>
       load_avg / 100, load_avg % 100);

  pass ();
c002cd9e:	e8 1b e2 ff ff       	call   c002afbe <pass>
}
c002cda3:	83 c4 2c             	add    $0x2c,%esp
c002cda6:	5b                   	pop    %ebx
c002cda7:	5e                   	pop    %esi
c002cda8:	5f                   	pop    %edi
c002cda9:	5d                   	pop    %ebp
c002cdaa:	c3                   	ret    
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002cdab:	83 ec 08             	sub    $0x8,%esp
c002cdae:	50                   	push   %eax
c002cdaf:	8d 83 9c 71 ff ff    	lea    -0x8e64(%ebx),%eax
c002cdb5:	50                   	push   %eax
c002cdb6:	e8 a9 e1 ff ff       	call   c002af64 <fail>
c002cdbb:	83 c4 10             	add    $0x10,%esp
c002cdbe:	e9 72 ff ff ff       	jmp    c002cd35 <test_mlfqs_load_1+0x102>
    fail ("load average fell below 0");
c002cdc3:	83 ec 0c             	sub    $0xc,%esp
c002cdc6:	8d 83 a8 70 ff ff    	lea    -0x8f58(%ebx),%eax
c002cdcc:	50                   	push   %eax
c002cdcd:	e8 92 e1 ff ff       	call   c002af64 <fail>
c002cdd2:	83 c4 10             	add    $0x10,%esp
c002cdd5:	eb 9e                	jmp    c002cd75 <test_mlfqs_load_1+0x142>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002cdd7:	83 ec 0c             	sub    $0xc,%esp
c002cdda:	8d 83 2c 72 ff ff    	lea    -0x8dd4(%ebx),%eax
c002cde0:	50                   	push   %eax
c002cde1:	e8 7e e1 ff ff       	call   c002af64 <fail>
c002cde6:	83 c4 10             	add    $0x10,%esp
c002cde9:	eb 8a                	jmp    c002cd75 <test_mlfqs_load_1+0x142>

c002cdeb <load_thread>:
    }
}

static void
load_thread (void *aux UNUSED) 
{
c002cdeb:	57                   	push   %edi
c002cdec:	56                   	push   %esi
c002cded:	53                   	push   %ebx
c002cdee:	e8 a4 0a 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002cdf3:	81 c3 0d d7 00 00    	add    $0xd70d,%ebx
  int64_t sleep_time = 10 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;

  thread_set_nice (20);
c002cdf9:	83 ec 0c             	sub    $0xc,%esp
c002cdfc:	6a 14                	push   $0x14
c002cdfe:	e8 8f 49 ff ff       	call   c0021792 <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002ce03:	83 c4 08             	add    $0x8,%esp
c002ce06:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002ce0c:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002ce12:	e8 9d 75 ff ff       	call   c00243b4 <timer_elapsed>
c002ce17:	83 c4 08             	add    $0x8,%esp
c002ce1a:	be e8 03 00 00       	mov    $0x3e8,%esi
c002ce1f:	bf 00 00 00 00       	mov    $0x0,%edi
c002ce24:	29 c6                	sub    %eax,%esi
c002ce26:	19 d7                	sbb    %edx,%edi
c002ce28:	57                   	push   %edi
c002ce29:	56                   	push   %esi
c002ce2a:	e8 a1 75 ff ff       	call   c00243d0 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002ce2f:	83 c4 10             	add    $0x10,%esp
c002ce32:	bf 57 1b 00 00       	mov    $0x1b57,%edi
c002ce37:	be 00 00 00 00       	mov    $0x0,%esi
c002ce3c:	83 ec 08             	sub    $0x8,%esp
c002ce3f:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002ce45:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002ce4b:	e8 64 75 ff ff       	call   c00243b4 <timer_elapsed>
c002ce50:	83 c4 10             	add    $0x10,%esp
c002ce53:	39 c7                	cmp    %eax,%edi
c002ce55:	89 f0                	mov    %esi,%eax
c002ce57:	19 d0                	sbb    %edx,%eax
c002ce59:	7d e1                	jge    c002ce3c <load_thread+0x51>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002ce5b:	83 ec 08             	sub    $0x8,%esp
c002ce5e:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002ce64:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002ce6a:	e8 45 75 ff ff       	call   c00243b4 <timer_elapsed>
c002ce6f:	83 c4 08             	add    $0x8,%esp
c002ce72:	be c8 32 00 00       	mov    $0x32c8,%esi
c002ce77:	bf 00 00 00 00       	mov    $0x0,%edi
c002ce7c:	29 c6                	sub    %eax,%esi
c002ce7e:	19 d7                	sbb    %edx,%edi
c002ce80:	57                   	push   %edi
c002ce81:	56                   	push   %esi
c002ce82:	e8 49 75 ff ff       	call   c00243d0 <timer_sleep>
}
c002ce87:	83 c4 10             	add    $0x10,%esp
c002ce8a:	5b                   	pop    %ebx
c002ce8b:	5e                   	pop    %esi
c002ce8c:	5f                   	pop    %edi
c002ce8d:	c3                   	ret    

c002ce8e <test_mlfqs_load_60>:
{
c002ce8e:	55                   	push   %ebp
c002ce8f:	57                   	push   %edi
c002ce90:	56                   	push   %esi
c002ce91:	53                   	push   %ebx
c002ce92:	83 ec 2c             	sub    $0x2c,%esp
c002ce95:	e8 fd 09 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002ce9a:	81 c3 66 d6 00 00    	add    $0xd666,%ebx
  ASSERT (thread_mlfqs);
c002cea0:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002cea6:	80 38 00             	cmpb   $0x0,(%eax)
c002cea9:	0f 84 29 01 00 00    	je     c002cfd8 <test_mlfqs_load_60+0x14a>
  start_time = timer_ticks ();
c002ceaf:	e8 cd 74 ff ff       	call   c0024381 <timer_ticks>
c002ceb4:	89 83 28 1d 00 00    	mov    %eax,0x1d28(%ebx)
c002ceba:	89 93 2c 1d 00 00    	mov    %edx,0x1d2c(%ebx)
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002cec0:	83 ec 08             	sub    $0x8,%esp
c002cec3:	6a 3c                	push   $0x3c
c002cec5:	8d 83 c0 72 ff ff    	lea    -0x8d40(%ebx),%eax
c002cecb:	50                   	push   %eax
c002cecc:	e8 c7 df ff ff       	call   c002ae98 <msg>
c002ced1:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002ced4:	be 00 00 00 00       	mov    $0x0,%esi
      snprintf(name, sizeof name, "load %d", i);
c002ced9:	8d ab 92 72 ff ff    	lea    -0x8d6e(%ebx),%ebp
c002cedf:	8d 7c 24 10          	lea    0x10(%esp),%edi
c002cee3:	56                   	push   %esi
c002cee4:	55                   	push   %ebp
c002cee5:	6a 10                	push   $0x10
c002cee7:	57                   	push   %edi
c002cee8:	e8 2c ab ff ff       	call   c0027a19 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002ceed:	6a 00                	push   $0x0
c002ceef:	8d 83 eb 28 ff ff    	lea    -0xd715(%ebx),%eax
c002cef5:	50                   	push   %eax
c002cef6:	6a 1f                	push   $0x1f
c002cef8:	57                   	push   %edi
c002cef9:	e8 5e 46 ff ff       	call   c002155c <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002cefe:	83 c6 01             	add    $0x1,%esi
c002cf01:	83 c4 20             	add    $0x20,%esp
c002cf04:	83 fe 3c             	cmp    $0x3c,%esi
c002cf07:	75 da                	jne    c002cee3 <test_mlfqs_load_60+0x55>
       timer_elapsed (start_time) / TIMER_FREQ);
c002cf09:	83 ec 08             	sub    $0x8,%esp
c002cf0c:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002cf12:	ff b3 28 1d 00 00    	pushl  0x1d28(%ebx)
c002cf18:	e8 97 74 ff ff       	call   c00243b4 <timer_elapsed>
  msg ("Starting threads took %d seconds.",
c002cf1d:	6a 00                	push   $0x0
c002cf1f:	6a 64                	push   $0x64
c002cf21:	52                   	push   %edx
c002cf22:	50                   	push   %eax
c002cf23:	e8 86 b9 ff ff       	call   c00288ae <__divdi3>
c002cf28:	83 c4 1c             	add    $0x1c,%esp
c002cf2b:	52                   	push   %edx
c002cf2c:	50                   	push   %eax
c002cf2d:	8d 83 e4 72 ff ff    	lea    -0x8d1c(%ebx),%eax
c002cf33:	50                   	push   %eax
c002cf34:	e8 5f df ff ff       	call   c002ae98 <msg>
c002cf39:	83 c4 10             	add    $0x10,%esp
c002cf3c:	bd 00 00 00 00       	mov    $0x0,%ebp
c002cf41:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
c002cf48:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002cf4f:	00 
      msg ("After %d seconds, load average=%d.%02d.",
c002cf50:	8d 83 08 73 ff ff    	lea    -0x8cf8(%ebx),%eax
c002cf56:	89 44 24 0c          	mov    %eax,0xc(%esp)
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002cf5a:	8b 34 24             	mov    (%esp),%esi
c002cf5d:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002cf61:	03 b3 28 1d 00 00    	add    0x1d28(%ebx),%esi
c002cf67:	13 bb 2c 1d 00 00    	adc    0x1d2c(%ebx),%edi
      timer_sleep (sleep_until - timer_ticks ());
c002cf6d:	e8 0f 74 ff ff       	call   c0024381 <timer_ticks>
c002cf72:	83 ec 08             	sub    $0x8,%esp
c002cf75:	29 c6                	sub    %eax,%esi
c002cf77:	19 d7                	sbb    %edx,%edi
c002cf79:	57                   	push   %edi
c002cf7a:	56                   	push   %esi
c002cf7b:	e8 50 74 ff ff       	call   c00243d0 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002cf80:	e8 35 41 ff ff       	call   c00210ba <thread_get_load_avg>
c002cf85:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002cf87:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002cf8c:	f7 e9                	imul   %ecx
c002cf8e:	c1 fa 05             	sar    $0x5,%edx
c002cf91:	89 c8                	mov    %ecx,%eax
c002cf93:	c1 f8 1f             	sar    $0x1f,%eax
c002cf96:	29 c2                	sub    %eax,%edx
c002cf98:	6b c2 64             	imul   $0x64,%edx,%eax
c002cf9b:	29 c1                	sub    %eax,%ecx
c002cf9d:	51                   	push   %ecx
c002cf9e:	52                   	push   %edx
c002cf9f:	55                   	push   %ebp
c002cfa0:	ff 74 24 28          	pushl  0x28(%esp)
c002cfa4:	e8 ef de ff ff       	call   c002ae98 <msg>
c002cfa9:	81 44 24 20 c8 00 00 	addl   $0xc8,0x20(%esp)
c002cfb0:	00 
c002cfb1:	83 54 24 24 00       	adcl   $0x0,0x24(%esp)
c002cfb6:	83 c5 02             	add    $0x2,%ebp
  for (i = 0; i < 90; i++) 
c002cfb9:	83 c4 20             	add    $0x20,%esp
c002cfbc:	8b 14 24             	mov    (%esp),%edx
c002cfbf:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002cfc3:	89 d0                	mov    %edx,%eax
c002cfc5:	35 38 4a 00 00       	xor    $0x4a38,%eax
c002cfca:	89 ca                	mov    %ecx,%edx
c002cfcc:	09 c2                	or     %eax,%edx
c002cfce:	75 8a                	jne    c002cf5a <test_mlfqs_load_60+0xcc>
}
c002cfd0:	83 c4 2c             	add    $0x2c,%esp
c002cfd3:	5b                   	pop    %ebx
c002cfd4:	5e                   	pop    %esi
c002cfd5:	5f                   	pop    %edi
c002cfd6:	5d                   	pop    %ebp
c002cfd7:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002cfd8:	83 ec 0c             	sub    $0xc,%esp
c002cfdb:	8d 83 d5 63 ff ff    	lea    -0x9c2b(%ebx),%eax
c002cfe1:	50                   	push   %eax
c002cfe2:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002cfe8:	50                   	push   %eax
c002cfe9:	8d 83 cc 43 ff ff    	lea    -0xbc34(%ebx),%eax
c002cfef:	50                   	push   %eax
c002cff0:	6a 77                	push   $0x77
c002cff2:	8d 83 9c 72 ff ff    	lea    -0x8d64(%ebx),%eax
c002cff8:	50                   	push   %eax
c002cff9:	e8 e6 be ff ff       	call   c0028ee4 <debug_panic>

c002cffe <load_thread>:
    }
}

static void
load_thread (void *seq_no_) 
{
c002cffe:	55                   	push   %ebp
c002cfff:	57                   	push   %edi
c002d000:	56                   	push   %esi
c002d001:	53                   	push   %ebx
c002d002:	83 ec 14             	sub    $0x14,%esp
c002d005:	e8 8d 08 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002d00a:	81 c3 f6 d4 00 00    	add    $0xd4f6,%ebx
  int seq_no = (int) seq_no_;
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002d010:	8b 44 24 28          	mov    0x28(%esp),%eax
c002d014:	8d 70 0a             	lea    0xa(%eax),%esi
c002d017:	6b f6 64             	imul   $0x64,%esi,%esi
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002d01a:	8d ae 70 17 00 00    	lea    0x1770(%esi),%ebp
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002d020:	ff b3 34 1d 00 00    	pushl  0x1d34(%ebx)
c002d026:	ff b3 30 1d 00 00    	pushl  0x1d30(%ebx)
c002d02c:	e8 83 73 ff ff       	call   c00243b4 <timer_elapsed>
c002d031:	83 c4 08             	add    $0x8,%esp
c002d034:	89 f7                	mov    %esi,%edi
c002d036:	c1 ff 1f             	sar    $0x1f,%edi
c002d039:	29 c6                	sub    %eax,%esi
c002d03b:	19 d7                	sbb    %edx,%edi
c002d03d:	57                   	push   %edi
c002d03e:	56                   	push   %esi
c002d03f:	e8 8c 73 ff ff       	call   c00243d0 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002d044:	83 c4 10             	add    $0x10,%esp
c002d047:	89 ef                	mov    %ebp,%edi
c002d049:	c1 ff 1f             	sar    $0x1f,%edi
c002d04c:	83 ec 08             	sub    $0x8,%esp
c002d04f:	ff b3 34 1d 00 00    	pushl  0x1d34(%ebx)
c002d055:	ff b3 30 1d 00 00    	pushl  0x1d30(%ebx)
c002d05b:	e8 54 73 ff ff       	call   c00243b4 <timer_elapsed>
c002d060:	83 c4 10             	add    $0x10,%esp
c002d063:	39 e8                	cmp    %ebp,%eax
c002d065:	19 fa                	sbb    %edi,%edx
c002d067:	7c e3                	jl     c002d04c <load_thread+0x4e>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002d069:	83 ec 08             	sub    $0x8,%esp
c002d06c:	ff b3 34 1d 00 00    	pushl  0x1d34(%ebx)
c002d072:	ff b3 30 1d 00 00    	pushl  0x1d30(%ebx)
c002d078:	e8 37 73 ff ff       	call   c00243b4 <timer_elapsed>
c002d07d:	83 c4 08             	add    $0x8,%esp
c002d080:	be e0 2e 00 00       	mov    $0x2ee0,%esi
c002d085:	bf 00 00 00 00       	mov    $0x0,%edi
c002d08a:	29 c6                	sub    %eax,%esi
c002d08c:	19 d7                	sbb    %edx,%edi
c002d08e:	57                   	push   %edi
c002d08f:	56                   	push   %esi
c002d090:	e8 3b 73 ff ff       	call   c00243d0 <timer_sleep>
}
c002d095:	83 c4 1c             	add    $0x1c,%esp
c002d098:	5b                   	pop    %ebx
c002d099:	5e                   	pop    %esi
c002d09a:	5f                   	pop    %edi
c002d09b:	5d                   	pop    %ebp
c002d09c:	c3                   	ret    

c002d09d <test_mlfqs_load_avg>:
{
c002d09d:	55                   	push   %ebp
c002d09e:	57                   	push   %edi
c002d09f:	56                   	push   %esi
c002d0a0:	53                   	push   %ebx
c002d0a1:	83 ec 2c             	sub    $0x2c,%esp
c002d0a4:	e8 ee 07 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002d0a9:	81 c3 57 d4 00 00    	add    $0xd457,%ebx
  ASSERT (thread_mlfqs);
c002d0af:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002d0b5:	80 38 00             	cmpb   $0x0,(%eax)
c002d0b8:	0f 84 34 01 00 00    	je     c002d1f2 <test_mlfqs_load_avg+0x155>
  start_time = timer_ticks ();
c002d0be:	e8 be 72 ff ff       	call   c0024381 <timer_ticks>
c002d0c3:	89 83 30 1d 00 00    	mov    %eax,0x1d30(%ebx)
c002d0c9:	89 93 34 1d 00 00    	mov    %edx,0x1d34(%ebx)
  msg ("Starting %d load threads...", THREAD_CNT);
c002d0cf:	83 ec 08             	sub    $0x8,%esp
c002d0d2:	6a 3c                	push   $0x3c
c002d0d4:	8d 83 30 73 ff ff    	lea    -0x8cd0(%ebx),%eax
c002d0da:	50                   	push   %eax
c002d0db:	e8 b8 dd ff ff       	call   c002ae98 <msg>
c002d0e0:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d0e3:	be 00 00 00 00       	mov    $0x0,%esi
      snprintf(name, sizeof name, "load %d", i);
c002d0e8:	8d ab 92 72 ff ff    	lea    -0x8d6e(%ebx),%ebp
c002d0ee:	8d 7c 24 10          	lea    0x10(%esp),%edi
c002d0f2:	56                   	push   %esi
c002d0f3:	55                   	push   %ebp
c002d0f4:	6a 10                	push   $0x10
c002d0f6:	57                   	push   %edi
c002d0f7:	e8 1d a9 ff ff       	call   c0027a19 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002d0fc:	56                   	push   %esi
c002d0fd:	8d 83 fe 2a ff ff    	lea    -0xd502(%ebx),%eax
c002d103:	50                   	push   %eax
c002d104:	6a 1f                	push   $0x1f
c002d106:	57                   	push   %edi
c002d107:	e8 50 44 ff ff       	call   c002155c <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002d10c:	83 c6 01             	add    $0x1,%esi
c002d10f:	83 c4 20             	add    $0x20,%esp
c002d112:	83 fe 3c             	cmp    $0x3c,%esi
c002d115:	75 db                	jne    c002d0f2 <test_mlfqs_load_avg+0x55>
       timer_elapsed (start_time) / TIMER_FREQ);
c002d117:	83 ec 08             	sub    $0x8,%esp
c002d11a:	ff b3 34 1d 00 00    	pushl  0x1d34(%ebx)
c002d120:	ff b3 30 1d 00 00    	pushl  0x1d30(%ebx)
c002d126:	e8 89 72 ff ff       	call   c00243b4 <timer_elapsed>
  msg ("Starting threads took %d seconds.",
c002d12b:	6a 00                	push   $0x0
c002d12d:	6a 64                	push   $0x64
c002d12f:	52                   	push   %edx
c002d130:	50                   	push   %eax
c002d131:	e8 78 b7 ff ff       	call   c00288ae <__divdi3>
c002d136:	83 c4 1c             	add    $0x1c,%esp
c002d139:	52                   	push   %edx
c002d13a:	50                   	push   %eax
c002d13b:	8d 83 e4 72 ff ff    	lea    -0x8d1c(%ebx),%eax
c002d141:	50                   	push   %eax
c002d142:	e8 51 dd ff ff       	call   c002ae98 <msg>
  thread_set_nice (-20);
c002d147:	c7 04 24 ec ff ff ff 	movl   $0xffffffec,(%esp)
c002d14e:	e8 3f 46 ff ff       	call   c0021792 <thread_set_nice>
c002d153:	83 c4 10             	add    $0x10,%esp
c002d156:	bd 00 00 00 00       	mov    $0x0,%ebp
c002d15b:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
c002d162:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002d169:	00 
      msg ("After %d seconds, load average=%d.%02d.",
c002d16a:	8d 83 08 73 ff ff    	lea    -0x8cf8(%ebx),%eax
c002d170:	89 44 24 0c          	mov    %eax,0xc(%esp)
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002d174:	8b 34 24             	mov    (%esp),%esi
c002d177:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002d17b:	03 b3 30 1d 00 00    	add    0x1d30(%ebx),%esi
c002d181:	13 bb 34 1d 00 00    	adc    0x1d34(%ebx),%edi
      timer_sleep (sleep_until - timer_ticks ());
c002d187:	e8 f5 71 ff ff       	call   c0024381 <timer_ticks>
c002d18c:	83 ec 08             	sub    $0x8,%esp
c002d18f:	29 c6                	sub    %eax,%esi
c002d191:	19 d7                	sbb    %edx,%edi
c002d193:	57                   	push   %edi
c002d194:	56                   	push   %esi
c002d195:	e8 36 72 ff ff       	call   c00243d0 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002d19a:	e8 1b 3f ff ff       	call   c00210ba <thread_get_load_avg>
c002d19f:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002d1a1:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d1a6:	f7 e9                	imul   %ecx
c002d1a8:	c1 fa 05             	sar    $0x5,%edx
c002d1ab:	89 c8                	mov    %ecx,%eax
c002d1ad:	c1 f8 1f             	sar    $0x1f,%eax
c002d1b0:	29 c2                	sub    %eax,%edx
c002d1b2:	6b c2 64             	imul   $0x64,%edx,%eax
c002d1b5:	29 c1                	sub    %eax,%ecx
c002d1b7:	51                   	push   %ecx
c002d1b8:	52                   	push   %edx
c002d1b9:	55                   	push   %ebp
c002d1ba:	ff 74 24 28          	pushl  0x28(%esp)
c002d1be:	e8 d5 dc ff ff       	call   c002ae98 <msg>
c002d1c3:	81 44 24 20 c8 00 00 	addl   $0xc8,0x20(%esp)
c002d1ca:	00 
c002d1cb:	83 54 24 24 00       	adcl   $0x0,0x24(%esp)
c002d1d0:	83 c5 02             	add    $0x2,%ebp
  for (i = 0; i < 90; i++) 
c002d1d3:	83 c4 20             	add    $0x20,%esp
c002d1d6:	8b 14 24             	mov    (%esp),%edx
c002d1d9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002d1dd:	89 d0                	mov    %edx,%eax
c002d1df:	35 38 4a 00 00       	xor    $0x4a38,%eax
c002d1e4:	89 ca                	mov    %ecx,%edx
c002d1e6:	09 c2                	or     %eax,%edx
c002d1e8:	75 8a                	jne    c002d174 <test_mlfqs_load_avg+0xd7>
}
c002d1ea:	83 c4 2c             	add    $0x2c,%esp
c002d1ed:	5b                   	pop    %ebx
c002d1ee:	5e                   	pop    %esi
c002d1ef:	5f                   	pop    %edi
c002d1f0:	5d                   	pop    %ebp
c002d1f1:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002d1f2:	83 ec 0c             	sub    $0xc,%esp
c002d1f5:	8d 83 d5 63 ff ff    	lea    -0x9c2b(%ebx),%eax
c002d1fb:	50                   	push   %eax
c002d1fc:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d202:	50                   	push   %eax
c002d203:	8d 83 e0 43 ff ff    	lea    -0xbc20(%ebx),%eax
c002d209:	50                   	push   %eax
c002d20a:	68 82 00 00 00       	push   $0x82
c002d20f:	8d 83 4c 73 ff ff    	lea    -0x8cb4(%ebx),%eax
c002d215:	50                   	push   %eax
c002d216:	e8 c9 bc ff ff       	call   c0028ee4 <debug_panic>

c002d21b <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002d21b:	55                   	push   %ebp
c002d21c:	57                   	push   %edi
c002d21d:	56                   	push   %esi
c002d21e:	53                   	push   %ebx
c002d21f:	83 ec 1c             	sub    $0x1c,%esp
c002d222:	e8 70 06 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002d227:	81 c3 d9 d2 00 00    	add    $0xd2d9,%ebx
  int64_t start_time;
  int last_elapsed = 0;
  
  ASSERT (thread_mlfqs);
c002d22d:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002d233:	80 38 00             	cmpb   $0x0,(%eax)
c002d236:	74 6b                	je     c002d2a3 <test_mlfqs_recent_1+0x88>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002d238:	8d ab 9c 73 ff ff    	lea    -0x8c64(%ebx),%ebp
c002d23e:	83 ec 0c             	sub    $0xc,%esp
c002d241:	55                   	push   %ebp
c002d242:	e8 51 dc ff ff       	call   c002ae98 <msg>
      start_time = timer_ticks ();
c002d247:	e8 35 71 ff ff       	call   c0024381 <timer_ticks>
c002d24c:	89 c6                	mov    %eax,%esi
c002d24e:	89 d7                	mov    %edx,%edi
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002d250:	83 c0 63             	add    $0x63,%eax
c002d253:	83 d2 00             	adc    $0x0,%edx
c002d256:	6a 00                	push   $0x0
c002d258:	6a 64                	push   $0x64
c002d25a:	52                   	push   %edx
c002d25b:	50                   	push   %eax
c002d25c:	e8 4d b6 ff ff       	call   c00288ae <__divdi3>
c002d261:	83 c4 18             	add    $0x18,%esp
c002d264:	29 f0                	sub    %esi,%eax
c002d266:	19 fa                	sbb    %edi,%edx
c002d268:	05 e8 03 00 00       	add    $0x3e8,%eax
c002d26d:	83 d2 00             	adc    $0x0,%edx
c002d270:	52                   	push   %edx
c002d271:	50                   	push   %eax
c002d272:	e8 59 71 ff ff       	call   c00243d0 <timer_sleep>
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002d277:	e8 99 3e ff ff       	call   c0021115 <thread_get_recent_cpu>
c002d27c:	83 c4 10             	add    $0x10,%esp
c002d27f:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002d284:	7f b8                	jg     c002d23e <test_mlfqs_recent_1+0x23>

  start_time = timer_ticks ();
c002d286:	e8 f6 70 ff ff       	call   c0024381 <timer_ticks>
c002d28b:	89 c6                	mov    %eax,%esi
c002d28d:	89 d7                	mov    %edx,%edi
  int last_elapsed = 0;
c002d28f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002d296:	00 
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
        {
          int recent_cpu = thread_get_recent_cpu ();
          int load_avg = thread_get_load_avg ();
          int elapsed_seconds = elapsed / TIMER_FREQ;
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002d297:	8d 83 e0 73 ff ff    	lea    -0x8c20(%ebx),%eax
c002d29d:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002d2a1:	eb 2a                	jmp    c002d2cd <test_mlfqs_recent_1+0xb2>
  ASSERT (thread_mlfqs);
c002d2a3:	83 ec 0c             	sub    $0xc,%esp
c002d2a6:	8d 83 d5 63 ff ff    	lea    -0x9c2b(%ebx),%eax
c002d2ac:	50                   	push   %eax
c002d2ad:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d2b3:	50                   	push   %eax
c002d2b4:	8d 83 f4 43 ff ff    	lea    -0xbc0c(%ebx),%eax
c002d2ba:	50                   	push   %eax
c002d2bb:	6a 73                	push   $0x73
c002d2bd:	8d 83 74 73 ff ff    	lea    -0x8c8c(%ebx),%eax
c002d2c3:	50                   	push   %eax
c002d2c4:	e8 1b bc ff ff       	call   c0028ee4 <debug_panic>
{
c002d2c9:	89 6c 24 08          	mov    %ebp,0x8(%esp)
      int elapsed = timer_elapsed (start_time);
c002d2cd:	83 ec 08             	sub    $0x8,%esp
c002d2d0:	57                   	push   %edi
c002d2d1:	56                   	push   %esi
c002d2d2:	e8 dd 70 ff ff       	call   c00243b4 <timer_elapsed>
c002d2d7:	89 c5                	mov    %eax,%ebp
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002d2d9:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d2de:	f7 ed                	imul   %ebp
c002d2e0:	c1 fa 06             	sar    $0x6,%edx
c002d2e3:	89 e8                	mov    %ebp,%eax
c002d2e5:	c1 f8 1f             	sar    $0x1f,%eax
c002d2e8:	29 c2                	sub    %eax,%edx
c002d2ea:	69 d2 c8 00 00 00    	imul   $0xc8,%edx,%edx
c002d2f0:	83 c4 10             	add    $0x10,%esp
c002d2f3:	39 d5                	cmp    %edx,%ebp
c002d2f5:	75 d2                	jne    c002d2c9 <test_mlfqs_recent_1+0xae>
c002d2f7:	39 6c 24 08          	cmp    %ebp,0x8(%esp)
c002d2fb:	7d cc                	jge    c002d2c9 <test_mlfqs_recent_1+0xae>
          int recent_cpu = thread_get_recent_cpu ();
c002d2fd:	e8 13 3e ff ff       	call   c0021115 <thread_get_recent_cpu>
c002d302:	89 44 24 08          	mov    %eax,0x8(%esp)
          int load_avg = thread_get_load_avg ();
c002d306:	e8 af 3d ff ff       	call   c00210ba <thread_get_load_avg>
c002d30b:	89 c1                	mov    %eax,%ecx
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002d30d:	83 ec 08             	sub    $0x8,%esp
c002d310:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d315:	f7 e9                	imul   %ecx
c002d317:	c1 fa 05             	sar    $0x5,%edx
c002d31a:	89 c8                	mov    %ecx,%eax
c002d31c:	c1 f8 1f             	sar    $0x1f,%eax
c002d31f:	29 c2                	sub    %eax,%edx
c002d321:	6b c2 64             	imul   $0x64,%edx,%eax
c002d324:	29 c1                	sub    %eax,%ecx
c002d326:	51                   	push   %ecx
c002d327:	52                   	push   %edx
c002d328:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d32d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c002d331:	f7 e9                	imul   %ecx
c002d333:	c1 fa 05             	sar    $0x5,%edx
c002d336:	89 c8                	mov    %ecx,%eax
c002d338:	c1 f8 1f             	sar    $0x1f,%eax
c002d33b:	29 c2                	sub    %eax,%edx
c002d33d:	6b c2 64             	imul   $0x64,%edx,%eax
c002d340:	29 c1                	sub    %eax,%ecx
c002d342:	51                   	push   %ecx
c002d343:	52                   	push   %edx
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002d344:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d349:	f7 ed                	imul   %ebp
c002d34b:	c1 fa 05             	sar    $0x5,%edx
c002d34e:	89 e8                	mov    %ebp,%eax
c002d350:	c1 f8 1f             	sar    $0x1f,%eax
c002d353:	29 c2                	sub    %eax,%edx
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002d355:	52                   	push   %edx
c002d356:	ff 74 24 28          	pushl  0x28(%esp)
c002d35a:	e8 39 db ff ff       	call   c002ae98 <msg>
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002d35f:	83 c4 20             	add    $0x20,%esp
c002d362:	81 fd 4f 46 00 00    	cmp    $0x464f,%ebp
c002d368:	0f 8e 5b ff ff ff    	jle    c002d2c9 <test_mlfqs_recent_1+0xae>
            break;
        } 
      last_elapsed = elapsed;
    }
}
c002d36e:	83 c4 1c             	add    $0x1c,%esp
c002d371:	5b                   	pop    %ebx
c002d372:	5e                   	pop    %esi
c002d373:	5f                   	pop    %edi
c002d374:	5d                   	pop    %ebp
c002d375:	c3                   	ret    

c002d376 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002d376:	55                   	push   %ebp
c002d377:	57                   	push   %edi
c002d378:	56                   	push   %esi
c002d379:	53                   	push   %ebx
c002d37a:	81 ec 7c 01 00 00    	sub    $0x17c,%esp
c002d380:	e8 12 05 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002d385:	81 c3 7b d1 00 00    	add    $0xd17b,%ebx
c002d38b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002d38f:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002d395:	80 38 00             	cmpb   $0x0,(%eax)
c002d398:	0f 84 91 00 00 00    	je     c002d42f <test_mlfqs_fair+0xb9>
c002d39e:	89 d6                	mov    %edx,%esi
c002d3a0:	89 cf                	mov    %ecx,%edi
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002d3a2:	83 7c 24 0c 14       	cmpl   $0x14,0xc(%esp)
c002d3a7:	0f 8f a8 00 00 00    	jg     c002d455 <test_mlfqs_fair+0xdf>
  ASSERT (nice_min >= -10);
c002d3ad:	83 fa f6             	cmp    $0xfffffff6,%edx
c002d3b0:	0f 8c c5 00 00 00    	jl     c002d47b <test_mlfqs_fair+0x105>
  ASSERT (nice_step >= 0);
c002d3b6:	85 c9                	test   %ecx,%ecx
c002d3b8:	0f 88 e3 00 00 00    	js     c002d4a1 <test_mlfqs_fair+0x12b>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002d3be:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d3c2:	83 e8 01             	sub    $0x1,%eax
c002d3c5:	0f af c1             	imul   %ecx,%eax
c002d3c8:	01 d0                	add    %edx,%eax
c002d3ca:	83 f8 14             	cmp    $0x14,%eax
c002d3cd:	0f 8f f4 00 00 00    	jg     c002d4c7 <test_mlfqs_fair+0x151>

  thread_set_nice (-20);
c002d3d3:	83 ec 0c             	sub    $0xc,%esp
c002d3d6:	6a ec                	push   $0xffffffec
c002d3d8:	e8 b5 43 ff ff       	call   c0021792 <thread_set_nice>

  start_time = timer_ticks ();
c002d3dd:	e8 9f 6f ff ff       	call   c0024381 <timer_ticks>
c002d3e2:	89 44 24 20          	mov    %eax,0x20(%esp)
c002d3e6:	89 54 24 24          	mov    %edx,0x24(%esp)
  msg ("Starting %d threads...", thread_cnt);
c002d3ea:	83 c4 08             	add    $0x8,%esp
c002d3ed:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c002d3f1:	55                   	push   %ebp
c002d3f2:	8d 83 5a 74 ff ff    	lea    -0x8ba6(%ebx),%eax
c002d3f8:	50                   	push   %eax
c002d3f9:	e8 9a da ff ff       	call   c002ae98 <msg>
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002d3fe:	83 c4 10             	add    $0x10,%esp
c002d401:	85 ed                	test   %ebp,%ebp
c002d403:	0f 8e b6 01 00 00    	jle    c002d5bf <test_mlfqs_fair+0x249>
c002d409:	8d 6c 24 30          	lea    0x30(%esp),%ebp
c002d40d:	b9 00 00 00 00       	mov    $0x0,%ecx
      // ASSERT(start_time == 26);
      ti->start_time = start_time;
      ti->tick_count = 0;
      ti->nice = nice;

      snprintf(name, sizeof name, "load %d", i);
c002d412:	8d 83 92 72 ff ff    	lea    -0x8d6e(%ebx),%eax
c002d418:	89 44 24 18          	mov    %eax,0x18(%esp)
c002d41c:	8d 44 24 20          	lea    0x20(%esp),%eax
c002d420:	89 44 24 08          	mov    %eax,0x8(%esp)
c002d424:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
c002d428:	89 cf                	mov    %ecx,%edi
c002d42a:	e9 c0 00 00 00       	jmp    c002d4ef <test_mlfqs_fair+0x179>
  ASSERT (thread_mlfqs);
c002d42f:	83 ec 0c             	sub    $0xc,%esp
c002d432:	8d 83 d5 63 ff ff    	lea    -0x9c2b(%ebx),%eax
c002d438:	50                   	push   %eax
c002d439:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d43f:	50                   	push   %eax
c002d440:	8d 83 08 44 ff ff    	lea    -0xbbf8(%ebx),%eax
c002d446:	50                   	push   %eax
c002d447:	6a 49                	push   $0x49
c002d449:	8d 83 90 74 ff ff    	lea    -0x8b70(%ebx),%eax
c002d44f:	50                   	push   %eax
c002d450:	e8 8f ba ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002d455:	83 ec 0c             	sub    $0xc,%esp
c002d458:	8d 83 1e 74 ff ff    	lea    -0x8be2(%ebx),%eax
c002d45e:	50                   	push   %eax
c002d45f:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d465:	50                   	push   %eax
c002d466:	8d 83 08 44 ff ff    	lea    -0xbbf8(%ebx),%eax
c002d46c:	50                   	push   %eax
c002d46d:	6a 4a                	push   $0x4a
c002d46f:	8d 83 90 74 ff ff    	lea    -0x8b70(%ebx),%eax
c002d475:	50                   	push   %eax
c002d476:	e8 69 ba ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (nice_min >= -10);
c002d47b:	83 ec 0c             	sub    $0xc,%esp
c002d47e:	8d 83 3b 74 ff ff    	lea    -0x8bc5(%ebx),%eax
c002d484:	50                   	push   %eax
c002d485:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d48b:	50                   	push   %eax
c002d48c:	8d 83 08 44 ff ff    	lea    -0xbbf8(%ebx),%eax
c002d492:	50                   	push   %eax
c002d493:	6a 4b                	push   $0x4b
c002d495:	8d 83 90 74 ff ff    	lea    -0x8b70(%ebx),%eax
c002d49b:	50                   	push   %eax
c002d49c:	e8 43 ba ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (nice_step >= 0);
c002d4a1:	83 ec 0c             	sub    $0xc,%esp
c002d4a4:	8d 83 4b 74 ff ff    	lea    -0x8bb5(%ebx),%eax
c002d4aa:	50                   	push   %eax
c002d4ab:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d4b1:	50                   	push   %eax
c002d4b2:	8d 83 08 44 ff ff    	lea    -0xbbf8(%ebx),%eax
c002d4b8:	50                   	push   %eax
c002d4b9:	6a 4c                	push   $0x4c
c002d4bb:	8d 83 90 74 ff ff    	lea    -0x8b70(%ebx),%eax
c002d4c1:	50                   	push   %eax
c002d4c2:	e8 1d ba ff ff       	call   c0028ee4 <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002d4c7:	83 ec 0c             	sub    $0xc,%esp
c002d4ca:	8d 83 b4 74 ff ff    	lea    -0x8b4c(%ebx),%eax
c002d4d0:	50                   	push   %eax
c002d4d1:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d4d7:	50                   	push   %eax
c002d4d8:	8d 83 08 44 ff ff    	lea    -0xbbf8(%ebx),%eax
c002d4de:	50                   	push   %eax
c002d4df:	6a 4d                	push   $0x4d
c002d4e1:	8d 83 90 74 ff ff    	lea    -0x8b70(%ebx),%eax
c002d4e7:	50                   	push   %eax
c002d4e8:	e8 f7 b9 ff ff       	call   c0028ee4 <debug_panic>
  for (i = 0; i < thread_cnt; i++) 
c002d4ed:	89 c7                	mov    %eax,%edi
      ti->start_time = start_time;
c002d4ef:	8b 44 24 10          	mov    0x10(%esp),%eax
c002d4f3:	8b 54 24 14          	mov    0x14(%esp),%edx
c002d4f7:	89 45 00             	mov    %eax,0x0(%ebp)
c002d4fa:	89 55 04             	mov    %edx,0x4(%ebp)
      ti->tick_count = 0;
c002d4fd:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
      ti->nice = nice;
c002d504:	89 75 0c             	mov    %esi,0xc(%ebp)
      snprintf(name, sizeof name, "load %d", i);
c002d507:	57                   	push   %edi
c002d508:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d50c:	6a 10                	push   $0x10
c002d50e:	ff 74 24 14          	pushl  0x14(%esp)
c002d512:	e8 02 a5 ff ff       	call   c0027a19 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002d517:	55                   	push   %ebp
c002d518:	8d 83 02 31 ff ff    	lea    -0xcefe(%ebx),%eax
c002d51e:	50                   	push   %eax
c002d51f:	6a 1f                	push   $0x1f
c002d521:	ff 74 24 24          	pushl  0x24(%esp)
c002d525:	e8 32 40 ff ff       	call   c002155c <thread_create>

      nice += nice_step;
c002d52a:	03 74 24 3c          	add    0x3c(%esp),%esi
  for (i = 0; i < thread_cnt; i++) 
c002d52e:	8d 47 01             	lea    0x1(%edi),%eax
c002d531:	83 c5 10             	add    $0x10,%ebp
c002d534:	83 c4 20             	add    $0x20,%esp
c002d537:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c002d53b:	75 b0                	jne    c002d4ed <test_mlfqs_fair+0x177>
c002d53d:	89 7c 24 08          	mov    %edi,0x8(%esp)
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002d541:	83 ec 08             	sub    $0x8,%esp
c002d544:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d548:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d54c:	e8 63 6e ff ff       	call   c00243b4 <timer_elapsed>
c002d551:	83 c4 0c             	add    $0xc,%esp
c002d554:	52                   	push   %edx
c002d555:	50                   	push   %eax
c002d556:	8d 83 e4 74 ff ff    	lea    -0x8b1c(%ebx),%eax
c002d55c:	50                   	push   %eax
c002d55d:	e8 36 d9 ff ff       	call   c002ae98 <msg>

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002d562:	8d 83 08 75 ff ff    	lea    -0x8af8(%ebx),%eax
c002d568:	89 04 24             	mov    %eax,(%esp)
c002d56b:	e8 28 d9 ff ff       	call   c002ae98 <msg>
  timer_sleep (40 * TIMER_FREQ);
c002d570:	83 c4 08             	add    $0x8,%esp
c002d573:	6a 00                	push   $0x0
c002d575:	68 a0 0f 00 00       	push   $0xfa0
c002d57a:	e8 51 6e ff ff       	call   c00243d0 <timer_sleep>
c002d57f:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002d582:	be 00 00 00 00       	mov    $0x0,%esi
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002d587:	8d 6c 24 38          	lea    0x38(%esp),%ebp
c002d58b:	8d bb 71 74 ff ff    	lea    -0x8b8f(%ebx),%edi
c002d591:	eb 02                	jmp    c002d595 <test_mlfqs_fair+0x21f>
  for (i = 0; i < thread_cnt; i++)
c002d593:	89 c6                	mov    %eax,%esi
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002d595:	83 ec 04             	sub    $0x4,%esp
c002d598:	89 f0                	mov    %esi,%eax
c002d59a:	c1 e0 04             	shl    $0x4,%eax
c002d59d:	ff 74 05 00          	pushl  0x0(%ebp,%eax,1)
c002d5a1:	56                   	push   %esi
c002d5a2:	57                   	push   %edi
c002d5a3:	e8 f0 d8 ff ff       	call   c002ae98 <msg>
  for (i = 0; i < thread_cnt; i++)
c002d5a8:	8d 46 01             	lea    0x1(%esi),%eax
c002d5ab:	83 c4 10             	add    $0x10,%esp
c002d5ae:	39 74 24 08          	cmp    %esi,0x8(%esp)
c002d5b2:	75 df                	jne    c002d593 <test_mlfqs_fair+0x21d>
}
c002d5b4:	81 c4 7c 01 00 00    	add    $0x17c,%esp
c002d5ba:	5b                   	pop    %ebx
c002d5bb:	5e                   	pop    %esi
c002d5bc:	5f                   	pop    %edi
c002d5bd:	5d                   	pop    %ebp
c002d5be:	c3                   	ret    
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002d5bf:	83 ec 08             	sub    $0x8,%esp
c002d5c2:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d5c6:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d5ca:	e8 e5 6d ff ff       	call   c00243b4 <timer_elapsed>
c002d5cf:	83 c4 0c             	add    $0xc,%esp
c002d5d2:	52                   	push   %edx
c002d5d3:	50                   	push   %eax
c002d5d4:	8d 83 e4 74 ff ff    	lea    -0x8b1c(%ebx),%eax
c002d5da:	50                   	push   %eax
c002d5db:	e8 b8 d8 ff ff       	call   c002ae98 <msg>
  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002d5e0:	8d 83 08 75 ff ff    	lea    -0x8af8(%ebx),%eax
c002d5e6:	89 04 24             	mov    %eax,(%esp)
c002d5e9:	e8 aa d8 ff ff       	call   c002ae98 <msg>
  timer_sleep (40 * TIMER_FREQ);
c002d5ee:	83 c4 08             	add    $0x8,%esp
c002d5f1:	6a 00                	push   $0x0
c002d5f3:	68 a0 0f 00 00       	push   $0xfa0
c002d5f8:	e8 d3 6d ff ff       	call   c00243d0 <timer_sleep>
c002d5fd:	83 c4 10             	add    $0x10,%esp
c002d600:	eb b2                	jmp    c002d5b4 <test_mlfqs_fair+0x23e>

c002d602 <load_thread>:

static void
load_thread (void *ti_) 
{
c002d602:	55                   	push   %ebp
c002d603:	57                   	push   %edi
c002d604:	56                   	push   %esi
c002d605:	53                   	push   %ebx
c002d606:	83 ec 28             	sub    $0x28,%esp
c002d609:	e8 89 02 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002d60e:	81 c3 f2 ce 00 00    	add    $0xcef2,%ebx
c002d614:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002d618:	89 c7                	mov    %eax,%edi
  struct thread_info *ti = ti_;
  int64_t sleep_time = 5 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
c002d61a:	ff 70 0c             	pushl  0xc(%eax)
c002d61d:	e8 70 41 ff ff       	call   c0021792 <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002d622:	83 c4 08             	add    $0x8,%esp
c002d625:	89 7c 24 14          	mov    %edi,0x14(%esp)
c002d629:	ff 77 04             	pushl  0x4(%edi)
c002d62c:	ff 37                	pushl  (%edi)
c002d62e:	e8 81 6d ff ff       	call   c00243b4 <timer_elapsed>
c002d633:	83 c4 08             	add    $0x8,%esp
c002d636:	bf f4 01 00 00       	mov    $0x1f4,%edi
c002d63b:	bd 00 00 00 00       	mov    $0x0,%ebp
c002d640:	29 c7                	sub    %eax,%edi
c002d642:	19 d5                	sbb    %edx,%ebp
c002d644:	55                   	push   %ebp
c002d645:	57                   	push   %edi
c002d646:	e8 85 6d ff ff       	call   c00243d0 <timer_sleep>
  while (timer_elapsed (ti->start_time) < spin_time) 
c002d64b:	83 c4 10             	add    $0x10,%esp
  int64_t last_time = 0;
c002d64e:	be 00 00 00 00       	mov    $0x0,%esi
c002d653:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002d65a:	00 
  while (timer_elapsed (ti->start_time) < spin_time) 
c002d65b:	bd 00 00 00 00       	mov    $0x0,%ebp
c002d660:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002d664:	eb 0a                	jmp    c002d670 <load_thread+0x6e>
    {
      int64_t cur_time = timer_ticks ();
      if (cur_time != last_time)
        ti->tick_count++;
c002d666:	83 47 08 01          	addl   $0x1,0x8(%edi)
{
c002d66a:	89 c6                	mov    %eax,%esi
c002d66c:	89 54 24 08          	mov    %edx,0x8(%esp)
  while (timer_elapsed (ti->start_time) < spin_time) 
c002d670:	83 ec 08             	sub    $0x8,%esp
c002d673:	ff 77 04             	pushl  0x4(%edi)
c002d676:	ff 37                	pushl  (%edi)
c002d678:	e8 37 6d ff ff       	call   c00243b4 <timer_elapsed>
c002d67d:	83 c4 10             	add    $0x10,%esp
c002d680:	b9 ab 0d 00 00       	mov    $0xdab,%ecx
c002d685:	39 c1                	cmp    %eax,%ecx
c002d687:	89 e8                	mov    %ebp,%eax
c002d689:	19 d0                	sbb    %edx,%eax
c002d68b:	7c 13                	jl     c002d6a0 <load_thread+0x9e>
      int64_t cur_time = timer_ticks ();
c002d68d:	e8 ef 6c ff ff       	call   c0024381 <timer_ticks>
      if (cur_time != last_time)
c002d692:	31 c6                	xor    %eax,%esi
c002d694:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002d698:	31 d1                	xor    %edx,%ecx
c002d69a:	09 f1                	or     %esi,%ecx
c002d69c:	75 c8                	jne    c002d666 <load_thread+0x64>
c002d69e:	eb ca                	jmp    c002d66a <load_thread+0x68>
      last_time = cur_time;
    }
}
c002d6a0:	83 c4 1c             	add    $0x1c,%esp
c002d6a3:	5b                   	pop    %ebx
c002d6a4:	5e                   	pop    %esi
c002d6a5:	5f                   	pop    %edi
c002d6a6:	5d                   	pop    %ebp
c002d6a7:	c3                   	ret    

c002d6a8 <test_mlfqs_fair_2>:
{
c002d6a8:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 0);
c002d6ab:	b9 00 00 00 00       	mov    $0x0,%ecx
c002d6b0:	ba 00 00 00 00       	mov    $0x0,%edx
c002d6b5:	b8 02 00 00 00       	mov    $0x2,%eax
c002d6ba:	e8 b7 fc ff ff       	call   c002d376 <test_mlfqs_fair>
}
c002d6bf:	83 c4 0c             	add    $0xc,%esp
c002d6c2:	c3                   	ret    

c002d6c3 <test_mlfqs_fair_20>:
{
c002d6c3:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (20, 0, 0);
c002d6c6:	b9 00 00 00 00       	mov    $0x0,%ecx
c002d6cb:	ba 00 00 00 00       	mov    $0x0,%edx
c002d6d0:	b8 14 00 00 00       	mov    $0x14,%eax
c002d6d5:	e8 9c fc ff ff       	call   c002d376 <test_mlfqs_fair>
}
c002d6da:	83 c4 0c             	add    $0xc,%esp
c002d6dd:	c3                   	ret    

c002d6de <test_mlfqs_nice_2>:
{
c002d6de:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 5);
c002d6e1:	b9 05 00 00 00       	mov    $0x5,%ecx
c002d6e6:	ba 00 00 00 00       	mov    $0x0,%edx
c002d6eb:	b8 02 00 00 00       	mov    $0x2,%eax
c002d6f0:	e8 81 fc ff ff       	call   c002d376 <test_mlfqs_fair>
}
c002d6f5:	83 c4 0c             	add    $0xc,%esp
c002d6f8:	c3                   	ret    

c002d6f9 <test_mlfqs_nice_10>:
{
c002d6f9:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (10, 0, 1);
c002d6fc:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d701:	ba 00 00 00 00       	mov    $0x0,%edx
c002d706:	b8 0a 00 00 00       	mov    $0xa,%eax
c002d70b:	e8 66 fc ff ff       	call   c002d376 <test_mlfqs_fair>
}
c002d710:	83 c4 0c             	add    $0xc,%esp
c002d713:	c3                   	ret    

c002d714 <block_thread>:
  msg ("Block thread should have already acquired lock.");
}

static void
block_thread (void *lock_) 
{
c002d714:	55                   	push   %ebp
c002d715:	57                   	push   %edi
c002d716:	56                   	push   %esi
c002d717:	53                   	push   %ebx
c002d718:	83 ec 18             	sub    $0x18,%esp
c002d71b:	e8 77 01 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002d720:	81 c3 e0 cd 00 00    	add    $0xcde0,%ebx
  struct lock *lock = lock_;
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002d726:	8d 83 40 75 ff ff    	lea    -0x8ac0(%ebx),%eax
c002d72c:	50                   	push   %eax
c002d72d:	e8 66 d7 ff ff       	call   c002ae98 <msg>
  start_time = timer_ticks ();
c002d732:	e8 4a 6c ff ff       	call   c0024381 <timer_ticks>
c002d737:	89 c6                	mov    %eax,%esi
c002d739:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002d73b:	83 c4 10             	add    $0x10,%esp
c002d73e:	bd 00 00 00 00       	mov    $0x0,%ebp
c002d743:	83 ec 08             	sub    $0x8,%esp
c002d746:	57                   	push   %edi
c002d747:	56                   	push   %esi
c002d748:	e8 67 6c ff ff       	call   c00243b4 <timer_elapsed>
c002d74d:	83 c4 10             	add    $0x10,%esp
c002d750:	b9 cf 07 00 00       	mov    $0x7cf,%ecx
c002d755:	39 c1                	cmp    %eax,%ecx
c002d757:	89 e8                	mov    %ebp,%eax
c002d759:	19 d0                	sbb    %edx,%eax
c002d75b:	7d e6                	jge    c002d743 <block_thread+0x2f>
    continue;

  msg ("Block thread acquiring lock...");
c002d75d:	83 ec 0c             	sub    $0xc,%esp
c002d760:	8d 83 68 75 ff ff    	lea    -0x8a98(%ebx),%eax
c002d766:	50                   	push   %eax
c002d767:	e8 2c d7 ff ff       	call   c002ae98 <msg>
  lock_acquire (lock);
c002d76c:	83 c4 04             	add    $0x4,%esp
c002d76f:	ff 74 24 2c          	pushl  0x2c(%esp)
c002d773:	e8 aa 58 ff ff       	call   c0023022 <lock_acquire>

  msg ("...got it.");
c002d778:	8d 83 40 76 ff ff    	lea    -0x89c0(%ebx),%eax
c002d77e:	89 04 24             	mov    %eax,(%esp)
c002d781:	e8 12 d7 ff ff       	call   c002ae98 <msg>
}
c002d786:	83 c4 1c             	add    $0x1c,%esp
c002d789:	5b                   	pop    %ebx
c002d78a:	5e                   	pop    %esi
c002d78b:	5f                   	pop    %edi
c002d78c:	5d                   	pop    %ebp
c002d78d:	c3                   	ret    

c002d78e <test_mlfqs_block>:
{
c002d78e:	55                   	push   %ebp
c002d78f:	57                   	push   %edi
c002d790:	56                   	push   %esi
c002d791:	53                   	push   %ebx
c002d792:	83 ec 3c             	sub    $0x3c,%esp
c002d795:	e8 fd 00 00 00       	call   c002d897 <__x86.get_pc_thunk.bx>
c002d79a:	81 c3 66 cd 00 00    	add    $0xcd66,%ebx
  ASSERT (thread_mlfqs);
c002d7a0:	c7 c0 40 c2 03 c0    	mov    $0xc003c240,%eax
c002d7a6:	80 38 00             	cmpb   $0x0,(%eax)
c002d7a9:	0f 84 c2 00 00 00    	je     c002d871 <test_mlfqs_block+0xe3>
  msg ("Main thread acquiring lock.");
c002d7af:	83 ec 0c             	sub    $0xc,%esp
c002d7b2:	8d 83 4b 76 ff ff    	lea    -0x89b5(%ebx),%eax
c002d7b8:	50                   	push   %eax
c002d7b9:	e8 da d6 ff ff       	call   c002ae98 <msg>
  lock_init (&lock);
c002d7be:	83 c4 04             	add    $0x4,%esp
c002d7c1:	8d 74 24 18          	lea    0x18(%esp),%esi
c002d7c5:	56                   	push   %esi
c002d7c6:	e8 ab 57 ff ff       	call   c0022f76 <lock_init>
  lock_acquire (&lock);
c002d7cb:	89 34 24             	mov    %esi,(%esp)
c002d7ce:	e8 4f 58 ff ff       	call   c0023022 <lock_acquire>
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002d7d3:	8d 83 ac 75 ff ff    	lea    -0x8a54(%ebx),%eax
c002d7d9:	89 04 24             	mov    %eax,(%esp)
c002d7dc:	e8 b7 d6 ff ff       	call   c002ae98 <msg>
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002d7e1:	56                   	push   %esi
c002d7e2:	8d 83 14 32 ff ff    	lea    -0xcdec(%ebx),%eax
c002d7e8:	50                   	push   %eax
c002d7e9:	6a 1f                	push   $0x1f
c002d7eb:	8d 83 ce 63 ff ff    	lea    -0x9c32(%ebx),%eax
c002d7f1:	50                   	push   %eax
c002d7f2:	e8 65 3d ff ff       	call   c002155c <thread_create>
  timer_sleep (25 * TIMER_FREQ);
c002d7f7:	83 c4 18             	add    $0x18,%esp
c002d7fa:	6a 00                	push   $0x0
c002d7fc:	68 c4 09 00 00       	push   $0x9c4
c002d801:	e8 ca 6b ff ff       	call   c00243d0 <timer_sleep>
  msg ("Main thread spinning for 5 seconds...");
c002d806:	8d 83 e8 75 ff ff    	lea    -0x8a18(%ebx),%eax
c002d80c:	89 04 24             	mov    %eax,(%esp)
c002d80f:	e8 84 d6 ff ff       	call   c002ae98 <msg>
  start_time = timer_ticks ();
c002d814:	e8 68 6b ff ff       	call   c0024381 <timer_ticks>
c002d819:	89 c6                	mov    %eax,%esi
c002d81b:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002d81d:	83 c4 10             	add    $0x10,%esp
c002d820:	bd 00 00 00 00       	mov    $0x0,%ebp
c002d825:	83 ec 08             	sub    $0x8,%esp
c002d828:	57                   	push   %edi
c002d829:	56                   	push   %esi
c002d82a:	e8 85 6b ff ff       	call   c00243b4 <timer_elapsed>
c002d82f:	83 c4 10             	add    $0x10,%esp
c002d832:	b9 f3 01 00 00       	mov    $0x1f3,%ecx
c002d837:	39 c1                	cmp    %eax,%ecx
c002d839:	89 e8                	mov    %ebp,%eax
c002d83b:	19 d0                	sbb    %edx,%eax
c002d83d:	7d e6                	jge    c002d825 <test_mlfqs_block+0x97>
  msg ("Main thread releasing lock.");
c002d83f:	83 ec 0c             	sub    $0xc,%esp
c002d842:	8d 83 67 76 ff ff    	lea    -0x8999(%ebx),%eax
c002d848:	50                   	push   %eax
c002d849:	e8 4a d6 ff ff       	call   c002ae98 <msg>
  lock_release (&lock);
c002d84e:	83 c4 04             	add    $0x4,%esp
c002d851:	8d 44 24 18          	lea    0x18(%esp),%eax
c002d855:	50                   	push   %eax
c002d856:	e8 c8 59 ff ff       	call   c0023223 <lock_release>
  msg ("Block thread should have already acquired lock.");
c002d85b:	8d 83 10 76 ff ff    	lea    -0x89f0(%ebx),%eax
c002d861:	89 04 24             	mov    %eax,(%esp)
c002d864:	e8 2f d6 ff ff       	call   c002ae98 <msg>
}
c002d869:	83 c4 4c             	add    $0x4c,%esp
c002d86c:	5b                   	pop    %ebx
c002d86d:	5e                   	pop    %esi
c002d86e:	5f                   	pop    %edi
c002d86f:	5d                   	pop    %ebp
c002d870:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002d871:	83 ec 0c             	sub    $0xc,%esp
c002d874:	8d 83 d5 63 ff ff    	lea    -0x9c2b(%ebx),%eax
c002d87a:	50                   	push   %eax
c002d87b:	8d 83 96 44 ff ff    	lea    -0xbb6a(%ebx),%eax
c002d881:	50                   	push   %eax
c002d882:	8d 83 18 44 ff ff    	lea    -0xbbe8(%ebx),%eax
c002d888:	50                   	push   %eax
c002d889:	6a 1c                	push   $0x1c
c002d88b:	8d 83 88 75 ff ff    	lea    -0x8a78(%ebx),%eax
c002d891:	50                   	push   %eax
c002d892:	e8 4d b6 ff ff       	call   c0028ee4 <debug_panic>

Disassembly of section .text.__x86.get_pc_thunk.bx:

c002d897 <__x86.get_pc_thunk.bx>:
c002d897:	8b 1c 24             	mov    (%esp),%ebx
c002d89a:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

c002d89b <__x86.get_pc_thunk.ax>:
c002d89b:	8b 04 24             	mov    (%esp),%eax
c002d89e:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bp:

c002d89f <__x86.get_pc_thunk.bp>:
c002d89f:	8b 2c 24             	mov    (%esp),%ebp
c002d8a2:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.di:

c002d8a3 <__x86.get_pc_thunk.di>:
c002d8a3:	8b 3c 24             	mov    (%esp),%edi
c002d8a6:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c002d8a7 <__x86.get_pc_thunk.dx>:
c002d8a7:	8b 14 24             	mov    (%esp),%edx
c002d8aa:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

c002d8ab <__x86.get_pc_thunk.cx>:
c002d8ab:	8b 0c 24             	mov    (%esp),%ecx
c002d8ae:	c3                   	ret    
