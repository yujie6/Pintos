
kernel.o：     文件格式 elf32-i386


Disassembly of section .text:

c00200b8 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c00200b8:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c00200bd:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c00200bf:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c00200c0:	b4 88                	mov    $0x88,%ah
	int $0x15
c00200c2:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c00200c4:	66 05 00 04          	add    $0x400,%ax
c00200c8:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c00200ca:	66 3d 00 00          	cmp    $0x0,%ax
c00200ce:	01 00                	add    %eax,(%eax)
	jbe 1f
c00200d0:	76 06                	jbe    c00200d8 <start+0x20>
	mov $0x10000, %eax
c00200d2:	66 b8 00 00          	mov    $0x0,%ax
c00200d6:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c00200d8:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c00200dc:	67 66 a3 be 01       	addr16 mov %ax,0x1be
c00200e1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200e3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200e5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200e7:	75 fa                	jne    c00200e3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200e9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200eb:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ed:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200ef:	a8 02                	test   $0x2,%al
	jnz 1b
c00200f1:	75 fa                	jne    c00200ed <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200f3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200f5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200f7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200f9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200fb:	75 fa                	jne    c00200f7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200fd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c0020102:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c0020105:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c0020108:	66 b9 00 04          	mov    $0x400,%cx
c002010c:	00 00                	add    %al,(%eax)
	rep stosl
c002010e:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c0020111:	66 b8 07 00          	mov    $0x7,%ax
c0020115:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c0020117:	66 b9 11 00          	mov    $0x11,%cx
c002011b:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c002011d:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020120:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c0020127:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c0020128:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c002012b:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c0020132:	00 e2                	add    %ah,%dl
	loop 1b
c0020134:	eb b8                	jmp    c00200ee <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c0020136:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c0020138:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c002013a:	66 b8 07 00          	mov    $0x7,%ax
c002013e:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020140:	66 b9 00 40          	mov    $0x4000,%cx
c0020144:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020146:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020149:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020150:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020151:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020156:	e2 f1                	loop   c0020149 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020158:	66 b8 00 f0          	mov    $0xf000,%ax
c002015c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002015e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020161:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020162:	67 66 0f 01 15       	lgdtw  (%di)
c0020167:	b8 01 00 00 0f       	mov    $0xf000001,%eax
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002016c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002016e:	66 0d 05 00          	or     $0x5,%ax
c0020172:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020178:	ea 7f 01 02 c0 08 00 	ljmp   $0x8,$0xc002017f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002017f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020183:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020185:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020187:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020189:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002018b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002018d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020193:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020198:	e8 2f 01 00 00       	call   c00202cc <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002019d:	eb fe                	jmp    c002019d <start+0xe5>
	...

c00201a0 <gdt>:
	...
c00201a8:	ff                   	(bad)  
c00201a9:	ff 00                	incl   (%eax)
c00201ab:	00 00                	add    %al,(%eax)
c00201ad:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c00201b4:	00                   	.byte 0x0
c00201b5:	92                   	xchg   %eax,%edx
c00201b6:	cf                   	iret   
	...

c00201b8 <gdtdesc>:
c00201b8:	17                   	pop    %ss
c00201b9:	00                   	.byte 0x0
c00201ba:	a0                   	.byte 0xa0
c00201bb:	01 02                	add    %eax,(%edx)
c00201bd:	c0                   	.byte 0xc0

c00201be <init_ram_pages>:
c00201be:	00 00                	add    %al,(%eax)
	...

c00201c2 <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device (enum block_type role, const char *name)
{
c00201c2:	55                   	push   %ebp
c00201c3:	57                   	push   %edi
c00201c4:	56                   	push   %esi
c00201c5:	53                   	push   %ebx
c00201c6:	83 ec 0c             	sub    $0xc,%esp
c00201c9:	e8 2a ed 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00201ce:	81 c3 5a af 01 00    	add    $0x1af5a,%ebx
c00201d4:	89 c7                	mov    %eax,%edi
  struct block *block = NULL;

  if (name != NULL)
c00201d6:	85 d2                	test   %edx,%edx
c00201d8:	74 70                	je     c002024a <locate_block_device+0x88>
c00201da:	89 d5                	mov    %edx,%ebp
    {
      block = block_get_by_name (name);
c00201dc:	83 ec 0c             	sub    $0xc,%esp
c00201df:	52                   	push   %edx
c00201e0:	e8 02 50 00 00       	call   c00251e7 <block_get_by_name>
c00201e5:	89 c6                	mov    %eax,%esi
      if (block == NULL)
c00201e7:	83 c4 10             	add    $0x10,%esp
c00201ea:	85 c0                	test   %eax,%eax
c00201ec:	74 39                	je     c0020227 <locate_block_device+0x65>
          break;
    }

  if (block != NULL)
    {
      printf ("%s: using %s\n", block_type_name (role), block_name (block));
c00201ee:	83 ec 0c             	sub    $0xc,%esp
c00201f1:	56                   	push   %esi
c00201f2:	e8 0a 51 00 00       	call   c0025301 <block_name>
c00201f7:	89 c5                	mov    %eax,%ebp
c00201f9:	89 3c 24             	mov    %edi,(%esp)
c00201fc:	e8 8f 4e 00 00       	call   c0025090 <block_type_name>
c0020201:	83 c4 0c             	add    $0xc,%esp
c0020204:	55                   	push   %ebp
c0020205:	50                   	push   %eax
c0020206:	8d 83 15 4f ff ff    	lea    -0xb0eb(%ebx),%eax
c002020c:	50                   	push   %eax
c002020d:	e8 6c 72 00 00       	call   c002747e <printf>
      block_set_role (role, block);
c0020212:	83 c4 08             	add    $0x8,%esp
c0020215:	56                   	push   %esi
c0020216:	57                   	push   %edi
c0020217:	e8 08 4f 00 00       	call   c0025124 <block_set_role>
c002021c:	83 c4 10             	add    $0x10,%esp
    }
}
c002021f:	83 c4 0c             	add    $0xc,%esp
c0020222:	5b                   	pop    %ebx
c0020223:	5e                   	pop    %esi
c0020224:	5f                   	pop    %edi
c0020225:	5d                   	pop    %ebp
c0020226:	c3                   	ret    
        PANIC ("No such block device \"%s\"", name);
c0020227:	83 ec 0c             	sub    $0xc,%esp
c002022a:	55                   	push   %ebp
c002022b:	8d 83 e6 4e ff ff    	lea    -0xb11a(%ebx),%eax
c0020231:	50                   	push   %eax
c0020232:	8d 83 04 3e ff ff    	lea    -0xc1fc(%ebx),%eax
c0020238:	50                   	push   %eax
c0020239:	68 ae 01 00 00       	push   $0x1ae
c002023e:	8d 83 00 4f ff ff    	lea    -0xb100(%ebx),%eax
c0020244:	50                   	push   %eax
c0020245:	e8 90 8e 00 00       	call   c00290da <debug_panic>
      for (block = block_first (); block != NULL; block = block_next (block))
c002024a:	e8 23 4f 00 00       	call   c0025172 <block_first>
c002024f:	89 c6                	mov    %eax,%esi
c0020251:	85 c0                	test   %eax,%eax
c0020253:	74 ca                	je     c002021f <locate_block_device+0x5d>
        if (block_type (block) == role)
c0020255:	83 ec 0c             	sub    $0xc,%esp
c0020258:	56                   	push   %esi
c0020259:	e8 ab 50 00 00       	call   c0025309 <block_type>
c002025e:	83 c4 10             	add    $0x10,%esp
c0020261:	39 f8                	cmp    %edi,%eax
c0020263:	74 14                	je     c0020279 <locate_block_device+0xb7>
      for (block = block_first (); block != NULL; block = block_next (block))
c0020265:	83 ec 0c             	sub    $0xc,%esp
c0020268:	56                   	push   %esi
c0020269:	e8 3e 4f 00 00       	call   c00251ac <block_next>
c002026e:	89 c6                	mov    %eax,%esi
c0020270:	83 c4 10             	add    $0x10,%esp
c0020273:	85 c0                	test   %eax,%eax
c0020275:	75 de                	jne    c0020255 <locate_block_device+0x93>
c0020277:	eb a6                	jmp    c002021f <locate_block_device+0x5d>
  if (block != NULL)
c0020279:	85 f6                	test   %esi,%esi
c002027b:	74 a2                	je     c002021f <locate_block_device+0x5d>
c002027d:	e9 6c ff ff ff       	jmp    c00201ee <locate_block_device+0x2c>

c0020282 <run_task>:
run_task(char **argv) {
c0020282:	56                   	push   %esi
c0020283:	53                   	push   %ebx
c0020284:	83 ec 0c             	sub    $0xc,%esp
c0020287:	e8 6c ec 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002028c:	81 c3 9c ae 01 00    	add    $0x1ae9c,%ebx
    const char *task = argv[1];
c0020292:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020296:	8b 70 04             	mov    0x4(%eax),%esi
    printf("Executing '%s':\n", task);
c0020299:	56                   	push   %esi
c002029a:	8d 83 23 4f ff ff    	lea    -0xb0dd(%ebx),%eax
c00202a0:	50                   	push   %eax
c00202a1:	e8 d8 71 00 00       	call   c002747e <printf>
    process_wait (process_execute (task));
c00202a6:	89 34 24             	mov    %esi,(%esp)
c00202a9:	e8 56 af 00 00       	call   c002b204 <process_execute>
c00202ae:	89 04 24             	mov    %eax,(%esp)
c00202b1:	e8 b9 b0 00 00       	call   c002b36f <process_wait>
    printf("Execution of '%s' complete.\n", task);
c00202b6:	83 c4 08             	add    $0x8,%esp
c00202b9:	56                   	push   %esi
c00202ba:	8d 83 34 4f ff ff    	lea    -0xb0cc(%ebx),%eax
c00202c0:	50                   	push   %eax
c00202c1:	e8 b8 71 00 00       	call   c002747e <printf>
}
c00202c6:	83 c4 14             	add    $0x14,%esp
c00202c9:	5b                   	pop    %ebx
c00202ca:	5e                   	pop    %esi
c00202cb:	c3                   	ret    

c00202cc <pintos_init>:
pintos_init(void) {
c00202cc:	55                   	push   %ebp
c00202cd:	57                   	push   %edi
c00202ce:	56                   	push   %esi
c00202cf:	53                   	push   %ebx
c00202d0:	83 ec 40             	sub    $0x40,%esp
c00202d3:	e8 20 ec 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00202d8:	81 c3 50 ae 01 00    	add    $0x1ae50,%ebx
    memset(&_start_bss, 0, &_end_bss - &_start_bss);
c00202de:	c7 c2 28 b1 03 c0    	mov    $0xc003b128,%edx
c00202e4:	c7 c0 88 d0 03 c0    	mov    $0xc003d088,%eax
c00202ea:	29 d0                	sub    %edx,%eax
c00202ec:	50                   	push   %eax
c00202ed:	6a 00                	push   $0x0
c00202ef:	52                   	push   %edx
c00202f0:	e8 54 83 00 00       	call   c0028649 <memset>
    argc = *(uint32_t *) ptov(LOADER_ARG_CNT);
c00202f5:	8b 3d 3a 7d 00 c0    	mov    0xc0007d3a,%edi
c00202fb:	89 7c 24 14          	mov    %edi,0x14(%esp)
    for (i = 0; i < argc; i++) {
c00202ff:	83 c4 10             	add    $0x10,%esp
c0020302:	be 00 00 00 00       	mov    $0x0,%esi
    p = ptov(LOADER_ARGS);
c0020307:	bd 3e 7d 00 c0       	mov    $0xc0007d3e,%ebp
    for (i = 0; i < argc; i++) {
c002030c:	85 ff                	test   %edi,%edi
c002030e:	0f 8e 3c 06 00 00    	jle    c0020950 <pintos_init+0x684>
        argv[i] = p;
c0020314:	89 ac b3 18 00 00 00 	mov    %ebp,0x18(%ebx,%esi,4)
        p += strnlen(p, end - p) + 1;
c002031b:	83 ec 08             	sub    $0x8,%esp
c002031e:	b8 be 7d 00 c0       	mov    $0xc0007dbe,%eax
c0020323:	29 e8                	sub    %ebp,%eax
c0020325:	50                   	push   %eax
c0020326:	55                   	push   %ebp
c0020327:	e8 c4 83 00 00       	call   c00286f0 <strnlen>
c002032c:	8d 6c 05 01          	lea    0x1(%ebp,%eax,1),%ebp
    for (i = 0; i < argc; i++) {
c0020330:	83 c6 01             	add    $0x1,%esi
c0020333:	83 c4 10             	add    $0x10,%esp
c0020336:	39 74 24 04          	cmp    %esi,0x4(%esp)
c002033a:	0f 84 d1 05 00 00    	je     c0020911 <pintos_init+0x645>
        if (p >= end)
c0020340:	81 fd bd 7d 00 c0    	cmp    $0xc0007dbd,%ebp
c0020346:	76 cc                	jbe    c0020314 <pintos_init+0x48>
            PANIC ("command line arguments overflow");
c0020348:	8d 83 2c 50 ff ff    	lea    -0xafd4(%ebx),%eax
c002034e:	50                   	push   %eax
c002034f:	8d 83 3c 3e ff ff    	lea    -0xc1c4(%ebx),%eax
c0020355:	50                   	push   %eax
c0020356:	68 e5 00 00 00       	push   $0xe5
c002035b:	8d 83 00 4f ff ff    	lea    -0xb100(%ebx),%eax
c0020361:	50                   	push   %eax
c0020362:	e8 73 8d 00 00       	call   c00290da <debug_panic>
            printf(" '%s'", argv[i]);
c0020367:	83 ec 08             	sub    $0x8,%esp
c002036a:	57                   	push   %edi
c002036b:	55                   	push   %ebp
c002036c:	e8 0d 71 00 00       	call   c002747e <printf>
c0020371:	83 c4 10             	add    $0x10,%esp
c0020374:	83 c6 04             	add    $0x4,%esi
    for (i = 0; i < argc; i++)
c0020377:	39 74 24 04          	cmp    %esi,0x4(%esp)
c002037b:	0f 84 ec 05 00 00    	je     c002096d <pintos_init+0x6a1>
        if (strchr(argv[i], ' ') == NULL)
c0020381:	8b 3e                	mov    (%esi),%edi
c0020383:	83 ec 08             	sub    $0x8,%esp
c0020386:	6a 20                	push   $0x20
c0020388:	57                   	push   %edi
c0020389:	e8 6d 80 00 00       	call   c00283fb <strchr>
c002038e:	83 c4 10             	add    $0x10,%esp
c0020391:	85 c0                	test   %eax,%eax
c0020393:	75 d2                	jne    c0020367 <pintos_init+0x9b>
            printf(" %s", argv[i]);
c0020395:	83 ec 08             	sub    $0x8,%esp
c0020398:	57                   	push   %edi
c0020399:	ff 74 24 14          	pushl  0x14(%esp)
c002039d:	e8 dc 70 00 00       	call   c002747e <printf>
c00203a2:	83 c4 10             	add    $0x10,%esp
c00203a5:	eb cd                	jmp    c0020374 <pintos_init+0xa8>
    printf("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00203a7:	83 ec 0c             	sub    $0xc,%esp
c00203aa:	8d 83 4c 50 ff ff    	lea    -0xafb4(%ebx),%eax
c00203b0:	50                   	push   %eax
c00203b1:	e8 fa ac 00 00       	call   c002b0b0 <puts>
    shutdown_power_off();
c00203b6:	e8 aa 68 00 00       	call   c0026c65 <shutdown_power_off>
            shutdown_configure(SHUTDOWN_POWER_OFF);
c00203bb:	83 ec 0c             	sub    $0xc,%esp
c00203be:	6a 01                	push   $0x1
c00203c0:	e8 0f 68 00 00       	call   c0026bd4 <shutdown_configure>
c00203c5:	83 c4 10             	add    $0x10,%esp
    for (; *argv != NULL && **argv == '-'; argv++) {
c00203c8:	83 44 24 04 04       	addl   $0x4,0x4(%esp)
c00203cd:	8b 44 24 04          	mov    0x4(%esp),%eax
c00203d1:	8b 00                	mov    (%eax),%eax
c00203d3:	85 c0                	test   %eax,%eax
c00203d5:	0f 84 ce 01 00 00    	je     c00205a9 <pintos_init+0x2dd>
c00203db:	80 38 2d             	cmpb   $0x2d,(%eax)
c00203de:	0f 85 af 01 00 00    	jne    c0020593 <pintos_init+0x2c7>
        char *name = strtok_r(*argv, "=", &save_ptr);
c00203e4:	83 ec 04             	sub    $0x4,%esp
c00203e7:	8b 7c 24 10          	mov    0x10(%esp),%edi
c00203eb:	57                   	push   %edi
c00203ec:	8d 93 cc 5e ff ff    	lea    -0xa134(%ebx),%edx
c00203f2:	52                   	push   %edx
c00203f3:	50                   	push   %eax
c00203f4:	e8 1c 81 00 00       	call   c0028515 <strtok_r>
c00203f9:	89 c5                	mov    %eax,%ebp
        char *value = strtok_r(NULL, "", &save_ptr);
c00203fb:	83 c4 0c             	add    $0xc,%esp
c00203fe:	57                   	push   %edi
c00203ff:	8d 83 46 6f ff ff    	lea    -0x90ba(%ebx),%eax
c0020405:	50                   	push   %eax
c0020406:	6a 00                	push   $0x0
c0020408:	e8 08 81 00 00       	call   c0028515 <strtok_r>
c002040d:	89 44 24 18          	mov    %eax,0x18(%esp)
        if (!strcmp(name, "-h"))
c0020411:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020416:	8d bb 57 4f ff ff    	lea    -0xb0a9(%ebx),%edi
c002041c:	89 ee                	mov    %ebp,%esi
c002041e:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020420:	0f 97 c0             	seta   %al
c0020423:	1c 00                	sbb    $0x0,%al
c0020425:	83 c4 10             	add    $0x10,%esp
c0020428:	84 c0                	test   %al,%al
c002042a:	0f 84 77 ff ff ff    	je     c00203a7 <pintos_init+0xdb>
        else if (!strcmp(name, "-q"))
c0020430:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020435:	8d bb 5a 4f ff ff    	lea    -0xb0a6(%ebx),%edi
c002043b:	89 ee                	mov    %ebp,%esi
c002043d:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002043f:	0f 97 c0             	seta   %al
c0020442:	1c 00                	sbb    $0x0,%al
c0020444:	84 c0                	test   %al,%al
c0020446:	0f 84 6f ff ff ff    	je     c00203bb <pintos_init+0xef>
        else if (!strcmp(name, "-r"))
c002044c:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020451:	8d bb 5d 4f ff ff    	lea    -0xb0a3(%ebx),%edi
c0020457:	89 ee                	mov    %ebp,%esi
c0020459:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002045b:	0f 97 c0             	seta   %al
c002045e:	1c 00                	sbb    $0x0,%al
c0020460:	84 c0                	test   %al,%al
c0020462:	74 24                	je     c0020488 <pintos_init+0x1bc>
            else if (!strcmp (name, "-f"))
c0020464:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020469:	8d bb 60 4f ff ff    	lea    -0xb0a0(%ebx),%edi
c002046f:	89 ee                	mov    %ebp,%esi
c0020471:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020473:	0f 97 c0             	seta   %al
c0020476:	1c 00                	sbb    $0x0,%al
c0020478:	84 c0                	test   %al,%al
c002047a:	75 1e                	jne    c002049a <pintos_init+0x1ce>
              format_filesys = true;
c002047c:	c6 83 24 01 00 00 01 	movb   $0x1,0x124(%ebx)
c0020483:	e9 40 ff ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            shutdown_configure(SHUTDOWN_REBOOT);
c0020488:	83 ec 0c             	sub    $0xc,%esp
c002048b:	6a 02                	push   $0x2
c002048d:	e8 42 67 00 00       	call   c0026bd4 <shutdown_configure>
c0020492:	83 c4 10             	add    $0x10,%esp
c0020495:	e9 2e ff ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            else if (!strcmp (name, "-filesys"))
c002049a:	b9 09 00 00 00       	mov    $0x9,%ecx
c002049f:	8d bb 63 4f ff ff    	lea    -0xb09d(%ebx),%edi
c00204a5:	89 ee                	mov    %ebp,%esi
c00204a7:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204a9:	0f 97 c0             	seta   %al
c00204ac:	1c 00                	sbb    $0x0,%al
c00204ae:	84 c0                	test   %al,%al
c00204b0:	75 0f                	jne    c00204c1 <pintos_init+0x1f5>
              filesys_bdev_name = value;
c00204b2:	8b 44 24 08          	mov    0x8(%esp),%eax
c00204b6:	89 83 20 01 00 00    	mov    %eax,0x120(%ebx)
c00204bc:	e9 07 ff ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            else if (!strcmp (name, "-scratch"))
c00204c1:	b9 09 00 00 00       	mov    $0x9,%ecx
c00204c6:	8d bb 6c 4f ff ff    	lea    -0xb094(%ebx),%edi
c00204cc:	89 ee                	mov    %ebp,%esi
c00204ce:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204d0:	0f 97 c0             	seta   %al
c00204d3:	1c 00                	sbb    $0x0,%al
c00204d5:	84 c0                	test   %al,%al
c00204d7:	75 0f                	jne    c00204e8 <pintos_init+0x21c>
              scratch_bdev_name = value;
c00204d9:	8b 44 24 08          	mov    0x8(%esp),%eax
c00204dd:	89 83 1c 01 00 00    	mov    %eax,0x11c(%ebx)
c00204e3:	e9 e0 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
        else if (!strcmp(name, "-rs"))
c00204e8:	b9 04 00 00 00       	mov    $0x4,%ecx
c00204ed:	8d bb 75 4f ff ff    	lea    -0xb08b(%ebx),%edi
c00204f3:	89 ee                	mov    %ebp,%esi
c00204f5:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204f7:	0f 97 c0             	seta   %al
c00204fa:	1c 00                	sbb    $0x0,%al
c00204fc:	84 c0                	test   %al,%al
c00204fe:	74 23                	je     c0020523 <pintos_init+0x257>
        else if (!strcmp(name, "-mlfqs"))
c0020500:	83 ec 08             	sub    $0x8,%esp
c0020503:	8d 83 79 4f ff ff    	lea    -0xb087(%ebx),%eax
c0020509:	50                   	push   %eax
c002050a:	55                   	push   %ebp
c002050b:	e8 80 7e 00 00       	call   c0028390 <strcmp>
c0020510:	83 c4 10             	add    $0x10,%esp
c0020513:	85 c0                	test   %eax,%eax
c0020515:	75 28                	jne    c002053f <pintos_init+0x273>
            thread_mlfqs = true;
c0020517:	8b 44 24 10          	mov    0x10(%esp),%eax
c002051b:	c6 00 01             	movb   $0x1,(%eax)
c002051e:	e9 a5 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            random_init(atoi(value));
c0020523:	83 ec 0c             	sub    $0xc,%esp
c0020526:	ff 74 24 14          	pushl  0x14(%esp)
c002052a:	e8 f4 7a 00 00       	call   c0028023 <atoi>
c002052f:	89 04 24             	mov    %eax,(%esp)
c0020532:	e8 55 69 00 00       	call   c0026e8c <random_init>
c0020537:	83 c4 10             	add    $0x10,%esp
c002053a:	e9 89 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            else if (!strcmp (name, "-ul"))
c002053f:	83 ec 08             	sub    $0x8,%esp
c0020542:	8d 83 80 4f ff ff    	lea    -0xb080(%ebx),%eax
c0020548:	50                   	push   %eax
c0020549:	55                   	push   %ebp
c002054a:	e8 41 7e 00 00       	call   c0028390 <strcmp>
c002054f:	83 c4 10             	add    $0x10,%esp
c0020552:	85 c0                	test   %eax,%eax
c0020554:	75 1a                	jne    c0020570 <pintos_init+0x2a4>
              user_page_limit = atoi (value);
c0020556:	83 ec 0c             	sub    $0xc,%esp
c0020559:	ff 74 24 14          	pushl  0x14(%esp)
c002055d:	e8 c1 7a 00 00       	call   c0028023 <atoi>
c0020562:	89 83 b8 fb ff ff    	mov    %eax,-0x448(%ebx)
c0020568:	83 c4 10             	add    $0x10,%esp
c002056b:	e9 58 fe ff ff       	jmp    c00203c8 <pintos_init+0xfc>
            PANIC ("unknown option `%s' (use -h for help)", name);
c0020570:	83 ec 0c             	sub    $0xc,%esp
c0020573:	55                   	push   %ebp
c0020574:	8d 83 74 54 ff ff    	lea    -0xab8c(%ebx),%eax
c002057a:	50                   	push   %eax
c002057b:	8d 83 2c 3e ff ff    	lea    -0xc1d4(%ebx),%eax
c0020581:	50                   	push   %eax
c0020582:	68 1c 01 00 00       	push   $0x11c
c0020587:	8d 83 00 4f ff ff    	lea    -0xb100(%ebx),%eax
c002058d:	50                   	push   %eax
c002058e:	e8 47 8b 00 00       	call   c00290da <debug_panic>
c0020593:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c0020597:	eb 14                	jmp    c00205ad <pintos_init+0x2e1>
    for (; *argv != NULL && **argv == '-'; argv++) {
c0020599:	8d ab 18 00 00 00    	lea    0x18(%ebx),%ebp
c002059f:	eb 0c                	jmp    c00205ad <pintos_init+0x2e1>
c00205a1:	8d ab 18 00 00 00    	lea    0x18(%ebx),%ebp
c00205a7:	eb 04                	jmp    c00205ad <pintos_init+0x2e1>
c00205a9:	8b 6c 24 04          	mov    0x4(%esp),%ebp
    random_init(rtc_get_time());
c00205ad:	e8 b5 64 00 00       	call   c0026a67 <rtc_get_time>
c00205b2:	83 ec 0c             	sub    $0xc,%esp
c00205b5:	50                   	push   %eax
c00205b6:	e8 d1 68 00 00       	call   c0026e8c <random_init>
    global_load_avg = fix_int(0);
c00205bb:	c7 c0 7c d0 03 c0    	mov    $0xc003d07c,%eax
c00205c1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    thread_init();
c00205c7:	e8 e3 07 00 00       	call   c0020daf <thread_init>
    console_init();
c00205cc:	e8 37 aa 00 00       	call   c002b008 <console_init>
    printf("Pintos booting with %'"PRIu32" kB RAM...\n",
c00205d1:	83 c4 08             	add    $0x8,%esp
           init_ram_pages * PGSIZE / 1024);
c00205d4:	c7 c6 be 01 02 c0    	mov    $0xc00201be,%esi
c00205da:	8b 06                	mov    (%esi),%eax
c00205dc:	c1 e0 0c             	shl    $0xc,%eax
    printf("Pintos booting with %'"PRIu32" kB RAM...\n",
c00205df:	c1 e8 0a             	shr    $0xa,%eax
c00205e2:	50                   	push   %eax
c00205e3:	8d 83 9c 54 ff ff    	lea    -0xab64(%ebx),%eax
c00205e9:	50                   	push   %eax
c00205ea:	e8 8f 6e 00 00       	call   c002747e <printf>
    palloc_init(user_page_limit);
c00205ef:	83 c4 04             	add    $0x4,%esp
c00205f2:	ff b3 b8 fb ff ff    	pushl  -0x448(%ebx)
c00205f8:	e8 8f 32 00 00       	call   c002388c <palloc_init>
    malloc_init();
c00205fd:	e8 08 37 00 00       	call   c0023d0a <malloc_init>
    pd = init_page_dir = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c0020602:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0020609:	e8 db 33 00 00       	call   c00239e9 <palloc_get_page>
c002060e:	89 c1                	mov    %eax,%ecx
c0020610:	89 44 24 20          	mov    %eax,0x20(%esp)
c0020614:	c7 c0 78 d0 03 c0    	mov    $0xc003d078,%eax
c002061a:	89 08                	mov    %ecx,(%eax)
    for (page = 0; page < init_ram_pages; page++) {
c002061c:	83 c4 10             	add    $0x10,%esp
c002061f:	83 3e 00             	cmpl   $0x0,(%esi)
c0020622:	0f 84 61 01 00 00    	je     c0020789 <pintos_init+0x4bd>
c0020628:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
    pt = NULL;
c002062d:	b9 00 00 00 00       	mov    $0x0,%ecx
    for (page = 0; page < init_ram_pages; page++) {
c0020632:	ba 00 00 00 00       	mov    $0x0,%edx
        bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020637:	c7 c0 00 30 03 c0    	mov    $0xc0033000,%eax
c002063d:	89 44 24 14          	mov    %eax,0x14(%esp)
c0020641:	c7 c0 00 00 02 c0    	mov    $0xc0020000,%eax
c0020647:	89 44 24 18          	mov    %eax,0x18(%esp)
c002064b:	89 c8                	mov    %ecx,%eax
c002064d:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c0020651:	89 d5                	mov    %edx,%ebp
c0020653:	e9 80 00 00 00       	jmp    c00206d8 <pintos_init+0x40c>
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create(uint32_t *pt) {
    ASSERT (pg_ofs(pt) == 0);
c0020658:	83 ec 0c             	sub    $0xc,%esp
c002065b:	8d 83 84 4f ff ff    	lea    -0xb07c(%ebx),%eax
c0020661:	50                   	push   %eax
c0020662:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020668:	50                   	push   %eax
c0020669:	8d 83 20 3e ff ff    	lea    -0xc1e0(%ebx),%eax
c002066f:	50                   	push   %eax
c0020670:	6a 48                	push   $0x48
c0020672:	8d 83 ab 4f ff ff    	lea    -0xb055(%ebx),%eax
c0020678:	50                   	push   %eax
c0020679:	e8 5c 8a 00 00       	call   c00290da <debug_panic>
   is mapped. */
static inline uintptr_t
vtop(const void *vaddr) {
    ASSERT (is_kernel_vaddr(vaddr));

    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002067e:	81 c2 00 00 00 40    	add    $0x40000000,%edx
    return vtop(pt) | PTE_U | PTE_P | PTE_W;
c0020684:	83 ca 07             	or     $0x7,%edx
c0020687:	89 16                	mov    %edx,(%esi)
        pt[pte_idx] = pte_create_kernel(vaddr, !in_kernel_text);
c0020689:	8b 54 24 08          	mov    0x8(%esp),%edx
c002068d:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
c0020690:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    ASSERT (is_kernel_vaddr(vaddr));
c0020694:	81 7c 24 0c ff ff ff 	cmpl   $0xbfffffff,0xc(%esp)
c002069b:	bf 
c002069c:	0f 86 bd 00 00 00    	jbe    c002075f <pintos_init+0x493>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00206a2:	89 e9                	mov    %ebp,%ecx
c00206a4:	c1 e1 0c             	shl    $0xc,%ecx
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel(void *page, bool writable) {
    ASSERT (pg_ofs(page) == 0);
    return vtop(page) | PTE_P | (writable ? PTE_W : 0);
c00206a7:	0f b6 74 24 04       	movzbl 0x4(%esp),%esi
c00206ac:	83 f6 01             	xor    $0x1,%esi
c00206af:	89 f2                	mov    %esi,%edx
c00206b1:	0f b6 f2             	movzbl %dl,%esi
c00206b4:	01 f6                	add    %esi,%esi
c00206b6:	09 f1                	or     %esi,%ecx
c00206b8:	83 c9 01             	or     $0x1,%ecx
c00206bb:	8b 54 24 08          	mov    0x8(%esp),%edx
c00206bf:	89 0a                	mov    %ecx,(%edx)
    for (page = 0; page < init_ram_pages; page++) {
c00206c1:	83 c5 01             	add    $0x1,%ebp
c00206c4:	81 c7 00 10 00 00    	add    $0x1000,%edi
c00206ca:	c7 c2 be 01 02 c0    	mov    $0xc00201be,%edx
c00206d0:	3b 2a                	cmp    (%edx),%ebp
c00206d2:	0f 83 ad 00 00 00    	jae    c0020785 <pintos_init+0x4b9>
    return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00206d8:	89 fa                	mov    %edi,%edx
c00206da:	c1 ea 0c             	shr    $0xc,%edx
c00206dd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c00206e3:	89 54 24 08          	mov    %edx,0x8(%esp)
        bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c00206e7:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c00206eb:	3b 7c 24 14          	cmp    0x14(%esp),%edi
c00206ef:	0f 92 c1             	setb   %cl
c00206f2:	3b 7c 24 18          	cmp    0x18(%esp),%edi
c00206f6:	0f 93 c2             	setae  %dl
c00206f9:	21 d1                	and    %edx,%ecx
c00206fb:	88 4c 24 04          	mov    %cl,0x4(%esp)
    return (uintptr_t) va >> PDSHIFT;
c00206ff:	89 fa                	mov    %edi,%edx
c0020701:	c1 ea 16             	shr    $0x16,%edx
        if (pd[pde_idx] == 0) {
c0020704:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0020708:	8d 34 91             	lea    (%ecx,%edx,4),%esi
c002070b:	83 3e 00             	cmpl   $0x0,(%esi)
c002070e:	0f 85 75 ff ff ff    	jne    c0020689 <pintos_init+0x3bd>
            pt = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c0020714:	83 ec 0c             	sub    $0xc,%esp
c0020717:	6a 03                	push   $0x3
c0020719:	e8 cb 32 00 00       	call   c00239e9 <palloc_get_page>
    return (uintptr_t) va & PGMASK;
c002071e:	89 c2                	mov    %eax,%edx
    ASSERT (pg_ofs(pt) == 0);
c0020720:	83 c4 10             	add    $0x10,%esp
c0020723:	a9 ff 0f 00 00       	test   $0xfff,%eax
c0020728:	0f 85 2a ff ff ff    	jne    c0020658 <pintos_init+0x38c>
    ASSERT (is_kernel_vaddr(vaddr));
c002072e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020733:	0f 87 45 ff ff ff    	ja     c002067e <pintos_init+0x3b2>
c0020739:	83 ec 0c             	sub    $0xc,%esp
c002073c:	8d 83 bf 4f ff ff    	lea    -0xb041(%ebx),%eax
c0020742:	50                   	push   %eax
c0020743:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020749:	50                   	push   %eax
c002074a:	8d 83 18 3e ff ff    	lea    -0xc1e8(%ebx),%eax
c0020750:	50                   	push   %eax
c0020751:	6a 55                	push   $0x55
c0020753:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c0020759:	50                   	push   %eax
c002075a:	e8 7b 89 00 00       	call   c00290da <debug_panic>
c002075f:	83 ec 0c             	sub    $0xc,%esp
c0020762:	8d 83 bf 4f ff ff    	lea    -0xb041(%ebx),%eax
c0020768:	50                   	push   %eax
c0020769:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002076f:	50                   	push   %eax
c0020770:	8d 83 18 3e ff ff    	lea    -0xc1e8(%ebx),%eax
c0020776:	50                   	push   %eax
c0020777:	6a 55                	push   $0x55
c0020779:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002077f:	50                   	push   %eax
c0020780:	e8 55 89 00 00       	call   c00290da <debug_panic>
c0020785:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
    asm volatile ("movl %0, %%cr3" : : "r" (vtop(init_page_dir)));
c0020789:	c7 c0 78 d0 03 c0    	mov    $0xc003d078,%eax
c002078f:	8b 00                	mov    (%eax),%eax
c0020791:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020796:	0f 86 a4 00 00 00    	jbe    c0020840 <pintos_init+0x574>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002079c:	05 00 00 00 40       	add    $0x40000000,%eax
c00207a1:	0f 22 d8             	mov    %eax,%cr3
    tss_init ();
c00207a4:	e8 ca cb 00 00       	call   c002d373 <tss_init>
    gdt_init ();
c00207a9:	e8 5a ca 00 00       	call   c002d208 <gdt_init>
    intr_init();
c00207ae:	e8 7d 15 00 00       	call   c0021d30 <intr_init>
    timer_init();
c00207b3:	e8 8b 3c 00 00       	call   c0024443 <timer_init>
    kbd_init();
c00207b8:	e8 13 42 00 00       	call   c00249d0 <kbd_init>
    input_init();
c00207bd:	e8 39 5d 00 00       	call   c00264fb <input_init>
    exception_init ();
c00207c2:	e8 24 be 00 00       	call   c002c5eb <exception_init>
    syscall_init ();
c00207c7:	e8 88 bf 00 00       	call   c002c754 <syscall_init>
    thread_start();
c00207cc:	e8 df 10 00 00       	call   c00218b0 <thread_start>
    serial_init_queue();
c00207d1:	e8 a8 46 00 00       	call   c0024e7e <serial_init_queue>
    timer_calibrate();
c00207d6:	e8 9f 3c 00 00       	call   c002447a <timer_calibrate>
    ide_init ();
c00207db:	e8 db 57 00 00       	call   c0025fbb <ide_init>
  locate_block_device (BLOCK_FILESYS, filesys_bdev_name);
c00207e0:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
c00207e6:	b8 01 00 00 00       	mov    $0x1,%eax
c00207eb:	e8 d2 f9 ff ff       	call   c00201c2 <locate_block_device>
  locate_block_device (BLOCK_SCRATCH, scratch_bdev_name);
c00207f0:	8b 93 1c 01 00 00    	mov    0x11c(%ebx),%edx
c00207f6:	b8 02 00 00 00       	mov    $0x2,%eax
c00207fb:	e8 c2 f9 ff ff       	call   c00201c2 <locate_block_device>
    filesys_init (format_filesys);
c0020800:	83 ec 0c             	sub    $0xc,%esp
c0020803:	0f b6 83 24 01 00 00 	movzbl 0x124(%ebx),%eax
c002080a:	50                   	push   %eax
c002080b:	e8 95 cb 00 00       	call   c002d3a5 <filesys_init>
    printf("Boot complete.\n");
c0020810:	8d 83 ec 4f ff ff    	lea    -0xb014(%ebx),%eax
c0020816:	89 04 24             	mov    %eax,(%esp)
c0020819:	e8 92 a8 00 00       	call   c002b0b0 <puts>
    if (*argv != NULL) {
c002081e:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020821:	83 c4 10             	add    $0x10,%esp
            if (a->name == NULL)
c0020824:	8d 83 6b 58 ff ff    	lea    -0xa795(%ebx),%eax
c002082a:	89 44 24 04          	mov    %eax,0x4(%esp)
    if (*argv != NULL) {
c002082e:	85 ff                	test   %edi,%edi
c0020830:	0f 85 94 00 00 00    	jne    c00208ca <pintos_init+0x5fe>
    shutdown();
c0020836:	e8 d2 64 00 00       	call   c0026d0d <shutdown>
    thread_exit();
c002083b:	e8 95 0d 00 00       	call   c00215d5 <thread_exit>
    ASSERT (is_kernel_vaddr(vaddr));
c0020840:	83 ec 0c             	sub    $0xc,%esp
c0020843:	8d 83 bf 4f ff ff    	lea    -0xb041(%ebx),%eax
c0020849:	50                   	push   %eax
c002084a:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020850:	50                   	push   %eax
c0020851:	8d 83 18 3e ff ff    	lea    -0xc1e8(%ebx),%eax
c0020857:	50                   	push   %eax
c0020858:	6a 55                	push   $0x55
c002085a:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c0020860:	50                   	push   %eax
c0020861:	e8 74 88 00 00       	call   c00290da <debug_panic>
        for (i = 1; i < a->argc; i++)
c0020866:	8b 56 04             	mov    0x4(%esi),%edx
c0020869:	83 fa 01             	cmp    $0x1,%edx
c002086c:	7e 40                	jle    c00208ae <pintos_init+0x5e2>
            if (argv[i] == NULL)
c002086e:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c0020872:	74 13                	je     c0020887 <pintos_init+0x5bb>
        for (i = 1; i < a->argc; i++)
c0020874:	b8 01 00 00 00       	mov    $0x1,%eax
c0020879:	83 c0 01             	add    $0x1,%eax
c002087c:	39 c2                	cmp    %eax,%edx
c002087e:	74 2e                	je     c00208ae <pintos_init+0x5e2>
            if (argv[i] == NULL)
c0020880:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c0020885:	75 f2                	jne    c0020879 <pintos_init+0x5ad>
                PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020887:	83 ec 08             	sub    $0x8,%esp
c002088a:	83 ea 01             	sub    $0x1,%edx
c002088d:	52                   	push   %edx
c002088e:	57                   	push   %edi
c002088f:	8d 83 e8 54 ff ff    	lea    -0xab18(%ebx),%eax
c0020895:	50                   	push   %eax
c0020896:	8d 83 f8 3d ff ff    	lea    -0xc208(%ebx),%eax
c002089c:	50                   	push   %eax
c002089d:	68 62 01 00 00       	push   $0x162
c00208a2:	8d 83 00 4f ff ff    	lea    -0xb100(%ebx),%eax
c00208a8:	50                   	push   %eax
c00208a9:	e8 2c 88 00 00       	call   c00290da <debug_panic>
        a->function(argv);
c00208ae:	83 ec 0c             	sub    $0xc,%esp
c00208b1:	55                   	push   %ebp
c00208b2:	ff 56 08             	call   *0x8(%esi)
        argv += a->argc;
c00208b5:	8b 46 04             	mov    0x4(%esi),%eax
c00208b8:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
    while (*argv != NULL) {
c00208bc:	8b 7d 00             	mov    0x0(%ebp),%edi
c00208bf:	83 c4 10             	add    $0x10,%esp
c00208c2:	85 ff                	test   %edi,%edi
c00208c4:	0f 84 6c ff ff ff    	je     c0020836 <pintos_init+0x56a>
            if (a->name == NULL)
c00208ca:	8b 44 24 04          	mov    0x4(%esp),%eax
        for (a = actions;; a++)
c00208ce:	8d b3 f8 76 ff ff    	lea    -0x8908(%ebx),%esi
            else if (!strcmp(*argv, a->name))
c00208d4:	83 ec 08             	sub    $0x8,%esp
c00208d7:	50                   	push   %eax
c00208d8:	57                   	push   %edi
c00208d9:	e8 b2 7a 00 00       	call   c0028390 <strcmp>
c00208de:	83 c4 10             	add    $0x10,%esp
c00208e1:	85 c0                	test   %eax,%eax
c00208e3:	74 81                	je     c0020866 <pintos_init+0x59a>
        for (a = actions;; a++)
c00208e5:	83 c6 0c             	add    $0xc,%esi
            if (a->name == NULL)
c00208e8:	8b 06                	mov    (%esi),%eax
c00208ea:	85 c0                	test   %eax,%eax
c00208ec:	75 e6                	jne    c00208d4 <pintos_init+0x608>
                PANIC ("unknown action `%s' (use -h for help)", *argv);
c00208ee:	83 ec 0c             	sub    $0xc,%esp
c00208f1:	57                   	push   %edi
c00208f2:	8d 83 c0 54 ff ff    	lea    -0xab40(%ebx),%eax
c00208f8:	50                   	push   %eax
c00208f9:	8d 83 f8 3d ff ff    	lea    -0xc208(%ebx),%eax
c00208ff:	50                   	push   %eax
c0020900:	68 5b 01 00 00       	push   $0x15b
c0020905:	8d 83 00 4f ff ff    	lea    -0xb100(%ebx),%eax
c002090b:	50                   	push   %eax
c002090c:	e8 c9 87 00 00       	call   c00290da <debug_panic>
    argv[argc] = NULL;
c0020911:	8d ab 18 00 00 00    	lea    0x18(%ebx),%ebp
c0020917:	c7 44 b5 00 00 00 00 	movl   $0x0,0x0(%ebp,%esi,4)
c002091e:	00 
    printf("Kernel command line:");
c002091f:	83 ec 0c             	sub    $0xc,%esp
c0020922:	8d 83 fb 4f ff ff    	lea    -0xb005(%ebx),%eax
c0020928:	50                   	push   %eax
c0020929:	e8 50 6b 00 00       	call   c002747e <printf>
    for (i = 0; i < argc; i++)
c002092e:	89 ee                	mov    %ebp,%esi
c0020930:	8d 44 bd 00          	lea    0x0(%ebp,%edi,4),%eax
c0020934:	89 44 24 14          	mov    %eax,0x14(%esp)
c0020938:	83 c4 10             	add    $0x10,%esp
            printf(" '%s'", argv[i]);
c002093b:	8d ab 51 4f ff ff    	lea    -0xb0af(%ebx),%ebp
            printf(" %s", argv[i]);
c0020941:	8d 83 3b 60 ff ff    	lea    -0x9fc5(%ebx),%eax
c0020947:	89 44 24 08          	mov    %eax,0x8(%esp)
c002094b:	e9 31 fa ff ff       	jmp    c0020381 <pintos_init+0xb5>
    argv[argc] = NULL;
c0020950:	c7 84 bb 18 00 00 00 	movl   $0x0,0x18(%ebx,%edi,4)
c0020957:	00 00 00 00 
    printf("Kernel command line:");
c002095b:	83 ec 0c             	sub    $0xc,%esp
c002095e:	8d 83 fb 4f ff ff    	lea    -0xb005(%ebx),%eax
c0020964:	50                   	push   %eax
c0020965:	e8 14 6b 00 00       	call   c002747e <printf>
c002096a:	83 c4 10             	add    $0x10,%esp
    printf("\n");
c002096d:	83 ec 0c             	sub    $0xc,%esp
c0020970:	6a 0a                	push   $0xa
c0020972:	e8 ab a7 00 00       	call   c002b122 <putchar>
    for (; *argv != NULL && **argv == '-'; argv++) {
c0020977:	8b 83 18 00 00 00    	mov    0x18(%ebx),%eax
c002097d:	83 c4 10             	add    $0x10,%esp
c0020980:	85 c0                	test   %eax,%eax
c0020982:	0f 84 11 fc ff ff    	je     c0020599 <pintos_init+0x2cd>
c0020988:	80 38 2d             	cmpb   $0x2d,(%eax)
c002098b:	0f 85 10 fc ff ff    	jne    c00205a1 <pintos_init+0x2d5>
c0020991:	8d ab 18 00 00 00    	lea    0x18(%ebx),%ebp
        char *name = strtok_r(*argv, "=", &save_ptr);
c0020997:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c002099b:	89 54 24 0c          	mov    %edx,0xc(%esp)
            thread_mlfqs = true;
c002099f:	c7 c1 80 d0 03 c0    	mov    $0xc003d080,%ecx
c00209a5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00209a9:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00209ad:	e9 32 fa ff ff       	jmp    c00203e4 <pintos_init+0x118>

c00209b2 <thread_cmp_priority>:
bool thread_cmp_priority(const struct list_elem *a,
                         const struct list_elem *b,
                         void *aux) {
    int priority_a = list_entry(a, struct thread, elem)->priority;
    int priority_b = list_entry(b, struct thread, elem)->priority;
    return priority_a > priority_b;
c00209b2:	8b 54 24 04          	mov    0x4(%esp),%edx
c00209b6:	8b 44 24 08          	mov    0x8(%esp),%eax
c00209ba:	8b 80 1c ff ff ff    	mov    -0xe4(%eax),%eax
c00209c0:	39 82 1c ff ff ff    	cmp    %eax,-0xe4(%edx)
c00209c6:	0f 9f c0             	setg   %al
}
c00209c9:	c3                   	ret    

c00209ca <lock_cmp_priority>:
bool lock_cmp_priority(const struct list_elem *a,
                       const struct list_elem *b,
                       void *aux) {
    int priority_a = list_entry(a, struct lock, elem)->max_priority;
    int priority_b = list_entry(b, struct lock, elem)->max_priority;
    return priority_a > priority_b;
c00209ca:	8b 54 24 04          	mov    0x4(%esp),%edx
c00209ce:	8b 44 24 08          	mov    0x8(%esp),%eax
c00209d2:	8b 40 08             	mov    0x8(%eax),%eax
c00209d5:	39 42 08             	cmp    %eax,0x8(%edx)
c00209d8:	0f 9f c0             	setg   %al
}
c00209db:	c3                   	ret    

c00209dc <update_thread_recent_cpu>:
void update_thread_recent_cpu(struct thread *t, void *aux) {
c00209dc:	55                   	push   %ebp
c00209dd:	57                   	push   %edi
c00209de:	56                   	push   %esi
c00209df:	53                   	push   %ebx
c00209e0:	83 ec 1c             	sub    $0x1c,%esp
c00209e3:	e8 10 e5 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00209e8:	81 c3 40 a7 01 00    	add    $0x1a740,%ebx
c00209ee:	8b 6c 24 30          	mov    0x30(%esp),%ebp

/* Returns X * Y. */
static inline fixed_point_t
fix_mul (fixed_point_t x, fixed_point_t y)
{
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c00209f2:	c7 c0 7c d0 03 c0    	mov    $0xc003d07c,%eax
c00209f8:	8b 00                	mov    (%eax),%eax
c00209fa:	99                   	cltd   
c00209fb:	0f a4 c2 11          	shld   $0x11,%eax,%edx
c00209ff:	c1 e0 11             	shl    $0x11,%eax
c0020a02:	89 d1                	mov    %edx,%ecx
c0020a04:	c1 f9 1f             	sar    $0x1f,%ecx
c0020a07:	0f b7 f1             	movzwl %cx,%esi
c0020a0a:	bf 00 00 00 00       	mov    $0x0,%edi
c0020a0f:	01 c6                	add    %eax,%esi
c0020a11:	11 d7                	adc    %edx,%edi
c0020a13:	89 f0                	mov    %esi,%eax
c0020a15:	0f ac f8 10          	shrd   $0x10,%edi,%eax

/* Returns X / Y. */
static inline fixed_point_t
fix_div (fixed_point_t x, fixed_point_t y)
{
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c0020a19:	89 c1                	mov    %eax,%ecx
c0020a1b:	c1 f9 1f             	sar    $0x1f,%ecx
c0020a1e:	89 c6                	mov    %eax,%esi
c0020a20:	89 cf                	mov    %ecx,%edi
c0020a22:	0f a4 c7 10          	shld   $0x10,%eax,%edi
c0020a26:	c1 e6 10             	shl    $0x10,%esi
    return __mk_fix (x.f + y.f);
c0020a29:	05 00 00 01 00       	add    $0x10000,%eax
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c0020a2e:	99                   	cltd   
c0020a2f:	52                   	push   %edx
c0020a30:	50                   	push   %eax
c0020a31:	57                   	push   %edi
c0020a32:	56                   	push   %esi
c0020a33:	e8 6c 80 00 00       	call   c0028aa4 <__divdi3>
c0020a38:	83 c4 10             	add    $0x10,%esp
c0020a3b:	89 04 24             	mov    %eax,(%esp)
    t->recent_cpu = fix_add(fix_mul(t->recent_cpu, tmp), fix_int(t->nice));
c0020a3e:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0020a41:	89 54 24 0c          	mov    %edx,0xc(%esp)
    ASSERT (n >= FIX_MIN_INT && n <= FIX_MAX_INT);
c0020a45:	81 c2 ff ff 00 00    	add    $0xffff,%edx
c0020a4b:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
c0020a51:	77 65                	ja     c0020ab8 <update_thread_recent_cpu+0xdc>
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0020a53:	8b 45 20             	mov    0x20(%ebp),%eax
c0020a56:	89 44 24 08          	mov    %eax,0x8(%esp)
c0020a5a:	89 c7                	mov    %eax,%edi
c0020a5c:	c1 ff 1f             	sar    $0x1f,%edi
c0020a5f:	8b 0c 24             	mov    (%esp),%ecx
c0020a62:	89 cb                	mov    %ecx,%ebx
c0020a64:	c1 fb 1f             	sar    $0x1f,%ebx
c0020a67:	89 fe                	mov    %edi,%esi
c0020a69:	0f af 34 24          	imul   (%esp),%esi
c0020a6d:	89 d9                	mov    %ebx,%ecx
c0020a6f:	0f af c8             	imul   %eax,%ecx
c0020a72:	01 f1                	add    %esi,%ecx
c0020a74:	8b 04 24             	mov    (%esp),%eax
c0020a77:	f7 64 24 08          	mull   0x8(%esp)
c0020a7b:	89 04 24             	mov    %eax,(%esp)
c0020a7e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0020a82:	01 4c 24 04          	add    %ecx,0x4(%esp)
c0020a86:	8b 74 24 04          	mov    0x4(%esp),%esi
c0020a8a:	c1 fe 1f             	sar    $0x1f,%esi
c0020a8d:	0f b7 ce             	movzwl %si,%ecx
c0020a90:	bb 00 00 00 00       	mov    $0x0,%ebx
c0020a95:	8b 04 24             	mov    (%esp),%eax
c0020a98:	8b 54 24 04          	mov    0x4(%esp),%edx
c0020a9c:	01 c8                	add    %ecx,%eax
c0020a9e:	11 da                	adc    %ebx,%edx
c0020aa0:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return __mk_fix (n * FIX_F);
c0020aa4:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0020aa8:	c1 e1 10             	shl    $0x10,%ecx
    return __mk_fix (x.f + y.f);
c0020aab:	01 c8                	add    %ecx,%eax
c0020aad:	89 45 20             	mov    %eax,0x20(%ebp)
}
c0020ab0:	83 c4 1c             	add    $0x1c,%esp
c0020ab3:	5b                   	pop    %ebx
c0020ab4:	5e                   	pop    %esi
c0020ab5:	5f                   	pop    %edi
c0020ab6:	5d                   	pop    %ebp
c0020ab7:	c3                   	ret    
    ASSERT (n >= FIX_MIN_INT && n <= FIX_MAX_INT);
c0020ab8:	83 ec 0c             	sub    $0xc,%esp
c0020abb:	8d 83 0c 55 ff ff    	lea    -0xaaf4(%ebx),%eax
c0020ac1:	50                   	push   %eax
c0020ac2:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020ac8:	50                   	push   %eax
c0020ac9:	8d 83 28 3f ff ff    	lea    -0xc0d8(%ebx),%eax
c0020acf:	50                   	push   %eax
c0020ad0:	6a 27                	push   $0x27
c0020ad2:	8d 83 1a 56 ff ff    	lea    -0xa9e6(%ebx),%eax
c0020ad8:	50                   	push   %eax
c0020ad9:	e8 fc 85 00 00       	call   c00290da <debug_panic>

c0020ade <alloc_frame>:
alloc_frame(struct thread *t, size_t size) {
c0020ade:	53                   	push   %ebx
c0020adf:	83 ec 08             	sub    $0x8,%esp
c0020ae2:	e8 11 e4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0020ae7:	81 c3 41 a6 01 00    	add    $0x1a641,%ebx
    return t != NULL && t->magic == THREAD_MAGIC;
c0020aed:	85 c0                	test   %eax,%eax
c0020aef:	74 0c                	je     c0020afd <alloc_frame+0x1f>
c0020af1:	81 b8 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%eax)
c0020af8:	bf 6a cd 
c0020afb:	74 52                	je     c0020b4f <alloc_frame+0x71>
    ASSERT(is_thread(t));
c0020afd:	83 ec 0c             	sub    $0xc,%esp
c0020b00:	8d 83 6a 56 ff ff    	lea    -0xa996(%ebx),%eax
c0020b06:	50                   	push   %eax
c0020b07:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020b0d:	50                   	push   %eax
c0020b0e:	8d 83 fc 3e ff ff    	lea    -0xc104(%ebx),%eax
c0020b14:	50                   	push   %eax
c0020b15:	68 3d 02 00 00       	push   $0x23d
c0020b1a:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020b20:	50                   	push   %eax
c0020b21:	e8 b4 85 00 00       	call   c00290da <debug_panic>
    ASSERT(size % sizeof(uint32_t) == 0);
c0020b26:	83 ec 0c             	sub    $0xc,%esp
c0020b29:	8d 83 36 56 ff ff    	lea    -0xa9ca(%ebx),%eax
c0020b2f:	50                   	push   %eax
c0020b30:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020b36:	50                   	push   %eax
c0020b37:	8d 83 fc 3e ff ff    	lea    -0xc104(%ebx),%eax
c0020b3d:	50                   	push   %eax
c0020b3e:	68 3e 02 00 00       	push   $0x23e
c0020b43:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020b49:	50                   	push   %eax
c0020b4a:	e8 8b 85 00 00       	call   c00290da <debug_panic>
c0020b4f:	f6 c2 03             	test   $0x3,%dl
c0020b52:	75 d2                	jne    c0020b26 <alloc_frame+0x48>
    t->stack -= size;
c0020b54:	8b 48 18             	mov    0x18(%eax),%ecx
c0020b57:	29 d1                	sub    %edx,%ecx
c0020b59:	89 48 18             	mov    %ecx,0x18(%eax)
}
c0020b5c:	89 c8                	mov    %ecx,%eax
c0020b5e:	83 c4 08             	add    $0x8,%esp
c0020b61:	5b                   	pop    %ebx
c0020b62:	c3                   	ret    

c0020b63 <update_thread_priority_mlfqs>:
void update_thread_priority_mlfqs(struct thread *t, void *aux) {
c0020b63:	57                   	push   %edi
c0020b64:	56                   	push   %esi
c0020b65:	53                   	push   %ebx
c0020b66:	e8 8d e3 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0020b6b:	81 c3 bd a5 01 00    	add    $0x1a5bd,%ebx
c0020b71:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    ASSERT(thread_mlfqs);
c0020b75:	c7 c2 80 d0 03 c0    	mov    $0xc003d080,%edx
c0020b7b:	80 3a 00             	cmpb   $0x0,(%edx)
c0020b7e:	74 58                	je     c0020bd8 <update_thread_priority_mlfqs+0x75>
    if (t == idle_thread) {
c0020b80:	39 8b 80 01 00 00    	cmp    %ecx,0x180(%ebx)
c0020b86:	74 4c                	je     c0020bd4 <update_thread_priority_mlfqs+0x71>
    return __mk_fix ((long long) x.f * FIX_F / y.f);
c0020b88:	8b 41 20             	mov    0x20(%ecx),%eax
c0020b8b:	99                   	cltd   
c0020b8c:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0020b90:	c1 e0 10             	shl    $0x10,%eax
c0020b93:	89 c6                	mov    %eax,%esi
c0020b95:	89 d7                	mov    %edx,%edi
c0020b97:	89 d3                	mov    %edx,%ebx
c0020b99:	c1 fb 1f             	sar    $0x1f,%ebx
c0020b9c:	81 e3 ff ff 03 00    	and    $0x3ffff,%ebx
c0020ba2:	ba 00 00 00 00       	mov    $0x0,%edx
c0020ba7:	01 de                	add    %ebx,%esi
c0020ba9:	11 d7                	adc    %edx,%edi
c0020bab:	89 f0                	mov    %esi,%eax
c0020bad:	0f ac f8 12          	shrd   $0x12,%edi,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c0020bb1:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c0020bb7:	05 00 80 00 00       	add    $0x8000,%eax
c0020bbc:	0f 49 d0             	cmovns %eax,%edx
c0020bbf:	c1 fa 10             	sar    $0x10,%edx
    t->priority = PRI_MAX - fix_round(fix_div(t->recent_cpu, fix_int(4)))
c0020bc2:	b8 3f 00 00 00       	mov    $0x3f,%eax
c0020bc7:	29 d0                	sub    %edx,%eax
                  - t->nice * 2;
c0020bc9:	8b 79 1c             	mov    0x1c(%ecx),%edi
c0020bcc:	8d 14 3f             	lea    (%edi,%edi,1),%edx
c0020bcf:	29 d0                	sub    %edx,%eax
c0020bd1:	89 41 24             	mov    %eax,0x24(%ecx)
}
c0020bd4:	5b                   	pop    %ebx
c0020bd5:	5e                   	pop    %esi
c0020bd6:	5f                   	pop    %edi
c0020bd7:	c3                   	ret    
    ASSERT(thread_mlfqs);
c0020bd8:	83 ec 0c             	sub    $0xc,%esp
c0020bdb:	8d 93 77 56 ff ff    	lea    -0xa989(%ebx),%edx
c0020be1:	52                   	push   %edx
c0020be2:	8d 93 94 4f ff ff    	lea    -0xb06c(%ebx),%edx
c0020be8:	52                   	push   %edx
c0020be9:	8d 93 74 3e ff ff    	lea    -0xc18c(%ebx),%edx
c0020bef:	52                   	push   %edx
c0020bf0:	68 91 01 00 00       	push   $0x191
c0020bf5:	8d 93 53 56 ff ff    	lea    -0xa9ad(%ebx),%edx
c0020bfb:	52                   	push   %edx
c0020bfc:	e8 d9 84 00 00       	call   c00290da <debug_panic>

c0020c01 <init_thread>:
init_thread(struct thread *t, const char *name, int priority) {
c0020c01:	55                   	push   %ebp
c0020c02:	57                   	push   %edi
c0020c03:	56                   	push   %esi
c0020c04:	53                   	push   %ebx
c0020c05:	83 ec 0c             	sub    $0xc,%esp
c0020c08:	e8 eb e2 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0020c0d:	81 c3 1b a5 01 00    	add    $0x1a51b,%ebx
    ASSERT(t != NULL);
c0020c13:	85 c0                	test   %eax,%eax
c0020c15:	0f 84 f8 00 00 00    	je     c0020d13 <init_thread+0x112>
c0020c1b:	89 c6                	mov    %eax,%esi
c0020c1d:	89 cd                	mov    %ecx,%ebp
    ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020c1f:	83 f9 3f             	cmp    $0x3f,%ecx
c0020c22:	0f 87 14 01 00 00    	ja     c0020d3c <init_thread+0x13b>
    ASSERT(name != NULL);
c0020c28:	85 d2                	test   %edx,%edx
c0020c2a:	0f 84 35 01 00 00    	je     c0020d65 <init_thread+0x164>
    memset(t, 0, sizeof *t);
c0020c30:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0020c36:	c7 80 14 01 00 00 00 	movl   $0x0,0x114(%eax)
c0020c3d:	00 00 00 
c0020c40:	8d 78 04             	lea    0x4(%eax),%edi
c0020c43:	83 e7 fc             	and    $0xfffffffc,%edi
c0020c46:	89 c1                	mov    %eax,%ecx
c0020c48:	29 f9                	sub    %edi,%ecx
c0020c4a:	81 c1 18 01 00 00    	add    $0x118,%ecx
c0020c50:	c1 e9 02             	shr    $0x2,%ecx
c0020c53:	b8 00 00 00 00       	mov    $0x0,%eax
c0020c58:	f3 ab                	rep stos %eax,%es:(%edi)
    t->status = THREAD_BLOCKED;
c0020c5a:	c7 46 04 02 00 00 00 	movl   $0x2,0x4(%esi)
    t->ticks_blocked = 0;
c0020c61:	c7 86 e4 00 00 00 00 	movl   $0x0,0xe4(%esi)
c0020c68:	00 00 00 
c0020c6b:	c7 86 e8 00 00 00 00 	movl   $0x0,0xe8(%esi)
c0020c72:	00 00 00 
    strlcpy(t->name, name, sizeof t->name);
c0020c75:	83 ec 04             	sub    $0x4,%esp
c0020c78:	6a 10                	push   $0x10
c0020c7a:	52                   	push   %edx
c0020c7b:	8d 46 08             	lea    0x8(%esi),%eax
c0020c7e:	50                   	push   %eax
c0020c7f:	e8 98 7a 00 00       	call   c002871c <strlcpy>
    t->stack = (uint8_t *) t + PGSIZE;
c0020c84:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
c0020c8a:	89 46 18             	mov    %eax,0x18(%esi)
    t->priority = priority;
c0020c8d:	89 6e 24             	mov    %ebp,0x24(%esi)
    t->original_priority = priority;
c0020c90:	89 6e 28             	mov    %ebp,0x28(%esi)
    t->lock_waiting = NULL;
c0020c93:	c7 86 04 01 00 00 00 	movl   $0x0,0x104(%esi)
c0020c9a:	00 00 00 
    list_init(&t->lock_list);
c0020c9d:	8d 86 f4 00 00 00    	lea    0xf4(%esi),%eax
c0020ca3:	89 04 24             	mov    %eax,(%esp)
c0020ca6:	e8 fc 84 00 00       	call   c00291a7 <list_init>
    list_init(&t->child_list);
c0020cab:	8d 86 cc 00 00 00    	lea    0xcc(%esi),%eax
c0020cb1:	89 04 24             	mov    %eax,(%esp)
c0020cb4:	e8 ee 84 00 00       	call   c00291a7 <list_init>
    list_init(&t->file_descriptor_list);
c0020cb9:	8d 46 30             	lea    0x30(%esi),%eax
c0020cbc:	89 04 24             	mov    %eax,(%esp)
c0020cbf:	e8 e3 84 00 00       	call   c00291a7 <list_init>
    t->magic = THREAD_MAGIC;
c0020cc4:	c7 86 14 01 00 00 4b 	movl   $0xcd6abf4b,0x114(%esi)
c0020ccb:	bf 6a cd 
    if (thread_mlfqs) {
c0020cce:	83 c4 10             	add    $0x10,%esp
c0020cd1:	c7 c0 80 d0 03 c0    	mov    $0xc003d080,%eax
c0020cd7:	80 38 00             	cmpb   $0x0,(%eax)
c0020cda:	0f 85 ae 00 00 00    	jne    c0020d8e <init_thread+0x18d>
    old_level = intr_disable();
c0020ce0:	e8 2a 10 00 00       	call   c0021d0f <intr_disable>
c0020ce5:	89 c7                	mov    %eax,%edi
    list_insert_ordered(&all_list, &t->allelem, (list_less_func *) &thread_cmp_priority, NULL);
c0020ce7:	6a 00                	push   $0x0
c0020ce9:	8d 83 8a 58 fe ff    	lea    -0x1a776(%ebx),%eax
c0020cef:	50                   	push   %eax
c0020cf0:	81 c6 ec 00 00 00    	add    $0xec,%esi
c0020cf6:	56                   	push   %esi
c0020cf7:	8d 83 84 01 00 00    	lea    0x184(%ebx),%eax
c0020cfd:	50                   	push   %eax
c0020cfe:	e8 9b 8f 00 00       	call   c0029c9e <list_insert_ordered>
    intr_set_level(old_level);
c0020d03:	89 3c 24             	mov    %edi,(%esp)
c0020d06:	e8 0b 10 00 00       	call   c0021d16 <intr_set_level>
}
c0020d0b:	83 c4 1c             	add    $0x1c,%esp
c0020d0e:	5b                   	pop    %ebx
c0020d0f:	5e                   	pop    %esi
c0020d10:	5f                   	pop    %edi
c0020d11:	5d                   	pop    %ebp
c0020d12:	c3                   	ret    
    ASSERT(t != NULL);
c0020d13:	83 ec 0c             	sub    $0xc,%esp
c0020d16:	8d 83 8b 6a ff ff    	lea    -0x9575(%ebx),%eax
c0020d1c:	50                   	push   %eax
c0020d1d:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020d23:	50                   	push   %eax
c0020d24:	8d 83 30 3f ff ff    	lea    -0xc0d0(%ebx),%eax
c0020d2a:	50                   	push   %eax
c0020d2b:	68 17 02 00 00       	push   $0x217
c0020d30:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020d36:	50                   	push   %eax
c0020d37:	e8 9e 83 00 00       	call   c00290da <debug_panic>
    ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020d3c:	83 ec 0c             	sub    $0xc,%esp
c0020d3f:	8d 83 34 55 ff ff    	lea    -0xaacc(%ebx),%eax
c0020d45:	50                   	push   %eax
c0020d46:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020d4c:	50                   	push   %eax
c0020d4d:	8d 83 30 3f ff ff    	lea    -0xc0d0(%ebx),%eax
c0020d53:	50                   	push   %eax
c0020d54:	68 18 02 00 00       	push   $0x218
c0020d59:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020d5f:	50                   	push   %eax
c0020d60:	e8 75 83 00 00       	call   c00290da <debug_panic>
    ASSERT(name != NULL);
c0020d65:	83 ec 0c             	sub    $0xc,%esp
c0020d68:	8d 83 84 56 ff ff    	lea    -0xa97c(%ebx),%eax
c0020d6e:	50                   	push   %eax
c0020d6f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020d75:	50                   	push   %eax
c0020d76:	8d 83 30 3f ff ff    	lea    -0xc0d0(%ebx),%eax
c0020d7c:	50                   	push   %eax
c0020d7d:	68 19 02 00 00       	push   $0x219
c0020d82:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020d88:	50                   	push   %eax
c0020d89:	e8 4c 83 00 00       	call   c00290da <debug_panic>
        t->nice = 0;
c0020d8e:	c7 46 1c 00 00 00 00 	movl   $0x0,0x1c(%esi)
        t->recent_cpu = fix_int(0);
c0020d95:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
        update_thread_priority_mlfqs(t, NULL);
c0020d9c:	83 ec 08             	sub    $0x8,%esp
c0020d9f:	6a 00                	push   $0x0
c0020da1:	56                   	push   %esi
c0020da2:	e8 bc fd ff ff       	call   c0020b63 <update_thread_priority_mlfqs>
c0020da7:	83 c4 10             	add    $0x10,%esp
c0020daa:	e9 31 ff ff ff       	jmp    c0020ce0 <init_thread+0xdf>

c0020daf <thread_init>:
thread_init(void) {
c0020daf:	55                   	push   %ebp
c0020db0:	57                   	push   %edi
c0020db1:	56                   	push   %esi
c0020db2:	53                   	push   %ebx
c0020db3:	83 ec 0c             	sub    $0xc,%esp
c0020db6:	e8 3d e1 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0020dbb:	81 c3 6d a3 01 00    	add    $0x1a36d,%ebx
    ASSERT(intr_get_level() == INTR_OFF);
c0020dc1:	e8 f7 0e 00 00       	call   c0021cbd <intr_get_level>
c0020dc6:	85 c0                	test   %eax,%eax
c0020dc8:	75 7e                	jne    c0020e48 <thread_init+0x99>
    lock_init(&tid_lock);
c0020dca:	83 ec 0c             	sub    $0xc,%esp
c0020dcd:	8d b3 58 01 00 00    	lea    0x158(%ebx),%esi
c0020dd3:	56                   	push   %esi
c0020dd4:	e8 84 23 00 00       	call   c002315d <lock_init>
    list_init(&ready_list);
c0020dd9:	8d 83 94 01 00 00    	lea    0x194(%ebx),%eax
c0020ddf:	89 04 24             	mov    %eax,(%esp)
c0020de2:	e8 c0 83 00 00       	call   c00291a7 <list_init>
    list_init(&all_list);
c0020de7:	8d 83 84 01 00 00    	lea    0x184(%ebx),%eax
c0020ded:	89 04 24             	mov    %eax,(%esp)
c0020df0:	e8 b2 83 00 00       	call   c00291a7 <list_init>
    asm ("mov %%esp, %0" : "=g" (esp));
c0020df5:	89 e0                	mov    %esp,%eax
    return (void *) ((uintptr_t) va & ~PGMASK);
c0020df7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    initial_thread = running_thread();
c0020dfc:	89 83 7c 01 00 00    	mov    %eax,0x17c(%ebx)
    init_thread(initial_thread, "main", PRI_DEFAULT);
c0020e02:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020e07:	8d 93 ae 56 ff ff    	lea    -0xa952(%ebx),%edx
c0020e0d:	e8 ef fd ff ff       	call   c0020c01 <init_thread>
    initial_thread->status = THREAD_RUNNING;
c0020e12:	8b bb 7c 01 00 00    	mov    0x17c(%ebx),%edi
c0020e18:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    lock_acquire(&tid_lock);
c0020e1f:	89 34 24             	mov    %esi,(%esp)
c0020e22:	e8 e2 23 00 00       	call   c0023209 <lock_acquire>
    tid = next_tid++;
c0020e27:	8b ab bc fb ff ff    	mov    -0x444(%ebx),%ebp
c0020e2d:	8d 45 01             	lea    0x1(%ebp),%eax
c0020e30:	89 83 bc fb ff ff    	mov    %eax,-0x444(%ebx)
    lock_release(&tid_lock);
c0020e36:	89 34 24             	mov    %esi,(%esp)
c0020e39:	e8 cc 25 00 00       	call   c002340a <lock_release>
    initial_thread->tid = allocate_tid();
c0020e3e:	89 2f                	mov    %ebp,(%edi)
}
c0020e40:	83 c4 1c             	add    $0x1c,%esp
c0020e43:	5b                   	pop    %ebx
c0020e44:	5e                   	pop    %esi
c0020e45:	5f                   	pop    %edi
c0020e46:	5d                   	pop    %ebp
c0020e47:	c3                   	ret    
    ASSERT(intr_get_level() == INTR_OFF);
c0020e48:	83 ec 0c             	sub    $0xc,%esp
c0020e4b:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0020e51:	50                   	push   %eax
c0020e52:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020e58:	50                   	push   %eax
c0020e59:	8d 83 3c 3f ff ff    	lea    -0xc0c4(%ebx),%eax
c0020e5f:	50                   	push   %eax
c0020e60:	6a 69                	push   $0x69
c0020e62:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020e68:	50                   	push   %eax
c0020e69:	e8 6c 82 00 00       	call   c00290da <debug_panic>

c0020e6e <thread_print_stats>:
thread_print_stats(void) {
c0020e6e:	53                   	push   %ebx
c0020e6f:	83 ec 0c             	sub    $0xc,%esp
c0020e72:	e8 81 e0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0020e77:	81 c3 b1 a2 01 00    	add    $0x1a2b1,%ebx
    printf("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020e7d:	ff b3 44 01 00 00    	pushl  0x144(%ebx)
c0020e83:	ff b3 40 01 00 00    	pushl  0x140(%ebx)
c0020e89:	ff b3 4c 01 00 00    	pushl  0x14c(%ebx)
c0020e8f:	ff b3 48 01 00 00    	pushl  0x148(%ebx)
c0020e95:	ff b3 54 01 00 00    	pushl  0x154(%ebx)
c0020e9b:	ff b3 50 01 00 00    	pushl  0x150(%ebx)
c0020ea1:	8d 83 60 55 ff ff    	lea    -0xaaa0(%ebx),%eax
c0020ea7:	50                   	push   %eax
c0020ea8:	e8 d1 65 00 00       	call   c002747e <printf>
}
c0020ead:	83 c4 28             	add    $0x28,%esp
c0020eb0:	5b                   	pop    %ebx
c0020eb1:	c3                   	ret    

c0020eb2 <get_cmp_priority_func>:
list_less_func *get_cmp_priority_func() {
c0020eb2:	e8 45 e0 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0020eb7:	05 71 a2 01 00       	add    $0x1a271,%eax
    return (list_less_func *) &thread_cmp_priority;
c0020ebc:	8d 80 8a 58 fe ff    	lea    -0x1a776(%eax),%eax
}
c0020ec2:	c3                   	ret    

c0020ec3 <thread_unblock>:
thread_unblock(struct thread *t) {
c0020ec3:	57                   	push   %edi
c0020ec4:	56                   	push   %esi
c0020ec5:	53                   	push   %ebx
c0020ec6:	e8 2d e0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0020ecb:	81 c3 5d a2 01 00    	add    $0x1a25d,%ebx
c0020ed1:	8b 74 24 10          	mov    0x10(%esp),%esi
    return t != NULL && t->magic == THREAD_MAGIC;
c0020ed5:	85 f6                	test   %esi,%esi
c0020ed7:	74 0c                	je     c0020ee5 <thread_unblock+0x22>
c0020ed9:	81 be 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%esi)
c0020ee0:	bf 6a cd 
c0020ee3:	74 52                	je     c0020f37 <thread_unblock+0x74>
    ASSERT(is_thread(t));
c0020ee5:	83 ec 0c             	sub    $0xc,%esp
c0020ee8:	8d 83 6a 56 ff ff    	lea    -0xa996(%ebx),%eax
c0020eee:	50                   	push   %eax
c0020eef:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020ef5:	50                   	push   %eax
c0020ef6:	8d 83 d0 3e ff ff    	lea    -0xc130(%ebx),%eax
c0020efc:	50                   	push   %eax
c0020efd:	68 12 01 00 00       	push   $0x112
c0020f02:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020f08:	50                   	push   %eax
c0020f09:	e8 cc 81 00 00       	call   c00290da <debug_panic>
    ASSERT(t->status == THREAD_BLOCKED);
c0020f0e:	83 ec 0c             	sub    $0xc,%esp
c0020f11:	8d 83 b3 56 ff ff    	lea    -0xa94d(%ebx),%eax
c0020f17:	50                   	push   %eax
c0020f18:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020f1e:	50                   	push   %eax
c0020f1f:	8d 83 d0 3e ff ff    	lea    -0xc130(%ebx),%eax
c0020f25:	50                   	push   %eax
c0020f26:	68 15 01 00 00       	push   $0x115
c0020f2b:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020f31:	50                   	push   %eax
c0020f32:	e8 a3 81 00 00       	call   c00290da <debug_panic>
    old_level = intr_disable();
c0020f37:	e8 d3 0d 00 00       	call   c0021d0f <intr_disable>
c0020f3c:	89 c7                	mov    %eax,%edi
    ASSERT(t->status == THREAD_BLOCKED);
c0020f3e:	83 7e 04 02          	cmpl   $0x2,0x4(%esi)
c0020f42:	75 ca                	jne    c0020f0e <thread_unblock+0x4b>
    list_insert_ordered(&ready_list, &t->elem, (list_less_func *) &thread_cmp_priority, NULL);
c0020f44:	6a 00                	push   $0x0
c0020f46:	8d 83 8a 58 fe ff    	lea    -0x1a776(%ebx),%eax
c0020f4c:	50                   	push   %eax
c0020f4d:	8d 86 08 01 00 00    	lea    0x108(%esi),%eax
c0020f53:	50                   	push   %eax
c0020f54:	8d 83 94 01 00 00    	lea    0x194(%ebx),%eax
c0020f5a:	50                   	push   %eax
c0020f5b:	e8 3e 8d 00 00       	call   c0029c9e <list_insert_ordered>
    t->status = THREAD_READY;
c0020f60:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
    intr_set_level(old_level);
c0020f67:	89 3c 24             	mov    %edi,(%esp)
c0020f6a:	e8 a7 0d 00 00       	call   c0021d16 <intr_set_level>
}
c0020f6f:	83 c4 10             	add    $0x10,%esp
c0020f72:	5b                   	pop    %ebx
c0020f73:	5e                   	pop    %esi
c0020f74:	5f                   	pop    %edi
c0020f75:	c3                   	ret    

c0020f76 <thread_current>:
thread_current(void) {
c0020f76:	53                   	push   %ebx
c0020f77:	83 ec 08             	sub    $0x8,%esp
c0020f7a:	e8 79 df 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0020f7f:	81 c3 a9 a1 01 00    	add    $0x1a1a9,%ebx
    asm ("mov %%esp, %0" : "=g" (esp));
c0020f85:	89 e0                	mov    %esp,%eax
    return t != NULL && t->magic == THREAD_MAGIC;
c0020f87:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0020f8c:	74 0c                	je     c0020f9a <thread_current+0x24>
c0020f8e:	81 b8 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%eax)
c0020f95:	bf 6a cd 
c0020f98:	74 52                	je     c0020fec <thread_current+0x76>
    ASSERT(is_thread(t));
c0020f9a:	83 ec 0c             	sub    $0xc,%esp
c0020f9d:	8d 83 6a 56 ff ff    	lea    -0xa996(%ebx),%eax
c0020fa3:	50                   	push   %eax
c0020fa4:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020faa:	50                   	push   %eax
c0020fab:	8d 83 c0 3e ff ff    	lea    -0xc140(%ebx),%eax
c0020fb1:	50                   	push   %eax
c0020fb2:	68 2e 01 00 00       	push   $0x12e
c0020fb7:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020fbd:	50                   	push   %eax
c0020fbe:	e8 17 81 00 00       	call   c00290da <debug_panic>
    ASSERT(t->status == THREAD_RUNNING);
c0020fc3:	83 ec 0c             	sub    $0xc,%esp
c0020fc6:	8d 83 cf 56 ff ff    	lea    -0xa931(%ebx),%eax
c0020fcc:	50                   	push   %eax
c0020fcd:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0020fd3:	50                   	push   %eax
c0020fd4:	8d 83 c0 3e ff ff    	lea    -0xc140(%ebx),%eax
c0020fda:	50                   	push   %eax
c0020fdb:	68 2f 01 00 00       	push   $0x12f
c0020fe0:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020fe6:	50                   	push   %eax
c0020fe7:	e8 ee 80 00 00       	call   c00290da <debug_panic>
c0020fec:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0020ff0:	75 d1                	jne    c0020fc3 <thread_current+0x4d>
}
c0020ff2:	83 c4 08             	add    $0x8,%esp
c0020ff5:	5b                   	pop    %ebx
c0020ff6:	c3                   	ret    

c0020ff7 <thread_tick>:
thread_tick(void) {
c0020ff7:	53                   	push   %ebx
c0020ff8:	83 ec 08             	sub    $0x8,%esp
c0020ffb:	e8 f8 de 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021000:	81 c3 28 a1 01 00    	add    $0x1a128,%ebx
    struct thread *t = thread_current();
c0021006:	e8 6b ff ff ff       	call   c0020f76 <thread_current>
    if (t == idle_thread)
c002100b:	39 83 80 01 00 00    	cmp    %eax,0x180(%ebx)
c0021011:	74 30                	je     c0021043 <thread_tick+0x4c>
        else if (t->pagedir != NULL)
c0021013:	83 b8 10 01 00 00 00 	cmpl   $0x0,0x110(%eax)
c002101a:	74 37                	je     c0021053 <thread_tick+0x5c>
          user_ticks++;
c002101c:	83 83 40 01 00 00 01 	addl   $0x1,0x140(%ebx)
c0021023:	83 93 44 01 00 00 00 	adcl   $0x0,0x144(%ebx)
    if (++thread_ticks >= TIME_SLICE)
c002102a:	8b 83 38 01 00 00    	mov    0x138(%ebx),%eax
c0021030:	83 c0 01             	add    $0x1,%eax
c0021033:	89 83 38 01 00 00    	mov    %eax,0x138(%ebx)
c0021039:	83 f8 03             	cmp    $0x3,%eax
c002103c:	77 25                	ja     c0021063 <thread_tick+0x6c>
}
c002103e:	83 c4 08             	add    $0x8,%esp
c0021041:	5b                   	pop    %ebx
c0021042:	c3                   	ret    
        idle_ticks++;
c0021043:	83 83 50 01 00 00 01 	addl   $0x1,0x150(%ebx)
c002104a:	83 93 54 01 00 00 00 	adcl   $0x0,0x154(%ebx)
c0021051:	eb d7                	jmp    c002102a <thread_tick+0x33>
        kernel_ticks++;
c0021053:	83 83 48 01 00 00 01 	addl   $0x1,0x148(%ebx)
c002105a:	83 93 4c 01 00 00 00 	adcl   $0x0,0x14c(%ebx)
c0021061:	eb c7                	jmp    c002102a <thread_tick+0x33>
        intr_yield_on_return();
c0021063:	e8 5f 0f 00 00       	call   c0021fc7 <intr_yield_on_return>
}
c0021068:	eb d4                	jmp    c002103e <thread_tick+0x47>

c002106a <thread_name>:
thread_name(void) {
c002106a:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->name;
c002106d:	e8 04 ff ff ff       	call   c0020f76 <thread_current>
c0021072:	83 c0 08             	add    $0x8,%eax
}
c0021075:	83 c4 0c             	add    $0xc,%esp
c0021078:	c3                   	ret    

c0021079 <thread_tid>:
thread_tid(void) {
c0021079:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->tid;
c002107c:	e8 f5 fe ff ff       	call   c0020f76 <thread_current>
c0021081:	8b 00                	mov    (%eax),%eax
}
c0021083:	83 c4 0c             	add    $0xc,%esp
c0021086:	c3                   	ret    

c0021087 <thread_foreach>:
thread_foreach(thread_action_func func, void *aux) {
c0021087:	55                   	push   %ebp
c0021088:	57                   	push   %edi
c0021089:	56                   	push   %esi
c002108a:	53                   	push   %ebx
c002108b:	83 ec 0c             	sub    $0xc,%esp
c002108e:	e8 65 de 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021093:	81 c3 95 a0 01 00    	add    $0x1a095,%ebx
c0021099:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    ASSERT(intr_get_level() == INTR_OFF);
c002109d:	e8 1b 0c 00 00       	call   c0021cbd <intr_get_level>
c00210a2:	85 c0                	test   %eax,%eax
c00210a4:	75 48                	jne    c00210ee <thread_foreach+0x67>
    for (e = list_begin(&all_list); e != list_end(&all_list);
c00210a6:	83 ec 0c             	sub    $0xc,%esp
c00210a9:	8d 83 84 01 00 00    	lea    0x184(%ebx),%eax
c00210af:	50                   	push   %eax
c00210b0:	e8 4a 81 00 00       	call   c00291ff <list_begin>
c00210b5:	89 c6                	mov    %eax,%esi
c00210b7:	83 c4 10             	add    $0x10,%esp
c00210ba:	8d bb 84 01 00 00    	lea    0x184(%ebx),%edi
c00210c0:	83 ec 0c             	sub    $0xc,%esp
c00210c3:	57                   	push   %edi
c00210c4:	e8 d8 81 00 00       	call   c00292a1 <list_end>
c00210c9:	83 c4 10             	add    $0x10,%esp
c00210cc:	39 f0                	cmp    %esi,%eax
c00210ce:	74 47                	je     c0021117 <thread_foreach+0x90>
        func(t, aux);
c00210d0:	83 ec 08             	sub    $0x8,%esp
c00210d3:	55                   	push   %ebp
        struct thread *t = list_entry(e, struct thread, allelem);
c00210d4:	8d 86 14 ff ff ff    	lea    -0xec(%esi),%eax
        func(t, aux);
c00210da:	50                   	push   %eax
c00210db:	ff 54 24 30          	call   *0x30(%esp)
         e = list_next(e)) {
c00210df:	89 34 24             	mov    %esi,(%esp)
c00210e2:	e8 5d 81 00 00       	call   c0029244 <list_next>
c00210e7:	89 c6                	mov    %eax,%esi
c00210e9:	83 c4 10             	add    $0x10,%esp
c00210ec:	eb d2                	jmp    c00210c0 <thread_foreach+0x39>
    ASSERT(intr_get_level() == INTR_OFF);
c00210ee:	83 ec 0c             	sub    $0xc,%esp
c00210f1:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c00210f7:	50                   	push   %eax
c00210f8:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00210fe:	50                   	push   %eax
c00210ff:	8d 83 94 3e ff ff    	lea    -0xc16c(%ebx),%eax
c0021105:	50                   	push   %eax
c0021106:	68 65 01 00 00       	push   $0x165
c002110b:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0021111:	50                   	push   %eax
c0021112:	e8 c3 7f 00 00       	call   c00290da <debug_panic>
}
c0021117:	83 c4 0c             	add    $0xc,%esp
c002111a:	5b                   	pop    %ebx
c002111b:	5e                   	pop    %esi
c002111c:	5f                   	pop    %edi
c002111d:	5d                   	pop    %ebp
c002111e:	c3                   	ret    

c002111f <thread_get_priority>:
thread_get_priority(void) {
c002111f:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->priority;
c0021122:	e8 4f fe ff ff       	call   c0020f76 <thread_current>
c0021127:	8b 40 24             	mov    0x24(%eax),%eax
}
c002112a:	83 c4 0c             	add    $0xc,%esp
c002112d:	c3                   	ret    

c002112e <get_ready_list_size>:
int get_ready_list_size(void) {
c002112e:	56                   	push   %esi
c002112f:	53                   	push   %ebx
c0021130:	83 ec 10             	sub    $0x10,%esp
c0021133:	e8 c0 dd 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021138:	81 c3 f0 9f 01 00    	add    $0x19ff0,%ebx
    return list_size(&ready_list) + ((thread_current() != idle_thread) ? 1 : 0);
c002113e:	8d 83 94 01 00 00    	lea    0x194(%ebx),%eax
c0021144:	50                   	push   %eax
c0021145:	e8 be 86 00 00       	call   c0029808 <list_size>
c002114a:	89 c6                	mov    %eax,%esi
c002114c:	e8 25 fe ff ff       	call   c0020f76 <thread_current>
c0021151:	39 83 80 01 00 00    	cmp    %eax,0x180(%ebx)
c0021157:	0f 95 c0             	setne  %al
c002115a:	0f b6 c0             	movzbl %al,%eax
c002115d:	01 f0                	add    %esi,%eax
};
c002115f:	83 c4 14             	add    $0x14,%esp
c0021162:	5b                   	pop    %ebx
c0021163:	5e                   	pop    %esi
c0021164:	c3                   	ret    

c0021165 <update_all_priority>:
void update_all_priority(void) {
c0021165:	83 ec 14             	sub    $0x14,%esp
c0021168:	e8 8f dd 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c002116d:	05 bb 9f 01 00       	add    $0x19fbb,%eax
    thread_foreach((thread_action_func) &update_thread_priority_mlfqs, NULL);
c0021172:	6a 00                	push   $0x0
c0021174:	8d 80 3b 5a fe ff    	lea    -0x1a5c5(%eax),%eax
c002117a:	50                   	push   %eax
c002117b:	e8 07 ff ff ff       	call   c0021087 <thread_foreach>
}
c0021180:	83 c4 1c             	add    $0x1c,%esp
c0021183:	c3                   	ret    

c0021184 <update_all_recent_cpu>:
void update_all_recent_cpu(void) {
c0021184:	83 ec 14             	sub    $0x14,%esp
c0021187:	e8 70 dd 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c002118c:	05 9c 9f 01 00       	add    $0x19f9c,%eax
    thread_foreach((thread_action_func) &update_thread_recent_cpu, NULL);
c0021191:	6a 00                	push   $0x0
c0021193:	8d 80 b4 58 fe ff    	lea    -0x1a74c(%eax),%eax
c0021199:	50                   	push   %eax
c002119a:	e8 e8 fe ff ff       	call   c0021087 <thread_foreach>
}
c002119f:	83 c4 1c             	add    $0x1c,%esp
c00211a2:	c3                   	ret    

c00211a3 <update_cur_thread_cpu>:
void update_cur_thread_cpu(void) {
c00211a3:	83 ec 0c             	sub    $0xc,%esp
    struct thread *cur = thread_current();
c00211a6:	e8 cb fd ff ff       	call   c0020f76 <thread_current>
    return __mk_fix (x.f + y.f);
c00211ab:	81 40 20 00 00 01 00 	addl   $0x10000,0x20(%eax)
}
c00211b2:	83 c4 0c             	add    $0xc,%esp
c00211b5:	c3                   	ret    

c00211b6 <thread_get_nice>:
thread_get_nice(void) {
c00211b6:	83 ec 0c             	sub    $0xc,%esp
    return thread_current()->nice;
c00211b9:	e8 b8 fd ff ff       	call   c0020f76 <thread_current>
c00211be:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00211c1:	83 c4 0c             	add    $0xc,%esp
c00211c4:	c3                   	ret    

c00211c5 <update_load_avg>:
void update_load_avg(void) {
c00211c5:	55                   	push   %ebp
c00211c6:	57                   	push   %edi
c00211c7:	56                   	push   %esi
c00211c8:	53                   	push   %ebx
c00211c9:	83 ec 1c             	sub    $0x1c,%esp
c00211cc:	e8 27 dd 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00211d1:	81 c3 57 9f 01 00    	add    $0x19f57,%ebx
    fixed_point_t a = fix_frac(get_ready_list_size(), 60);
c00211d7:	e8 52 ff ff ff       	call   c002112e <get_ready_list_size>
c00211dc:	89 c1                	mov    %eax,%ecx
    ASSERT (n / d >= FIX_MIN_INT && n / d <= FIX_MAX_INT);
c00211de:	ba 89 88 88 88       	mov    $0x88888889,%edx
c00211e3:	f7 ea                	imul   %edx
c00211e5:	01 ca                	add    %ecx,%edx
c00211e7:	c1 fa 05             	sar    $0x5,%edx
c00211ea:	89 c8                	mov    %ecx,%eax
c00211ec:	c1 f8 1f             	sar    $0x1f,%eax
c00211ef:	29 c2                	sub    %eax,%edx
c00211f1:	81 c2 ff ff 00 00    	add    $0xffff,%edx
c00211f7:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
c00211fd:	77 77                	ja     c0021276 <update_load_avg+0xb1>
    global_load_avg = fix_add(a, b);
c00211ff:	c7 c5 7c d0 03 c0    	mov    $0xc003d07c,%ebp
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0021205:	8b 45 00             	mov    0x0(%ebp),%eax
c0021208:	89 c7                	mov    %eax,%edi
c002120a:	c1 ff 1f             	sar    $0x1f,%edi
c002120d:	69 ff bb fb 00 00    	imul   $0xfbbb,%edi,%edi
c0021213:	be bb fb 00 00       	mov    $0xfbbb,%esi
c0021218:	f7 e6                	mul    %esi
c002121a:	89 04 24             	mov    %eax,(%esp)
c002121d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0021221:	01 7c 24 04          	add    %edi,0x4(%esp)
c0021225:	8b 74 24 04          	mov    0x4(%esp),%esi
c0021229:	c1 fe 1f             	sar    $0x1f,%esi
c002122c:	89 f0                	mov    %esi,%eax
c002122e:	25 ff ff 00 00       	and    $0xffff,%eax
c0021233:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021237:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002123e:	00 
c002123f:	8b 04 24             	mov    (%esp),%eax
c0021242:	8b 54 24 04          	mov    0x4(%esp),%edx
c0021246:	03 44 24 08          	add    0x8(%esp),%eax
c002124a:	13 54 24 0c          	adc    0xc(%esp),%edx
c002124e:	0f ac d0 10          	shrd   $0x10,%edx,%eax
c0021252:	89 c6                	mov    %eax,%esi
    return __mk_fix ((long long) n * FIX_F / d);
c0021254:	89 c8                	mov    %ecx,%eax
c0021256:	99                   	cltd   
c0021257:	0f a4 ca 10          	shld   $0x10,%ecx,%edx
c002125b:	c1 e0 10             	shl    $0x10,%eax
c002125e:	6a 00                	push   $0x0
c0021260:	6a 3c                	push   $0x3c
c0021262:	52                   	push   %edx
c0021263:	50                   	push   %eax
c0021264:	e8 3b 78 00 00       	call   c0028aa4 <__divdi3>
    return __mk_fix (x.f + y.f);
c0021269:	01 c6                	add    %eax,%esi
c002126b:	89 75 00             	mov    %esi,0x0(%ebp)
}
c002126e:	83 c4 2c             	add    $0x2c,%esp
c0021271:	5b                   	pop    %ebx
c0021272:	5e                   	pop    %esi
c0021273:	5f                   	pop    %edi
c0021274:	5d                   	pop    %ebp
c0021275:	c3                   	ret    
    ASSERT (n / d >= FIX_MIN_INT && n / d <= FIX_MAX_INT);
c0021276:	83 ec 0c             	sub    $0xc,%esp
c0021279:	8d 83 a0 55 ff ff    	lea    -0xaa60(%ebx),%eax
c002127f:	50                   	push   %eax
c0021280:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021286:	50                   	push   %eax
c0021287:	8d 83 68 3e ff ff    	lea    -0xc198(%ebx),%eax
c002128d:	50                   	push   %eax
c002128e:	6a 30                	push   $0x30
c0021290:	8d 83 1a 56 ff ff    	lea    -0xa9e6(%ebx),%eax
c0021296:	50                   	push   %eax
c0021297:	e8 3e 7e 00 00       	call   c00290da <debug_panic>

c002129c <thread_get_load_avg>:
thread_get_load_avg(void) {
c002129c:	55                   	push   %ebp
c002129d:	57                   	push   %edi
c002129e:	56                   	push   %esi
c002129f:	53                   	push   %ebx
c00212a0:	e8 57 dc 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c00212a5:	05 83 9e 01 00       	add    $0x19e83,%eax
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c00212aa:	c7 c0 7c d0 03 c0    	mov    $0xc003d07c,%eax
c00212b0:	8b 38                	mov    (%eax),%edi
c00212b2:	89 fb                	mov    %edi,%ebx
c00212b4:	c1 fb 1f             	sar    $0x1f,%ebx
c00212b7:	69 f3 00 00 64 00    	imul   $0x640000,%ebx,%esi
c00212bd:	b9 00 00 64 00       	mov    $0x640000,%ecx
c00212c2:	89 f8                	mov    %edi,%eax
c00212c4:	f7 e1                	mul    %ecx
c00212c6:	89 c7                	mov    %eax,%edi
c00212c8:	89 d5                	mov    %edx,%ebp
c00212ca:	01 f5                	add    %esi,%ebp
c00212cc:	89 ee                	mov    %ebp,%esi
c00212ce:	c1 fe 1f             	sar    $0x1f,%esi
c00212d1:	0f b7 c6             	movzwl %si,%eax
c00212d4:	ba 00 00 00 00       	mov    $0x0,%edx
c00212d9:	01 f8                	add    %edi,%eax
c00212db:	11 ea                	adc    %ebp,%edx
c00212dd:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c00212e1:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c00212e7:	05 00 80 00 00       	add    $0x8000,%eax
c00212ec:	0f 48 c2             	cmovs  %edx,%eax
c00212ef:	c1 f8 10             	sar    $0x10,%eax
}
c00212f2:	5b                   	pop    %ebx
c00212f3:	5e                   	pop    %esi
c00212f4:	5f                   	pop    %edi
c00212f5:	5d                   	pop    %ebp
c00212f6:	c3                   	ret    

c00212f7 <thread_get_recent_cpu>:
thread_get_recent_cpu(void) {
c00212f7:	55                   	push   %ebp
c00212f8:	57                   	push   %edi
c00212f9:	56                   	push   %esi
c00212fa:	53                   	push   %ebx
c00212fb:	83 ec 0c             	sub    $0xc,%esp
    return fix_round(fix_mul(fix_int(100), thread_current()->recent_cpu));
c00212fe:	e8 73 fc ff ff       	call   c0020f76 <thread_current>
    return __mk_fix ((long long) x.f * y.f / FIX_F);
c0021303:	8b 78 20             	mov    0x20(%eax),%edi
c0021306:	89 fb                	mov    %edi,%ebx
c0021308:	c1 fb 1f             	sar    $0x1f,%ebx
c002130b:	69 f3 00 00 64 00    	imul   $0x640000,%ebx,%esi
c0021311:	b9 00 00 64 00       	mov    $0x640000,%ecx
c0021316:	89 f8                	mov    %edi,%eax
c0021318:	f7 e1                	mul    %ecx
c002131a:	89 c7                	mov    %eax,%edi
c002131c:	89 d5                	mov    %edx,%ebp
c002131e:	01 f5                	add    %esi,%ebp
c0021320:	89 ee                	mov    %ebp,%esi
c0021322:	c1 fe 1f             	sar    $0x1f,%esi
c0021325:	0f b7 c6             	movzwl %si,%eax
c0021328:	ba 00 00 00 00       	mov    $0x0,%edx
c002132d:	01 f8                	add    %edi,%eax
c002132f:	11 ea                	adc    %ebp,%edx
c0021331:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    return (x.f + FIX_F / 2) / FIX_F;
c0021335:	8d 90 ff 7f 01 00    	lea    0x17fff(%eax),%edx
c002133b:	05 00 80 00 00       	add    $0x8000,%eax
c0021340:	0f 48 c2             	cmovs  %edx,%eax
c0021343:	c1 f8 10             	sar    $0x10,%eax
}
c0021346:	83 c4 0c             	add    $0xc,%esp
c0021349:	5b                   	pop    %ebx
c002134a:	5e                   	pop    %esi
c002134b:	5f                   	pop    %edi
c002134c:	5d                   	pop    %ebp
c002134d:	c3                   	ret    

c002134e <thread_schedule_tail>:
thread_schedule_tail(struct thread *prev) {
c002134e:	57                   	push   %edi
c002134f:	56                   	push   %esi
c0021350:	53                   	push   %ebx
c0021351:	e8 a2 db 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021356:	81 c3 d2 9d 01 00    	add    $0x19dd2,%ebx
c002135c:	8b 7c 24 10          	mov    0x10(%esp),%edi
    asm ("mov %%esp, %0" : "=g" (esp));
c0021360:	89 e6                	mov    %esp,%esi
c0021362:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    ASSERT(intr_get_level() == INTR_OFF);
c0021368:	e8 50 09 00 00       	call   c0021cbd <intr_get_level>
c002136d:	85 c0                	test   %eax,%eax
c002136f:	75 24                	jne    c0021395 <thread_schedule_tail+0x47>
    cur->status = THREAD_RUNNING;
c0021371:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    thread_ticks = 0;
c0021378:	c7 83 38 01 00 00 00 	movl   $0x0,0x138(%ebx)
c002137f:	00 00 00 
     process_activate();
c0021382:	e8 8f a1 00 00       	call   c002b516 <process_activate>
    if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) {
c0021387:	85 ff                	test   %edi,%edi
c0021389:	74 06                	je     c0021391 <thread_schedule_tail+0x43>
c002138b:	83 7f 04 03          	cmpl   $0x3,0x4(%edi)
c002138f:	74 2d                	je     c00213be <thread_schedule_tail+0x70>
}
c0021391:	5b                   	pop    %ebx
c0021392:	5e                   	pop    %esi
c0021393:	5f                   	pop    %edi
c0021394:	c3                   	ret    
    ASSERT(intr_get_level() == INTR_OFF);
c0021395:	83 ec 0c             	sub    $0xc,%esp
c0021398:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c002139e:	50                   	push   %eax
c002139f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00213a5:	50                   	push   %eax
c00213a6:	8d 83 50 3e ff ff    	lea    -0xc1b0(%ebx),%eax
c00213ac:	50                   	push   %eax
c00213ad:	68 68 02 00 00       	push   $0x268
c00213b2:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c00213b8:	50                   	push   %eax
c00213b9:	e8 1c 7d 00 00       	call   c00290da <debug_panic>
    if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) {
c00213be:	39 bb 7c 01 00 00    	cmp    %edi,0x17c(%ebx)
c00213c4:	74 cb                	je     c0021391 <thread_schedule_tail+0x43>
        ASSERT(prev != cur);
c00213c6:	39 f7                	cmp    %esi,%edi
c00213c8:	74 0e                	je     c00213d8 <thread_schedule_tail+0x8a>
        palloc_free_page(prev);
c00213ca:	83 ec 0c             	sub    $0xc,%esp
c00213cd:	57                   	push   %edi
c00213ce:	e8 81 27 00 00       	call   c0023b54 <palloc_free_page>
c00213d3:	83 c4 10             	add    $0x10,%esp
}
c00213d6:	eb b9                	jmp    c0021391 <thread_schedule_tail+0x43>
        ASSERT(prev != cur);
c00213d8:	83 ec 0c             	sub    $0xc,%esp
c00213db:	8d 83 eb 56 ff ff    	lea    -0xa915(%ebx),%eax
c00213e1:	50                   	push   %eax
c00213e2:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00213e8:	50                   	push   %eax
c00213e9:	8d 83 50 3e ff ff    	lea    -0xc1b0(%ebx),%eax
c00213ef:	50                   	push   %eax
c00213f0:	68 7b 02 00 00       	push   $0x27b
c00213f5:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c00213fb:	50                   	push   %eax
c00213fc:	e8 d9 7c 00 00       	call   c00290da <debug_panic>

c0021401 <schedule>:
schedule(void) {
c0021401:	57                   	push   %edi
c0021402:	56                   	push   %esi
c0021403:	53                   	push   %ebx
c0021404:	e8 ef da 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021409:	81 c3 1f 9d 01 00    	add    $0x19d1f,%ebx
    asm ("mov %%esp, %0" : "=g" (esp));
c002140f:	89 e6                	mov    %esp,%esi
c0021411:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    if (list_empty(&ready_list))
c0021417:	83 ec 0c             	sub    $0xc,%esp
c002141a:	8d 83 94 01 00 00    	lea    0x194(%ebx),%eax
c0021420:	50                   	push   %eax
c0021421:	e8 25 84 00 00       	call   c002984b <list_empty>
c0021426:	83 c4 10             	add    $0x10,%esp
c0021429:	84 c0                	test   %al,%al
c002142b:	74 56                	je     c0021483 <schedule+0x82>
        return idle_thread;
c002142d:	8b bb 80 01 00 00    	mov    0x180(%ebx),%edi
    ASSERT(intr_get_level() == INTR_OFF);
c0021433:	e8 85 08 00 00       	call   c0021cbd <intr_get_level>
c0021438:	85 c0                	test   %eax,%eax
c002143a:	75 61                	jne    c002149d <schedule+0x9c>
    ASSERT(cur->status != THREAD_RUNNING);
c002143c:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0021440:	0f 84 80 00 00 00    	je     c00214c6 <schedule+0xc5>
    return t != NULL && t->magic == THREAD_MAGIC;
c0021446:	85 ff                	test   %edi,%edi
c0021448:	74 10                	je     c002145a <schedule+0x59>
c002144a:	81 bf 14 01 00 00 4b 	cmpl   $0xcd6abf4b,0x114(%edi)
c0021451:	bf 6a cd 
c0021454:	0f 84 95 00 00 00    	je     c00214ef <schedule+0xee>
    ASSERT(is_thread(next));
c002145a:	83 ec 0c             	sub    $0xc,%esp
c002145d:	8d 83 15 57 ff ff    	lea    -0xa8eb(%ebx),%eax
c0021463:	50                   	push   %eax
c0021464:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002146a:	50                   	push   %eax
c002146b:	8d 83 e0 3e ff ff    	lea    -0xc120(%ebx),%eax
c0021471:	50                   	push   %eax
c0021472:	68 8f 02 00 00       	push   $0x28f
c0021477:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c002147d:	50                   	push   %eax
c002147e:	e8 57 7c 00 00       	call   c00290da <debug_panic>
        return list_entry(list_pop_front(&ready_list),
c0021483:	83 ec 0c             	sub    $0xc,%esp
c0021486:	8d 83 94 01 00 00    	lea    0x194(%ebx),%eax
c002148c:	50                   	push   %eax
c002148d:	e8 30 84 00 00       	call   c00298c2 <list_pop_front>
c0021492:	8d b8 f8 fe ff ff    	lea    -0x108(%eax),%edi
c0021498:	83 c4 10             	add    $0x10,%esp
c002149b:	eb 96                	jmp    c0021433 <schedule+0x32>
    ASSERT(intr_get_level() == INTR_OFF);
c002149d:	83 ec 0c             	sub    $0xc,%esp
c00214a0:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c00214a6:	50                   	push   %eax
c00214a7:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00214ad:	50                   	push   %eax
c00214ae:	8d 83 e0 3e ff ff    	lea    -0xc120(%ebx),%eax
c00214b4:	50                   	push   %eax
c00214b5:	68 8d 02 00 00       	push   $0x28d
c00214ba:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c00214c0:	50                   	push   %eax
c00214c1:	e8 14 7c 00 00       	call   c00290da <debug_panic>
    ASSERT(cur->status != THREAD_RUNNING);
c00214c6:	83 ec 0c             	sub    $0xc,%esp
c00214c9:	8d 83 f7 56 ff ff    	lea    -0xa909(%ebx),%eax
c00214cf:	50                   	push   %eax
c00214d0:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00214d6:	50                   	push   %eax
c00214d7:	8d 83 e0 3e ff ff    	lea    -0xc120(%ebx),%eax
c00214dd:	50                   	push   %eax
c00214de:	68 8e 02 00 00       	push   $0x28e
c00214e3:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c00214e9:	50                   	push   %eax
c00214ea:	e8 eb 7b 00 00       	call   c00290da <debug_panic>
    struct thread *prev = NULL;
c00214ef:	b8 00 00 00 00       	mov    $0x0,%eax
    if (cur != next)
c00214f4:	39 f7                	cmp    %esi,%edi
c00214f6:	74 0d                	je     c0021505 <schedule+0x104>
        prev = switch_threads(cur, next);
c00214f8:	83 ec 08             	sub    $0x8,%esp
c00214fb:	57                   	push   %edi
c00214fc:	56                   	push   %esi
c00214fd:	e8 3a 06 00 00       	call   c0021b3c <switch_threads>
c0021502:	83 c4 10             	add    $0x10,%esp
    thread_schedule_tail(prev);
c0021505:	83 ec 0c             	sub    $0xc,%esp
c0021508:	50                   	push   %eax
c0021509:	e8 40 fe ff ff       	call   c002134e <thread_schedule_tail>
}
c002150e:	83 c4 10             	add    $0x10,%esp
c0021511:	5b                   	pop    %ebx
c0021512:	5e                   	pop    %esi
c0021513:	5f                   	pop    %edi
c0021514:	c3                   	ret    

c0021515 <thread_block>:
thread_block(void) {
c0021515:	53                   	push   %ebx
c0021516:	83 ec 08             	sub    $0x8,%esp
c0021519:	e8 da d9 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002151e:	81 c3 0a 9c 01 00    	add    $0x19c0a,%ebx
    ASSERT(!intr_context());
c0021524:	e8 8c 0a 00 00       	call   c0021fb5 <intr_context>
c0021529:	84 c0                	test   %al,%al
c002152b:	75 1f                	jne    c002154c <thread_block+0x37>
    ASSERT(intr_get_level() == INTR_OFF);
c002152d:	e8 8b 07 00 00       	call   c0021cbd <intr_get_level>
c0021532:	85 c0                	test   %eax,%eax
c0021534:	75 3f                	jne    c0021575 <thread_block+0x60>
    thread_current()->status = THREAD_BLOCKED;
c0021536:	e8 3b fa ff ff       	call   c0020f76 <thread_current>
c002153b:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    schedule();
c0021542:	e8 ba fe ff ff       	call   c0021401 <schedule>
}
c0021547:	83 c4 08             	add    $0x8,%esp
c002154a:	5b                   	pop    %ebx
c002154b:	c3                   	ret    
    ASSERT(!intr_context());
c002154c:	83 ec 0c             	sub    $0xc,%esp
c002154f:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c0021555:	50                   	push   %eax
c0021556:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002155c:	50                   	push   %eax
c002155d:	8d 83 ec 3e ff ff    	lea    -0xc114(%ebx),%eax
c0021563:	50                   	push   %eax
c0021564:	68 f1 00 00 00       	push   $0xf1
c0021569:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c002156f:	50                   	push   %eax
c0021570:	e8 65 7b 00 00       	call   c00290da <debug_panic>
    ASSERT(intr_get_level() == INTR_OFF);
c0021575:	83 ec 0c             	sub    $0xc,%esp
c0021578:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c002157e:	50                   	push   %eax
c002157f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021585:	50                   	push   %eax
c0021586:	8d 83 ec 3e ff ff    	lea    -0xc114(%ebx),%eax
c002158c:	50                   	push   %eax
c002158d:	68 f2 00 00 00       	push   $0xf2
c0021592:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0021598:	50                   	push   %eax
c0021599:	e8 3c 7b 00 00       	call   c00290da <debug_panic>

c002159e <idle>:
idle(void *idle_started_ UNUSED) {
c002159e:	53                   	push   %ebx
c002159f:	83 ec 08             	sub    $0x8,%esp
c00215a2:	e8 51 d9 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00215a7:	81 c3 81 9b 01 00    	add    $0x19b81,%ebx
    idle_thread = thread_current();
c00215ad:	e8 c4 f9 ff ff       	call   c0020f76 <thread_current>
c00215b2:	89 83 80 01 00 00    	mov    %eax,0x180(%ebx)
    sema_up(idle_started);
c00215b8:	83 ec 0c             	sub    $0xc,%esp
c00215bb:	ff 74 24 1c          	pushl  0x1c(%esp)
c00215bf:	e8 47 1a 00 00       	call   c002300b <sema_up>
c00215c4:	83 c4 10             	add    $0x10,%esp
        intr_disable();
c00215c7:	e8 43 07 00 00       	call   c0021d0f <intr_disable>
        thread_block();
c00215cc:	e8 44 ff ff ff       	call   c0021515 <thread_block>
        asm volatile ("sti; hlt" : : : "memory");
c00215d1:	fb                   	sti    
c00215d2:	f4                   	hlt    
c00215d3:	eb f2                	jmp    c00215c7 <idle+0x29>

c00215d5 <thread_exit>:
thread_exit(void) {
c00215d5:	53                   	push   %ebx
c00215d6:	83 ec 08             	sub    $0x8,%esp
c00215d9:	e8 1a d9 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00215de:	81 c3 4a 9b 01 00    	add    $0x19b4a,%ebx
    ASSERT(!intr_context());
c00215e4:	e8 cc 09 00 00       	call   c0021fb5 <intr_context>
c00215e9:	84 c0                	test   %al,%al
c00215eb:	74 29                	je     c0021616 <thread_exit+0x41>
c00215ed:	83 ec 0c             	sub    $0xc,%esp
c00215f0:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c00215f6:	50                   	push   %eax
c00215f7:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00215fd:	50                   	push   %eax
c00215fe:	8d 83 b4 3e ff ff    	lea    -0xc14c(%ebx),%eax
c0021604:	50                   	push   %eax
c0021605:	68 3e 01 00 00       	push   $0x13e
c002160a:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0021610:	50                   	push   %eax
c0021611:	e8 c4 7a 00 00       	call   c00290da <debug_panic>
    process_exit ();
c0021616:	e8 45 9e 00 00       	call   c002b460 <process_exit>
    intr_disable();
c002161b:	e8 ef 06 00 00       	call   c0021d0f <intr_disable>
    list_remove(&thread_current()->allelem);
c0021620:	e8 51 f9 ff ff       	call   c0020f76 <thread_current>
c0021625:	83 ec 0c             	sub    $0xc,%esp
c0021628:	05 ec 00 00 00       	add    $0xec,%eax
c002162d:	50                   	push   %eax
c002162e:	e8 76 81 00 00       	call   c00297a9 <list_remove>
    thread_current()->status = THREAD_DYING;
c0021633:	e8 3e f9 ff ff       	call   c0020f76 <thread_current>
c0021638:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    schedule();
c002163f:	e8 bd fd ff ff       	call   c0021401 <schedule>
    NOT_REACHED();
c0021644:	8d 83 d0 55 ff ff    	lea    -0xaa30(%ebx),%eax
c002164a:	50                   	push   %eax
c002164b:	8d 83 b4 3e ff ff    	lea    -0xc14c(%ebx),%eax
c0021651:	50                   	push   %eax
c0021652:	68 4b 01 00 00       	push   $0x14b
c0021657:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c002165d:	50                   	push   %eax
c002165e:	e8 77 7a 00 00       	call   c00290da <debug_panic>

c0021663 <kernel_thread>:
kernel_thread(thread_func *function, void *aux) {
c0021663:	56                   	push   %esi
c0021664:	53                   	push   %ebx
c0021665:	83 ec 04             	sub    $0x4,%esp
c0021668:	e8 8b d8 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002166d:	81 c3 bb 9a 01 00    	add    $0x19abb,%ebx
c0021673:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT(function != NULL);
c0021677:	85 f6                	test   %esi,%esi
c0021679:	74 13                	je     c002168e <kernel_thread+0x2b>
    intr_enable();       /* The scheduler runs with interrupts off. */
c002167b:	e8 46 06 00 00       	call   c0021cc6 <intr_enable>
    function(aux);       /* Execute the thread function. */
c0021680:	83 ec 0c             	sub    $0xc,%esp
c0021683:	ff 74 24 20          	pushl  0x20(%esp)
c0021687:	ff d6                	call   *%esi
    thread_exit();       /* If function() returns, kill the thread. */
c0021689:	e8 47 ff ff ff       	call   c00215d5 <thread_exit>
    ASSERT(function != NULL);
c002168e:	83 ec 0c             	sub    $0xc,%esp
c0021691:	8d 83 35 57 ff ff    	lea    -0xa8cb(%ebx),%eax
c0021697:	50                   	push   %eax
c0021698:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002169e:	50                   	push   %eax
c002169f:	8d 83 08 3f ff ff    	lea    -0xc0f8(%ebx),%eax
c00216a5:	50                   	push   %eax
c00216a6:	68 f4 01 00 00       	push   $0x1f4
c00216ab:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c00216b1:	50                   	push   %eax
c00216b2:	e8 23 7a 00 00       	call   c00290da <debug_panic>

c00216b7 <thread_yield>:
thread_yield(void) {
c00216b7:	57                   	push   %edi
c00216b8:	56                   	push   %esi
c00216b9:	53                   	push   %ebx
c00216ba:	e8 39 d8 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00216bf:	81 c3 69 9a 01 00    	add    $0x19a69,%ebx
    struct thread *cur = thread_current();
c00216c5:	e8 ac f8 ff ff       	call   c0020f76 <thread_current>
c00216ca:	89 c6                	mov    %eax,%esi
    ASSERT(!intr_context()); // int from inside
c00216cc:	e8 e4 08 00 00       	call   c0021fb5 <intr_context>
c00216d1:	84 c0                	test   %al,%al
c00216d3:	75 4a                	jne    c002171f <thread_yield+0x68>
    old_level = intr_disable(); // interrupt to schedule
c00216d5:	e8 35 06 00 00       	call   c0021d0f <intr_disable>
c00216da:	89 c7                	mov    %eax,%edi
    if (cur != idle_thread)
c00216dc:	39 b3 80 01 00 00    	cmp    %esi,0x180(%ebx)
c00216e2:	74 1f                	je     c0021703 <thread_yield+0x4c>
        list_insert_ordered(&ready_list, &cur->elem, (list_less_func *) &thread_cmp_priority, NULL);
c00216e4:	6a 00                	push   $0x0
c00216e6:	8d 83 8a 58 fe ff    	lea    -0x1a776(%ebx),%eax
c00216ec:	50                   	push   %eax
c00216ed:	8d 86 08 01 00 00    	lea    0x108(%esi),%eax
c00216f3:	50                   	push   %eax
c00216f4:	8d 83 94 01 00 00    	lea    0x194(%ebx),%eax
c00216fa:	50                   	push   %eax
c00216fb:	e8 9e 85 00 00       	call   c0029c9e <list_insert_ordered>
c0021700:	83 c4 10             	add    $0x10,%esp
    cur->status = THREAD_READY;
c0021703:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
    schedule();
c002170a:	e8 f2 fc ff ff       	call   c0021401 <schedule>
    intr_set_level(old_level);
c002170f:	83 ec 0c             	sub    $0xc,%esp
c0021712:	57                   	push   %edi
c0021713:	e8 fe 05 00 00       	call   c0021d16 <intr_set_level>
}
c0021718:	83 c4 10             	add    $0x10,%esp
c002171b:	5b                   	pop    %ebx
c002171c:	5e                   	pop    %esi
c002171d:	5f                   	pop    %edi
c002171e:	c3                   	ret    
    ASSERT(!intr_context()); // int from inside
c002171f:	83 ec 0c             	sub    $0xc,%esp
c0021722:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c0021728:	50                   	push   %eax
c0021729:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002172f:	50                   	push   %eax
c0021730:	8d 83 a4 3e ff ff    	lea    -0xc15c(%ebx),%eax
c0021736:	50                   	push   %eax
c0021737:	68 55 01 00 00       	push   $0x155
c002173c:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0021742:	50                   	push   %eax
c0021743:	e8 92 79 00 00       	call   c00290da <debug_panic>

c0021748 <thread_create>:
              thread_func *function, void *aux) {
c0021748:	55                   	push   %ebp
c0021749:	57                   	push   %edi
c002174a:	56                   	push   %esi
c002174b:	53                   	push   %ebx
c002174c:	83 ec 0c             	sub    $0xc,%esp
c002174f:	e8 a4 d7 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021754:	81 c3 d4 99 01 00    	add    $0x199d4,%ebx
    ASSERT(function != NULL);
c002175a:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c002175f:	0f 84 01 01 00 00    	je     c0021866 <thread_create+0x11e>
    t = palloc_get_page(PAL_ZERO);
c0021765:	83 ec 0c             	sub    $0xc,%esp
c0021768:	6a 02                	push   $0x2
c002176a:	e8 7a 22 00 00       	call   c00239e9 <palloc_get_page>
c002176f:	89 c6                	mov    %eax,%esi
    if (t == NULL)
c0021771:	83 c4 10             	add    $0x10,%esp
c0021774:	85 c0                	test   %eax,%eax
c0021776:	0f 84 2d 01 00 00    	je     c00218a9 <thread_create+0x161>
    init_thread(t, name, priority);
c002177c:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0021780:	8b 54 24 20          	mov    0x20(%esp),%edx
c0021784:	e8 78 f4 ff ff       	call   c0020c01 <init_thread>
    lock_acquire(&tid_lock);
c0021789:	83 ec 0c             	sub    $0xc,%esp
c002178c:	8d ab 58 01 00 00    	lea    0x158(%ebx),%ebp
c0021792:	55                   	push   %ebp
c0021793:	e8 71 1a 00 00       	call   c0023209 <lock_acquire>
    tid = next_tid++;
c0021798:	8b bb bc fb ff ff    	mov    -0x444(%ebx),%edi
c002179e:	8d 47 01             	lea    0x1(%edi),%eax
c00217a1:	89 83 bc fb ff ff    	mov    %eax,-0x444(%ebx)
    lock_release(&tid_lock);
c00217a7:	89 2c 24             	mov    %ebp,(%esp)
c00217aa:	e8 5b 1c 00 00       	call   c002340a <lock_release>
    tid = t->tid = allocate_tid();
c00217af:	89 3e                	mov    %edi,(%esi)
    if (thread_current() != NULL) {
c00217b1:	e8 c0 f7 ff ff       	call   c0020f76 <thread_current>
c00217b6:	89 c5                	mov    %eax,%ebp
c00217b8:	83 c4 10             	add    $0x10,%esp
c00217bb:	85 c0                	test   %eax,%eax
c00217bd:	74 33                	je     c00217f2 <thread_create+0xaa>
        t->parent = parent;
c00217bf:	89 86 dc 00 00 00    	mov    %eax,0xdc(%esi)
        struct process_info *info_t = (struct process_info *) malloc(sizeof(struct process_info));
c00217c5:	83 ec 0c             	sub    $0xc,%esp
c00217c8:	6a 18                	push   $0x18
c00217ca:	e8 2c 26 00 00       	call   c0023dfb <malloc>
        info_t->is_waiting = false;
c00217cf:	c6 00 00             	movb   $0x0,(%eax)
        info_t->has_exited = false;
c00217d2:	c6 40 01 00          	movb   $0x0,0x1(%eax)
        info_t->tid = tid;
c00217d6:	89 78 04             	mov    %edi,0x4(%eax)
        info_t->thread_ = t;
c00217d9:	89 70 14             	mov    %esi,0x14(%eax)
        list_push_back(&parent->child_list, &info_t->elem);
c00217dc:	83 c4 08             	add    $0x8,%esp
c00217df:	83 c0 0c             	add    $0xc,%eax
c00217e2:	50                   	push   %eax
c00217e3:	81 c5 cc 00 00 00    	add    $0xcc,%ebp
c00217e9:	55                   	push   %ebp
c00217ea:	e8 9d 7f 00 00       	call   c002978c <list_push_back>
c00217ef:	83 c4 10             	add    $0x10,%esp
    kf = alloc_frame(t, sizeof *kf);
c00217f2:	ba 0c 00 00 00       	mov    $0xc,%edx
c00217f7:	89 f0                	mov    %esi,%eax
c00217f9:	e8 e0 f2 ff ff       	call   c0020ade <alloc_frame>
    kf->eip = NULL;
c00217fe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    kf->function = function;
c0021804:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0021808:	89 48 04             	mov    %ecx,0x4(%eax)
    kf->aux = aux;
c002180b:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c002180f:	89 50 08             	mov    %edx,0x8(%eax)
    ef = alloc_frame(t, sizeof *ef);
c0021812:	ba 04 00 00 00       	mov    $0x4,%edx
c0021817:	89 f0                	mov    %esi,%eax
c0021819:	e8 c0 f2 ff ff       	call   c0020ade <alloc_frame>
    ef->eip = (void (*)(void)) kernel_thread;
c002181e:	8d 93 3b 65 fe ff    	lea    -0x19ac5(%ebx),%edx
c0021824:	89 10                	mov    %edx,(%eax)
    sf = alloc_frame(t, sizeof *sf);
c0021826:	ba 1c 00 00 00       	mov    $0x1c,%edx
c002182b:	89 f0                	mov    %esi,%eax
c002182d:	e8 ac f2 ff ff       	call   c0020ade <alloc_frame>
    sf->eip = switch_entry;
c0021832:	c7 c2 59 1b 02 c0    	mov    $0xc0021b59,%edx
c0021838:	89 50 10             	mov    %edx,0x10(%eax)
    sf->ebp = 0;
c002183b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    thread_unblock(t);
c0021842:	83 ec 0c             	sub    $0xc,%esp
c0021845:	56                   	push   %esi
c0021846:	e8 78 f6 ff ff       	call   c0020ec3 <thread_unblock>
    if (thread_current()->priority < priority) {
c002184b:	e8 26 f7 ff ff       	call   c0020f76 <thread_current>
c0021850:	83 c4 10             	add    $0x10,%esp
c0021853:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0021857:	39 48 24             	cmp    %ecx,0x24(%eax)
c002185a:	7c 33                	jl     c002188f <thread_create+0x147>
}
c002185c:	89 f8                	mov    %edi,%eax
c002185e:	83 c4 0c             	add    $0xc,%esp
c0021861:	5b                   	pop    %ebx
c0021862:	5e                   	pop    %esi
c0021863:	5f                   	pop    %edi
c0021864:	5d                   	pop    %ebp
c0021865:	c3                   	ret    
    ASSERT(function != NULL);
c0021866:	83 ec 0c             	sub    $0xc,%esp
c0021869:	8d 83 35 57 ff ff    	lea    -0xa8cb(%ebx),%eax
c002186f:	50                   	push   %eax
c0021870:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021876:	50                   	push   %eax
c0021877:	8d 83 18 3f ff ff    	lea    -0xc0e8(%ebx),%eax
c002187d:	50                   	push   %eax
c002187e:	68 ba 00 00 00       	push   $0xba
c0021883:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0021889:	50                   	push   %eax
c002188a:	e8 4b 78 00 00       	call   c00290da <debug_panic>
        enum intr_level old_level = intr_disable();
c002188f:	e8 7b 04 00 00       	call   c0021d0f <intr_disable>
c0021894:	89 c6                	mov    %eax,%esi
        thread_yield();
c0021896:	e8 1c fe ff ff       	call   c00216b7 <thread_yield>
        intr_set_level(old_level);
c002189b:	83 ec 0c             	sub    $0xc,%esp
c002189e:	56                   	push   %esi
c002189f:	e8 72 04 00 00       	call   c0021d16 <intr_set_level>
c00218a4:	83 c4 10             	add    $0x10,%esp
c00218a7:	eb b3                	jmp    c002185c <thread_create+0x114>
        return TID_ERROR;
c00218a9:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c00218ae:	eb ac                	jmp    c002185c <thread_create+0x114>

c00218b0 <thread_start>:
thread_start(void) {
c00218b0:	56                   	push   %esi
c00218b1:	53                   	push   %ebx
c00218b2:	83 ec 2c             	sub    $0x2c,%esp
c00218b5:	e8 3e d6 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00218ba:	81 c3 6e 98 01 00    	add    $0x1986e,%ebx
    sema_init(&idle_started, 0);
c00218c0:	6a 00                	push   $0x0
c00218c2:	8d 74 24 18          	lea    0x18(%esp),%esi
c00218c6:	56                   	push   %esi
c00218c7:	e8 c0 15 00 00       	call   c0022e8c <sema_init>
    thread_create("idle", PRI_MIN, idle, &idle_started);
c00218cc:	56                   	push   %esi
c00218cd:	8d 83 76 64 fe ff    	lea    -0x19b8a(%ebx),%eax
c00218d3:	50                   	push   %eax
c00218d4:	6a 00                	push   $0x0
c00218d6:	8d 83 46 57 ff ff    	lea    -0xa8ba(%ebx),%eax
c00218dc:	50                   	push   %eax
c00218dd:	e8 66 fe ff ff       	call   c0021748 <thread_create>
    intr_enable();
c00218e2:	83 c4 20             	add    $0x20,%esp
c00218e5:	e8 dc 03 00 00       	call   c0021cc6 <intr_enable>
    sema_down(&idle_started);
c00218ea:	83 ec 0c             	sub    $0xc,%esp
c00218ed:	56                   	push   %esi
c00218ee:	e8 ed 15 00 00       	call   c0022ee0 <sema_down>
}
c00218f3:	83 c4 34             	add    $0x34,%esp
c00218f6:	5b                   	pop    %ebx
c00218f7:	5e                   	pop    %esi
c00218f8:	c3                   	ret    

c00218f9 <thread_set_priority>:
thread_set_priority(int new_priority) {
c00218f9:	55                   	push   %ebp
c00218fa:	57                   	push   %edi
c00218fb:	56                   	push   %esi
c00218fc:	53                   	push   %ebx
c00218fd:	83 ec 0c             	sub    $0xc,%esp
c0021900:	e8 f3 d5 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021905:	81 c3 23 98 01 00    	add    $0x19823,%ebx
    struct thread *cur = thread_current();
c002190b:	e8 66 f6 ff ff       	call   c0020f76 <thread_current>
c0021910:	89 c6                	mov    %eax,%esi
    if (thread_mlfqs) {
c0021912:	c7 c0 80 d0 03 c0    	mov    $0xc003d080,%eax
c0021918:	80 38 00             	cmpb   $0x0,(%eax)
c002191b:	75 4d                	jne    c002196a <thread_set_priority+0x71>
    enum intr_level old_level = intr_disable();
c002191d:	e8 ed 03 00 00       	call   c0021d0f <intr_disable>
c0021922:	89 c7                	mov    %eax,%edi
    int old_priority = cur->priority;
c0021924:	8b 6e 24             	mov    0x24(%esi),%ebp
    cur->original_priority = new_priority;
c0021927:	8b 44 24 20          	mov    0x20(%esp),%eax
c002192b:	89 46 28             	mov    %eax,0x28(%esi)
    if (list_empty(&cur->lock_list) || new_priority > old_priority) {
c002192e:	83 ec 0c             	sub    $0xc,%esp
c0021931:	8d 86 f4 00 00 00    	lea    0xf4(%esi),%eax
c0021937:	50                   	push   %eax
c0021938:	e8 0e 7f 00 00       	call   c002984b <list_empty>
c002193d:	83 c4 10             	add    $0x10,%esp
c0021940:	3b 6c 24 20          	cmp    0x20(%esp),%ebp
c0021944:	7c 04                	jl     c002194a <thread_set_priority+0x51>
c0021946:	84 c0                	test   %al,%al
c0021948:	74 0c                	je     c0021956 <thread_set_priority+0x5d>
        cur->priority = new_priority;
c002194a:	8b 44 24 20          	mov    0x20(%esp),%eax
c002194e:	89 46 24             	mov    %eax,0x24(%esi)
        thread_yield();
c0021951:	e8 61 fd ff ff       	call   c00216b7 <thread_yield>
    intr_set_level(old_level);
c0021956:	83 ec 0c             	sub    $0xc,%esp
c0021959:	57                   	push   %edi
c002195a:	e8 b7 03 00 00       	call   c0021d16 <intr_set_level>
c002195f:	83 c4 10             	add    $0x10,%esp
}
c0021962:	83 c4 0c             	add    $0xc,%esp
c0021965:	5b                   	pop    %ebx
c0021966:	5e                   	pop    %esi
c0021967:	5f                   	pop    %edi
c0021968:	5d                   	pop    %ebp
c0021969:	c3                   	ret    
        printf("\n\n !!!mlfqs should not set priority\n\n\n");
c002196a:	83 ec 0c             	sub    $0xc,%esp
c002196d:	8d 83 f4 55 ff ff    	lea    -0xaa0c(%ebx),%eax
c0021973:	50                   	push   %eax
c0021974:	e8 37 97 00 00       	call   c002b0b0 <puts>
        return;
c0021979:	83 c4 10             	add    $0x10,%esp
c002197c:	eb e4                	jmp    c0021962 <thread_set_priority+0x69>

c002197e <thread_set_nice>:
thread_set_nice(int new_nice) {
c002197e:	56                   	push   %esi
c002197f:	53                   	push   %ebx
c0021980:	83 ec 04             	sub    $0x4,%esp
c0021983:	e8 70 d5 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021988:	81 c3 a0 97 01 00    	add    $0x197a0,%ebx
    struct thread *cur = thread_current();
c002198e:	e8 e3 f5 ff ff       	call   c0020f76 <thread_current>
    cur->nice = new_nice;
c0021993:	8b 54 24 10          	mov    0x10(%esp),%edx
c0021997:	89 50 1c             	mov    %edx,0x1c(%eax)
    update_thread_priority_mlfqs(cur, NULL);
c002199a:	83 ec 08             	sub    $0x8,%esp
c002199d:	6a 00                	push   $0x0
c002199f:	50                   	push   %eax
c00219a0:	e8 be f1 ff ff       	call   c0020b63 <update_thread_priority_mlfqs>
    enum intr_level old_level = intr_disable();
c00219a5:	e8 65 03 00 00       	call   c0021d0f <intr_disable>
c00219aa:	89 c6                	mov    %eax,%esi
    thread_yield();
c00219ac:	e8 06 fd ff ff       	call   c00216b7 <thread_yield>
    intr_set_level(old_level);
c00219b1:	89 34 24             	mov    %esi,(%esp)
c00219b4:	e8 5d 03 00 00       	call   c0021d16 <intr_set_level>
}
c00219b9:	83 c4 14             	add    $0x14,%esp
c00219bc:	5b                   	pop    %ebx
c00219bd:	5e                   	pop    %esi
c00219be:	c3                   	ret    

c00219bf <thread_update_priority>:


void
thread_update_priority(struct thread *t) {
c00219bf:	55                   	push   %ebp
c00219c0:	57                   	push   %edi
c00219c1:	56                   	push   %esi
c00219c2:	53                   	push   %ebx
c00219c3:	83 ec 1c             	sub    $0x1c,%esp
c00219c6:	e8 2d d5 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00219cb:	81 c3 5d 97 01 00    	add    $0x1975d,%ebx
c00219d1:	8b 74 24 30          	mov    0x30(%esp),%esi
    enum intr_level old_level = intr_disable();
c00219d5:	e8 35 03 00 00       	call   c0021d0f <intr_disable>
c00219da:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int max_priority = t->original_priority;
c00219de:	8b 7e 28             	mov    0x28(%esi),%edi
    int lock_priority;

    if (!list_empty(&t->lock_list)) {
c00219e1:	8d ae f4 00 00 00    	lea    0xf4(%esi),%ebp
c00219e7:	83 ec 0c             	sub    $0xc,%esp
c00219ea:	55                   	push   %ebp
c00219eb:	e8 5b 7e 00 00       	call   c002984b <list_empty>
c00219f0:	83 c4 10             	add    $0x10,%esp
c00219f3:	84 c0                	test   %al,%al
c00219f5:	74 17                	je     c0021a0e <thread_update_priority+0x4f>
        lock_priority = list_entry (list_front(&t->lock_list), struct lock, elem)->max_priority;
        if (lock_priority > max_priority)
            max_priority = lock_priority;
    }

    t->priority = max_priority;
c00219f7:	89 7e 24             	mov    %edi,0x24(%esi)
    intr_set_level(old_level);
c00219fa:	83 ec 0c             	sub    $0xc,%esp
c00219fd:	ff 74 24 18          	pushl  0x18(%esp)
c0021a01:	e8 10 03 00 00       	call   c0021d16 <intr_set_level>
}
c0021a06:	83 c4 2c             	add    $0x2c,%esp
c0021a09:	5b                   	pop    %ebx
c0021a0a:	5e                   	pop    %esi
c0021a0b:	5f                   	pop    %edi
c0021a0c:	5d                   	pop    %ebp
c0021a0d:	c3                   	ret    
        list_sort(&t->lock_list, lock_cmp_priority, NULL);
c0021a0e:	83 ec 04             	sub    $0x4,%esp
c0021a11:	6a 00                	push   $0x0
c0021a13:	8d 83 a2 58 fe ff    	lea    -0x1a75e(%ebx),%eax
c0021a19:	50                   	push   %eax
c0021a1a:	55                   	push   %ebp
c0021a1b:	e8 91 7f 00 00       	call   c00299b1 <list_sort>
        lock_priority = list_entry (list_front(&t->lock_list), struct lock, elem)->max_priority;
c0021a20:	89 2c 24             	mov    %ebp,(%esp)
c0021a23:	e8 47 7e 00 00       	call   c002986f <list_front>
        if (lock_priority > max_priority)
c0021a28:	8b 40 08             	mov    0x8(%eax),%eax
c0021a2b:	83 c4 10             	add    $0x10,%esp
c0021a2e:	39 c7                	cmp    %eax,%edi
c0021a30:	0f 4c f8             	cmovl  %eax,%edi
c0021a33:	eb c2                	jmp    c00219f7 <thread_update_priority+0x38>

c0021a35 <thread_donate_priority>:


/* Donate current priority to thread t. */
void
thread_donate_priority(struct thread *t) {
c0021a35:	57                   	push   %edi
c0021a36:	56                   	push   %esi
c0021a37:	53                   	push   %ebx
c0021a38:	e8 bb d4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021a3d:	81 c3 eb 96 01 00    	add    $0x196eb,%ebx
c0021a43:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0021a47:	e8 c3 02 00 00       	call   c0021d0f <intr_disable>
c0021a4c:	89 c7                	mov    %eax,%edi
    thread_update_priority(t);
c0021a4e:	83 ec 0c             	sub    $0xc,%esp
c0021a51:	56                   	push   %esi
c0021a52:	e8 68 ff ff ff       	call   c00219bf <thread_update_priority>

    if (t->status == THREAD_READY) {
c0021a57:	83 c4 10             	add    $0x10,%esp
c0021a5a:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
c0021a5e:	74 10                	je     c0021a70 <thread_donate_priority+0x3b>
        list_remove(&t->elem);
        list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
    }
    intr_set_level(old_level);
c0021a60:	83 ec 0c             	sub    $0xc,%esp
c0021a63:	57                   	push   %edi
c0021a64:	e8 ad 02 00 00       	call   c0021d16 <intr_set_level>
}
c0021a69:	83 c4 10             	add    $0x10,%esp
c0021a6c:	5b                   	pop    %ebx
c0021a6d:	5e                   	pop    %esi
c0021a6e:	5f                   	pop    %edi
c0021a6f:	c3                   	ret    
        list_remove(&t->elem);
c0021a70:	81 c6 08 01 00 00    	add    $0x108,%esi
c0021a76:	83 ec 0c             	sub    $0xc,%esp
c0021a79:	56                   	push   %esi
c0021a7a:	e8 2a 7d 00 00       	call   c00297a9 <list_remove>
        list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
c0021a7f:	6a 00                	push   $0x0
c0021a81:	8d 83 8a 58 fe ff    	lea    -0x1a776(%ebx),%eax
c0021a87:	50                   	push   %eax
c0021a88:	56                   	push   %esi
c0021a89:	8d 83 94 01 00 00    	lea    0x194(%ebx),%eax
c0021a8f:	50                   	push   %eax
c0021a90:	e8 09 82 00 00       	call   c0029c9e <list_insert_ordered>
c0021a95:	83 c4 20             	add    $0x20,%esp
c0021a98:	eb c6                	jmp    c0021a60 <thread_donate_priority+0x2b>

c0021a9a <thread_remove_lock>:

void thread_remove_lock(struct lock *lock) {
c0021a9a:	56                   	push   %esi
c0021a9b:	53                   	push   %ebx
c0021a9c:	83 ec 04             	sub    $0x4,%esp
c0021a9f:	e8 54 d4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021aa4:	81 c3 84 96 01 00    	add    $0x19684,%ebx
    enum intr_level old_level = intr_disable();
c0021aaa:	e8 60 02 00 00       	call   c0021d0f <intr_disable>
c0021aaf:	89 c6                	mov    %eax,%esi
    list_remove(&lock->elem);
c0021ab1:	83 ec 0c             	sub    $0xc,%esp
c0021ab4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0021ab8:	83 c0 18             	add    $0x18,%eax
c0021abb:	50                   	push   %eax
c0021abc:	e8 e8 7c 00 00       	call   c00297a9 <list_remove>
    thread_update_priority(thread_current());
c0021ac1:	e8 b0 f4 ff ff       	call   c0020f76 <thread_current>
c0021ac6:	89 04 24             	mov    %eax,(%esp)
c0021ac9:	e8 f1 fe ff ff       	call   c00219bf <thread_update_priority>
    intr_set_level(old_level);
c0021ace:	89 34 24             	mov    %esi,(%esp)
c0021ad1:	e8 40 02 00 00       	call   c0021d16 <intr_set_level>
}
c0021ad6:	83 c4 14             	add    $0x14,%esp
c0021ad9:	5b                   	pop    %ebx
c0021ada:	5e                   	pop    %esi
c0021adb:	c3                   	ret    

c0021adc <thread_hold_the_lock>:

void thread_hold_the_lock(struct lock *lock) {
c0021adc:	57                   	push   %edi
c0021add:	56                   	push   %esi
c0021ade:	53                   	push   %ebx
c0021adf:	e8 14 d4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021ae4:	81 c3 44 96 01 00    	add    $0x19644,%ebx
c0021aea:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0021aee:	e8 1c 02 00 00       	call   c0021d0f <intr_disable>
c0021af3:	89 c7                	mov    %eax,%edi
    list_insert_ordered(&thread_current()->lock_list, &lock->elem, lock_cmp_priority, NULL);
c0021af5:	e8 7c f4 ff ff       	call   c0020f76 <thread_current>
c0021afa:	6a 00                	push   $0x0
c0021afc:	8d 93 a2 58 fe ff    	lea    -0x1a75e(%ebx),%edx
c0021b02:	52                   	push   %edx
c0021b03:	8d 56 18             	lea    0x18(%esi),%edx
c0021b06:	52                   	push   %edx
c0021b07:	05 f4 00 00 00       	add    $0xf4,%eax
c0021b0c:	50                   	push   %eax
c0021b0d:	e8 8c 81 00 00       	call   c0029c9e <list_insert_ordered>

    if (lock->max_priority > thread_current()->priority) {
c0021b12:	8b 76 20             	mov    0x20(%esi),%esi
c0021b15:	e8 5c f4 ff ff       	call   c0020f76 <thread_current>
c0021b1a:	83 c4 10             	add    $0x10,%esp
c0021b1d:	3b 70 24             	cmp    0x24(%eax),%esi
c0021b20:	7f 10                	jg     c0021b32 <thread_hold_the_lock+0x56>
        thread_current()->priority = lock->max_priority;
        thread_yield();
    }

    intr_set_level(old_level);
c0021b22:	83 ec 0c             	sub    $0xc,%esp
c0021b25:	57                   	push   %edi
c0021b26:	e8 eb 01 00 00       	call   c0021d16 <intr_set_level>
}
c0021b2b:	83 c4 10             	add    $0x10,%esp
c0021b2e:	5b                   	pop    %ebx
c0021b2f:	5e                   	pop    %esi
c0021b30:	5f                   	pop    %edi
c0021b31:	c3                   	ret    
        thread_current()->priority = lock->max_priority;
c0021b32:	89 70 24             	mov    %esi,0x24(%eax)
        thread_yield();
c0021b35:	e8 7d fb ff ff       	call   c00216b7 <thread_yield>
c0021b3a:	eb e6                	jmp    c0021b22 <thread_hold_the_lock+0x46>

c0021b3c <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021b3c:	53                   	push   %ebx
	pushl %ebp
c0021b3d:	55                   	push   %ebp
	pushl %esi
c0021b3e:	56                   	push   %esi
	pushl %edi
c0021b3f:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021b40:	8b 15 e8 ac 03 c0    	mov    0xc003ace8,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021b46:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021b4a:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021b4d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021b51:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021b54:	5f                   	pop    %edi
	popl %esi
c0021b55:	5e                   	pop    %esi
	popl %ebp
c0021b56:	5d                   	pop    %ebp
	popl %ebx
c0021b57:	5b                   	pop    %ebx
        ret
c0021b58:	c3                   	ret    

c0021b59 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021b59:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021b5c:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021b5d:	e8 ec f7 ff ff       	call   c002134e <thread_schedule_tail>
	addl $4, %esp
c0021b62:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021b65:	c3                   	ret    

c0021b66 <make_gate>:
   trap gate).  The difference is that entering an interrupt gate
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate(void (*function)(void), int dpl, int type) {
c0021b66:	53                   	push   %ebx
c0021b67:	83 ec 08             	sub    $0x8,%esp
c0021b6a:	e8 89 d3 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021b6f:	81 c3 b9 95 01 00    	add    $0x195b9,%ebx
    uint32_t e0, e1;

    ASSERT (function != NULL);
c0021b75:	85 c0                	test   %eax,%eax
c0021b77:	74 2c                	je     c0021ba5 <make_gate+0x3f>
    ASSERT (dpl >= 0 && dpl <= 3);
c0021b79:	83 fa 03             	cmp    $0x3,%edx
c0021b7c:	77 50                	ja     c0021bce <make_gate+0x68>
    ASSERT (type >= 0 && type <= 15);
c0021b7e:	83 f9 0f             	cmp    $0xf,%ecx
c0021b81:	77 74                	ja     c0021bf7 <make_gate+0x91>

    e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
          | (SEL_KCSEG << 16));              /* Target code segment. */

    e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021b83:	89 c3                	mov    %eax,%ebx
c0021b85:	66 bb 00 00          	mov    $0x0,%bx
          | (1 << 15)                        /* Present. */
          | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
          | (0 << 12)                        /* System. */
          | ((uint32_t) type << 8));         /* Gate type. */
c0021b89:	c1 e1 08             	shl    $0x8,%ecx
c0021b8c:	09 cb                	or     %ecx,%ebx
          | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c0021b8e:	c1 e2 0d             	shl    $0xd,%edx
          | ((uint32_t) type << 8));         /* Gate type. */
c0021b91:	09 d3                	or     %edx,%ebx
    e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021b93:	89 da                	mov    %ebx,%edx
c0021b95:	80 ce 80             	or     $0x80,%dh
    e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021b98:	0f b7 c0             	movzwl %ax,%eax
c0021b9b:	0d 00 00 08 00       	or     $0x80000,%eax

    return e0 | ((uint64_t) e1 << 32);
}
c0021ba0:	83 c4 08             	add    $0x8,%esp
c0021ba3:	5b                   	pop    %ebx
c0021ba4:	c3                   	ret    
    ASSERT (function != NULL);
c0021ba5:	83 ec 0c             	sub    $0xc,%esp
c0021ba8:	8d 83 35 57 ff ff    	lea    -0xa8cb(%ebx),%eax
c0021bae:	50                   	push   %eax
c0021baf:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021bb5:	50                   	push   %eax
c0021bb6:	8d 83 c4 3f ff ff    	lea    -0xc03c(%ebx),%eax
c0021bbc:	50                   	push   %eax
c0021bbd:	68 1d 01 00 00       	push   $0x11d
c0021bc2:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0021bc8:	50                   	push   %eax
c0021bc9:	e8 0c 75 00 00       	call   c00290da <debug_panic>
    ASSERT (dpl >= 0 && dpl <= 3);
c0021bce:	83 ec 0c             	sub    $0xc,%esp
c0021bd1:	8d 83 65 57 ff ff    	lea    -0xa89b(%ebx),%eax
c0021bd7:	50                   	push   %eax
c0021bd8:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021bde:	50                   	push   %eax
c0021bdf:	8d 83 c4 3f ff ff    	lea    -0xc03c(%ebx),%eax
c0021be5:	50                   	push   %eax
c0021be6:	68 1e 01 00 00       	push   $0x11e
c0021beb:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0021bf1:	50                   	push   %eax
c0021bf2:	e8 e3 74 00 00       	call   c00290da <debug_panic>
    ASSERT (type >= 0 && type <= 15);
c0021bf7:	83 ec 0c             	sub    $0xc,%esp
c0021bfa:	8d 83 7a 57 ff ff    	lea    -0xa886(%ebx),%eax
c0021c00:	50                   	push   %eax
c0021c01:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021c07:	50                   	push   %eax
c0021c08:	8d 83 c4 3f ff ff    	lea    -0xc03c(%ebx),%eax
c0021c0e:	50                   	push   %eax
c0021c0f:	68 1f 01 00 00       	push   $0x11f
c0021c14:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0021c1a:	50                   	push   %eax
c0021c1b:	e8 ba 74 00 00       	call   c00290da <debug_panic>

c0021c20 <register_handler>:
                 intr_handler_func *handler, const char *name) {
c0021c20:	56                   	push   %esi
c0021c21:	53                   	push   %ebx
c0021c22:	83 ec 04             	sub    $0x4,%esp
c0021c25:	e8 ce d2 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021c2a:	81 c3 fe 94 01 00    	add    $0x194fe,%ebx
    ASSERT (intr_handlers[vec_no] == NULL);
c0021c30:	0f b6 f0             	movzbl %al,%esi
c0021c33:	83 bc b3 d8 09 00 00 	cmpl   $0x0,0x9d8(%ebx,%esi,4)
c0021c3a:	00 
c0021c3b:	75 42                	jne    c0021c7f <register_handler+0x5f>
    if (level == INTR_ON)
c0021c3d:	83 f9 01             	cmp    $0x1,%ecx
c0021c40:	74 66                	je     c0021ca8 <register_handler+0x88>
        idt[vec_no] = make_intr_gate(intr_stubs[vec_no], dpl);
c0021c42:	c7 c0 ec ac 03 c0    	mov    $0xc003acec,%eax

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate(void (*function)(void), int dpl) {
    return make_gate(function, dpl, 14);
c0021c48:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021c4b:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021c50:	e8 11 ff ff ff       	call   c0021b66 <make_gate>
c0021c55:	89 84 f3 d8 0d 00 00 	mov    %eax,0xdd8(%ebx,%esi,8)
c0021c5c:	89 94 f3 dc 0d 00 00 	mov    %edx,0xddc(%ebx,%esi,8)
    intr_handlers[vec_no] = handler;
c0021c63:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021c67:	89 84 b3 d8 09 00 00 	mov    %eax,0x9d8(%ebx,%esi,4)
    intr_names[vec_no] = name;
c0021c6e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021c72:	89 84 b3 d8 05 00 00 	mov    %eax,0x5d8(%ebx,%esi,4)
}
c0021c79:	83 c4 04             	add    $0x4,%esp
c0021c7c:	5b                   	pop    %ebx
c0021c7d:	5e                   	pop    %esi
c0021c7e:	c3                   	ret    
    ASSERT (intr_handlers[vec_no] == NULL);
c0021c7f:	83 ec 0c             	sub    $0xc,%esp
c0021c82:	8d 83 92 57 ff ff    	lea    -0xa86e(%ebx),%eax
c0021c88:	50                   	push   %eax
c0021c89:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021c8f:	50                   	push   %eax
c0021c90:	8d 83 9c 3f ff ff    	lea    -0xc064(%ebx),%eax
c0021c96:	50                   	push   %eax
c0021c97:	68 a2 00 00 00       	push   $0xa2
c0021c9c:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0021ca2:	50                   	push   %eax
c0021ca3:	e8 32 74 00 00       	call   c00290da <debug_panic>
        idt[vec_no] = make_trap_gate(intr_stubs[vec_no], dpl);
c0021ca8:	c7 c0 ec ac 03 c0    	mov    $0xc003acec,%eax

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate(void (*function)(void), int dpl) {
    return make_gate(function, dpl, 15);
c0021cae:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021cb1:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021cb6:	e8 ab fe ff ff       	call   c0021b66 <make_gate>
c0021cbb:	eb 98                	jmp    c0021c55 <register_handler+0x35>

c0021cbd <intr_get_level>:
    asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021cbd:	9c                   	pushf  
c0021cbe:	58                   	pop    %eax
    return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021cbf:	c1 e8 09             	shr    $0x9,%eax
c0021cc2:	83 e0 01             	and    $0x1,%eax
}
c0021cc5:	c3                   	ret    

c0021cc6 <intr_enable>:
intr_enable(void) {
c0021cc6:	53                   	push   %ebx
c0021cc7:	83 ec 08             	sub    $0x8,%esp
c0021cca:	e8 29 d2 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021ccf:	81 c3 59 94 01 00    	add    $0x19459,%ebx
    enum intr_level old_level = intr_get_level();
c0021cd5:	e8 e3 ff ff ff       	call   c0021cbd <intr_get_level>
    ASSERT (!intr_context());
c0021cda:	80 bb b9 01 00 00 00 	cmpb   $0x0,0x1b9(%ebx)
c0021ce1:	75 06                	jne    c0021ce9 <intr_enable+0x23>
    asm volatile ("sti");
c0021ce3:	fb                   	sti    
}
c0021ce4:	83 c4 08             	add    $0x8,%esp
c0021ce7:	5b                   	pop    %ebx
c0021ce8:	c3                   	ret    
    ASSERT (!intr_context());
c0021ce9:	83 ec 0c             	sub    $0xc,%esp
c0021cec:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c0021cf2:	50                   	push   %eax
c0021cf3:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021cf9:	50                   	push   %eax
c0021cfa:	8d 83 d0 3f ff ff    	lea    -0xc030(%ebx),%eax
c0021d00:	50                   	push   %eax
c0021d01:	6a 5e                	push   $0x5e
c0021d03:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0021d09:	50                   	push   %eax
c0021d0a:	e8 cb 73 00 00       	call   c00290da <debug_panic>

c0021d0f <intr_disable>:
    enum intr_level old_level = intr_get_level();
c0021d0f:	e8 a9 ff ff ff       	call   c0021cbd <intr_get_level>
    asm volatile ("cli" : : : "memory"); // clear interrupt
c0021d14:	fa                   	cli    
}
c0021d15:	c3                   	ret    

c0021d16 <intr_set_level>:
intr_set_level(enum intr_level level) {
c0021d16:	83 ec 0c             	sub    $0xc,%esp
    return level == INTR_ON ? intr_enable() : intr_disable();
c0021d19:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021d1e:	74 09                	je     c0021d29 <intr_set_level+0x13>
c0021d20:	e8 ea ff ff ff       	call   c0021d0f <intr_disable>
}
c0021d25:	83 c4 0c             	add    $0xc,%esp
c0021d28:	c3                   	ret    
    return level == INTR_ON ? intr_enable() : intr_disable();
c0021d29:	e8 98 ff ff ff       	call   c0021cc6 <intr_enable>
c0021d2e:	eb f5                	jmp    c0021d25 <intr_set_level+0xf>

c0021d30 <intr_init>:
intr_init(void) {
c0021d30:	55                   	push   %ebp
c0021d31:	57                   	push   %edi
c0021d32:	56                   	push   %esi
c0021d33:	53                   	push   %ebx
c0021d34:	83 ec 2c             	sub    $0x2c,%esp
c0021d37:	e8 c4 d1 00 00       	call   c002ef00 <__x86.get_pc_thunk.bp>
c0021d3c:	81 c5 ec 93 01 00    	add    $0x193ec,%ebp

/* Writes byte DATA to PORT. */
static inline void
outb(uint16_t port, uint8_t data) {
    /* See [IA32-v2b] "OUT". */
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021d42:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0021d47:	e6 21                	out    %al,$0x21
c0021d49:	e6 a1                	out    %al,$0xa1
c0021d4b:	b9 11 00 00 00       	mov    $0x11,%ecx
c0021d50:	89 c8                	mov    %ecx,%eax
c0021d52:	e6 20                	out    %al,$0x20
c0021d54:	b8 20 00 00 00       	mov    $0x20,%eax
c0021d59:	e6 21                	out    %al,$0x21
c0021d5b:	b8 04 00 00 00       	mov    $0x4,%eax
c0021d60:	e6 21                	out    %al,$0x21
c0021d62:	ba 01 00 00 00       	mov    $0x1,%edx
c0021d67:	89 d0                	mov    %edx,%eax
c0021d69:	e6 21                	out    %al,$0x21
c0021d6b:	89 c8                	mov    %ecx,%eax
c0021d6d:	e6 a0                	out    %al,$0xa0
c0021d6f:	b8 28 00 00 00       	mov    $0x28,%eax
c0021d74:	e6 a1                	out    %al,$0xa1
c0021d76:	b8 02 00 00 00       	mov    $0x2,%eax
c0021d7b:	e6 a1                	out    %al,$0xa1
c0021d7d:	89 d0                	mov    %edx,%eax
c0021d7f:	e6 a1                	out    %al,$0xa1
c0021d81:	b8 00 00 00 00       	mov    $0x0,%eax
c0021d86:	e6 21                	out    %al,$0x21
c0021d88:	e6 a1                	out    %al,$0xa1
c0021d8a:	c7 c3 ec ac 03 c0    	mov    $0xc003acec,%ebx
c0021d90:	8d 85 d8 0d 00 00    	lea    0xdd8(%ebp),%eax
c0021d96:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0021d9a:	8d bb 00 04 00 00    	lea    0x400(%ebx),%edi
c0021da0:	89 c6                	mov    %eax,%esi
    return make_gate(function, dpl, 14);
c0021da2:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021da7:	ba 00 00 00 00       	mov    $0x0,%edx
c0021dac:	8b 03                	mov    (%ebx),%eax
c0021dae:	e8 b3 fd ff ff       	call   c0021b66 <make_gate>
        idt[i] = make_intr_gate(intr_stubs[i], 0);
c0021db3:	89 06                	mov    %eax,(%esi)
c0021db5:	89 56 04             	mov    %edx,0x4(%esi)
c0021db8:	83 c3 04             	add    $0x4,%ebx
c0021dbb:	83 c6 08             	add    $0x8,%esi
    for (i = 0; i < INTR_CNT; i++)
c0021dbe:	39 fb                	cmp    %edi,%ebx
c0021dc0:	75 e0                	jne    c0021da2 <intr_init+0x72>

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand(uint16_t limit, void *base) {
    return limit | ((uint64_t) (uint32_t) base << 16);
c0021dc2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0021dc6:	ba 00 00 00 00       	mov    $0x0,%edx
c0021dcb:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021dcf:	c1 e0 10             	shl    $0x10,%eax
c0021dd2:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021dd7:	89 44 24 18          	mov    %eax,0x18(%esp)
c0021ddb:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021ddf:	0f 01 5c 24 18       	lidtl  0x18(%esp)
    for (i = 0; i < INTR_CNT; i++)
c0021de4:	8d 85 d8 05 00 00    	lea    0x5d8(%ebp),%eax
c0021dea:	8d 8d d8 09 00 00    	lea    0x9d8(%ebp),%ecx
        intr_names[i] = "unknown";
c0021df0:	8d 95 b0 57 ff ff    	lea    -0xa850(%ebp),%edx
c0021df6:	89 10                	mov    %edx,(%eax)
c0021df8:	83 c0 04             	add    $0x4,%eax
    for (i = 0; i < INTR_CNT; i++)
c0021dfb:	39 c1                	cmp    %eax,%ecx
c0021dfd:	75 f7                	jne    c0021df6 <intr_init+0xc6>
    intr_names[0] = "#DE Divide Error";
c0021dff:	8d 85 b8 57 ff ff    	lea    -0xa848(%ebp),%eax
c0021e05:	89 85 d8 05 00 00    	mov    %eax,0x5d8(%ebp)
    intr_names[1] = "#DB Debug Exception";
c0021e0b:	8d 85 c9 57 ff ff    	lea    -0xa837(%ebp),%eax
c0021e11:	89 85 dc 05 00 00    	mov    %eax,0x5dc(%ebp)
    intr_names[2] = "NMI Interrupt";
c0021e17:	8d 85 dd 57 ff ff    	lea    -0xa823(%ebp),%eax
c0021e1d:	89 85 e0 05 00 00    	mov    %eax,0x5e0(%ebp)
    intr_names[3] = "#BP Breakpoint Exception";
c0021e23:	8d 85 eb 57 ff ff    	lea    -0xa815(%ebp),%eax
c0021e29:	89 85 e4 05 00 00    	mov    %eax,0x5e4(%ebp)
    intr_names[4] = "#OF Overflow Exception";
c0021e2f:	8d 85 04 58 ff ff    	lea    -0xa7fc(%ebp),%eax
c0021e35:	89 85 e8 05 00 00    	mov    %eax,0x5e8(%ebp)
    intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021e3b:	8d 85 40 59 ff ff    	lea    -0xa6c0(%ebp),%eax
c0021e41:	89 85 ec 05 00 00    	mov    %eax,0x5ec(%ebp)
    intr_names[6] = "#UD Invalid Opcode Exception";
c0021e47:	8d 85 1b 58 ff ff    	lea    -0xa7e5(%ebp),%eax
c0021e4d:	89 85 f0 05 00 00    	mov    %eax,0x5f0(%ebp)
    intr_names[7] = "#NM Device Not Available Exception";
c0021e53:	8d 85 64 59 ff ff    	lea    -0xa69c(%ebp),%eax
c0021e59:	89 85 f4 05 00 00    	mov    %eax,0x5f4(%ebp)
    intr_names[8] = "#DF Double Fault Exception";
c0021e5f:	8d 85 38 58 ff ff    	lea    -0xa7c8(%ebp),%eax
c0021e65:	89 85 f8 05 00 00    	mov    %eax,0x5f8(%ebp)
    intr_names[9] = "Coprocessor Segment Overrun";
c0021e6b:	8d 85 53 58 ff ff    	lea    -0xa7ad(%ebp),%eax
c0021e71:	89 85 fc 05 00 00    	mov    %eax,0x5fc(%ebp)
    intr_names[10] = "#TS Invalid TSS Exception";
c0021e77:	8d 85 6f 58 ff ff    	lea    -0xa791(%ebp),%eax
c0021e7d:	89 85 00 06 00 00    	mov    %eax,0x600(%ebp)
    intr_names[11] = "#NP Segment Not Present";
c0021e83:	8d 85 89 58 ff ff    	lea    -0xa777(%ebp),%eax
c0021e89:	89 85 04 06 00 00    	mov    %eax,0x604(%ebp)
    intr_names[12] = "#SS Stack Fault Exception";
c0021e8f:	8d 85 a1 58 ff ff    	lea    -0xa75f(%ebp),%eax
c0021e95:	89 85 08 06 00 00    	mov    %eax,0x608(%ebp)
    intr_names[13] = "#GP General Protection Exception";
c0021e9b:	8d 85 88 59 ff ff    	lea    -0xa678(%ebp),%eax
c0021ea1:	89 85 0c 06 00 00    	mov    %eax,0x60c(%ebp)
    intr_names[14] = "#PF Page-Fault Exception";
c0021ea7:	8d 85 bb 58 ff ff    	lea    -0xa745(%ebp),%eax
c0021ead:	89 85 10 06 00 00    	mov    %eax,0x610(%ebp)
    intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021eb3:	8d 85 ac 59 ff ff    	lea    -0xa654(%ebp),%eax
c0021eb9:	89 85 18 06 00 00    	mov    %eax,0x618(%ebp)
    intr_names[17] = "#AC Alignment Check Exception";
c0021ebf:	8d 85 d4 58 ff ff    	lea    -0xa72c(%ebp),%eax
c0021ec5:	89 85 1c 06 00 00    	mov    %eax,0x61c(%ebp)
    intr_names[18] = "#MC Machine-Check Exception";
c0021ecb:	8d 85 f2 58 ff ff    	lea    -0xa70e(%ebp),%eax
c0021ed1:	89 85 20 06 00 00    	mov    %eax,0x620(%ebp)
    intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021ed7:	8d 85 d0 59 ff ff    	lea    -0xa630(%ebp),%eax
c0021edd:	89 85 24 06 00 00    	mov    %eax,0x624(%ebp)
}
c0021ee3:	83 c4 2c             	add    $0x2c,%esp
c0021ee6:	5b                   	pop    %ebx
c0021ee7:	5e                   	pop    %esi
c0021ee8:	5f                   	pop    %edi
c0021ee9:	5d                   	pop    %ebp
c0021eea:	c3                   	ret    

c0021eeb <intr_register_ext>:
                  const char *name) {
c0021eeb:	53                   	push   %ebx
c0021eec:	83 ec 08             	sub    $0x8,%esp
c0021eef:	e8 04 d0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021ef4:	81 c3 34 92 01 00    	add    $0x19234,%ebx
c0021efa:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021efe:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021f01:	80 fa 0f             	cmp    $0xf,%dl
c0021f04:	77 22                	ja     c0021f28 <intr_register_ext+0x3d>
    register_handler(vec_no, 0, INTR_OFF, handler, name);
c0021f06:	0f b6 c0             	movzbl %al,%eax
c0021f09:	83 ec 08             	sub    $0x8,%esp
c0021f0c:	ff 74 24 20          	pushl  0x20(%esp)
c0021f10:	ff 74 24 20          	pushl  0x20(%esp)
c0021f14:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021f19:	ba 00 00 00 00       	mov    $0x0,%edx
c0021f1e:	e8 fd fc ff ff       	call   c0021c20 <register_handler>
}
c0021f23:	83 c4 18             	add    $0x18,%esp
c0021f26:	5b                   	pop    %ebx
c0021f27:	c3                   	ret    
    ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021f28:	83 ec 0c             	sub    $0xc,%esp
c0021f2b:	8d 83 f4 59 ff ff    	lea    -0xa60c(%ebx),%eax
c0021f31:	50                   	push   %eax
c0021f32:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021f38:	50                   	push   %eax
c0021f39:	8d 83 b0 3f ff ff    	lea    -0xc050(%ebx),%eax
c0021f3f:	50                   	push   %eax
c0021f40:	68 b1 00 00 00       	push   $0xb1
c0021f45:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0021f4b:	50                   	push   %eax
c0021f4c:	e8 89 71 00 00       	call   c00290da <debug_panic>

c0021f51 <intr_register_int>:
                  intr_handler_func *handler, const char *name) {
c0021f51:	53                   	push   %ebx
c0021f52:	83 ec 08             	sub    $0x8,%esp
c0021f55:	e8 9e cf 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021f5a:	81 c3 ce 91 01 00    	add    $0x191ce,%ebx
c0021f60:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021f64:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021f67:	80 fa 0f             	cmp    $0xf,%dl
c0021f6a:	76 20                	jbe    c0021f8c <intr_register_int+0x3b>
    register_handler(vec_no, dpl, level, handler, name);
c0021f6c:	0f b6 c0             	movzbl %al,%eax
c0021f6f:	83 ec 08             	sub    $0x8,%esp
c0021f72:	ff 74 24 28          	pushl  0x28(%esp)
c0021f76:	ff 74 24 28          	pushl  0x28(%esp)
c0021f7a:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0021f7e:	8b 54 24 24          	mov    0x24(%esp),%edx
c0021f82:	e8 99 fc ff ff       	call   c0021c20 <register_handler>
}
c0021f87:	83 c4 18             	add    $0x18,%esp
c0021f8a:	5b                   	pop    %ebx
c0021f8b:	c3                   	ret    
    ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021f8c:	83 ec 0c             	sub    $0xc,%esp
c0021f8f:	8d 83 18 5a ff ff    	lea    -0xa5e8(%ebx),%eax
c0021f95:	50                   	push   %eax
c0021f96:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0021f9c:	50                   	push   %eax
c0021f9d:	8d 83 88 3f ff ff    	lea    -0xc078(%ebx),%eax
c0021fa3:	50                   	push   %eax
c0021fa4:	68 c5 00 00 00       	push   $0xc5
c0021fa9:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0021faf:	50                   	push   %eax
c0021fb0:	e8 25 71 00 00       	call   c00290da <debug_panic>

c0021fb5 <intr_context>:
intr_context(void) {
c0021fb5:	e8 42 cf 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0021fba:	05 6e 91 01 00       	add    $0x1916e,%eax
    return in_external_intr;
c0021fbf:	0f b6 80 b9 01 00 00 	movzbl 0x1b9(%eax),%eax
}
c0021fc6:	c3                   	ret    

c0021fc7 <intr_yield_on_return>:
intr_yield_on_return(void) {
c0021fc7:	53                   	push   %ebx
c0021fc8:	83 ec 08             	sub    $0x8,%esp
c0021fcb:	e8 28 cf 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0021fd0:	81 c3 58 91 01 00    	add    $0x19158,%ebx
    ASSERT (intr_context());
c0021fd6:	80 bb b9 01 00 00 00 	cmpb   $0x0,0x1b9(%ebx)
c0021fdd:	74 0c                	je     c0021feb <intr_yield_on_return+0x24>
    yield_on_return = true;
c0021fdf:	c6 83 b8 01 00 00 01 	movb   $0x1,0x1b8(%ebx)
}
c0021fe6:	83 c4 08             	add    $0x8,%esp
c0021fe9:	5b                   	pop    %ebx
c0021fea:	c3                   	ret    
    ASSERT (intr_context());
c0021feb:	83 ec 0c             	sub    $0xc,%esp
c0021fee:	8d 93 26 57 ff ff    	lea    -0xa8da(%ebx),%edx
c0021ff4:	52                   	push   %edx
c0021ff5:	8d 93 94 4f ff ff    	lea    -0xb06c(%ebx),%edx
c0021ffb:	52                   	push   %edx
c0021ffc:	8d 93 70 3f ff ff    	lea    -0xc090(%ebx),%edx
c0022002:	52                   	push   %edx
c0022003:	68 d6 00 00 00       	push   $0xd6
c0022008:	8d 93 4b 57 ff ff    	lea    -0xa8b5(%ebx),%edx
c002200e:	52                   	push   %edx
c002200f:	e8 c6 70 00 00       	call   c00290da <debug_panic>

c0022014 <intr_handler>:
/* Handler for all interrupts, faults, and exceptions.  This
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler(struct intr_frame *frame) {
c0022014:	55                   	push   %ebp
c0022015:	57                   	push   %edi
c0022016:	56                   	push   %esi
c0022017:	53                   	push   %ebx
c0022018:	83 ec 0c             	sub    $0xc,%esp
c002201b:	e8 d8 ce 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0022020:	81 c3 08 91 01 00    	add    $0x19108,%ebx
c0022026:	8b 7c 24 20          	mov    0x20(%esp),%edi

    /* External interrupts are special.
       We only handle one at a time (so interrupts must be off)
       and they need to be acknowledged on the PIC (see below).
       An external interrupt handler cannot sleep. */
    external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c002202a:	8b 47 30             	mov    0x30(%edi),%eax
c002202d:	8d 70 e0             	lea    -0x20(%eax),%esi
    if (external) {
c0022030:	83 fe 0f             	cmp    $0xf,%esi
c0022033:	76 2c                	jbe    c0022061 <intr_handler+0x4d>
        in_external_intr = true;
        yield_on_return = false;
    }

    /* Invoke the interrupt's handler. */
    handler = intr_handlers[frame->vec_no];
c0022035:	8b 57 30             	mov    0x30(%edi),%edx
c0022038:	8b 84 93 d8 09 00 00 	mov    0x9d8(%ebx,%edx,4),%eax
    if (handler != NULL)
c002203f:	85 c0                	test   %eax,%eax
c0022041:	0f 84 8e 00 00 00    	je     c00220d5 <intr_handler+0xc1>
        handler(frame);
c0022047:	83 ec 0c             	sub    $0xc,%esp
c002204a:	57                   	push   %edi
c002204b:	ff d0                	call   *%eax
c002204d:	83 c4 10             	add    $0x10,%esp
           condition.  Ignore it. */
    } else
        unexpected_interrupt(frame);

    /* Complete the processing of an external interrupt. */
    if (external) {
c0022050:	83 fe 0f             	cmp    $0xf,%esi
c0022053:	0f 86 c2 00 00 00    	jbe    c002211b <intr_handler+0x107>
        pic_end_of_interrupt(frame->vec_no);

        if (yield_on_return)
            thread_yield();
    }
}
c0022059:	83 c4 0c             	add    $0xc,%esp
c002205c:	5b                   	pop    %ebx
c002205d:	5e                   	pop    %esi
c002205e:	5f                   	pop    %edi
c002205f:	5d                   	pop    %ebp
c0022060:	c3                   	ret    
        ASSERT (intr_get_level() == INTR_OFF);
c0022061:	e8 57 fc ff ff       	call   c0021cbd <intr_get_level>
c0022066:	85 c0                	test   %eax,%eax
c0022068:	75 19                	jne    c0022083 <intr_handler+0x6f>
        ASSERT (!intr_context());
c002206a:	80 bb b9 01 00 00 00 	cmpb   $0x0,0x1b9(%ebx)
c0022071:	75 39                	jne    c00220ac <intr_handler+0x98>
        in_external_intr = true;
c0022073:	c6 83 b9 01 00 00 01 	movb   $0x1,0x1b9(%ebx)
        yield_on_return = false;
c002207a:	c6 83 b8 01 00 00 00 	movb   $0x0,0x1b8(%ebx)
c0022081:	eb b2                	jmp    c0022035 <intr_handler+0x21>
        ASSERT (intr_get_level() == INTR_OFF);
c0022083:	83 ec 0c             	sub    $0xc,%esp
c0022086:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c002208c:	50                   	push   %eax
c002208d:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0022093:	50                   	push   %eax
c0022094:	8d 83 60 3f ff ff    	lea    -0xc0a0(%ebx),%eax
c002209a:	50                   	push   %eax
c002209b:	68 53 01 00 00       	push   $0x153
c00220a0:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c00220a6:	50                   	push   %eax
c00220a7:	e8 2e 70 00 00       	call   c00290da <debug_panic>
        ASSERT (!intr_context());
c00220ac:	83 ec 0c             	sub    $0xc,%esp
c00220af:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c00220b5:	50                   	push   %eax
c00220b6:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00220bc:	50                   	push   %eax
c00220bd:	8d 83 60 3f ff ff    	lea    -0xc0a0(%ebx),%eax
c00220c3:	50                   	push   %eax
c00220c4:	68 54 01 00 00       	push   $0x154
c00220c9:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c00220cf:	50                   	push   %eax
c00220d0:	e8 05 70 00 00       	call   c00290da <debug_panic>
    else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f) {
c00220d5:	89 d0                	mov    %edx,%eax
c00220d7:	83 e0 f7             	and    $0xfffffff7,%eax
c00220da:	83 f8 27             	cmp    $0x27,%eax
c00220dd:	0f 84 6d ff ff ff    	je     c0022050 <intr_handler+0x3c>
/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt(const struct intr_frame *f) {
    /* Count the number so far. */
    unsigned int n = ++unexpected_cnt[f->vec_no];
c00220e3:	8d ab d8 01 00 00    	lea    0x1d8(%ebx),%ebp
c00220e9:	8b 4c 95 00          	mov    0x0(%ebp,%edx,4),%ecx
c00220ed:	8d 41 01             	lea    0x1(%ecx),%eax
c00220f0:	89 44 95 00          	mov    %eax,0x0(%ebp,%edx,4)
    /* If the number is a power of 2, print a message.  This rate
       limiting means that we get information about an uncommon
       unexpected interrupt the first time and fairly often after
       that, but one that occurs many times will not overwhelm the
       console. */
    if ((n & (n - 1)) == 0)
c00220f4:	85 c1                	test   %eax,%ecx
c00220f6:	0f 85 54 ff ff ff    	jne    c0022050 <intr_handler+0x3c>
        printf("Unexpected interrupt %#04x (%s)\n",
c00220fc:	83 ec 04             	sub    $0x4,%esp
c00220ff:	ff b4 93 d8 05 00 00 	pushl  0x5d8(%ebx,%edx,4)
c0022106:	52                   	push   %edx
c0022107:	8d 83 38 5a ff ff    	lea    -0xa5c8(%ebx),%eax
c002210d:	50                   	push   %eax
c002210e:	e8 6b 53 00 00       	call   c002747e <printf>
c0022113:	83 c4 10             	add    $0x10,%esp
c0022116:	e9 35 ff ff ff       	jmp    c0022050 <intr_handler+0x3c>
        ASSERT (intr_get_level() == INTR_OFF);
c002211b:	e8 9d fb ff ff       	call   c0021cbd <intr_get_level>
c0022120:	85 c0                	test   %eax,%eax
c0022122:	75 40                	jne    c0022164 <intr_handler+0x150>
        ASSERT (intr_context());
c0022124:	80 bb b9 01 00 00 00 	cmpb   $0x0,0x1b9(%ebx)
c002212b:	74 60                	je     c002218d <intr_handler+0x179>
        in_external_intr = false;
c002212d:	c6 83 b9 01 00 00 00 	movb   $0x0,0x1b9(%ebx)
        pic_end_of_interrupt(frame->vec_no);
c0022134:	8b 57 30             	mov    0x30(%edi),%edx
    ASSERT (irq >= 0x20 && irq < 0x30);
c0022137:	8d 42 e0             	lea    -0x20(%edx),%eax
c002213a:	83 f8 0f             	cmp    $0xf,%eax
c002213d:	77 77                	ja     c00221b6 <intr_handler+0x1a2>
c002213f:	b8 20 00 00 00       	mov    $0x20,%eax
c0022144:	e6 20                	out    %al,$0x20
    if (irq >= 0x28)
c0022146:	83 fa 27             	cmp    $0x27,%edx
c0022149:	7e 02                	jle    c002214d <intr_handler+0x139>
c002214b:	e6 a0                	out    %al,$0xa0
        if (yield_on_return)
c002214d:	80 bb b8 01 00 00 00 	cmpb   $0x0,0x1b8(%ebx)
c0022154:	0f 84 ff fe ff ff    	je     c0022059 <intr_handler+0x45>
            thread_yield();
c002215a:	e8 58 f5 ff ff       	call   c00216b7 <thread_yield>
}
c002215f:	e9 f5 fe ff ff       	jmp    c0022059 <intr_handler+0x45>
        ASSERT (intr_get_level() == INTR_OFF);
c0022164:	83 ec 0c             	sub    $0xc,%esp
c0022167:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c002216d:	50                   	push   %eax
c002216e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0022174:	50                   	push   %eax
c0022175:	8d 83 60 3f ff ff    	lea    -0xc0a0(%ebx),%eax
c002217b:	50                   	push   %eax
c002217c:	68 67 01 00 00       	push   $0x167
c0022181:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c0022187:	50                   	push   %eax
c0022188:	e8 4d 6f 00 00       	call   c00290da <debug_panic>
        ASSERT (intr_context());
c002218d:	83 ec 0c             	sub    $0xc,%esp
c0022190:	8d 83 26 57 ff ff    	lea    -0xa8da(%ebx),%eax
c0022196:	50                   	push   %eax
c0022197:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002219d:	50                   	push   %eax
c002219e:	8d 83 60 3f ff ff    	lea    -0xc0a0(%ebx),%eax
c00221a4:	50                   	push   %eax
c00221a5:	68 68 01 00 00       	push   $0x168
c00221aa:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c00221b0:	50                   	push   %eax
c00221b1:	e8 24 6f 00 00       	call   c00290da <debug_panic>
    ASSERT (irq >= 0x20 && irq < 0x30);
c00221b6:	83 ec 0c             	sub    $0xc,%esp
c00221b9:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c00221bf:	50                   	push   %eax
c00221c0:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00221c6:	50                   	push   %eax
c00221c7:	8d 83 48 3f ff ff    	lea    -0xc0b8(%ebx),%eax
c00221cd:	50                   	push   %eax
c00221ce:	68 ff 00 00 00       	push   $0xff
c00221d3:	8d 83 4b 57 ff ff    	lea    -0xa8b5(%ebx),%eax
c00221d9:	50                   	push   %eax
c00221da:	e8 fb 6e 00 00       	call   c00290da <debug_panic>

c00221df <intr_dump_frame>:
               f->vec_no, intr_names[f->vec_no]);
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame(const struct intr_frame *f) {
c00221df:	57                   	push   %edi
c00221e0:	56                   	push   %esi
c00221e1:	53                   	push   %ebx
c00221e2:	e8 11 cd 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00221e7:	81 c3 41 8f 01 00    	add    $0x18f41,%ebx
c00221ed:	8b 74 24 10          	mov    0x10(%esp),%esi
    /* Store current value of CR2 into `cr2'.
       CR2 is the linear address of the last page fault.
       See [IA32-v2a] "MOV--Move to/from Control Registers" and
       [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
       (#PF)". */
    asm ("movl %%cr2, %0" : "=r" (cr2));
c00221f1:	0f 20 d7             	mov    %cr2,%edi

    printf("Interrupt %#04x (%s) at eip=%p\n",
           f->vec_no, intr_names[f->vec_no], f->eip);
c00221f4:	8b 46 30             	mov    0x30(%esi),%eax
    printf("Interrupt %#04x (%s) at eip=%p\n",
c00221f7:	ff 76 3c             	pushl  0x3c(%esi)
c00221fa:	ff b4 83 d8 05 00 00 	pushl  0x5d8(%ebx,%eax,4)
c0022201:	50                   	push   %eax
c0022202:	8d 83 5c 5a ff ff    	lea    -0xa5a4(%ebx),%eax
c0022208:	50                   	push   %eax
c0022209:	e8 70 52 00 00       	call   c002747e <printf>
    printf(" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c002220e:	83 c4 0c             	add    $0xc,%esp
c0022211:	ff 76 34             	pushl  0x34(%esi)
c0022214:	57                   	push   %edi
c0022215:	8d 83 28 59 ff ff    	lea    -0xa6d8(%ebx),%eax
c002221b:	50                   	push   %eax
c002221c:	e8 5d 52 00 00       	call   c002747e <printf>
    printf(" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0022221:	83 c4 04             	add    $0x4,%esp
c0022224:	ff 76 14             	pushl  0x14(%esi)
c0022227:	ff 76 18             	pushl  0x18(%esi)
c002222a:	ff 76 10             	pushl  0x10(%esi)
c002222d:	ff 76 1c             	pushl  0x1c(%esi)
c0022230:	8d 83 7c 5a ff ff    	lea    -0xa584(%ebx),%eax
c0022236:	50                   	push   %eax
c0022237:	e8 42 52 00 00       	call   c002747e <printf>
           f->eax, f->ebx, f->ecx, f->edx);
    printf(" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c002223c:	83 c4 14             	add    $0x14,%esp
c002223f:	ff 76 08             	pushl  0x8(%esi)
c0022242:	ff 76 48             	pushl  0x48(%esi)
c0022245:	ff 36                	pushl  (%esi)
c0022247:	ff 76 04             	pushl  0x4(%esi)
c002224a:	8d 83 a4 5a ff ff    	lea    -0xa55c(%ebx),%eax
c0022250:	50                   	push   %eax
c0022251:	e8 28 52 00 00       	call   c002747e <printf>
           f->esi, f->edi, (uint32_t) f->esp, f->ebp);
    printf(" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022256:	83 c4 14             	add    $0x14,%esp
c0022259:	0f b7 46 4c          	movzwl 0x4c(%esi),%eax
c002225d:	50                   	push   %eax
c002225e:	0f b7 46 28          	movzwl 0x28(%esi),%eax
c0022262:	50                   	push   %eax
c0022263:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
c0022267:	50                   	push   %eax
c0022268:	0f b7 46 40          	movzwl 0x40(%esi),%eax
c002226c:	50                   	push   %eax
c002226d:	8d 83 cc 5a ff ff    	lea    -0xa534(%ebx),%eax
c0022273:	50                   	push   %eax
c0022274:	e8 05 52 00 00       	call   c002747e <printf>
           f->cs, f->ds, f->es, f->ss);
}
c0022279:	83 c4 20             	add    $0x20,%esp
c002227c:	5b                   	pop    %ebx
c002227d:	5e                   	pop    %esi
c002227e:	5f                   	pop    %edi
c002227f:	c3                   	ret    

c0022280 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name(uint8_t vec) {
c0022280:	e8 77 cc 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0022285:	05 a3 8e 01 00       	add    $0x18ea3,%eax
    return intr_names[vec];
c002228a:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c002228f:	8b 84 90 d8 05 00 00 	mov    0x5d8(%eax,%edx,4),%eax
}
c0022296:	c3                   	ret    

c0022297 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0022297:	1e                   	push   %ds
	pushl %es
c0022298:	06                   	push   %es
	pushl %fs
c0022299:	0f a0                	push   %fs
	pushl %gs
c002229b:	0f a8                	push   %gs
	pushal
c002229d:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c002229e:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c002229f:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c00222a4:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c00222a6:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c00222a8:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c00222ac:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c00222ad:	e8 62 fd ff ff       	call   c0022014 <intr_handler>
	addl $4, %esp
c00222b2:	83 c4 04             	add    $0x4,%esp

c00222b5 <intr_exit>:
        	EBX = Pop();
        	EDX = Pop();
        	ECX = Pop();
        	EAX = Pop();
        */
	popal
c00222b5:	61                   	popa   
	popl %gs
c00222b6:	0f a9                	pop    %gs
	popl %fs
c00222b8:	0f a1                	pop    %fs
	popl %es
c00222ba:	07                   	pop    %es
	popl %ds
c00222bb:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c00222bc:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c00222bf:	cf                   	iret   

c00222c0 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c00222c0:	55                   	push   %ebp
c00222c1:	6a 00                	push   $0x0
c00222c3:	6a 00                	push   $0x0
c00222c5:	eb d0                	jmp    c0022297 <intr_entry>

c00222c7 <intr01_stub>:
c00222c7:	55                   	push   %ebp
c00222c8:	6a 00                	push   $0x0
c00222ca:	6a 01                	push   $0x1
c00222cc:	eb c9                	jmp    c0022297 <intr_entry>

c00222ce <intr02_stub>:
c00222ce:	55                   	push   %ebp
c00222cf:	6a 00                	push   $0x0
c00222d1:	6a 02                	push   $0x2
c00222d3:	eb c2                	jmp    c0022297 <intr_entry>

c00222d5 <intr03_stub>:
c00222d5:	55                   	push   %ebp
c00222d6:	6a 00                	push   $0x0
c00222d8:	6a 03                	push   $0x3
c00222da:	eb bb                	jmp    c0022297 <intr_entry>

c00222dc <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c00222dc:	55                   	push   %ebp
c00222dd:	6a 00                	push   $0x0
c00222df:	6a 04                	push   $0x4
c00222e1:	eb b4                	jmp    c0022297 <intr_entry>

c00222e3 <intr05_stub>:
c00222e3:	55                   	push   %ebp
c00222e4:	6a 00                	push   $0x0
c00222e6:	6a 05                	push   $0x5
c00222e8:	eb ad                	jmp    c0022297 <intr_entry>

c00222ea <intr06_stub>:
c00222ea:	55                   	push   %ebp
c00222eb:	6a 00                	push   $0x0
c00222ed:	6a 06                	push   $0x6
c00222ef:	eb a6                	jmp    c0022297 <intr_entry>

c00222f1 <intr07_stub>:
c00222f1:	55                   	push   %ebp
c00222f2:	6a 00                	push   $0x0
c00222f4:	6a 07                	push   $0x7
c00222f6:	eb 9f                	jmp    c0022297 <intr_entry>

c00222f8 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c00222f8:	ff 34 24             	pushl  (%esp)
c00222fb:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00222ff:	6a 08                	push   $0x8
c0022301:	eb 94                	jmp    c0022297 <intr_entry>

c0022303 <intr09_stub>:
c0022303:	55                   	push   %ebp
c0022304:	6a 00                	push   $0x0
c0022306:	6a 09                	push   $0x9
c0022308:	eb 8d                	jmp    c0022297 <intr_entry>

c002230a <intr0a_stub>:
c002230a:	ff 34 24             	pushl  (%esp)
c002230d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022311:	6a 0a                	push   $0xa
c0022313:	eb 82                	jmp    c0022297 <intr_entry>

c0022315 <intr0b_stub>:
c0022315:	ff 34 24             	pushl  (%esp)
c0022318:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002231c:	6a 0b                	push   $0xb
c002231e:	e9 74 ff ff ff       	jmp    c0022297 <intr_entry>

c0022323 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0022323:	55                   	push   %ebp
c0022324:	6a 00                	push   $0x0
c0022326:	6a 0c                	push   $0xc
c0022328:	e9 6a ff ff ff       	jmp    c0022297 <intr_entry>

c002232d <intr0d_stub>:
c002232d:	ff 34 24             	pushl  (%esp)
c0022330:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022334:	6a 0d                	push   $0xd
c0022336:	e9 5c ff ff ff       	jmp    c0022297 <intr_entry>

c002233b <intr0e_stub>:
c002233b:	ff 34 24             	pushl  (%esp)
c002233e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022342:	6a 0e                	push   $0xe
c0022344:	e9 4e ff ff ff       	jmp    c0022297 <intr_entry>

c0022349 <intr0f_stub>:
c0022349:	55                   	push   %ebp
c002234a:	6a 00                	push   $0x0
c002234c:	6a 0f                	push   $0xf
c002234e:	e9 44 ff ff ff       	jmp    c0022297 <intr_entry>

c0022353 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0022353:	55                   	push   %ebp
c0022354:	6a 00                	push   $0x0
c0022356:	6a 10                	push   $0x10
c0022358:	e9 3a ff ff ff       	jmp    c0022297 <intr_entry>

c002235d <intr11_stub>:
c002235d:	ff 34 24             	pushl  (%esp)
c0022360:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022364:	6a 11                	push   $0x11
c0022366:	e9 2c ff ff ff       	jmp    c0022297 <intr_entry>

c002236b <intr12_stub>:
c002236b:	55                   	push   %ebp
c002236c:	6a 00                	push   $0x0
c002236e:	6a 12                	push   $0x12
c0022370:	e9 22 ff ff ff       	jmp    c0022297 <intr_entry>

c0022375 <intr13_stub>:
c0022375:	55                   	push   %ebp
c0022376:	6a 00                	push   $0x0
c0022378:	6a 13                	push   $0x13
c002237a:	e9 18 ff ff ff       	jmp    c0022297 <intr_entry>

c002237f <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c002237f:	55                   	push   %ebp
c0022380:	6a 00                	push   $0x0
c0022382:	6a 14                	push   $0x14
c0022384:	e9 0e ff ff ff       	jmp    c0022297 <intr_entry>

c0022389 <intr15_stub>:
c0022389:	55                   	push   %ebp
c002238a:	6a 00                	push   $0x0
c002238c:	6a 15                	push   $0x15
c002238e:	e9 04 ff ff ff       	jmp    c0022297 <intr_entry>

c0022393 <intr16_stub>:
c0022393:	55                   	push   %ebp
c0022394:	6a 00                	push   $0x0
c0022396:	6a 16                	push   $0x16
c0022398:	e9 fa fe ff ff       	jmp    c0022297 <intr_entry>

c002239d <intr17_stub>:
c002239d:	55                   	push   %ebp
c002239e:	6a 00                	push   $0x0
c00223a0:	6a 17                	push   $0x17
c00223a2:	e9 f0 fe ff ff       	jmp    c0022297 <intr_entry>

c00223a7 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c00223a7:	ff 34 24             	pushl  (%esp)
c00223aa:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00223ae:	6a 18                	push   $0x18
c00223b0:	e9 e2 fe ff ff       	jmp    c0022297 <intr_entry>

c00223b5 <intr19_stub>:
c00223b5:	55                   	push   %ebp
c00223b6:	6a 00                	push   $0x0
c00223b8:	6a 19                	push   $0x19
c00223ba:	e9 d8 fe ff ff       	jmp    c0022297 <intr_entry>

c00223bf <intr1a_stub>:
c00223bf:	ff 34 24             	pushl  (%esp)
c00223c2:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00223c6:	6a 1a                	push   $0x1a
c00223c8:	e9 ca fe ff ff       	jmp    c0022297 <intr_entry>

c00223cd <intr1b_stub>:
c00223cd:	ff 34 24             	pushl  (%esp)
c00223d0:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00223d4:	6a 1b                	push   $0x1b
c00223d6:	e9 bc fe ff ff       	jmp    c0022297 <intr_entry>

c00223db <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c00223db:	55                   	push   %ebp
c00223dc:	6a 00                	push   $0x0
c00223de:	6a 1c                	push   $0x1c
c00223e0:	e9 b2 fe ff ff       	jmp    c0022297 <intr_entry>

c00223e5 <intr1d_stub>:
c00223e5:	ff 34 24             	pushl  (%esp)
c00223e8:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00223ec:	6a 1d                	push   $0x1d
c00223ee:	e9 a4 fe ff ff       	jmp    c0022297 <intr_entry>

c00223f3 <intr1e_stub>:
c00223f3:	ff 34 24             	pushl  (%esp)
c00223f6:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00223fa:	6a 1e                	push   $0x1e
c00223fc:	e9 96 fe ff ff       	jmp    c0022297 <intr_entry>

c0022401 <intr1f_stub>:
c0022401:	55                   	push   %ebp
c0022402:	6a 00                	push   $0x0
c0022404:	6a 1f                	push   $0x1f
c0022406:	e9 8c fe ff ff       	jmp    c0022297 <intr_entry>

c002240b <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c002240b:	55                   	push   %ebp
c002240c:	6a 00                	push   $0x0
c002240e:	6a 20                	push   $0x20
c0022410:	e9 82 fe ff ff       	jmp    c0022297 <intr_entry>

c0022415 <intr21_stub>:
c0022415:	55                   	push   %ebp
c0022416:	6a 00                	push   $0x0
c0022418:	6a 21                	push   $0x21
c002241a:	e9 78 fe ff ff       	jmp    c0022297 <intr_entry>

c002241f <intr22_stub>:
c002241f:	55                   	push   %ebp
c0022420:	6a 00                	push   $0x0
c0022422:	6a 22                	push   $0x22
c0022424:	e9 6e fe ff ff       	jmp    c0022297 <intr_entry>

c0022429 <intr23_stub>:
c0022429:	55                   	push   %ebp
c002242a:	6a 00                	push   $0x0
c002242c:	6a 23                	push   $0x23
c002242e:	e9 64 fe ff ff       	jmp    c0022297 <intr_entry>

c0022433 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0022433:	55                   	push   %ebp
c0022434:	6a 00                	push   $0x0
c0022436:	6a 24                	push   $0x24
c0022438:	e9 5a fe ff ff       	jmp    c0022297 <intr_entry>

c002243d <intr25_stub>:
c002243d:	55                   	push   %ebp
c002243e:	6a 00                	push   $0x0
c0022440:	6a 25                	push   $0x25
c0022442:	e9 50 fe ff ff       	jmp    c0022297 <intr_entry>

c0022447 <intr26_stub>:
c0022447:	55                   	push   %ebp
c0022448:	6a 00                	push   $0x0
c002244a:	6a 26                	push   $0x26
c002244c:	e9 46 fe ff ff       	jmp    c0022297 <intr_entry>

c0022451 <intr27_stub>:
c0022451:	55                   	push   %ebp
c0022452:	6a 00                	push   $0x0
c0022454:	6a 27                	push   $0x27
c0022456:	e9 3c fe ff ff       	jmp    c0022297 <intr_entry>

c002245b <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c002245b:	55                   	push   %ebp
c002245c:	6a 00                	push   $0x0
c002245e:	6a 28                	push   $0x28
c0022460:	e9 32 fe ff ff       	jmp    c0022297 <intr_entry>

c0022465 <intr29_stub>:
c0022465:	55                   	push   %ebp
c0022466:	6a 00                	push   $0x0
c0022468:	6a 29                	push   $0x29
c002246a:	e9 28 fe ff ff       	jmp    c0022297 <intr_entry>

c002246f <intr2a_stub>:
c002246f:	55                   	push   %ebp
c0022470:	6a 00                	push   $0x0
c0022472:	6a 2a                	push   $0x2a
c0022474:	e9 1e fe ff ff       	jmp    c0022297 <intr_entry>

c0022479 <intr2b_stub>:
c0022479:	55                   	push   %ebp
c002247a:	6a 00                	push   $0x0
c002247c:	6a 2b                	push   $0x2b
c002247e:	e9 14 fe ff ff       	jmp    c0022297 <intr_entry>

c0022483 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0022483:	55                   	push   %ebp
c0022484:	6a 00                	push   $0x0
c0022486:	6a 2c                	push   $0x2c
c0022488:	e9 0a fe ff ff       	jmp    c0022297 <intr_entry>

c002248d <intr2d_stub>:
c002248d:	55                   	push   %ebp
c002248e:	6a 00                	push   $0x0
c0022490:	6a 2d                	push   $0x2d
c0022492:	e9 00 fe ff ff       	jmp    c0022297 <intr_entry>

c0022497 <intr2e_stub>:
c0022497:	55                   	push   %ebp
c0022498:	6a 00                	push   $0x0
c002249a:	6a 2e                	push   $0x2e
c002249c:	e9 f6 fd ff ff       	jmp    c0022297 <intr_entry>

c00224a1 <intr2f_stub>:
c00224a1:	55                   	push   %ebp
c00224a2:	6a 00                	push   $0x0
c00224a4:	6a 2f                	push   $0x2f
c00224a6:	e9 ec fd ff ff       	jmp    c0022297 <intr_entry>

c00224ab <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00224ab:	55                   	push   %ebp
c00224ac:	6a 00                	push   $0x0
c00224ae:	6a 30                	push   $0x30
c00224b0:	e9 e2 fd ff ff       	jmp    c0022297 <intr_entry>

c00224b5 <intr31_stub>:
c00224b5:	55                   	push   %ebp
c00224b6:	6a 00                	push   $0x0
c00224b8:	6a 31                	push   $0x31
c00224ba:	e9 d8 fd ff ff       	jmp    c0022297 <intr_entry>

c00224bf <intr32_stub>:
c00224bf:	55                   	push   %ebp
c00224c0:	6a 00                	push   $0x0
c00224c2:	6a 32                	push   $0x32
c00224c4:	e9 ce fd ff ff       	jmp    c0022297 <intr_entry>

c00224c9 <intr33_stub>:
c00224c9:	55                   	push   %ebp
c00224ca:	6a 00                	push   $0x0
c00224cc:	6a 33                	push   $0x33
c00224ce:	e9 c4 fd ff ff       	jmp    c0022297 <intr_entry>

c00224d3 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c00224d3:	55                   	push   %ebp
c00224d4:	6a 00                	push   $0x0
c00224d6:	6a 34                	push   $0x34
c00224d8:	e9 ba fd ff ff       	jmp    c0022297 <intr_entry>

c00224dd <intr35_stub>:
c00224dd:	55                   	push   %ebp
c00224de:	6a 00                	push   $0x0
c00224e0:	6a 35                	push   $0x35
c00224e2:	e9 b0 fd ff ff       	jmp    c0022297 <intr_entry>

c00224e7 <intr36_stub>:
c00224e7:	55                   	push   %ebp
c00224e8:	6a 00                	push   $0x0
c00224ea:	6a 36                	push   $0x36
c00224ec:	e9 a6 fd ff ff       	jmp    c0022297 <intr_entry>

c00224f1 <intr37_stub>:
c00224f1:	55                   	push   %ebp
c00224f2:	6a 00                	push   $0x0
c00224f4:	6a 37                	push   $0x37
c00224f6:	e9 9c fd ff ff       	jmp    c0022297 <intr_entry>

c00224fb <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c00224fb:	55                   	push   %ebp
c00224fc:	6a 00                	push   $0x0
c00224fe:	6a 38                	push   $0x38
c0022500:	e9 92 fd ff ff       	jmp    c0022297 <intr_entry>

c0022505 <intr39_stub>:
c0022505:	55                   	push   %ebp
c0022506:	6a 00                	push   $0x0
c0022508:	6a 39                	push   $0x39
c002250a:	e9 88 fd ff ff       	jmp    c0022297 <intr_entry>

c002250f <intr3a_stub>:
c002250f:	55                   	push   %ebp
c0022510:	6a 00                	push   $0x0
c0022512:	6a 3a                	push   $0x3a
c0022514:	e9 7e fd ff ff       	jmp    c0022297 <intr_entry>

c0022519 <intr3b_stub>:
c0022519:	55                   	push   %ebp
c002251a:	6a 00                	push   $0x0
c002251c:	6a 3b                	push   $0x3b
c002251e:	e9 74 fd ff ff       	jmp    c0022297 <intr_entry>

c0022523 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0022523:	55                   	push   %ebp
c0022524:	6a 00                	push   $0x0
c0022526:	6a 3c                	push   $0x3c
c0022528:	e9 6a fd ff ff       	jmp    c0022297 <intr_entry>

c002252d <intr3d_stub>:
c002252d:	55                   	push   %ebp
c002252e:	6a 00                	push   $0x0
c0022530:	6a 3d                	push   $0x3d
c0022532:	e9 60 fd ff ff       	jmp    c0022297 <intr_entry>

c0022537 <intr3e_stub>:
c0022537:	55                   	push   %ebp
c0022538:	6a 00                	push   $0x0
c002253a:	6a 3e                	push   $0x3e
c002253c:	e9 56 fd ff ff       	jmp    c0022297 <intr_entry>

c0022541 <intr3f_stub>:
c0022541:	55                   	push   %ebp
c0022542:	6a 00                	push   $0x0
c0022544:	6a 3f                	push   $0x3f
c0022546:	e9 4c fd ff ff       	jmp    c0022297 <intr_entry>

c002254b <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c002254b:	55                   	push   %ebp
c002254c:	6a 00                	push   $0x0
c002254e:	6a 40                	push   $0x40
c0022550:	e9 42 fd ff ff       	jmp    c0022297 <intr_entry>

c0022555 <intr41_stub>:
c0022555:	55                   	push   %ebp
c0022556:	6a 00                	push   $0x0
c0022558:	6a 41                	push   $0x41
c002255a:	e9 38 fd ff ff       	jmp    c0022297 <intr_entry>

c002255f <intr42_stub>:
c002255f:	55                   	push   %ebp
c0022560:	6a 00                	push   $0x0
c0022562:	6a 42                	push   $0x42
c0022564:	e9 2e fd ff ff       	jmp    c0022297 <intr_entry>

c0022569 <intr43_stub>:
c0022569:	55                   	push   %ebp
c002256a:	6a 00                	push   $0x0
c002256c:	6a 43                	push   $0x43
c002256e:	e9 24 fd ff ff       	jmp    c0022297 <intr_entry>

c0022573 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0022573:	55                   	push   %ebp
c0022574:	6a 00                	push   $0x0
c0022576:	6a 44                	push   $0x44
c0022578:	e9 1a fd ff ff       	jmp    c0022297 <intr_entry>

c002257d <intr45_stub>:
c002257d:	55                   	push   %ebp
c002257e:	6a 00                	push   $0x0
c0022580:	6a 45                	push   $0x45
c0022582:	e9 10 fd ff ff       	jmp    c0022297 <intr_entry>

c0022587 <intr46_stub>:
c0022587:	55                   	push   %ebp
c0022588:	6a 00                	push   $0x0
c002258a:	6a 46                	push   $0x46
c002258c:	e9 06 fd ff ff       	jmp    c0022297 <intr_entry>

c0022591 <intr47_stub>:
c0022591:	55                   	push   %ebp
c0022592:	6a 00                	push   $0x0
c0022594:	6a 47                	push   $0x47
c0022596:	e9 fc fc ff ff       	jmp    c0022297 <intr_entry>

c002259b <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c002259b:	55                   	push   %ebp
c002259c:	6a 00                	push   $0x0
c002259e:	6a 48                	push   $0x48
c00225a0:	e9 f2 fc ff ff       	jmp    c0022297 <intr_entry>

c00225a5 <intr49_stub>:
c00225a5:	55                   	push   %ebp
c00225a6:	6a 00                	push   $0x0
c00225a8:	6a 49                	push   $0x49
c00225aa:	e9 e8 fc ff ff       	jmp    c0022297 <intr_entry>

c00225af <intr4a_stub>:
c00225af:	55                   	push   %ebp
c00225b0:	6a 00                	push   $0x0
c00225b2:	6a 4a                	push   $0x4a
c00225b4:	e9 de fc ff ff       	jmp    c0022297 <intr_entry>

c00225b9 <intr4b_stub>:
c00225b9:	55                   	push   %ebp
c00225ba:	6a 00                	push   $0x0
c00225bc:	6a 4b                	push   $0x4b
c00225be:	e9 d4 fc ff ff       	jmp    c0022297 <intr_entry>

c00225c3 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c00225c3:	55                   	push   %ebp
c00225c4:	6a 00                	push   $0x0
c00225c6:	6a 4c                	push   $0x4c
c00225c8:	e9 ca fc ff ff       	jmp    c0022297 <intr_entry>

c00225cd <intr4d_stub>:
c00225cd:	55                   	push   %ebp
c00225ce:	6a 00                	push   $0x0
c00225d0:	6a 4d                	push   $0x4d
c00225d2:	e9 c0 fc ff ff       	jmp    c0022297 <intr_entry>

c00225d7 <intr4e_stub>:
c00225d7:	55                   	push   %ebp
c00225d8:	6a 00                	push   $0x0
c00225da:	6a 4e                	push   $0x4e
c00225dc:	e9 b6 fc ff ff       	jmp    c0022297 <intr_entry>

c00225e1 <intr4f_stub>:
c00225e1:	55                   	push   %ebp
c00225e2:	6a 00                	push   $0x0
c00225e4:	6a 4f                	push   $0x4f
c00225e6:	e9 ac fc ff ff       	jmp    c0022297 <intr_entry>

c00225eb <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c00225eb:	55                   	push   %ebp
c00225ec:	6a 00                	push   $0x0
c00225ee:	6a 50                	push   $0x50
c00225f0:	e9 a2 fc ff ff       	jmp    c0022297 <intr_entry>

c00225f5 <intr51_stub>:
c00225f5:	55                   	push   %ebp
c00225f6:	6a 00                	push   $0x0
c00225f8:	6a 51                	push   $0x51
c00225fa:	e9 98 fc ff ff       	jmp    c0022297 <intr_entry>

c00225ff <intr52_stub>:
c00225ff:	55                   	push   %ebp
c0022600:	6a 00                	push   $0x0
c0022602:	6a 52                	push   $0x52
c0022604:	e9 8e fc ff ff       	jmp    c0022297 <intr_entry>

c0022609 <intr53_stub>:
c0022609:	55                   	push   %ebp
c002260a:	6a 00                	push   $0x0
c002260c:	6a 53                	push   $0x53
c002260e:	e9 84 fc ff ff       	jmp    c0022297 <intr_entry>

c0022613 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0022613:	55                   	push   %ebp
c0022614:	6a 00                	push   $0x0
c0022616:	6a 54                	push   $0x54
c0022618:	e9 7a fc ff ff       	jmp    c0022297 <intr_entry>

c002261d <intr55_stub>:
c002261d:	55                   	push   %ebp
c002261e:	6a 00                	push   $0x0
c0022620:	6a 55                	push   $0x55
c0022622:	e9 70 fc ff ff       	jmp    c0022297 <intr_entry>

c0022627 <intr56_stub>:
c0022627:	55                   	push   %ebp
c0022628:	6a 00                	push   $0x0
c002262a:	6a 56                	push   $0x56
c002262c:	e9 66 fc ff ff       	jmp    c0022297 <intr_entry>

c0022631 <intr57_stub>:
c0022631:	55                   	push   %ebp
c0022632:	6a 00                	push   $0x0
c0022634:	6a 57                	push   $0x57
c0022636:	e9 5c fc ff ff       	jmp    c0022297 <intr_entry>

c002263b <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c002263b:	55                   	push   %ebp
c002263c:	6a 00                	push   $0x0
c002263e:	6a 58                	push   $0x58
c0022640:	e9 52 fc ff ff       	jmp    c0022297 <intr_entry>

c0022645 <intr59_stub>:
c0022645:	55                   	push   %ebp
c0022646:	6a 00                	push   $0x0
c0022648:	6a 59                	push   $0x59
c002264a:	e9 48 fc ff ff       	jmp    c0022297 <intr_entry>

c002264f <intr5a_stub>:
c002264f:	55                   	push   %ebp
c0022650:	6a 00                	push   $0x0
c0022652:	6a 5a                	push   $0x5a
c0022654:	e9 3e fc ff ff       	jmp    c0022297 <intr_entry>

c0022659 <intr5b_stub>:
c0022659:	55                   	push   %ebp
c002265a:	6a 00                	push   $0x0
c002265c:	6a 5b                	push   $0x5b
c002265e:	e9 34 fc ff ff       	jmp    c0022297 <intr_entry>

c0022663 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0022663:	55                   	push   %ebp
c0022664:	6a 00                	push   $0x0
c0022666:	6a 5c                	push   $0x5c
c0022668:	e9 2a fc ff ff       	jmp    c0022297 <intr_entry>

c002266d <intr5d_stub>:
c002266d:	55                   	push   %ebp
c002266e:	6a 00                	push   $0x0
c0022670:	6a 5d                	push   $0x5d
c0022672:	e9 20 fc ff ff       	jmp    c0022297 <intr_entry>

c0022677 <intr5e_stub>:
c0022677:	55                   	push   %ebp
c0022678:	6a 00                	push   $0x0
c002267a:	6a 5e                	push   $0x5e
c002267c:	e9 16 fc ff ff       	jmp    c0022297 <intr_entry>

c0022681 <intr5f_stub>:
c0022681:	55                   	push   %ebp
c0022682:	6a 00                	push   $0x0
c0022684:	6a 5f                	push   $0x5f
c0022686:	e9 0c fc ff ff       	jmp    c0022297 <intr_entry>

c002268b <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c002268b:	55                   	push   %ebp
c002268c:	6a 00                	push   $0x0
c002268e:	6a 60                	push   $0x60
c0022690:	e9 02 fc ff ff       	jmp    c0022297 <intr_entry>

c0022695 <intr61_stub>:
c0022695:	55                   	push   %ebp
c0022696:	6a 00                	push   $0x0
c0022698:	6a 61                	push   $0x61
c002269a:	e9 f8 fb ff ff       	jmp    c0022297 <intr_entry>

c002269f <intr62_stub>:
c002269f:	55                   	push   %ebp
c00226a0:	6a 00                	push   $0x0
c00226a2:	6a 62                	push   $0x62
c00226a4:	e9 ee fb ff ff       	jmp    c0022297 <intr_entry>

c00226a9 <intr63_stub>:
c00226a9:	55                   	push   %ebp
c00226aa:	6a 00                	push   $0x0
c00226ac:	6a 63                	push   $0x63
c00226ae:	e9 e4 fb ff ff       	jmp    c0022297 <intr_entry>

c00226b3 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c00226b3:	55                   	push   %ebp
c00226b4:	6a 00                	push   $0x0
c00226b6:	6a 64                	push   $0x64
c00226b8:	e9 da fb ff ff       	jmp    c0022297 <intr_entry>

c00226bd <intr65_stub>:
c00226bd:	55                   	push   %ebp
c00226be:	6a 00                	push   $0x0
c00226c0:	6a 65                	push   $0x65
c00226c2:	e9 d0 fb ff ff       	jmp    c0022297 <intr_entry>

c00226c7 <intr66_stub>:
c00226c7:	55                   	push   %ebp
c00226c8:	6a 00                	push   $0x0
c00226ca:	6a 66                	push   $0x66
c00226cc:	e9 c6 fb ff ff       	jmp    c0022297 <intr_entry>

c00226d1 <intr67_stub>:
c00226d1:	55                   	push   %ebp
c00226d2:	6a 00                	push   $0x0
c00226d4:	6a 67                	push   $0x67
c00226d6:	e9 bc fb ff ff       	jmp    c0022297 <intr_entry>

c00226db <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c00226db:	55                   	push   %ebp
c00226dc:	6a 00                	push   $0x0
c00226de:	6a 68                	push   $0x68
c00226e0:	e9 b2 fb ff ff       	jmp    c0022297 <intr_entry>

c00226e5 <intr69_stub>:
c00226e5:	55                   	push   %ebp
c00226e6:	6a 00                	push   $0x0
c00226e8:	6a 69                	push   $0x69
c00226ea:	e9 a8 fb ff ff       	jmp    c0022297 <intr_entry>

c00226ef <intr6a_stub>:
c00226ef:	55                   	push   %ebp
c00226f0:	6a 00                	push   $0x0
c00226f2:	6a 6a                	push   $0x6a
c00226f4:	e9 9e fb ff ff       	jmp    c0022297 <intr_entry>

c00226f9 <intr6b_stub>:
c00226f9:	55                   	push   %ebp
c00226fa:	6a 00                	push   $0x0
c00226fc:	6a 6b                	push   $0x6b
c00226fe:	e9 94 fb ff ff       	jmp    c0022297 <intr_entry>

c0022703 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022703:	55                   	push   %ebp
c0022704:	6a 00                	push   $0x0
c0022706:	6a 6c                	push   $0x6c
c0022708:	e9 8a fb ff ff       	jmp    c0022297 <intr_entry>

c002270d <intr6d_stub>:
c002270d:	55                   	push   %ebp
c002270e:	6a 00                	push   $0x0
c0022710:	6a 6d                	push   $0x6d
c0022712:	e9 80 fb ff ff       	jmp    c0022297 <intr_entry>

c0022717 <intr6e_stub>:
c0022717:	55                   	push   %ebp
c0022718:	6a 00                	push   $0x0
c002271a:	6a 6e                	push   $0x6e
c002271c:	e9 76 fb ff ff       	jmp    c0022297 <intr_entry>

c0022721 <intr6f_stub>:
c0022721:	55                   	push   %ebp
c0022722:	6a 00                	push   $0x0
c0022724:	6a 6f                	push   $0x6f
c0022726:	e9 6c fb ff ff       	jmp    c0022297 <intr_entry>

c002272b <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c002272b:	55                   	push   %ebp
c002272c:	6a 00                	push   $0x0
c002272e:	6a 70                	push   $0x70
c0022730:	e9 62 fb ff ff       	jmp    c0022297 <intr_entry>

c0022735 <intr71_stub>:
c0022735:	55                   	push   %ebp
c0022736:	6a 00                	push   $0x0
c0022738:	6a 71                	push   $0x71
c002273a:	e9 58 fb ff ff       	jmp    c0022297 <intr_entry>

c002273f <intr72_stub>:
c002273f:	55                   	push   %ebp
c0022740:	6a 00                	push   $0x0
c0022742:	6a 72                	push   $0x72
c0022744:	e9 4e fb ff ff       	jmp    c0022297 <intr_entry>

c0022749 <intr73_stub>:
c0022749:	55                   	push   %ebp
c002274a:	6a 00                	push   $0x0
c002274c:	6a 73                	push   $0x73
c002274e:	e9 44 fb ff ff       	jmp    c0022297 <intr_entry>

c0022753 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0022753:	55                   	push   %ebp
c0022754:	6a 00                	push   $0x0
c0022756:	6a 74                	push   $0x74
c0022758:	e9 3a fb ff ff       	jmp    c0022297 <intr_entry>

c002275d <intr75_stub>:
c002275d:	55                   	push   %ebp
c002275e:	6a 00                	push   $0x0
c0022760:	6a 75                	push   $0x75
c0022762:	e9 30 fb ff ff       	jmp    c0022297 <intr_entry>

c0022767 <intr76_stub>:
c0022767:	55                   	push   %ebp
c0022768:	6a 00                	push   $0x0
c002276a:	6a 76                	push   $0x76
c002276c:	e9 26 fb ff ff       	jmp    c0022297 <intr_entry>

c0022771 <intr77_stub>:
c0022771:	55                   	push   %ebp
c0022772:	6a 00                	push   $0x0
c0022774:	6a 77                	push   $0x77
c0022776:	e9 1c fb ff ff       	jmp    c0022297 <intr_entry>

c002277b <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c002277b:	55                   	push   %ebp
c002277c:	6a 00                	push   $0x0
c002277e:	6a 78                	push   $0x78
c0022780:	e9 12 fb ff ff       	jmp    c0022297 <intr_entry>

c0022785 <intr79_stub>:
c0022785:	55                   	push   %ebp
c0022786:	6a 00                	push   $0x0
c0022788:	6a 79                	push   $0x79
c002278a:	e9 08 fb ff ff       	jmp    c0022297 <intr_entry>

c002278f <intr7a_stub>:
c002278f:	55                   	push   %ebp
c0022790:	6a 00                	push   $0x0
c0022792:	6a 7a                	push   $0x7a
c0022794:	e9 fe fa ff ff       	jmp    c0022297 <intr_entry>

c0022799 <intr7b_stub>:
c0022799:	55                   	push   %ebp
c002279a:	6a 00                	push   $0x0
c002279c:	6a 7b                	push   $0x7b
c002279e:	e9 f4 fa ff ff       	jmp    c0022297 <intr_entry>

c00227a3 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00227a3:	55                   	push   %ebp
c00227a4:	6a 00                	push   $0x0
c00227a6:	6a 7c                	push   $0x7c
c00227a8:	e9 ea fa ff ff       	jmp    c0022297 <intr_entry>

c00227ad <intr7d_stub>:
c00227ad:	55                   	push   %ebp
c00227ae:	6a 00                	push   $0x0
c00227b0:	6a 7d                	push   $0x7d
c00227b2:	e9 e0 fa ff ff       	jmp    c0022297 <intr_entry>

c00227b7 <intr7e_stub>:
c00227b7:	55                   	push   %ebp
c00227b8:	6a 00                	push   $0x0
c00227ba:	6a 7e                	push   $0x7e
c00227bc:	e9 d6 fa ff ff       	jmp    c0022297 <intr_entry>

c00227c1 <intr7f_stub>:
c00227c1:	55                   	push   %ebp
c00227c2:	6a 00                	push   $0x0
c00227c4:	6a 7f                	push   $0x7f
c00227c6:	e9 cc fa ff ff       	jmp    c0022297 <intr_entry>

c00227cb <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c00227cb:	55                   	push   %ebp
c00227cc:	6a 00                	push   $0x0
c00227ce:	68 80 00 00 00       	push   $0x80
c00227d3:	e9 bf fa ff ff       	jmp    c0022297 <intr_entry>

c00227d8 <intr81_stub>:
c00227d8:	55                   	push   %ebp
c00227d9:	6a 00                	push   $0x0
c00227db:	68 81 00 00 00       	push   $0x81
c00227e0:	e9 b2 fa ff ff       	jmp    c0022297 <intr_entry>

c00227e5 <intr82_stub>:
c00227e5:	55                   	push   %ebp
c00227e6:	6a 00                	push   $0x0
c00227e8:	68 82 00 00 00       	push   $0x82
c00227ed:	e9 a5 fa ff ff       	jmp    c0022297 <intr_entry>

c00227f2 <intr83_stub>:
c00227f2:	55                   	push   %ebp
c00227f3:	6a 00                	push   $0x0
c00227f5:	68 83 00 00 00       	push   $0x83
c00227fa:	e9 98 fa ff ff       	jmp    c0022297 <intr_entry>

c00227ff <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c00227ff:	55                   	push   %ebp
c0022800:	6a 00                	push   $0x0
c0022802:	68 84 00 00 00       	push   $0x84
c0022807:	e9 8b fa ff ff       	jmp    c0022297 <intr_entry>

c002280c <intr85_stub>:
c002280c:	55                   	push   %ebp
c002280d:	6a 00                	push   $0x0
c002280f:	68 85 00 00 00       	push   $0x85
c0022814:	e9 7e fa ff ff       	jmp    c0022297 <intr_entry>

c0022819 <intr86_stub>:
c0022819:	55                   	push   %ebp
c002281a:	6a 00                	push   $0x0
c002281c:	68 86 00 00 00       	push   $0x86
c0022821:	e9 71 fa ff ff       	jmp    c0022297 <intr_entry>

c0022826 <intr87_stub>:
c0022826:	55                   	push   %ebp
c0022827:	6a 00                	push   $0x0
c0022829:	68 87 00 00 00       	push   $0x87
c002282e:	e9 64 fa ff ff       	jmp    c0022297 <intr_entry>

c0022833 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022833:	55                   	push   %ebp
c0022834:	6a 00                	push   $0x0
c0022836:	68 88 00 00 00       	push   $0x88
c002283b:	e9 57 fa ff ff       	jmp    c0022297 <intr_entry>

c0022840 <intr89_stub>:
c0022840:	55                   	push   %ebp
c0022841:	6a 00                	push   $0x0
c0022843:	68 89 00 00 00       	push   $0x89
c0022848:	e9 4a fa ff ff       	jmp    c0022297 <intr_entry>

c002284d <intr8a_stub>:
c002284d:	55                   	push   %ebp
c002284e:	6a 00                	push   $0x0
c0022850:	68 8a 00 00 00       	push   $0x8a
c0022855:	e9 3d fa ff ff       	jmp    c0022297 <intr_entry>

c002285a <intr8b_stub>:
c002285a:	55                   	push   %ebp
c002285b:	6a 00                	push   $0x0
c002285d:	68 8b 00 00 00       	push   $0x8b
c0022862:	e9 30 fa ff ff       	jmp    c0022297 <intr_entry>

c0022867 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c0022867:	55                   	push   %ebp
c0022868:	6a 00                	push   $0x0
c002286a:	68 8c 00 00 00       	push   $0x8c
c002286f:	e9 23 fa ff ff       	jmp    c0022297 <intr_entry>

c0022874 <intr8d_stub>:
c0022874:	55                   	push   %ebp
c0022875:	6a 00                	push   $0x0
c0022877:	68 8d 00 00 00       	push   $0x8d
c002287c:	e9 16 fa ff ff       	jmp    c0022297 <intr_entry>

c0022881 <intr8e_stub>:
c0022881:	55                   	push   %ebp
c0022882:	6a 00                	push   $0x0
c0022884:	68 8e 00 00 00       	push   $0x8e
c0022889:	e9 09 fa ff ff       	jmp    c0022297 <intr_entry>

c002288e <intr8f_stub>:
c002288e:	55                   	push   %ebp
c002288f:	6a 00                	push   $0x0
c0022891:	68 8f 00 00 00       	push   $0x8f
c0022896:	e9 fc f9 ff ff       	jmp    c0022297 <intr_entry>

c002289b <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c002289b:	55                   	push   %ebp
c002289c:	6a 00                	push   $0x0
c002289e:	68 90 00 00 00       	push   $0x90
c00228a3:	e9 ef f9 ff ff       	jmp    c0022297 <intr_entry>

c00228a8 <intr91_stub>:
c00228a8:	55                   	push   %ebp
c00228a9:	6a 00                	push   $0x0
c00228ab:	68 91 00 00 00       	push   $0x91
c00228b0:	e9 e2 f9 ff ff       	jmp    c0022297 <intr_entry>

c00228b5 <intr92_stub>:
c00228b5:	55                   	push   %ebp
c00228b6:	6a 00                	push   $0x0
c00228b8:	68 92 00 00 00       	push   $0x92
c00228bd:	e9 d5 f9 ff ff       	jmp    c0022297 <intr_entry>

c00228c2 <intr93_stub>:
c00228c2:	55                   	push   %ebp
c00228c3:	6a 00                	push   $0x0
c00228c5:	68 93 00 00 00       	push   $0x93
c00228ca:	e9 c8 f9 ff ff       	jmp    c0022297 <intr_entry>

c00228cf <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c00228cf:	55                   	push   %ebp
c00228d0:	6a 00                	push   $0x0
c00228d2:	68 94 00 00 00       	push   $0x94
c00228d7:	e9 bb f9 ff ff       	jmp    c0022297 <intr_entry>

c00228dc <intr95_stub>:
c00228dc:	55                   	push   %ebp
c00228dd:	6a 00                	push   $0x0
c00228df:	68 95 00 00 00       	push   $0x95
c00228e4:	e9 ae f9 ff ff       	jmp    c0022297 <intr_entry>

c00228e9 <intr96_stub>:
c00228e9:	55                   	push   %ebp
c00228ea:	6a 00                	push   $0x0
c00228ec:	68 96 00 00 00       	push   $0x96
c00228f1:	e9 a1 f9 ff ff       	jmp    c0022297 <intr_entry>

c00228f6 <intr97_stub>:
c00228f6:	55                   	push   %ebp
c00228f7:	6a 00                	push   $0x0
c00228f9:	68 97 00 00 00       	push   $0x97
c00228fe:	e9 94 f9 ff ff       	jmp    c0022297 <intr_entry>

c0022903 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022903:	55                   	push   %ebp
c0022904:	6a 00                	push   $0x0
c0022906:	68 98 00 00 00       	push   $0x98
c002290b:	e9 87 f9 ff ff       	jmp    c0022297 <intr_entry>

c0022910 <intr99_stub>:
c0022910:	55                   	push   %ebp
c0022911:	6a 00                	push   $0x0
c0022913:	68 99 00 00 00       	push   $0x99
c0022918:	e9 7a f9 ff ff       	jmp    c0022297 <intr_entry>

c002291d <intr9a_stub>:
c002291d:	55                   	push   %ebp
c002291e:	6a 00                	push   $0x0
c0022920:	68 9a 00 00 00       	push   $0x9a
c0022925:	e9 6d f9 ff ff       	jmp    c0022297 <intr_entry>

c002292a <intr9b_stub>:
c002292a:	55                   	push   %ebp
c002292b:	6a 00                	push   $0x0
c002292d:	68 9b 00 00 00       	push   $0x9b
c0022932:	e9 60 f9 ff ff       	jmp    c0022297 <intr_entry>

c0022937 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022937:	55                   	push   %ebp
c0022938:	6a 00                	push   $0x0
c002293a:	68 9c 00 00 00       	push   $0x9c
c002293f:	e9 53 f9 ff ff       	jmp    c0022297 <intr_entry>

c0022944 <intr9d_stub>:
c0022944:	55                   	push   %ebp
c0022945:	6a 00                	push   $0x0
c0022947:	68 9d 00 00 00       	push   $0x9d
c002294c:	e9 46 f9 ff ff       	jmp    c0022297 <intr_entry>

c0022951 <intr9e_stub>:
c0022951:	55                   	push   %ebp
c0022952:	6a 00                	push   $0x0
c0022954:	68 9e 00 00 00       	push   $0x9e
c0022959:	e9 39 f9 ff ff       	jmp    c0022297 <intr_entry>

c002295e <intr9f_stub>:
c002295e:	55                   	push   %ebp
c002295f:	6a 00                	push   $0x0
c0022961:	68 9f 00 00 00       	push   $0x9f
c0022966:	e9 2c f9 ff ff       	jmp    c0022297 <intr_entry>

c002296b <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c002296b:	55                   	push   %ebp
c002296c:	6a 00                	push   $0x0
c002296e:	68 a0 00 00 00       	push   $0xa0
c0022973:	e9 1f f9 ff ff       	jmp    c0022297 <intr_entry>

c0022978 <intra1_stub>:
c0022978:	55                   	push   %ebp
c0022979:	6a 00                	push   $0x0
c002297b:	68 a1 00 00 00       	push   $0xa1
c0022980:	e9 12 f9 ff ff       	jmp    c0022297 <intr_entry>

c0022985 <intra2_stub>:
c0022985:	55                   	push   %ebp
c0022986:	6a 00                	push   $0x0
c0022988:	68 a2 00 00 00       	push   $0xa2
c002298d:	e9 05 f9 ff ff       	jmp    c0022297 <intr_entry>

c0022992 <intra3_stub>:
c0022992:	55                   	push   %ebp
c0022993:	6a 00                	push   $0x0
c0022995:	68 a3 00 00 00       	push   $0xa3
c002299a:	e9 f8 f8 ff ff       	jmp    c0022297 <intr_entry>

c002299f <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c002299f:	55                   	push   %ebp
c00229a0:	6a 00                	push   $0x0
c00229a2:	68 a4 00 00 00       	push   $0xa4
c00229a7:	e9 eb f8 ff ff       	jmp    c0022297 <intr_entry>

c00229ac <intra5_stub>:
c00229ac:	55                   	push   %ebp
c00229ad:	6a 00                	push   $0x0
c00229af:	68 a5 00 00 00       	push   $0xa5
c00229b4:	e9 de f8 ff ff       	jmp    c0022297 <intr_entry>

c00229b9 <intra6_stub>:
c00229b9:	55                   	push   %ebp
c00229ba:	6a 00                	push   $0x0
c00229bc:	68 a6 00 00 00       	push   $0xa6
c00229c1:	e9 d1 f8 ff ff       	jmp    c0022297 <intr_entry>

c00229c6 <intra7_stub>:
c00229c6:	55                   	push   %ebp
c00229c7:	6a 00                	push   $0x0
c00229c9:	68 a7 00 00 00       	push   $0xa7
c00229ce:	e9 c4 f8 ff ff       	jmp    c0022297 <intr_entry>

c00229d3 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c00229d3:	55                   	push   %ebp
c00229d4:	6a 00                	push   $0x0
c00229d6:	68 a8 00 00 00       	push   $0xa8
c00229db:	e9 b7 f8 ff ff       	jmp    c0022297 <intr_entry>

c00229e0 <intra9_stub>:
c00229e0:	55                   	push   %ebp
c00229e1:	6a 00                	push   $0x0
c00229e3:	68 a9 00 00 00       	push   $0xa9
c00229e8:	e9 aa f8 ff ff       	jmp    c0022297 <intr_entry>

c00229ed <intraa_stub>:
c00229ed:	55                   	push   %ebp
c00229ee:	6a 00                	push   $0x0
c00229f0:	68 aa 00 00 00       	push   $0xaa
c00229f5:	e9 9d f8 ff ff       	jmp    c0022297 <intr_entry>

c00229fa <intrab_stub>:
c00229fa:	55                   	push   %ebp
c00229fb:	6a 00                	push   $0x0
c00229fd:	68 ab 00 00 00       	push   $0xab
c0022a02:	e9 90 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a07 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022a07:	55                   	push   %ebp
c0022a08:	6a 00                	push   $0x0
c0022a0a:	68 ac 00 00 00       	push   $0xac
c0022a0f:	e9 83 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a14 <intrad_stub>:
c0022a14:	55                   	push   %ebp
c0022a15:	6a 00                	push   $0x0
c0022a17:	68 ad 00 00 00       	push   $0xad
c0022a1c:	e9 76 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a21 <intrae_stub>:
c0022a21:	55                   	push   %ebp
c0022a22:	6a 00                	push   $0x0
c0022a24:	68 ae 00 00 00       	push   $0xae
c0022a29:	e9 69 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a2e <intraf_stub>:
c0022a2e:	55                   	push   %ebp
c0022a2f:	6a 00                	push   $0x0
c0022a31:	68 af 00 00 00       	push   $0xaf
c0022a36:	e9 5c f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a3b <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022a3b:	55                   	push   %ebp
c0022a3c:	6a 00                	push   $0x0
c0022a3e:	68 b0 00 00 00       	push   $0xb0
c0022a43:	e9 4f f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a48 <intrb1_stub>:
c0022a48:	55                   	push   %ebp
c0022a49:	6a 00                	push   $0x0
c0022a4b:	68 b1 00 00 00       	push   $0xb1
c0022a50:	e9 42 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a55 <intrb2_stub>:
c0022a55:	55                   	push   %ebp
c0022a56:	6a 00                	push   $0x0
c0022a58:	68 b2 00 00 00       	push   $0xb2
c0022a5d:	e9 35 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a62 <intrb3_stub>:
c0022a62:	55                   	push   %ebp
c0022a63:	6a 00                	push   $0x0
c0022a65:	68 b3 00 00 00       	push   $0xb3
c0022a6a:	e9 28 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a6f <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022a6f:	55                   	push   %ebp
c0022a70:	6a 00                	push   $0x0
c0022a72:	68 b4 00 00 00       	push   $0xb4
c0022a77:	e9 1b f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a7c <intrb5_stub>:
c0022a7c:	55                   	push   %ebp
c0022a7d:	6a 00                	push   $0x0
c0022a7f:	68 b5 00 00 00       	push   $0xb5
c0022a84:	e9 0e f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a89 <intrb6_stub>:
c0022a89:	55                   	push   %ebp
c0022a8a:	6a 00                	push   $0x0
c0022a8c:	68 b6 00 00 00       	push   $0xb6
c0022a91:	e9 01 f8 ff ff       	jmp    c0022297 <intr_entry>

c0022a96 <intrb7_stub>:
c0022a96:	55                   	push   %ebp
c0022a97:	6a 00                	push   $0x0
c0022a99:	68 b7 00 00 00       	push   $0xb7
c0022a9e:	e9 f4 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022aa3 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022aa3:	55                   	push   %ebp
c0022aa4:	6a 00                	push   $0x0
c0022aa6:	68 b8 00 00 00       	push   $0xb8
c0022aab:	e9 e7 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022ab0 <intrb9_stub>:
c0022ab0:	55                   	push   %ebp
c0022ab1:	6a 00                	push   $0x0
c0022ab3:	68 b9 00 00 00       	push   $0xb9
c0022ab8:	e9 da f7 ff ff       	jmp    c0022297 <intr_entry>

c0022abd <intrba_stub>:
c0022abd:	55                   	push   %ebp
c0022abe:	6a 00                	push   $0x0
c0022ac0:	68 ba 00 00 00       	push   $0xba
c0022ac5:	e9 cd f7 ff ff       	jmp    c0022297 <intr_entry>

c0022aca <intrbb_stub>:
c0022aca:	55                   	push   %ebp
c0022acb:	6a 00                	push   $0x0
c0022acd:	68 bb 00 00 00       	push   $0xbb
c0022ad2:	e9 c0 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022ad7 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022ad7:	55                   	push   %ebp
c0022ad8:	6a 00                	push   $0x0
c0022ada:	68 bc 00 00 00       	push   $0xbc
c0022adf:	e9 b3 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022ae4 <intrbd_stub>:
c0022ae4:	55                   	push   %ebp
c0022ae5:	6a 00                	push   $0x0
c0022ae7:	68 bd 00 00 00       	push   $0xbd
c0022aec:	e9 a6 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022af1 <intrbe_stub>:
c0022af1:	55                   	push   %ebp
c0022af2:	6a 00                	push   $0x0
c0022af4:	68 be 00 00 00       	push   $0xbe
c0022af9:	e9 99 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022afe <intrbf_stub>:
c0022afe:	55                   	push   %ebp
c0022aff:	6a 00                	push   $0x0
c0022b01:	68 bf 00 00 00       	push   $0xbf
c0022b06:	e9 8c f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b0b <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022b0b:	55                   	push   %ebp
c0022b0c:	6a 00                	push   $0x0
c0022b0e:	68 c0 00 00 00       	push   $0xc0
c0022b13:	e9 7f f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b18 <intrc1_stub>:
c0022b18:	55                   	push   %ebp
c0022b19:	6a 00                	push   $0x0
c0022b1b:	68 c1 00 00 00       	push   $0xc1
c0022b20:	e9 72 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b25 <intrc2_stub>:
c0022b25:	55                   	push   %ebp
c0022b26:	6a 00                	push   $0x0
c0022b28:	68 c2 00 00 00       	push   $0xc2
c0022b2d:	e9 65 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b32 <intrc3_stub>:
c0022b32:	55                   	push   %ebp
c0022b33:	6a 00                	push   $0x0
c0022b35:	68 c3 00 00 00       	push   $0xc3
c0022b3a:	e9 58 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b3f <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022b3f:	55                   	push   %ebp
c0022b40:	6a 00                	push   $0x0
c0022b42:	68 c4 00 00 00       	push   $0xc4
c0022b47:	e9 4b f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b4c <intrc5_stub>:
c0022b4c:	55                   	push   %ebp
c0022b4d:	6a 00                	push   $0x0
c0022b4f:	68 c5 00 00 00       	push   $0xc5
c0022b54:	e9 3e f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b59 <intrc6_stub>:
c0022b59:	55                   	push   %ebp
c0022b5a:	6a 00                	push   $0x0
c0022b5c:	68 c6 00 00 00       	push   $0xc6
c0022b61:	e9 31 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b66 <intrc7_stub>:
c0022b66:	55                   	push   %ebp
c0022b67:	6a 00                	push   $0x0
c0022b69:	68 c7 00 00 00       	push   $0xc7
c0022b6e:	e9 24 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b73 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022b73:	55                   	push   %ebp
c0022b74:	6a 00                	push   $0x0
c0022b76:	68 c8 00 00 00       	push   $0xc8
c0022b7b:	e9 17 f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b80 <intrc9_stub>:
c0022b80:	55                   	push   %ebp
c0022b81:	6a 00                	push   $0x0
c0022b83:	68 c9 00 00 00       	push   $0xc9
c0022b88:	e9 0a f7 ff ff       	jmp    c0022297 <intr_entry>

c0022b8d <intrca_stub>:
c0022b8d:	55                   	push   %ebp
c0022b8e:	6a 00                	push   $0x0
c0022b90:	68 ca 00 00 00       	push   $0xca
c0022b95:	e9 fd f6 ff ff       	jmp    c0022297 <intr_entry>

c0022b9a <intrcb_stub>:
c0022b9a:	55                   	push   %ebp
c0022b9b:	6a 00                	push   $0x0
c0022b9d:	68 cb 00 00 00       	push   $0xcb
c0022ba2:	e9 f0 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022ba7 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022ba7:	55                   	push   %ebp
c0022ba8:	6a 00                	push   $0x0
c0022baa:	68 cc 00 00 00       	push   $0xcc
c0022baf:	e9 e3 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022bb4 <intrcd_stub>:
c0022bb4:	55                   	push   %ebp
c0022bb5:	6a 00                	push   $0x0
c0022bb7:	68 cd 00 00 00       	push   $0xcd
c0022bbc:	e9 d6 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022bc1 <intrce_stub>:
c0022bc1:	55                   	push   %ebp
c0022bc2:	6a 00                	push   $0x0
c0022bc4:	68 ce 00 00 00       	push   $0xce
c0022bc9:	e9 c9 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022bce <intrcf_stub>:
c0022bce:	55                   	push   %ebp
c0022bcf:	6a 00                	push   $0x0
c0022bd1:	68 cf 00 00 00       	push   $0xcf
c0022bd6:	e9 bc f6 ff ff       	jmp    c0022297 <intr_entry>

c0022bdb <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022bdb:	55                   	push   %ebp
c0022bdc:	6a 00                	push   $0x0
c0022bde:	68 d0 00 00 00       	push   $0xd0
c0022be3:	e9 af f6 ff ff       	jmp    c0022297 <intr_entry>

c0022be8 <intrd1_stub>:
c0022be8:	55                   	push   %ebp
c0022be9:	6a 00                	push   $0x0
c0022beb:	68 d1 00 00 00       	push   $0xd1
c0022bf0:	e9 a2 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022bf5 <intrd2_stub>:
c0022bf5:	55                   	push   %ebp
c0022bf6:	6a 00                	push   $0x0
c0022bf8:	68 d2 00 00 00       	push   $0xd2
c0022bfd:	e9 95 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c02 <intrd3_stub>:
c0022c02:	55                   	push   %ebp
c0022c03:	6a 00                	push   $0x0
c0022c05:	68 d3 00 00 00       	push   $0xd3
c0022c0a:	e9 88 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c0f <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022c0f:	55                   	push   %ebp
c0022c10:	6a 00                	push   $0x0
c0022c12:	68 d4 00 00 00       	push   $0xd4
c0022c17:	e9 7b f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c1c <intrd5_stub>:
c0022c1c:	55                   	push   %ebp
c0022c1d:	6a 00                	push   $0x0
c0022c1f:	68 d5 00 00 00       	push   $0xd5
c0022c24:	e9 6e f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c29 <intrd6_stub>:
c0022c29:	55                   	push   %ebp
c0022c2a:	6a 00                	push   $0x0
c0022c2c:	68 d6 00 00 00       	push   $0xd6
c0022c31:	e9 61 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c36 <intrd7_stub>:
c0022c36:	55                   	push   %ebp
c0022c37:	6a 00                	push   $0x0
c0022c39:	68 d7 00 00 00       	push   $0xd7
c0022c3e:	e9 54 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c43 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022c43:	55                   	push   %ebp
c0022c44:	6a 00                	push   $0x0
c0022c46:	68 d8 00 00 00       	push   $0xd8
c0022c4b:	e9 47 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c50 <intrd9_stub>:
c0022c50:	55                   	push   %ebp
c0022c51:	6a 00                	push   $0x0
c0022c53:	68 d9 00 00 00       	push   $0xd9
c0022c58:	e9 3a f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c5d <intrda_stub>:
c0022c5d:	55                   	push   %ebp
c0022c5e:	6a 00                	push   $0x0
c0022c60:	68 da 00 00 00       	push   $0xda
c0022c65:	e9 2d f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c6a <intrdb_stub>:
c0022c6a:	55                   	push   %ebp
c0022c6b:	6a 00                	push   $0x0
c0022c6d:	68 db 00 00 00       	push   $0xdb
c0022c72:	e9 20 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c77 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022c77:	55                   	push   %ebp
c0022c78:	6a 00                	push   $0x0
c0022c7a:	68 dc 00 00 00       	push   $0xdc
c0022c7f:	e9 13 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c84 <intrdd_stub>:
c0022c84:	55                   	push   %ebp
c0022c85:	6a 00                	push   $0x0
c0022c87:	68 dd 00 00 00       	push   $0xdd
c0022c8c:	e9 06 f6 ff ff       	jmp    c0022297 <intr_entry>

c0022c91 <intrde_stub>:
c0022c91:	55                   	push   %ebp
c0022c92:	6a 00                	push   $0x0
c0022c94:	68 de 00 00 00       	push   $0xde
c0022c99:	e9 f9 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022c9e <intrdf_stub>:
c0022c9e:	55                   	push   %ebp
c0022c9f:	6a 00                	push   $0x0
c0022ca1:	68 df 00 00 00       	push   $0xdf
c0022ca6:	e9 ec f5 ff ff       	jmp    c0022297 <intr_entry>

c0022cab <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022cab:	55                   	push   %ebp
c0022cac:	6a 00                	push   $0x0
c0022cae:	68 e0 00 00 00       	push   $0xe0
c0022cb3:	e9 df f5 ff ff       	jmp    c0022297 <intr_entry>

c0022cb8 <intre1_stub>:
c0022cb8:	55                   	push   %ebp
c0022cb9:	6a 00                	push   $0x0
c0022cbb:	68 e1 00 00 00       	push   $0xe1
c0022cc0:	e9 d2 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022cc5 <intre2_stub>:
c0022cc5:	55                   	push   %ebp
c0022cc6:	6a 00                	push   $0x0
c0022cc8:	68 e2 00 00 00       	push   $0xe2
c0022ccd:	e9 c5 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022cd2 <intre3_stub>:
c0022cd2:	55                   	push   %ebp
c0022cd3:	6a 00                	push   $0x0
c0022cd5:	68 e3 00 00 00       	push   $0xe3
c0022cda:	e9 b8 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022cdf <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022cdf:	55                   	push   %ebp
c0022ce0:	6a 00                	push   $0x0
c0022ce2:	68 e4 00 00 00       	push   $0xe4
c0022ce7:	e9 ab f5 ff ff       	jmp    c0022297 <intr_entry>

c0022cec <intre5_stub>:
c0022cec:	55                   	push   %ebp
c0022ced:	6a 00                	push   $0x0
c0022cef:	68 e5 00 00 00       	push   $0xe5
c0022cf4:	e9 9e f5 ff ff       	jmp    c0022297 <intr_entry>

c0022cf9 <intre6_stub>:
c0022cf9:	55                   	push   %ebp
c0022cfa:	6a 00                	push   $0x0
c0022cfc:	68 e6 00 00 00       	push   $0xe6
c0022d01:	e9 91 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d06 <intre7_stub>:
c0022d06:	55                   	push   %ebp
c0022d07:	6a 00                	push   $0x0
c0022d09:	68 e7 00 00 00       	push   $0xe7
c0022d0e:	e9 84 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d13 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022d13:	55                   	push   %ebp
c0022d14:	6a 00                	push   $0x0
c0022d16:	68 e8 00 00 00       	push   $0xe8
c0022d1b:	e9 77 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d20 <intre9_stub>:
c0022d20:	55                   	push   %ebp
c0022d21:	6a 00                	push   $0x0
c0022d23:	68 e9 00 00 00       	push   $0xe9
c0022d28:	e9 6a f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d2d <intrea_stub>:
c0022d2d:	55                   	push   %ebp
c0022d2e:	6a 00                	push   $0x0
c0022d30:	68 ea 00 00 00       	push   $0xea
c0022d35:	e9 5d f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d3a <intreb_stub>:
c0022d3a:	55                   	push   %ebp
c0022d3b:	6a 00                	push   $0x0
c0022d3d:	68 eb 00 00 00       	push   $0xeb
c0022d42:	e9 50 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d47 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022d47:	55                   	push   %ebp
c0022d48:	6a 00                	push   $0x0
c0022d4a:	68 ec 00 00 00       	push   $0xec
c0022d4f:	e9 43 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d54 <intred_stub>:
c0022d54:	55                   	push   %ebp
c0022d55:	6a 00                	push   $0x0
c0022d57:	68 ed 00 00 00       	push   $0xed
c0022d5c:	e9 36 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d61 <intree_stub>:
c0022d61:	55                   	push   %ebp
c0022d62:	6a 00                	push   $0x0
c0022d64:	68 ee 00 00 00       	push   $0xee
c0022d69:	e9 29 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d6e <intref_stub>:
c0022d6e:	55                   	push   %ebp
c0022d6f:	6a 00                	push   $0x0
c0022d71:	68 ef 00 00 00       	push   $0xef
c0022d76:	e9 1c f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d7b <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022d7b:	55                   	push   %ebp
c0022d7c:	6a 00                	push   $0x0
c0022d7e:	68 f0 00 00 00       	push   $0xf0
c0022d83:	e9 0f f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d88 <intrf1_stub>:
c0022d88:	55                   	push   %ebp
c0022d89:	6a 00                	push   $0x0
c0022d8b:	68 f1 00 00 00       	push   $0xf1
c0022d90:	e9 02 f5 ff ff       	jmp    c0022297 <intr_entry>

c0022d95 <intrf2_stub>:
c0022d95:	55                   	push   %ebp
c0022d96:	6a 00                	push   $0x0
c0022d98:	68 f2 00 00 00       	push   $0xf2
c0022d9d:	e9 f5 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022da2 <intrf3_stub>:
c0022da2:	55                   	push   %ebp
c0022da3:	6a 00                	push   $0x0
c0022da5:	68 f3 00 00 00       	push   $0xf3
c0022daa:	e9 e8 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022daf <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022daf:	55                   	push   %ebp
c0022db0:	6a 00                	push   $0x0
c0022db2:	68 f4 00 00 00       	push   $0xf4
c0022db7:	e9 db f4 ff ff       	jmp    c0022297 <intr_entry>

c0022dbc <intrf5_stub>:
c0022dbc:	55                   	push   %ebp
c0022dbd:	6a 00                	push   $0x0
c0022dbf:	68 f5 00 00 00       	push   $0xf5
c0022dc4:	e9 ce f4 ff ff       	jmp    c0022297 <intr_entry>

c0022dc9 <intrf6_stub>:
c0022dc9:	55                   	push   %ebp
c0022dca:	6a 00                	push   $0x0
c0022dcc:	68 f6 00 00 00       	push   $0xf6
c0022dd1:	e9 c1 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022dd6 <intrf7_stub>:
c0022dd6:	55                   	push   %ebp
c0022dd7:	6a 00                	push   $0x0
c0022dd9:	68 f7 00 00 00       	push   $0xf7
c0022dde:	e9 b4 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022de3 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022de3:	55                   	push   %ebp
c0022de4:	6a 00                	push   $0x0
c0022de6:	68 f8 00 00 00       	push   $0xf8
c0022deb:	e9 a7 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022df0 <intrf9_stub>:
c0022df0:	55                   	push   %ebp
c0022df1:	6a 00                	push   $0x0
c0022df3:	68 f9 00 00 00       	push   $0xf9
c0022df8:	e9 9a f4 ff ff       	jmp    c0022297 <intr_entry>

c0022dfd <intrfa_stub>:
c0022dfd:	55                   	push   %ebp
c0022dfe:	6a 00                	push   $0x0
c0022e00:	68 fa 00 00 00       	push   $0xfa
c0022e05:	e9 8d f4 ff ff       	jmp    c0022297 <intr_entry>

c0022e0a <intrfb_stub>:
c0022e0a:	55                   	push   %ebp
c0022e0b:	6a 00                	push   $0x0
c0022e0d:	68 fb 00 00 00       	push   $0xfb
c0022e12:	e9 80 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022e17 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022e17:	55                   	push   %ebp
c0022e18:	6a 00                	push   $0x0
c0022e1a:	68 fc 00 00 00       	push   $0xfc
c0022e1f:	e9 73 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022e24 <intrfd_stub>:
c0022e24:	55                   	push   %ebp
c0022e25:	6a 00                	push   $0x0
c0022e27:	68 fd 00 00 00       	push   $0xfd
c0022e2c:	e9 66 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022e31 <intrfe_stub>:
c0022e31:	55                   	push   %ebp
c0022e32:	6a 00                	push   $0x0
c0022e34:	68 fe 00 00 00       	push   $0xfe
c0022e39:	e9 59 f4 ff ff       	jmp    c0022297 <intr_entry>

c0022e3e <intrff_stub>:
c0022e3e:	55                   	push   %ebp
c0022e3f:	6a 00                	push   $0x0
c0022e41:	68 ff 00 00 00       	push   $0xff
c0022e46:	e9 4c f4 ff ff       	jmp    c0022297 <intr_entry>

c0022e4b <sema_cmp_priority>:
    lock_acquire(lock);
}

bool sema_cmp_priority(const struct list_elem *a,
                       const struct list_elem *b,
                       void *aux) {
c0022e4b:	56                   	push   %esi
c0022e4c:	53                   	push   %ebx
c0022e4d:	83 ec 10             	sub    $0x10,%esp
c0022e50:	e8 a3 c0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0022e55:	81 c3 d3 82 01 00    	add    $0x182d3,%ebx
    struct semaphore_elem *sema_a = list_entry(a, struct semaphore_elem, elem);
    struct semaphore_elem *sema_b = list_entry(b, struct semaphore_elem, elem);
    int priority_a = list_entry(list_front(&sema_a->semaphore.waiters), struct thread, elem)->priority;
c0022e5b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0022e5f:	83 c0 0c             	add    $0xc,%eax
c0022e62:	50                   	push   %eax
c0022e63:	e8 07 6a 00 00       	call   c002986f <list_front>
c0022e68:	8b b0 1c ff ff ff    	mov    -0xe4(%eax),%esi
    int priority_b = list_entry(list_front(&sema_b->semaphore.waiters), struct thread, elem)->priority;
c0022e6e:	8b 44 24 24          	mov    0x24(%esp),%eax
c0022e72:	83 c0 0c             	add    $0xc,%eax
c0022e75:	89 04 24             	mov    %eax,(%esp)
c0022e78:	e8 f2 69 00 00       	call   c002986f <list_front>
    return priority_a > priority_b;
c0022e7d:	3b b0 1c ff ff ff    	cmp    -0xe4(%eax),%esi
c0022e83:	0f 9f c0             	setg   %al
}
c0022e86:	83 c4 14             	add    $0x14,%esp
c0022e89:	5b                   	pop    %ebx
c0022e8a:	5e                   	pop    %esi
c0022e8b:	c3                   	ret    

c0022e8c <sema_init>:
sema_init(struct semaphore *sema, unsigned value) {
c0022e8c:	53                   	push   %ebx
c0022e8d:	83 ec 08             	sub    $0x8,%esp
c0022e90:	e8 63 c0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0022e95:	81 c3 93 82 01 00    	add    $0x18293,%ebx
c0022e9b:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (sema != NULL);
c0022e9f:	85 c0                	test   %eax,%eax
c0022ea1:	74 17                	je     c0022eba <sema_init+0x2e>
    sema->value = value;
c0022ea3:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022ea7:	89 10                	mov    %edx,(%eax)
    list_init(&sema->waiters);
c0022ea9:	83 ec 0c             	sub    $0xc,%esp
c0022eac:	83 c0 04             	add    $0x4,%eax
c0022eaf:	50                   	push   %eax
c0022eb0:	e8 f2 62 00 00       	call   c00291a7 <list_init>
}
c0022eb5:	83 c4 18             	add    $0x18,%esp
c0022eb8:	5b                   	pop    %ebx
c0022eb9:	c3                   	ret    
    ASSERT (sema != NULL);
c0022eba:	83 ec 0c             	sub    $0xc,%esp
c0022ebd:	8d 83 f2 5a ff ff    	lea    -0xa50e(%ebx),%eax
c0022ec3:	50                   	push   %eax
c0022ec4:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0022eca:	50                   	push   %eax
c0022ecb:	8d 83 90 40 ff ff    	lea    -0xbf70(%ebx),%eax
c0022ed1:	50                   	push   %eax
c0022ed2:	6a 2e                	push   $0x2e
c0022ed4:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0022eda:	50                   	push   %eax
c0022edb:	e8 fa 61 00 00       	call   c00290da <debug_panic>

c0022ee0 <sema_down>:
sema_down(struct semaphore *sema) {
c0022ee0:	55                   	push   %ebp
c0022ee1:	57                   	push   %edi
c0022ee2:	56                   	push   %esi
c0022ee3:	53                   	push   %ebx
c0022ee4:	83 ec 1c             	sub    $0x1c,%esp
c0022ee7:	e8 0c c0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0022eec:	81 c3 3c 82 01 00    	add    $0x1823c,%ebx
c0022ef2:	8b 7c 24 30          	mov    0x30(%esp),%edi
    ASSERT (sema != NULL);
c0022ef6:	85 ff                	test   %edi,%edi
c0022ef8:	74 5d                	je     c0022f57 <sema_down+0x77>
    ASSERT (!intr_context());
c0022efa:	e8 b6 f0 ff ff       	call   c0021fb5 <intr_context>
c0022eff:	84 c0                	test   %al,%al
c0022f01:	75 7a                	jne    c0022f7d <sema_down+0x9d>
    old_level = intr_disable();
c0022f03:	e8 07 ee ff ff       	call   c0021d0f <intr_disable>
c0022f08:	89 44 24 0c          	mov    %eax,0xc(%esp)
    while (sema->value == 0) {
c0022f0c:	8b 07                	mov    (%edi),%eax
c0022f0e:	85 c0                	test   %eax,%eax
c0022f10:	75 2c                	jne    c0022f3e <sema_down+0x5e>
        list_insert_ordered(&sema->waiters, &thread_current()->elem, get_cmp_priority_func(), NULL);
c0022f12:	8d 6f 04             	lea    0x4(%edi),%ebp
c0022f15:	e8 98 df ff ff       	call   c0020eb2 <get_cmp_priority_func>
c0022f1a:	89 c6                	mov    %eax,%esi
c0022f1c:	e8 55 e0 ff ff       	call   c0020f76 <thread_current>
c0022f21:	6a 00                	push   $0x0
c0022f23:	56                   	push   %esi
c0022f24:	05 08 01 00 00       	add    $0x108,%eax
c0022f29:	50                   	push   %eax
c0022f2a:	55                   	push   %ebp
c0022f2b:	e8 6e 6d 00 00       	call   c0029c9e <list_insert_ordered>
        thread_block();
c0022f30:	e8 e0 e5 ff ff       	call   c0021515 <thread_block>
    while (sema->value == 0) {
c0022f35:	8b 07                	mov    (%edi),%eax
c0022f37:	83 c4 10             	add    $0x10,%esp
c0022f3a:	85 c0                	test   %eax,%eax
c0022f3c:	74 d7                	je     c0022f15 <sema_down+0x35>
    sema->value--;
c0022f3e:	83 e8 01             	sub    $0x1,%eax
c0022f41:	89 07                	mov    %eax,(%edi)
    intr_set_level(old_level);
c0022f43:	83 ec 0c             	sub    $0xc,%esp
c0022f46:	ff 74 24 18          	pushl  0x18(%esp)
c0022f4a:	e8 c7 ed ff ff       	call   c0021d16 <intr_set_level>
}
c0022f4f:	83 c4 2c             	add    $0x2c,%esp
c0022f52:	5b                   	pop    %ebx
c0022f53:	5e                   	pop    %esi
c0022f54:	5f                   	pop    %edi
c0022f55:	5d                   	pop    %ebp
c0022f56:	c3                   	ret    
    ASSERT (sema != NULL);
c0022f57:	83 ec 0c             	sub    $0xc,%esp
c0022f5a:	8d 83 f2 5a ff ff    	lea    -0xa50e(%ebx),%eax
c0022f60:	50                   	push   %eax
c0022f61:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0022f67:	50                   	push   %eax
c0022f68:	8d 83 84 40 ff ff    	lea    -0xbf7c(%ebx),%eax
c0022f6e:	50                   	push   %eax
c0022f6f:	6a 3f                	push   $0x3f
c0022f71:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0022f77:	50                   	push   %eax
c0022f78:	e8 5d 61 00 00       	call   c00290da <debug_panic>
    ASSERT (!intr_context());
c0022f7d:	83 ec 0c             	sub    $0xc,%esp
c0022f80:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c0022f86:	50                   	push   %eax
c0022f87:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0022f8d:	50                   	push   %eax
c0022f8e:	8d 83 84 40 ff ff    	lea    -0xbf7c(%ebx),%eax
c0022f94:	50                   	push   %eax
c0022f95:	6a 40                	push   $0x40
c0022f97:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0022f9d:	50                   	push   %eax
c0022f9e:	e8 37 61 00 00       	call   c00290da <debug_panic>

c0022fa3 <sema_try_down>:
sema_try_down(struct semaphore *sema) {
c0022fa3:	57                   	push   %edi
c0022fa4:	56                   	push   %esi
c0022fa5:	53                   	push   %ebx
c0022fa6:	e8 4d bf 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0022fab:	81 c3 7d 81 01 00    	add    $0x1817d,%ebx
c0022fb1:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (sema != NULL);
c0022fb5:	85 f6                	test   %esi,%esi
c0022fb7:	74 2c                	je     c0022fe5 <sema_try_down+0x42>
    old_level = intr_disable();
c0022fb9:	e8 51 ed ff ff       	call   c0021d0f <intr_disable>
    if (sema->value > 0) {
c0022fbe:	8b 16                	mov    (%esi),%edx
        success = false;
c0022fc0:	bf 00 00 00 00       	mov    $0x0,%edi
    if (sema->value > 0) {
c0022fc5:	85 d2                	test   %edx,%edx
c0022fc7:	74 0a                	je     c0022fd3 <sema_try_down+0x30>
        sema->value--;
c0022fc9:	83 ea 01             	sub    $0x1,%edx
c0022fcc:	89 16                	mov    %edx,(%esi)
        success = true;
c0022fce:	bf 01 00 00 00       	mov    $0x1,%edi
    intr_set_level(old_level);
c0022fd3:	83 ec 0c             	sub    $0xc,%esp
c0022fd6:	50                   	push   %eax
c0022fd7:	e8 3a ed ff ff       	call   c0021d16 <intr_set_level>
    return success;
c0022fdc:	83 c4 10             	add    $0x10,%esp
}
c0022fdf:	89 f8                	mov    %edi,%eax
c0022fe1:	5b                   	pop    %ebx
c0022fe2:	5e                   	pop    %esi
c0022fe3:	5f                   	pop    %edi
c0022fe4:	c3                   	ret    
    ASSERT (sema != NULL);
c0022fe5:	83 ec 0c             	sub    $0xc,%esp
c0022fe8:	8d 83 f2 5a ff ff    	lea    -0xa50e(%ebx),%eax
c0022fee:	50                   	push   %eax
c0022fef:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0022ff5:	50                   	push   %eax
c0022ff6:	8d 83 74 40 ff ff    	lea    -0xbf8c(%ebx),%eax
c0022ffc:	50                   	push   %eax
c0022ffd:	6a 55                	push   $0x55
c0022fff:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0023005:	50                   	push   %eax
c0023006:	e8 cf 60 00 00       	call   c00290da <debug_panic>

c002300b <sema_up>:
sema_up(struct semaphore *sema) {
c002300b:	57                   	push   %edi
c002300c:	56                   	push   %esi
c002300d:	53                   	push   %ebx
c002300e:	e8 e5 be 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023013:	81 c3 15 81 01 00    	add    $0x18115,%ebx
c0023019:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (sema != NULL);
c002301d:	85 f6                	test   %esi,%esi
c002301f:	74 2d                	je     c002304e <sema_up+0x43>
    old_level = intr_disable();
c0023021:	e8 e9 ec ff ff       	call   c0021d0f <intr_disable>
c0023026:	89 c7                	mov    %eax,%edi
    sema->value++;
c0023028:	83 06 01             	addl   $0x1,(%esi)
    if (!list_empty(&sema->waiters)) {
c002302b:	83 c6 04             	add    $0x4,%esi
c002302e:	83 ec 0c             	sub    $0xc,%esp
c0023031:	56                   	push   %esi
c0023032:	e8 14 68 00 00       	call   c002984b <list_empty>
c0023037:	83 c4 10             	add    $0x10,%esp
c002303a:	84 c0                	test   %al,%al
c002303c:	74 36                	je     c0023074 <sema_up+0x69>
    intr_set_level(old_level);
c002303e:	83 ec 0c             	sub    $0xc,%esp
c0023041:	57                   	push   %edi
c0023042:	e8 cf ec ff ff       	call   c0021d16 <intr_set_level>
}
c0023047:	83 c4 10             	add    $0x10,%esp
c002304a:	5b                   	pop    %ebx
c002304b:	5e                   	pop    %esi
c002304c:	5f                   	pop    %edi
c002304d:	c3                   	ret    
    ASSERT (sema != NULL);
c002304e:	83 ec 0c             	sub    $0xc,%esp
c0023051:	8d 83 f2 5a ff ff    	lea    -0xa50e(%ebx),%eax
c0023057:	50                   	push   %eax
c0023058:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002305e:	50                   	push   %eax
c002305f:	8d 83 6c 40 ff ff    	lea    -0xbf94(%ebx),%eax
c0023065:	50                   	push   %eax
c0023066:	6a 6d                	push   $0x6d
c0023068:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c002306e:	50                   	push   %eax
c002306f:	e8 66 60 00 00       	call   c00290da <debug_panic>
        list_sort(&sema->waiters, get_cmp_priority_func(), NULL);
c0023074:	e8 39 de ff ff       	call   c0020eb2 <get_cmp_priority_func>
c0023079:	83 ec 04             	sub    $0x4,%esp
c002307c:	6a 00                	push   $0x0
c002307e:	50                   	push   %eax
c002307f:	56                   	push   %esi
c0023080:	e8 2c 69 00 00       	call   c00299b1 <list_sort>
        thread_unblock(list_entry (list_pop_front(&sema->waiters),
c0023085:	89 34 24             	mov    %esi,(%esp)
c0023088:	e8 35 68 00 00       	call   c00298c2 <list_pop_front>
c002308d:	2d 08 01 00 00       	sub    $0x108,%eax
c0023092:	89 04 24             	mov    %eax,(%esp)
c0023095:	e8 29 de ff ff       	call   c0020ec3 <thread_unblock>
c002309a:	83 c4 10             	add    $0x10,%esp
c002309d:	eb 9f                	jmp    c002303e <sema_up+0x33>

c002309f <sema_test_helper>:
sema_test_helper(void *sema_) {
c002309f:	57                   	push   %edi
c00230a0:	56                   	push   %esi
c00230a1:	53                   	push   %ebx
c00230a2:	8b 74 24 10          	mov    0x10(%esp),%esi
c00230a6:	bb 0a 00 00 00       	mov    $0xa,%ebx
        sema_up(&sema[1]);
c00230ab:	8d 7e 14             	lea    0x14(%esi),%edi
        sema_down(&sema[0]);
c00230ae:	83 ec 0c             	sub    $0xc,%esp
c00230b1:	56                   	push   %esi
c00230b2:	e8 29 fe ff ff       	call   c0022ee0 <sema_down>
        sema_up(&sema[1]);
c00230b7:	89 3c 24             	mov    %edi,(%esp)
c00230ba:	e8 4c ff ff ff       	call   c002300b <sema_up>
    for (i = 0; i < 10; i++) {
c00230bf:	83 c4 10             	add    $0x10,%esp
c00230c2:	83 eb 01             	sub    $0x1,%ebx
c00230c5:	75 e7                	jne    c00230ae <sema_test_helper+0xf>
}
c00230c7:	5b                   	pop    %ebx
c00230c8:	5e                   	pop    %esi
c00230c9:	5f                   	pop    %edi
c00230ca:	c3                   	ret    

c00230cb <sema_self_test>:
sema_self_test(void) {
c00230cb:	55                   	push   %ebp
c00230cc:	57                   	push   %edi
c00230cd:	56                   	push   %esi
c00230ce:	53                   	push   %ebx
c00230cf:	83 ec 48             	sub    $0x48,%esp
c00230d2:	e8 21 be 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00230d7:	81 c3 51 80 01 00    	add    $0x18051,%ebx
    printf("Testing semaphores...");
c00230dd:	8d 83 15 5b ff ff    	lea    -0xa4eb(%ebx),%eax
c00230e3:	50                   	push   %eax
c00230e4:	e8 95 43 00 00       	call   c002747e <printf>
    sema_init(&sema[0], 0);
c00230e9:	83 c4 08             	add    $0x8,%esp
c00230ec:	6a 00                	push   $0x0
c00230ee:	8d 74 24 14          	lea    0x14(%esp),%esi
c00230f2:	56                   	push   %esi
c00230f3:	e8 94 fd ff ff       	call   c0022e8c <sema_init>
    sema_init(&sema[1], 0);
c00230f8:	83 c4 08             	add    $0x8,%esp
c00230fb:	6a 00                	push   $0x0
c00230fd:	8d 44 24 28          	lea    0x28(%esp),%eax
c0023101:	50                   	push   %eax
c0023102:	e8 85 fd ff ff       	call   c0022e8c <sema_init>
    thread_create("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0023107:	56                   	push   %esi
c0023108:	8d 83 77 7f fe ff    	lea    -0x18089(%ebx),%eax
c002310e:	50                   	push   %eax
c002310f:	6a 1f                	push   $0x1f
c0023111:	8d 83 2b 5b ff ff    	lea    -0xa4d5(%ebx),%eax
c0023117:	50                   	push   %eax
c0023118:	e8 2b e6 ff ff       	call   c0021748 <thread_create>
c002311d:	83 c4 20             	add    $0x20,%esp
c0023120:	be 0a 00 00 00       	mov    $0xa,%esi
        sema_up(&sema[0]);
c0023125:	8d 6c 24 08          	lea    0x8(%esp),%ebp
        sema_down(&sema[1]);
c0023129:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
        sema_up(&sema[0]);
c002312d:	83 ec 0c             	sub    $0xc,%esp
c0023130:	55                   	push   %ebp
c0023131:	e8 d5 fe ff ff       	call   c002300b <sema_up>
        sema_down(&sema[1]);
c0023136:	89 3c 24             	mov    %edi,(%esp)
c0023139:	e8 a2 fd ff ff       	call   c0022ee0 <sema_down>
    for (i = 0; i < 10; i++) {
c002313e:	83 c4 10             	add    $0x10,%esp
c0023141:	83 ee 01             	sub    $0x1,%esi
c0023144:	75 e7                	jne    c002312d <sema_self_test+0x62>
    printf("done.\n");
c0023146:	83 ec 0c             	sub    $0xc,%esp
c0023149:	8d 83 35 5b ff ff    	lea    -0xa4cb(%ebx),%eax
c002314f:	50                   	push   %eax
c0023150:	e8 5b 7f 00 00       	call   c002b0b0 <puts>
}
c0023155:	83 c4 4c             	add    $0x4c,%esp
c0023158:	5b                   	pop    %ebx
c0023159:	5e                   	pop    %esi
c002315a:	5f                   	pop    %edi
c002315b:	5d                   	pop    %ebp
c002315c:	c3                   	ret    

c002315d <lock_init>:
lock_init(struct lock *lock) {
c002315d:	53                   	push   %ebx
c002315e:	83 ec 08             	sub    $0x8,%esp
c0023161:	e8 92 bd 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023166:	81 c3 c2 7f 01 00    	add    $0x17fc2,%ebx
c002316c:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (lock != NULL);
c0023170:	85 c0                	test   %eax,%eax
c0023172:	74 19                	je     c002318d <lock_init+0x30>
    lock->holder = NULL;
c0023174:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    sema_init(&lock->semaphore, 1);
c002317a:	83 ec 08             	sub    $0x8,%esp
c002317d:	6a 01                	push   $0x1
c002317f:	83 c0 04             	add    $0x4,%eax
c0023182:	50                   	push   %eax
c0023183:	e8 04 fd ff ff       	call   c0022e8c <sema_init>
}
c0023188:	83 c4 18             	add    $0x18,%esp
c002318b:	5b                   	pop    %ebx
c002318c:	c3                   	ret    
    ASSERT (lock != NULL);
c002318d:	83 ec 0c             	sub    $0xc,%esp
c0023190:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c0023196:	50                   	push   %eax
c0023197:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002319d:	50                   	push   %eax
c002319e:	8d 83 60 40 ff ff    	lea    -0xbfa0(%ebx),%eax
c00231a4:	50                   	push   %eax
c00231a5:	68 b3 00 00 00       	push   $0xb3
c00231aa:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00231b0:	50                   	push   %eax
c00231b1:	e8 24 5f 00 00       	call   c00290da <debug_panic>

c00231b6 <lock_held_by_current_thread>:
lock_held_by_current_thread(const struct lock *lock) {
c00231b6:	56                   	push   %esi
c00231b7:	53                   	push   %ebx
c00231b8:	83 ec 04             	sub    $0x4,%esp
c00231bb:	e8 38 bd 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00231c0:	81 c3 68 7f 01 00    	add    $0x17f68,%ebx
c00231c6:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (lock != NULL);
c00231ca:	85 c0                	test   %eax,%eax
c00231cc:	74 12                	je     c00231e0 <lock_held_by_current_thread+0x2a>
    return lock->holder == thread_current();
c00231ce:	8b 30                	mov    (%eax),%esi
c00231d0:	e8 a1 dd ff ff       	call   c0020f76 <thread_current>
c00231d5:	39 c6                	cmp    %eax,%esi
c00231d7:	0f 94 c0             	sete   %al
}
c00231da:	83 c4 04             	add    $0x4,%esp
c00231dd:	5b                   	pop    %ebx
c00231de:	5e                   	pop    %esi
c00231df:	c3                   	ret    
    ASSERT (lock != NULL);
c00231e0:	83 ec 0c             	sub    $0xc,%esp
c00231e3:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c00231e9:	50                   	push   %eax
c00231ea:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00231f0:	50                   	push   %eax
c00231f1:	8d 83 10 40 ff ff    	lea    -0xbff0(%ebx),%eax
c00231f7:	50                   	push   %eax
c00231f8:	68 0d 01 00 00       	push   $0x10d
c00231fd:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0023203:	50                   	push   %eax
c0023204:	e8 d1 5e 00 00       	call   c00290da <debug_panic>

c0023209 <lock_acquire>:
lock_acquire(struct lock *lock) {
c0023209:	55                   	push   %ebp
c002320a:	57                   	push   %edi
c002320b:	56                   	push   %esi
c002320c:	53                   	push   %ebx
c002320d:	83 ec 0c             	sub    $0xc,%esp
c0023210:	e8 e3 bc 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023215:	81 c3 13 7f 01 00    	add    $0x17f13,%ebx
c002321b:	8b 7c 24 20          	mov    0x20(%esp),%edi
    struct thread *current_thread = thread_current();
c002321f:	e8 52 dd ff ff       	call   c0020f76 <thread_current>
    ASSERT (lock != NULL);
c0023224:	85 ff                	test   %edi,%edi
c0023226:	0f 84 a6 00 00 00    	je     c00232d2 <lock_acquire+0xc9>
c002322c:	89 c5                	mov    %eax,%ebp
    ASSERT (!intr_context());
c002322e:	e8 82 ed ff ff       	call   c0021fb5 <intr_context>
c0023233:	84 c0                	test   %al,%al
c0023235:	0f 85 c0 00 00 00    	jne    c00232fb <lock_acquire+0xf2>
    ASSERT (!lock_held_by_current_thread(lock));
c002323b:	83 ec 0c             	sub    $0xc,%esp
c002323e:	57                   	push   %edi
c002323f:	e8 72 ff ff ff       	call   c00231b6 <lock_held_by_current_thread>
c0023244:	83 c4 10             	add    $0x10,%esp
c0023247:	84 c0                	test   %al,%al
c0023249:	0f 85 d5 00 00 00    	jne    c0023324 <lock_acquire+0x11b>
    if (lock->holder != NULL && !thread_mlfqs) {
c002324f:	83 3f 00             	cmpl   $0x0,(%edi)
c0023252:	74 3f                	je     c0023293 <lock_acquire+0x8a>
c0023254:	c7 c0 80 d0 03 c0    	mov    $0xc003d080,%eax
c002325a:	80 38 00             	cmpb   $0x0,(%eax)
c002325d:	75 34                	jne    c0023293 <lock_acquire+0x8a>
        current_thread->lock_waiting = lock;
c002325f:	89 bd 04 01 00 00    	mov    %edi,0x104(%ebp)
        while (l && current_thread->priority > l->max_priority) {
c0023265:	8b 45 24             	mov    0x24(%ebp),%eax
c0023268:	3b 47 20             	cmp    0x20(%edi),%eax
c002326b:	7e 26                	jle    c0023293 <lock_acquire+0x8a>
        l = lock;
c002326d:	89 fe                	mov    %edi,%esi
            l->max_priority = current_thread->priority;
c002326f:	89 46 20             	mov    %eax,0x20(%esi)
            thread_donate_priority(l->holder);
c0023272:	83 ec 0c             	sub    $0xc,%esp
c0023275:	ff 36                	pushl  (%esi)
c0023277:	e8 b9 e7 ff ff       	call   c0021a35 <thread_donate_priority>
            l = l->holder->lock_waiting;
c002327c:	8b 06                	mov    (%esi),%eax
c002327e:	8b b0 04 01 00 00    	mov    0x104(%eax),%esi
        while (l && current_thread->priority > l->max_priority) {
c0023284:	83 c4 10             	add    $0x10,%esp
c0023287:	85 f6                	test   %esi,%esi
c0023289:	74 08                	je     c0023293 <lock_acquire+0x8a>
c002328b:	8b 45 24             	mov    0x24(%ebp),%eax
c002328e:	3b 46 20             	cmp    0x20(%esi),%eax
c0023291:	7f dc                	jg     c002326f <lock_acquire+0x66>
    sema_down(&lock->semaphore);
c0023293:	83 ec 0c             	sub    $0xc,%esp
c0023296:	8d 47 04             	lea    0x4(%edi),%eax
c0023299:	50                   	push   %eax
c002329a:	e8 41 fc ff ff       	call   c0022ee0 <sema_down>
    enum intr_level old_level = intr_disable();
c002329f:	e8 6b ea ff ff       	call   c0021d0f <intr_disable>
c00232a4:	89 c5                	mov    %eax,%ebp
    current_thread = thread_current();
c00232a6:	e8 cb dc ff ff       	call   c0020f76 <thread_current>
c00232ab:	89 c6                	mov    %eax,%esi
    if (!thread_mlfqs) {
c00232ad:	83 c4 10             	add    $0x10,%esp
c00232b0:	c7 c0 80 d0 03 c0    	mov    $0xc003d080,%eax
c00232b6:	80 38 00             	cmpb   $0x0,(%eax)
c00232b9:	0f 84 8e 00 00 00    	je     c002334d <lock_acquire+0x144>
    lock->holder = current_thread;
c00232bf:	89 37                	mov    %esi,(%edi)
    intr_set_level(old_level);
c00232c1:	83 ec 0c             	sub    $0xc,%esp
c00232c4:	55                   	push   %ebp
c00232c5:	e8 4c ea ff ff       	call   c0021d16 <intr_set_level>
}
c00232ca:	83 c4 1c             	add    $0x1c,%esp
c00232cd:	5b                   	pop    %ebx
c00232ce:	5e                   	pop    %esi
c00232cf:	5f                   	pop    %edi
c00232d0:	5d                   	pop    %ebp
c00232d1:	c3                   	ret    
    ASSERT (lock != NULL);
c00232d2:	83 ec 0c             	sub    $0xc,%esp
c00232d5:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c00232db:	50                   	push   %eax
c00232dc:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00232e2:	50                   	push   %eax
c00232e3:	8d 83 50 40 ff ff    	lea    -0xbfb0(%ebx),%eax
c00232e9:	50                   	push   %eax
c00232ea:	68 c6 00 00 00       	push   $0xc6
c00232ef:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00232f5:	50                   	push   %eax
c00232f6:	e8 df 5d 00 00       	call   c00290da <debug_panic>
    ASSERT (!intr_context());
c00232fb:	83 ec 0c             	sub    $0xc,%esp
c00232fe:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c0023304:	50                   	push   %eax
c0023305:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002330b:	50                   	push   %eax
c002330c:	8d 83 50 40 ff ff    	lea    -0xbfb0(%ebx),%eax
c0023312:	50                   	push   %eax
c0023313:	68 c7 00 00 00       	push   $0xc7
c0023318:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c002331e:	50                   	push   %eax
c002331f:	e8 b6 5d 00 00       	call   c00290da <debug_panic>
    ASSERT (!lock_held_by_current_thread(lock));
c0023324:	83 ec 0c             	sub    $0xc,%esp
c0023327:	8d 83 58 5b ff ff    	lea    -0xa4a8(%ebx),%eax
c002332d:	50                   	push   %eax
c002332e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023334:	50                   	push   %eax
c0023335:	8d 83 50 40 ff ff    	lea    -0xbfb0(%ebx),%eax
c002333b:	50                   	push   %eax
c002333c:	68 c8 00 00 00       	push   $0xc8
c0023341:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0023347:	50                   	push   %eax
c0023348:	e8 8d 5d 00 00       	call   c00290da <debug_panic>
        current_thread->lock_waiting = NULL;
c002334d:	c7 86 04 01 00 00 00 	movl   $0x0,0x104(%esi)
c0023354:	00 00 00 
        lock->max_priority = current_thread->priority;
c0023357:	8b 46 24             	mov    0x24(%esi),%eax
c002335a:	89 47 20             	mov    %eax,0x20(%edi)
        thread_hold_the_lock(lock);
c002335d:	83 ec 0c             	sub    $0xc,%esp
c0023360:	57                   	push   %edi
c0023361:	e8 76 e7 ff ff       	call   c0021adc <thread_hold_the_lock>
c0023366:	83 c4 10             	add    $0x10,%esp
c0023369:	e9 51 ff ff ff       	jmp    c00232bf <lock_acquire+0xb6>

c002336e <lock_try_acquire>:
lock_try_acquire(struct lock *lock) {
c002336e:	57                   	push   %edi
c002336f:	56                   	push   %esi
c0023370:	53                   	push   %ebx
c0023371:	e8 82 bb 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023376:	81 c3 b2 7d 01 00    	add    $0x17db2,%ebx
c002337c:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (lock != NULL);
c0023380:	85 f6                	test   %esi,%esi
c0023382:	74 2b                	je     c00233af <lock_try_acquire+0x41>
    ASSERT (!lock_held_by_current_thread(lock));
c0023384:	83 ec 0c             	sub    $0xc,%esp
c0023387:	56                   	push   %esi
c0023388:	e8 29 fe ff ff       	call   c00231b6 <lock_held_by_current_thread>
c002338d:	83 c4 10             	add    $0x10,%esp
c0023390:	84 c0                	test   %al,%al
c0023392:	75 44                	jne    c00233d8 <lock_try_acquire+0x6a>
    success = sema_try_down(&lock->semaphore);
c0023394:	83 ec 0c             	sub    $0xc,%esp
c0023397:	8d 46 04             	lea    0x4(%esi),%eax
c002339a:	50                   	push   %eax
c002339b:	e8 03 fc ff ff       	call   c0022fa3 <sema_try_down>
c00233a0:	89 c7                	mov    %eax,%edi
    if (success)
c00233a2:	83 c4 10             	add    $0x10,%esp
c00233a5:	84 c0                	test   %al,%al
c00233a7:	75 58                	jne    c0023401 <lock_try_acquire+0x93>
}
c00233a9:	89 f8                	mov    %edi,%eax
c00233ab:	5b                   	pop    %ebx
c00233ac:	5e                   	pop    %esi
c00233ad:	5f                   	pop    %edi
c00233ae:	c3                   	ret    
    ASSERT (lock != NULL);
c00233af:	83 ec 0c             	sub    $0xc,%esp
c00233b2:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c00233b8:	50                   	push   %eax
c00233b9:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00233bf:	50                   	push   %eax
c00233c0:	8d 83 3c 40 ff ff    	lea    -0xbfc4(%ebx),%eax
c00233c6:	50                   	push   %eax
c00233c7:	68 ee 00 00 00       	push   $0xee
c00233cc:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00233d2:	50                   	push   %eax
c00233d3:	e8 02 5d 00 00       	call   c00290da <debug_panic>
    ASSERT (!lock_held_by_current_thread(lock));
c00233d8:	83 ec 0c             	sub    $0xc,%esp
c00233db:	8d 83 58 5b ff ff    	lea    -0xa4a8(%ebx),%eax
c00233e1:	50                   	push   %eax
c00233e2:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00233e8:	50                   	push   %eax
c00233e9:	8d 83 3c 40 ff ff    	lea    -0xbfc4(%ebx),%eax
c00233ef:	50                   	push   %eax
c00233f0:	68 ef 00 00 00       	push   $0xef
c00233f5:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00233fb:	50                   	push   %eax
c00233fc:	e8 d9 5c 00 00       	call   c00290da <debug_panic>
        lock->holder = thread_current();
c0023401:	e8 70 db ff ff       	call   c0020f76 <thread_current>
c0023406:	89 06                	mov    %eax,(%esi)
    return success;
c0023408:	eb 9f                	jmp    c00233a9 <lock_try_acquire+0x3b>

c002340a <lock_release>:
lock_release(struct lock *lock) {
c002340a:	56                   	push   %esi
c002340b:	53                   	push   %ebx
c002340c:	83 ec 04             	sub    $0x4,%esp
c002340f:	e8 e4 ba 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023414:	81 c3 14 7d 01 00    	add    $0x17d14,%ebx
c002341a:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (lock != NULL);
c002341e:	85 f6                	test   %esi,%esi
c0023420:	74 33                	je     c0023455 <lock_release+0x4b>
    ASSERT (lock_held_by_current_thread(lock));
c0023422:	83 ec 0c             	sub    $0xc,%esp
c0023425:	56                   	push   %esi
c0023426:	e8 8b fd ff ff       	call   c00231b6 <lock_held_by_current_thread>
c002342b:	83 c4 10             	add    $0x10,%esp
c002342e:	84 c0                	test   %al,%al
c0023430:	74 4c                	je     c002347e <lock_release+0x74>
    lock->holder = NULL;
c0023432:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    if (!thread_mlfqs)
c0023438:	c7 c0 80 d0 03 c0    	mov    $0xc003d080,%eax
c002343e:	80 38 00             	cmpb   $0x0,(%eax)
c0023441:	74 64                	je     c00234a7 <lock_release+0x9d>
    sema_up(&lock->semaphore);
c0023443:	83 ec 0c             	sub    $0xc,%esp
c0023446:	83 c6 04             	add    $0x4,%esi
c0023449:	56                   	push   %esi
c002344a:	e8 bc fb ff ff       	call   c002300b <sema_up>
}
c002344f:	83 c4 14             	add    $0x14,%esp
c0023452:	5b                   	pop    %ebx
c0023453:	5e                   	pop    %esi
c0023454:	c3                   	ret    
    ASSERT (lock != NULL);
c0023455:	83 ec 0c             	sub    $0xc,%esp
c0023458:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c002345e:	50                   	push   %eax
c002345f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023465:	50                   	push   %eax
c0023466:	8d 83 2c 40 ff ff    	lea    -0xbfd4(%ebx),%eax
c002346c:	50                   	push   %eax
c002346d:	68 fe 00 00 00       	push   $0xfe
c0023472:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0023478:	50                   	push   %eax
c0023479:	e8 5c 5c 00 00       	call   c00290da <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c002347e:	83 ec 0c             	sub    $0xc,%esp
c0023481:	8d 83 7c 5b ff ff    	lea    -0xa484(%ebx),%eax
c0023487:	50                   	push   %eax
c0023488:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002348e:	50                   	push   %eax
c002348f:	8d 83 2c 40 ff ff    	lea    -0xbfd4(%ebx),%eax
c0023495:	50                   	push   %eax
c0023496:	68 ff 00 00 00       	push   $0xff
c002349b:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00234a1:	50                   	push   %eax
c00234a2:	e8 33 5c 00 00       	call   c00290da <debug_panic>
        thread_remove_lock(lock);
c00234a7:	83 ec 0c             	sub    $0xc,%esp
c00234aa:	56                   	push   %esi
c00234ab:	e8 ea e5 ff ff       	call   c0021a9a <thread_remove_lock>
c00234b0:	83 c4 10             	add    $0x10,%esp
c00234b3:	eb 8e                	jmp    c0023443 <lock_release+0x39>

c00234b5 <cond_init>:
cond_init(struct condition *cond) {
c00234b5:	53                   	push   %ebx
c00234b6:	83 ec 08             	sub    $0x8,%esp
c00234b9:	e8 3a ba 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00234be:	81 c3 6a 7c 01 00    	add    $0x17c6a,%ebx
c00234c4:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (cond != NULL);
c00234c8:	85 c0                	test   %eax,%eax
c00234ca:	74 0e                	je     c00234da <cond_init+0x25>
    list_init(&cond->waiters);
c00234cc:	83 ec 0c             	sub    $0xc,%esp
c00234cf:	50                   	push   %eax
c00234d0:	e8 d2 5c 00 00       	call   c00291a7 <list_init>
}
c00234d5:	83 c4 18             	add    $0x18,%esp
c00234d8:	5b                   	pop    %ebx
c00234d9:	c3                   	ret    
    ASSERT (cond != NULL);
c00234da:	83 ec 0c             	sub    $0xc,%esp
c00234dd:	8d 83 48 5b ff ff    	lea    -0xa4b8(%ebx),%eax
c00234e3:	50                   	push   %eax
c00234e4:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00234ea:	50                   	push   %eax
c00234eb:	8d 83 04 40 ff ff    	lea    -0xbffc(%ebx),%eax
c00234f1:	50                   	push   %eax
c00234f2:	68 1d 01 00 00       	push   $0x11d
c00234f7:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00234fd:	50                   	push   %eax
c00234fe:	e8 d7 5b 00 00       	call   c00290da <debug_panic>

c0023503 <cond_wait>:
cond_wait(struct condition *cond, struct lock *lock) {
c0023503:	55                   	push   %ebp
c0023504:	57                   	push   %edi
c0023505:	56                   	push   %esi
c0023506:	53                   	push   %ebx
c0023507:	83 ec 2c             	sub    $0x2c,%esp
c002350a:	e8 f5 b9 00 00       	call   c002ef04 <__x86.get_pc_thunk.di>
c002350f:	81 c7 19 7c 01 00    	add    $0x17c19,%edi
c0023515:	8b 74 24 44          	mov    0x44(%esp),%esi
    ASSERT (cond != NULL);
c0023519:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c002351e:	74 6d                	je     c002358d <cond_wait+0x8a>
    ASSERT (lock != NULL);
c0023520:	85 f6                	test   %esi,%esi
c0023522:	0f 84 90 00 00 00    	je     c00235b8 <cond_wait+0xb5>
    ASSERT (!intr_context());
c0023528:	89 fb                	mov    %edi,%ebx
c002352a:	e8 86 ea ff ff       	call   c0021fb5 <intr_context>
c002352f:	84 c0                	test   %al,%al
c0023531:	0f 85 ac 00 00 00    	jne    c00235e3 <cond_wait+0xe0>
    ASSERT (lock_held_by_current_thread(lock));
c0023537:	83 ec 0c             	sub    $0xc,%esp
c002353a:	56                   	push   %esi
c002353b:	e8 76 fc ff ff       	call   c00231b6 <lock_held_by_current_thread>
c0023540:	83 c4 10             	add    $0x10,%esp
c0023543:	84 c0                	test   %al,%al
c0023545:	0f 84 c1 00 00 00    	je     c002360c <cond_wait+0x109>
    sema_init(&waiter.semaphore, 0);
c002354b:	83 ec 08             	sub    $0x8,%esp
c002354e:	6a 00                	push   $0x0
c0023550:	8d 5c 24 10          	lea    0x10(%esp),%ebx
c0023554:	8d 6c 24 18          	lea    0x18(%esp),%ebp
c0023558:	55                   	push   %ebp
c0023559:	e8 2e f9 ff ff       	call   c0022e8c <sema_init>
    list_push_back(&cond->waiters, &waiter.elem);
c002355e:	83 c4 08             	add    $0x8,%esp
c0023561:	53                   	push   %ebx
c0023562:	ff 74 24 4c          	pushl  0x4c(%esp)
c0023566:	89 fb                	mov    %edi,%ebx
c0023568:	e8 1f 62 00 00       	call   c002978c <list_push_back>
    lock_release(lock);
c002356d:	89 34 24             	mov    %esi,(%esp)
c0023570:	e8 95 fe ff ff       	call   c002340a <lock_release>
    sema_down(&waiter.semaphore);
c0023575:	89 2c 24             	mov    %ebp,(%esp)
c0023578:	e8 63 f9 ff ff       	call   c0022ee0 <sema_down>
    lock_acquire(lock);
c002357d:	89 34 24             	mov    %esi,(%esp)
c0023580:	e8 84 fc ff ff       	call   c0023209 <lock_acquire>
}
c0023585:	83 c4 3c             	add    $0x3c,%esp
c0023588:	5b                   	pop    %ebx
c0023589:	5e                   	pop    %esi
c002358a:	5f                   	pop    %edi
c002358b:	5d                   	pop    %ebp
c002358c:	c3                   	ret    
    ASSERT (cond != NULL);
c002358d:	83 ec 0c             	sub    $0xc,%esp
c0023590:	8d 87 48 5b ff ff    	lea    -0xa4b8(%edi),%eax
c0023596:	50                   	push   %eax
c0023597:	8d 87 94 4f ff ff    	lea    -0xb06c(%edi),%eax
c002359d:	50                   	push   %eax
c002359e:	8d 87 f8 3f ff ff    	lea    -0xc008(%edi),%eax
c00235a4:	50                   	push   %eax
c00235a5:	68 3a 01 00 00       	push   $0x13a
c00235aa:	8d 87 ff 5a ff ff    	lea    -0xa501(%edi),%eax
c00235b0:	50                   	push   %eax
c00235b1:	89 fb                	mov    %edi,%ebx
c00235b3:	e8 22 5b 00 00       	call   c00290da <debug_panic>
    ASSERT (lock != NULL);
c00235b8:	83 ec 0c             	sub    $0xc,%esp
c00235bb:	8d 87 3b 5b ff ff    	lea    -0xa4c5(%edi),%eax
c00235c1:	50                   	push   %eax
c00235c2:	8d 87 94 4f ff ff    	lea    -0xb06c(%edi),%eax
c00235c8:	50                   	push   %eax
c00235c9:	8d 87 f8 3f ff ff    	lea    -0xc008(%edi),%eax
c00235cf:	50                   	push   %eax
c00235d0:	68 3b 01 00 00       	push   $0x13b
c00235d5:	8d 87 ff 5a ff ff    	lea    -0xa501(%edi),%eax
c00235db:	50                   	push   %eax
c00235dc:	89 fb                	mov    %edi,%ebx
c00235de:	e8 f7 5a 00 00       	call   c00290da <debug_panic>
    ASSERT (!intr_context());
c00235e3:	83 ec 0c             	sub    $0xc,%esp
c00235e6:	8d 87 25 57 ff ff    	lea    -0xa8db(%edi),%eax
c00235ec:	50                   	push   %eax
c00235ed:	8d 87 94 4f ff ff    	lea    -0xb06c(%edi),%eax
c00235f3:	50                   	push   %eax
c00235f4:	8d 87 f8 3f ff ff    	lea    -0xc008(%edi),%eax
c00235fa:	50                   	push   %eax
c00235fb:	68 3c 01 00 00       	push   $0x13c
c0023600:	8d 87 ff 5a ff ff    	lea    -0xa501(%edi),%eax
c0023606:	50                   	push   %eax
c0023607:	e8 ce 5a 00 00       	call   c00290da <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c002360c:	83 ec 0c             	sub    $0xc,%esp
c002360f:	8d 87 7c 5b ff ff    	lea    -0xa484(%edi),%eax
c0023615:	50                   	push   %eax
c0023616:	8d 87 94 4f ff ff    	lea    -0xb06c(%edi),%eax
c002361c:	50                   	push   %eax
c002361d:	8d 87 f8 3f ff ff    	lea    -0xc008(%edi),%eax
c0023623:	50                   	push   %eax
c0023624:	68 3d 01 00 00       	push   $0x13d
c0023629:	8d 87 ff 5a ff ff    	lea    -0xa501(%edi),%eax
c002362f:	50                   	push   %eax
c0023630:	e8 a5 5a 00 00       	call   c00290da <debug_panic>

c0023635 <cond_signal>:

   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal(struct condition *cond, struct lock *lock UNUSED) {
c0023635:	57                   	push   %edi
c0023636:	56                   	push   %esi
c0023637:	53                   	push   %ebx
c0023638:	e8 bb b8 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002363d:	81 c3 eb 7a 01 00    	add    $0x17aeb,%ebx
c0023643:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023647:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (cond != NULL);
c002364b:	85 f6                	test   %esi,%esi
c002364d:	74 4e                	je     c002369d <cond_signal+0x68>
    ASSERT (lock != NULL);
c002364f:	85 ff                	test   %edi,%edi
c0023651:	74 73                	je     c00236c6 <cond_signal+0x91>
    ASSERT (!intr_context());
c0023653:	e8 5d e9 ff ff       	call   c0021fb5 <intr_context>
c0023658:	84 c0                	test   %al,%al
c002365a:	0f 85 8f 00 00 00    	jne    c00236ef <cond_signal+0xba>
    ASSERT (lock_held_by_current_thread(lock));
c0023660:	83 ec 0c             	sub    $0xc,%esp
c0023663:	57                   	push   %edi
c0023664:	e8 4d fb ff ff       	call   c00231b6 <lock_held_by_current_thread>
c0023669:	83 c4 10             	add    $0x10,%esp
c002366c:	84 c0                	test   %al,%al
c002366e:	0f 84 a4 00 00 00    	je     c0023718 <cond_signal+0xe3>
    list_sort(&cond->waiters, sema_cmp_priority, NULL);
c0023674:	83 ec 04             	sub    $0x4,%esp
c0023677:	6a 00                	push   $0x0
c0023679:	8d 83 23 7d fe ff    	lea    -0x182dd(%ebx),%eax
c002367f:	50                   	push   %eax
c0023680:	56                   	push   %esi
c0023681:	e8 2b 63 00 00       	call   c00299b1 <list_sort>
    // put the one with least sema value at front
    if (!list_empty(&cond->waiters))
c0023686:	89 34 24             	mov    %esi,(%esp)
c0023689:	e8 bd 61 00 00       	call   c002984b <list_empty>
c002368e:	83 c4 10             	add    $0x10,%esp
c0023691:	84 c0                	test   %al,%al
c0023693:	0f 84 a8 00 00 00    	je     c0023741 <cond_signal+0x10c>
        sema_up(&list_entry (list_pop_front(&cond->waiters),
                             struct semaphore_elem, elem)->semaphore);
}
c0023699:	5b                   	pop    %ebx
c002369a:	5e                   	pop    %esi
c002369b:	5f                   	pop    %edi
c002369c:	c3                   	ret    
    ASSERT (cond != NULL);
c002369d:	83 ec 0c             	sub    $0xc,%esp
c00236a0:	8d 83 48 5b ff ff    	lea    -0xa4b8(%ebx),%eax
c00236a6:	50                   	push   %eax
c00236a7:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00236ad:	50                   	push   %eax
c00236ae:	8d 83 ec 3f ff ff    	lea    -0xc014(%ebx),%eax
c00236b4:	50                   	push   %eax
c00236b5:	68 59 01 00 00       	push   $0x159
c00236ba:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00236c0:	50                   	push   %eax
c00236c1:	e8 14 5a 00 00       	call   c00290da <debug_panic>
    ASSERT (lock != NULL);
c00236c6:	83 ec 0c             	sub    $0xc,%esp
c00236c9:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c00236cf:	50                   	push   %eax
c00236d0:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00236d6:	50                   	push   %eax
c00236d7:	8d 83 ec 3f ff ff    	lea    -0xc014(%ebx),%eax
c00236dd:	50                   	push   %eax
c00236de:	68 5a 01 00 00       	push   $0x15a
c00236e3:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00236e9:	50                   	push   %eax
c00236ea:	e8 eb 59 00 00       	call   c00290da <debug_panic>
    ASSERT (!intr_context());
c00236ef:	83 ec 0c             	sub    $0xc,%esp
c00236f2:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c00236f8:	50                   	push   %eax
c00236f9:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00236ff:	50                   	push   %eax
c0023700:	8d 83 ec 3f ff ff    	lea    -0xc014(%ebx),%eax
c0023706:	50                   	push   %eax
c0023707:	68 5b 01 00 00       	push   $0x15b
c002370c:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c0023712:	50                   	push   %eax
c0023713:	e8 c2 59 00 00       	call   c00290da <debug_panic>
    ASSERT (lock_held_by_current_thread(lock));
c0023718:	83 ec 0c             	sub    $0xc,%esp
c002371b:	8d 83 7c 5b ff ff    	lea    -0xa484(%ebx),%eax
c0023721:	50                   	push   %eax
c0023722:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023728:	50                   	push   %eax
c0023729:	8d 83 ec 3f ff ff    	lea    -0xc014(%ebx),%eax
c002372f:	50                   	push   %eax
c0023730:	68 5c 01 00 00       	push   $0x15c
c0023735:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c002373b:	50                   	push   %eax
c002373c:	e8 99 59 00 00       	call   c00290da <debug_panic>
        sema_up(&list_entry (list_pop_front(&cond->waiters),
c0023741:	83 ec 0c             	sub    $0xc,%esp
c0023744:	56                   	push   %esi
c0023745:	e8 78 61 00 00       	call   c00298c2 <list_pop_front>
c002374a:	83 c0 08             	add    $0x8,%eax
c002374d:	89 04 24             	mov    %eax,(%esp)
c0023750:	e8 b6 f8 ff ff       	call   c002300b <sema_up>
c0023755:	83 c4 10             	add    $0x10,%esp
}
c0023758:	e9 3c ff ff ff       	jmp    c0023699 <cond_signal+0x64>

c002375d <cond_broadcast>:

   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast(struct condition *cond, struct lock *lock) {
c002375d:	57                   	push   %edi
c002375e:	56                   	push   %esi
c002375f:	53                   	push   %ebx
c0023760:	e8 93 b7 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023765:	81 c3 c3 79 01 00    	add    $0x179c3,%ebx
c002376b:	8b 74 24 10          	mov    0x10(%esp),%esi
c002376f:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (cond != NULL);
c0023773:	85 f6                	test   %esi,%esi
c0023775:	74 23                	je     c002379a <cond_broadcast+0x3d>
    ASSERT (lock != NULL);
c0023777:	85 ff                	test   %edi,%edi
c0023779:	74 48                	je     c00237c3 <cond_broadcast+0x66>

    while (!list_empty(&cond->waiters))
c002377b:	83 ec 0c             	sub    $0xc,%esp
c002377e:	56                   	push   %esi
c002377f:	e8 c7 60 00 00       	call   c002984b <list_empty>
c0023784:	83 c4 10             	add    $0x10,%esp
c0023787:	84 c0                	test   %al,%al
c0023789:	75 61                	jne    c00237ec <cond_broadcast+0x8f>
        cond_signal(cond, lock);
c002378b:	83 ec 08             	sub    $0x8,%esp
c002378e:	57                   	push   %edi
c002378f:	56                   	push   %esi
c0023790:	e8 a0 fe ff ff       	call   c0023635 <cond_signal>
c0023795:	83 c4 10             	add    $0x10,%esp
c0023798:	eb e1                	jmp    c002377b <cond_broadcast+0x1e>
    ASSERT (cond != NULL);
c002379a:	83 ec 0c             	sub    $0xc,%esp
c002379d:	8d 83 48 5b ff ff    	lea    -0xa4b8(%ebx),%eax
c00237a3:	50                   	push   %eax
c00237a4:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00237aa:	50                   	push   %eax
c00237ab:	8d 83 dc 3f ff ff    	lea    -0xc024(%ebx),%eax
c00237b1:	50                   	push   %eax
c00237b2:	68 6c 01 00 00       	push   $0x16c
c00237b7:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00237bd:	50                   	push   %eax
c00237be:	e8 17 59 00 00       	call   c00290da <debug_panic>
    ASSERT (lock != NULL);
c00237c3:	83 ec 0c             	sub    $0xc,%esp
c00237c6:	8d 83 3b 5b ff ff    	lea    -0xa4c5(%ebx),%eax
c00237cc:	50                   	push   %eax
c00237cd:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00237d3:	50                   	push   %eax
c00237d4:	8d 83 dc 3f ff ff    	lea    -0xc024(%ebx),%eax
c00237da:	50                   	push   %eax
c00237db:	68 6d 01 00 00       	push   $0x16d
c00237e0:	8d 83 ff 5a ff ff    	lea    -0xa501(%ebx),%eax
c00237e6:	50                   	push   %eax
c00237e7:	e8 ee 58 00 00       	call   c00290da <debug_panic>
}
c00237ec:	5b                   	pop    %ebx
c00237ed:	5e                   	pop    %esi
c00237ee:	5f                   	pop    %edi
c00237ef:	c3                   	ret    

c00237f0 <init_pool>:
}

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool(struct pool *p, void *base, size_t page_cnt, const char *name) {
c00237f0:	55                   	push   %ebp
c00237f1:	57                   	push   %edi
c00237f2:	56                   	push   %esi
c00237f3:	53                   	push   %ebx
c00237f4:	83 ec 28             	sub    $0x28,%esp
c00237f7:	e8 fc b6 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00237fc:	81 c3 2c 79 01 00    	add    $0x1792c,%ebx
c0023802:	89 c5                	mov    %eax,%ebp
c0023804:	89 54 24 18          	mov    %edx,0x18(%esp)
c0023808:	89 cf                	mov    %ecx,%edi
    /* We'll put the pool's used_map at its base.
       Calculate the space needed for the bitmap
       and subtract it from the pool's size. */
    size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size(page_cnt), PGSIZE); // page_id = size / pgsize
c002380a:	51                   	push   %ecx
c002380b:	e8 72 67 00 00       	call   c0029f82 <bitmap_buf_size>
c0023810:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
c0023816:	89 f0                	mov    %esi,%eax
c0023818:	c1 e8 0c             	shr    $0xc,%eax
    if (bm_pages > page_cnt)
c002381b:	83 c4 10             	add    $0x10,%esp
c002381e:	39 c7                	cmp    %eax,%edi
c0023820:	72 44                	jb     c0023866 <init_pool+0x76>
        PANIC ("Not enough memory in %s for bitmap.", name);
    page_cnt -= bm_pages;
c0023822:	29 c7                	sub    %eax,%edi

    printf("%zu pages available in %s.\n", page_cnt, name);
c0023824:	83 ec 04             	sub    $0x4,%esp
c0023827:	ff 74 24 34          	pushl  0x34(%esp)
c002382b:	57                   	push   %edi
c002382c:	8d 83 0a 5c ff ff    	lea    -0xa3f6(%ebx),%eax
c0023832:	50                   	push   %eax
c0023833:	e8 46 3c 00 00       	call   c002747e <printf>

    /* Initialize the pool. */
    lock_init(&p->lock);
c0023838:	89 2c 24             	mov    %ebp,(%esp)
c002383b:	e8 1d f9 ff ff       	call   c002315d <lock_init>
    p->used_map = bitmap_create_in_buf(page_cnt, base, bm_pages * PGSIZE);
c0023840:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c0023846:	83 c4 0c             	add    $0xc,%esp
c0023849:	56                   	push   %esi
c002384a:	ff 74 24 14          	pushl  0x14(%esp)
c002384e:	57                   	push   %edi
c002384f:	e8 97 6a 00 00       	call   c002a2eb <bitmap_create_in_buf>
c0023854:	89 45 24             	mov    %eax,0x24(%ebp)
    p->base = base + bm_pages * PGSIZE;
c0023857:	03 74 24 1c          	add    0x1c(%esp),%esi
c002385b:	89 75 28             	mov    %esi,0x28(%ebp)
}
c002385e:	83 c4 2c             	add    $0x2c,%esp
c0023861:	5b                   	pop    %ebx
c0023862:	5e                   	pop    %esi
c0023863:	5f                   	pop    %edi
c0023864:	5d                   	pop    %ebp
c0023865:	c3                   	ret    
        PANIC ("Not enough memory in %s for bitmap.", name);
c0023866:	83 ec 0c             	sub    $0xc,%esp
c0023869:	ff 74 24 3c          	pushl  0x3c(%esp)
c002386d:	8d 83 a0 5b ff ff    	lea    -0xa460(%ebx),%eax
c0023873:	50                   	push   %eax
c0023874:	8d 83 c8 40 ff ff    	lea    -0xbf38(%ebx),%eax
c002387a:	50                   	push   %eax
c002387b:	68 98 00 00 00       	push   $0x98
c0023880:	8d 83 f3 5b ff ff    	lea    -0xa40d(%ebx),%eax
c0023886:	50                   	push   %eax
c0023887:	e8 4e 58 00 00       	call   c00290da <debug_panic>

c002388c <palloc_init>:
palloc_init(size_t user_page_limit) {
c002388c:	57                   	push   %edi
c002388d:	56                   	push   %esi
c002388e:	53                   	push   %ebx
c002388f:	e8 64 b6 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023894:	81 c3 94 78 01 00    	add    $0x17894,%ebx
c002389a:	8b 54 24 10          	mov    0x10(%esp),%edx
    uint8_t *free_end = ptov(init_ram_pages * PGSIZE); // num * 4KB
c002389e:	c7 c0 be 01 02 c0    	mov    $0xc00201be,%eax
c00238a4:	8b 00                	mov    (%eax),%eax
c00238a6:	c1 e0 0c             	shl    $0xc,%eax
    ASSERT ((void *) paddr < PHYS_BASE);
c00238a9:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00238ae:	77 5e                	ja     c002390e <palloc_init+0x82>
    size_t free_pages = (free_end - free_start) / PGSIZE;
c00238b0:	8d b0 ff 0f f0 ff    	lea    -0xff001(%eax),%esi
c00238b6:	2d 00 00 10 00       	sub    $0x100000,%eax
c00238bb:	0f 49 f0             	cmovns %eax,%esi
c00238be:	c1 fe 0c             	sar    $0xc,%esi
    size_t user_pages = free_pages / 2;
c00238c1:	89 f7                	mov    %esi,%edi
c00238c3:	d1 ef                	shr    %edi
    if (user_pages > user_page_limit)
c00238c5:	39 d7                	cmp    %edx,%edi
c00238c7:	0f 47 fa             	cmova  %edx,%edi
    kernel_pages = free_pages - user_pages;
c00238ca:	29 fe                	sub    %edi,%esi
    init_pool(&kernel_pool, free_start, kernel_pages, "kernel pool");
c00238cc:	83 ec 0c             	sub    $0xc,%esp
c00238cf:	8d 83 41 5c ff ff    	lea    -0xa3bf(%ebx),%eax
c00238d5:	50                   	push   %eax
c00238d6:	89 f1                	mov    %esi,%ecx
c00238d8:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c00238dd:	8d 83 18 16 00 00    	lea    0x1618(%ebx),%eax
c00238e3:	e8 08 ff ff ff       	call   c00237f0 <init_pool>
    init_pool(&user_pool, free_start + kernel_pages * PGSIZE,
c00238e8:	c1 e6 0c             	shl    $0xc,%esi
c00238eb:	8d 96 00 00 10 c0    	lea    -0x3ff00000(%esi),%edx
c00238f1:	8d 83 4d 5c ff ff    	lea    -0xa3b3(%ebx),%eax
c00238f7:	89 04 24             	mov    %eax,(%esp)
c00238fa:	89 f9                	mov    %edi,%ecx
c00238fc:	8d 83 d8 15 00 00    	lea    0x15d8(%ebx),%eax
c0023902:	e8 e9 fe ff ff       	call   c00237f0 <init_pool>
}
c0023907:	83 c4 10             	add    $0x10,%esp
c002390a:	5b                   	pop    %ebx
c002390b:	5e                   	pop    %esi
c002390c:	5f                   	pop    %edi
c002390d:	c3                   	ret    
c002390e:	83 ec 0c             	sub    $0xc,%esp
c0023911:	8d 83 26 5c ff ff    	lea    -0xa3da(%ebx),%eax
c0023917:	50                   	push   %eax
c0023918:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002391e:	50                   	push   %eax
c002391f:	8d 83 d4 40 ff ff    	lea    -0xbf2c(%ebx),%eax
c0023925:	50                   	push   %eax
c0023926:	6a 4c                	push   $0x4c
c0023928:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002392e:	50                   	push   %eax
c002392f:	e8 a6 57 00 00       	call   c00290da <debug_panic>

c0023934 <palloc_get_multiple>:
palloc_get_multiple(enum palloc_flags flags, size_t page_cnt) {
c0023934:	55                   	push   %ebp
c0023935:	57                   	push   %edi
c0023936:	56                   	push   %esi
c0023937:	53                   	push   %ebx
c0023938:	83 ec 0c             	sub    $0xc,%esp
c002393b:	e8 b8 b5 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023940:	81 c3 e8 77 01 00    	add    $0x177e8,%ebx
c0023946:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002394a:	8b 44 24 20          	mov    0x20(%esp),%eax
c002394e:	83 e0 04             	and    $0x4,%eax
c0023951:	8d b3 d8 15 00 00    	lea    0x15d8(%ebx),%esi
c0023957:	8d 83 18 16 00 00    	lea    0x1618(%ebx),%eax
c002395d:	0f 44 f0             	cmove  %eax,%esi
    if (page_cnt == 0)
c0023960:	85 ed                	test   %ebp,%ebp
c0023962:	74 7e                	je     c00239e2 <palloc_get_multiple+0xae>
    lock_acquire(&pool->lock);
c0023964:	83 ec 0c             	sub    $0xc,%esp
c0023967:	56                   	push   %esi
c0023968:	e8 9c f8 ff ff       	call   c0023209 <lock_acquire>
    page_idx = bitmap_scan_and_flip(pool->used_map, 0, page_cnt, false);
c002396d:	6a 00                	push   $0x0
c002396f:	55                   	push   %ebp
c0023970:	6a 00                	push   $0x0
c0023972:	ff 76 24             	pushl  0x24(%esi)
c0023975:	e8 de 6c 00 00       	call   c002a658 <bitmap_scan_and_flip>
c002397a:	89 c7                	mov    %eax,%edi
    lock_release(&pool->lock);
c002397c:	83 c4 14             	add    $0x14,%esp
c002397f:	56                   	push   %esi
c0023980:	e8 85 fa ff ff       	call   c002340a <lock_release>
    if (page_idx != BITMAP_ERROR)
c0023985:	83 c4 10             	add    $0x10,%esp
c0023988:	83 ff ff             	cmp    $0xffffffff,%edi
c002398b:	74 23                	je     c00239b0 <palloc_get_multiple+0x7c>
        pages = pool->base + PGSIZE * page_idx;
c002398d:	c1 e7 0c             	shl    $0xc,%edi
    if (pages != NULL) {
c0023990:	03 7e 28             	add    0x28(%esi),%edi
c0023993:	74 1b                	je     c00239b0 <palloc_get_multiple+0x7c>
        if (flags & PAL_ZERO)
c0023995:	f6 44 24 20 02       	testb  $0x2,0x20(%esp)
c002399a:	74 20                	je     c00239bc <palloc_get_multiple+0x88>
            memset(pages, 0, PGSIZE * page_cnt);
c002399c:	c1 e5 0c             	shl    $0xc,%ebp
c002399f:	83 ec 04             	sub    $0x4,%esp
c00239a2:	55                   	push   %ebp
c00239a3:	6a 00                	push   $0x0
c00239a5:	57                   	push   %edi
c00239a6:	e8 9e 4c 00 00       	call   c0028649 <memset>
c00239ab:	83 c4 10             	add    $0x10,%esp
c00239ae:	eb 0c                	jmp    c00239bc <palloc_get_multiple+0x88>
        if (flags & PAL_ASSERT)
c00239b0:	f6 44 24 20 01       	testb  $0x1,0x20(%esp)
c00239b5:	75 0f                	jne    c00239c6 <palloc_get_multiple+0x92>
c00239b7:	bf 00 00 00 00       	mov    $0x0,%edi
}
c00239bc:	89 f8                	mov    %edi,%eax
c00239be:	83 c4 0c             	add    $0xc,%esp
c00239c1:	5b                   	pop    %ebx
c00239c2:	5e                   	pop    %esi
c00239c3:	5f                   	pop    %edi
c00239c4:	5d                   	pop    %ebp
c00239c5:	c3                   	ret    
            PANIC ("palloc_get: out of pages");
c00239c6:	8d 83 57 5c ff ff    	lea    -0xa3a9(%ebx),%eax
c00239cc:	50                   	push   %eax
c00239cd:	8d 83 b4 40 ff ff    	lea    -0xbf4c(%ebx),%eax
c00239d3:	50                   	push   %eax
c00239d4:	6a 5c                	push   $0x5c
c00239d6:	8d 83 f3 5b ff ff    	lea    -0xa40d(%ebx),%eax
c00239dc:	50                   	push   %eax
c00239dd:	e8 f8 56 00 00       	call   c00290da <debug_panic>
        return NULL;
c00239e2:	bf 00 00 00 00       	mov    $0x0,%edi
c00239e7:	eb d3                	jmp    c00239bc <palloc_get_multiple+0x88>

c00239e9 <palloc_get_page>:
palloc_get_page(enum palloc_flags flags) {
c00239e9:	83 ec 14             	sub    $0x14,%esp
    return palloc_get_multiple(flags, 1);
c00239ec:	6a 01                	push   $0x1
c00239ee:	ff 74 24 1c          	pushl  0x1c(%esp)
c00239f2:	e8 3d ff ff ff       	call   c0023934 <palloc_get_multiple>
}
c00239f7:	83 c4 1c             	add    $0x1c,%esp
c00239fa:	c3                   	ret    

c00239fb <palloc_free_multiple>:
palloc_free_multiple(void *pages, size_t page_cnt) {
c00239fb:	55                   	push   %ebp
c00239fc:	57                   	push   %edi
c00239fd:	56                   	push   %esi
c00239fe:	53                   	push   %ebx
c00239ff:	83 ec 0c             	sub    $0xc,%esp
c0023a02:	e8 f1 b4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023a07:	81 c3 21 77 01 00    	add    $0x17721,%ebx
c0023a0d:	8b 74 24 20          	mov    0x20(%esp),%esi
    ASSERT (pg_ofs(pages) == 0);
c0023a11:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c0023a17:	0f 85 9d 00 00 00    	jne    c0023aba <palloc_free_multiple+0xbf>
    if (pages == NULL || page_cnt == 0)
c0023a1d:	85 f6                	test   %esi,%esi
c0023a1f:	0f 84 8d 00 00 00    	je     c0023ab2 <palloc_free_multiple+0xb7>
c0023a25:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0023a2a:	0f 84 82 00 00 00    	je     c0023ab2 <palloc_free_multiple+0xb7>
    return (uintptr_t) va >> PGBITS;
c0023a30:	89 f7                	mov    %esi,%edi
c0023a32:	c1 ef 0c             	shr    $0xc,%edi
c0023a35:	8b 83 40 16 00 00    	mov    0x1640(%ebx),%eax
c0023a3b:	c1 e8 0c             	shr    $0xc,%eax
c0023a3e:	89 c5                	mov    %eax,%ebp
   false otherwise. */
static bool
page_from_pool(const struct pool *pool, void *page) {
    size_t page_no = pg_no(page);
    size_t start_page = pg_no(pool->base);
    size_t end_page = start_page + bitmap_size(pool->used_map);
c0023a40:	83 ec 0c             	sub    $0xc,%esp
c0023a43:	ff b3 3c 16 00 00    	pushl  0x163c(%ebx)
c0023a49:	e8 7a 65 00 00       	call   c0029fc8 <bitmap_size>
c0023a4e:	89 ea                	mov    %ebp,%edx
c0023a50:	01 e8                	add    %ebp,%eax

    return page_no >= start_page && page_no < end_page;
c0023a52:	83 c4 10             	add    $0x10,%esp
    if (page_from_pool(&kernel_pool, pages))
c0023a55:	39 c7                	cmp    %eax,%edi
c0023a57:	0f 83 83 00 00 00    	jae    c0023ae0 <palloc_free_multiple+0xe5>
        pool = &kernel_pool;
c0023a5d:	8d ab 18 16 00 00    	lea    0x1618(%ebx),%ebp
    if (page_from_pool(&kernel_pool, pages))
c0023a63:	39 d7                	cmp    %edx,%edi
c0023a65:	72 79                	jb     c0023ae0 <palloc_free_multiple+0xe5>
c0023a67:	8b 45 28             	mov    0x28(%ebp),%eax
c0023a6a:	c1 e8 0c             	shr    $0xc,%eax
    page_idx = pg_no(pages) - pg_no(pool->base);
c0023a6d:	29 c7                	sub    %eax,%edi
    memset(pages, 0xcc, PGSIZE * page_cnt);
c0023a6f:	83 ec 04             	sub    $0x4,%esp
c0023a72:	8b 44 24 28          	mov    0x28(%esp),%eax
c0023a76:	c1 e0 0c             	shl    $0xc,%eax
c0023a79:	50                   	push   %eax
c0023a7a:	68 cc 00 00 00       	push   $0xcc
c0023a7f:	56                   	push   %esi
c0023a80:	e8 c4 4b 00 00       	call   c0028649 <memset>
    ASSERT (bitmap_all(pool->used_map, page_idx, page_cnt));
c0023a85:	83 c4 0c             	add    $0xc,%esp
c0023a88:	ff 74 24 28          	pushl  0x28(%esp)
c0023a8c:	57                   	push   %edi
c0023a8d:	ff 75 24             	pushl  0x24(%ebp)
c0023a90:	e8 d6 6a 00 00       	call   c002a56b <bitmap_all>
c0023a95:	83 c4 10             	add    $0x10,%esp
c0023a98:	84 c0                	test   %al,%al
c0023a9a:	0f 84 8b 00 00 00    	je     c0023b2b <palloc_free_multiple+0x130>
    bitmap_set_multiple(pool->used_map, page_idx, page_cnt, false);
c0023aa0:	6a 00                	push   $0x0
c0023aa2:	ff 74 24 28          	pushl  0x28(%esp)
c0023aa6:	57                   	push   %edi
c0023aa7:	ff 75 24             	pushl  0x24(%ebp)
c0023aaa:	e8 9e 66 00 00       	call   c002a14d <bitmap_set_multiple>
c0023aaf:	83 c4 10             	add    $0x10,%esp
}
c0023ab2:	83 c4 0c             	add    $0xc,%esp
c0023ab5:	5b                   	pop    %ebx
c0023ab6:	5e                   	pop    %esi
c0023ab7:	5f                   	pop    %edi
c0023ab8:	5d                   	pop    %ebp
c0023ab9:	c3                   	ret    
    ASSERT (pg_ofs(pages) == 0);
c0023aba:	83 ec 0c             	sub    $0xc,%esp
c0023abd:	8d 83 70 5c ff ff    	lea    -0xa390(%ebx),%eax
c0023ac3:	50                   	push   %eax
c0023ac4:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023aca:	50                   	push   %eax
c0023acb:	8d 83 9c 40 ff ff    	lea    -0xbf64(%ebx),%eax
c0023ad1:	50                   	push   %eax
c0023ad2:	6a 74                	push   $0x74
c0023ad4:	8d 83 f3 5b ff ff    	lea    -0xa40d(%ebx),%eax
c0023ada:	50                   	push   %eax
c0023adb:	e8 fa 55 00 00       	call   c00290da <debug_panic>
c0023ae0:	8b ab 00 16 00 00    	mov    0x1600(%ebx),%ebp
c0023ae6:	c1 ed 0c             	shr    $0xc,%ebp
    size_t end_page = start_page + bitmap_size(pool->used_map);
c0023ae9:	83 ec 0c             	sub    $0xc,%esp
c0023aec:	ff b3 fc 15 00 00    	pushl  0x15fc(%ebx)
c0023af2:	e8 d1 64 00 00       	call   c0029fc8 <bitmap_size>
c0023af7:	01 e8                	add    %ebp,%eax
    return page_no >= start_page && page_no < end_page;
c0023af9:	83 c4 10             	add    $0x10,%esp
    else if (page_from_pool(&user_pool, pages))
c0023afc:	39 c7                	cmp    %eax,%edi
c0023afe:	73 0f                	jae    c0023b0f <palloc_free_multiple+0x114>
c0023b00:	39 ef                	cmp    %ebp,%edi
c0023b02:	72 0b                	jb     c0023b0f <palloc_free_multiple+0x114>
        pool = &user_pool;
c0023b04:	8d ab d8 15 00 00    	lea    0x15d8(%ebx),%ebp
c0023b0a:	e9 58 ff ff ff       	jmp    c0023a67 <palloc_free_multiple+0x6c>
        NOT_REACHED ();
c0023b0f:	8d 83 d0 55 ff ff    	lea    -0xaa30(%ebx),%eax
c0023b15:	50                   	push   %eax
c0023b16:	8d 83 9c 40 ff ff    	lea    -0xbf64(%ebx),%eax
c0023b1c:	50                   	push   %eax
c0023b1d:	6a 7d                	push   $0x7d
c0023b1f:	8d 83 f3 5b ff ff    	lea    -0xa40d(%ebx),%eax
c0023b25:	50                   	push   %eax
c0023b26:	e8 af 55 00 00       	call   c00290da <debug_panic>
    ASSERT (bitmap_all(pool->used_map, page_idx, page_cnt));
c0023b2b:	83 ec 0c             	sub    $0xc,%esp
c0023b2e:	8d 83 c4 5b ff ff    	lea    -0xa43c(%ebx),%eax
c0023b34:	50                   	push   %eax
c0023b35:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023b3b:	50                   	push   %eax
c0023b3c:	8d 83 9c 40 ff ff    	lea    -0xbf64(%ebx),%eax
c0023b42:	50                   	push   %eax
c0023b43:	68 85 00 00 00       	push   $0x85
c0023b48:	8d 83 f3 5b ff ff    	lea    -0xa40d(%ebx),%eax
c0023b4e:	50                   	push   %eax
c0023b4f:	e8 86 55 00 00       	call   c00290da <debug_panic>

c0023b54 <palloc_free_page>:
palloc_free_page(void *page) {
c0023b54:	83 ec 14             	sub    $0x14,%esp
    palloc_free_multiple(page, 1);
c0023b57:	6a 01                	push   $0x1
c0023b59:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023b5d:	e8 99 fe ff ff       	call   c00239fb <palloc_free_multiple>
}
c0023b62:	83 c4 1c             	add    $0x1c,%esp
c0023b65:	c3                   	ret    

c0023b66 <arena_to_block>:
    return a;
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block(struct arena *a, size_t idx) {
c0023b66:	53                   	push   %ebx
c0023b67:	83 ec 08             	sub    $0x8,%esp
c0023b6a:	e8 89 b3 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023b6f:	81 c3 b9 75 01 00    	add    $0x175b9,%ebx
    ASSERT (a != NULL);
c0023b75:	85 c0                	test   %eax,%eax
c0023b77:	74 1c                	je     c0023b95 <arena_to_block+0x2f>
    ASSERT (a->magic == ARENA_MAGIC);
c0023b79:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c0023b7f:	75 3d                	jne    c0023bbe <arena_to_block+0x58>
    ASSERT (idx < a->desc->blocks_per_arena);
c0023b81:	8b 48 04             	mov    0x4(%eax),%ecx
c0023b84:	39 51 04             	cmp    %edx,0x4(%ecx)
c0023b87:	76 5e                	jbe    c0023be7 <arena_to_block+0x81>
    return (struct block *) ((uint8_t *) a
                             + sizeof *a
                             + idx * a->desc->block_size);
c0023b89:	0f af 11             	imul   (%ecx),%edx
    return (struct block *) ((uint8_t *) a
c0023b8c:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c0023b90:	83 c4 08             	add    $0x8,%esp
c0023b93:	5b                   	pop    %ebx
c0023b94:	c3                   	ret    
    ASSERT (a != NULL);
c0023b95:	83 ec 0c             	sub    $0xc,%esp
c0023b98:	8d 83 f5 5a ff ff    	lea    -0xa50b(%ebx),%eax
c0023b9e:	50                   	push   %eax
c0023b9f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023ba5:	50                   	push   %eax
c0023ba6:	8d 83 f4 40 ff ff    	lea    -0xbf0c(%ebx),%eax
c0023bac:	50                   	push   %eax
c0023bad:	68 07 01 00 00       	push   $0x107
c0023bb2:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023bb8:	50                   	push   %eax
c0023bb9:	e8 1c 55 00 00       	call   c00290da <debug_panic>
    ASSERT (a->magic == ARENA_MAGIC);
c0023bbe:	83 ec 0c             	sub    $0xc,%esp
c0023bc1:	8d 83 9a 5c ff ff    	lea    -0xa366(%ebx),%eax
c0023bc7:	50                   	push   %eax
c0023bc8:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023bce:	50                   	push   %eax
c0023bcf:	8d 83 f4 40 ff ff    	lea    -0xbf0c(%ebx),%eax
c0023bd5:	50                   	push   %eax
c0023bd6:	68 08 01 00 00       	push   $0x108
c0023bdb:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023be1:	50                   	push   %eax
c0023be2:	e8 f3 54 00 00       	call   c00290da <debug_panic>
    ASSERT (idx < a->desc->blocks_per_arena);
c0023be7:	83 ec 0c             	sub    $0xc,%esp
c0023bea:	8d 83 b4 5c ff ff    	lea    -0xa34c(%ebx),%eax
c0023bf0:	50                   	push   %eax
c0023bf1:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023bf7:	50                   	push   %eax
c0023bf8:	8d 83 f4 40 ff ff    	lea    -0xbf0c(%ebx),%eax
c0023bfe:	50                   	push   %eax
c0023bff:	68 09 01 00 00       	push   $0x109
c0023c04:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023c0a:	50                   	push   %eax
c0023c0b:	e8 ca 54 00 00       	call   c00290da <debug_panic>

c0023c10 <block_to_arena>:
block_to_arena(struct block *b) {
c0023c10:	56                   	push   %esi
c0023c11:	53                   	push   %ebx
c0023c12:	83 ec 04             	sub    $0x4,%esp
c0023c15:	e8 de b2 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023c1a:	81 c3 0e 75 01 00    	add    $0x1750e,%ebx
    ASSERT (a != NULL);
c0023c20:	89 c1                	mov    %eax,%ecx
c0023c22:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0023c28:	74 2e                	je     c0023c58 <block_to_arena+0x48>
    ASSERT (a->magic == ARENA_MAGIC);
c0023c2a:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023c30:	75 4f                	jne    c0023c81 <block_to_arena+0x71>
    ASSERT (a->desc == NULL
c0023c32:	8b 71 04             	mov    0x4(%ecx),%esi
c0023c35:	85 f6                	test   %esi,%esi
c0023c37:	0f 84 96 00 00 00    	je     c0023cd3 <block_to_arena+0xc3>
    return (uintptr_t) va & PGMASK;
c0023c3d:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023c42:	83 e8 0c             	sub    $0xc,%eax
c0023c45:	ba 00 00 00 00       	mov    $0x0,%edx
c0023c4a:	f7 36                	divl   (%esi)
c0023c4c:	85 d2                	test   %edx,%edx
c0023c4e:	75 5a                	jne    c0023caa <block_to_arena+0x9a>
}
c0023c50:	89 c8                	mov    %ecx,%eax
c0023c52:	83 c4 04             	add    $0x4,%esp
c0023c55:	5b                   	pop    %ebx
c0023c56:	5e                   	pop    %esi
c0023c57:	c3                   	ret    
    ASSERT (a != NULL);
c0023c58:	83 ec 0c             	sub    $0xc,%esp
c0023c5b:	8d 83 f5 5a ff ff    	lea    -0xa50b(%ebx),%eax
c0023c61:	50                   	push   %eax
c0023c62:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023c68:	50                   	push   %eax
c0023c69:	8d 83 e4 40 ff ff    	lea    -0xbf1c(%ebx),%eax
c0023c6f:	50                   	push   %eax
c0023c70:	68 f9 00 00 00       	push   $0xf9
c0023c75:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023c7b:	50                   	push   %eax
c0023c7c:	e8 59 54 00 00       	call   c00290da <debug_panic>
    ASSERT (a->magic == ARENA_MAGIC);
c0023c81:	83 ec 0c             	sub    $0xc,%esp
c0023c84:	8d 83 9a 5c ff ff    	lea    -0xa366(%ebx),%eax
c0023c8a:	50                   	push   %eax
c0023c8b:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023c91:	50                   	push   %eax
c0023c92:	8d 83 e4 40 ff ff    	lea    -0xbf1c(%ebx),%eax
c0023c98:	50                   	push   %eax
c0023c99:	68 fa 00 00 00       	push   $0xfa
c0023c9e:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023ca4:	50                   	push   %eax
c0023ca5:	e8 30 54 00 00       	call   c00290da <debug_panic>
    ASSERT (a->desc == NULL
c0023caa:	83 ec 0c             	sub    $0xc,%esp
c0023cad:	8d 83 d4 5c ff ff    	lea    -0xa32c(%ebx),%eax
c0023cb3:	50                   	push   %eax
c0023cb4:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023cba:	50                   	push   %eax
c0023cbb:	8d 83 e4 40 ff ff    	lea    -0xbf1c(%ebx),%eax
c0023cc1:	50                   	push   %eax
c0023cc2:	68 fe 00 00 00       	push   $0xfe
c0023cc7:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023ccd:	50                   	push   %eax
c0023cce:	e8 07 54 00 00       	call   c00290da <debug_panic>
c0023cd3:	25 ff 0f 00 00       	and    $0xfff,%eax
    ASSERT (a->desc != NULL || pg_ofs(b) == sizeof *a);
c0023cd8:	83 f8 0c             	cmp    $0xc,%eax
c0023cdb:	0f 84 6f ff ff ff    	je     c0023c50 <block_to_arena+0x40>
c0023ce1:	83 ec 0c             	sub    $0xc,%esp
c0023ce4:	8d 83 1c 5d ff ff    	lea    -0xa2e4(%ebx),%eax
c0023cea:	50                   	push   %eax
c0023ceb:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023cf1:	50                   	push   %eax
c0023cf2:	8d 83 e4 40 ff ff    	lea    -0xbf1c(%ebx),%eax
c0023cf8:	50                   	push   %eax
c0023cf9:	68 ff 00 00 00       	push   $0xff
c0023cfe:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023d04:	50                   	push   %eax
c0023d05:	e8 d0 53 00 00       	call   c00290da <debug_panic>

c0023d0a <malloc_init>:
malloc_init(void) {
c0023d0a:	55                   	push   %ebp
c0023d0b:	57                   	push   %edi
c0023d0c:	56                   	push   %esi
c0023d0d:	53                   	push   %ebx
c0023d0e:	83 ec 0c             	sub    $0xc,%esp
c0023d11:	e8 e2 b1 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023d16:	81 c3 12 74 01 00    	add    $0x17412,%ebx
        struct desc *d = &descs[desc_cnt++];
c0023d1c:	8b b3 58 16 00 00    	mov    0x1658(%ebx),%esi
c0023d22:	8d 46 01             	lea    0x1(%esi),%eax
c0023d25:	89 83 58 16 00 00    	mov    %eax,0x1658(%ebx)
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023d2b:	83 f8 0a             	cmp    $0xa,%eax
c0023d2e:	0f 87 a1 00 00 00    	ja     c0023dd5 <malloc_init+0xcb>
        d->block_size = block_size;
c0023d34:	8d bb 78 16 00 00    	lea    0x1678(%ebx),%edi
c0023d3a:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023d3d:	c7 84 33 78 16 00 00 	movl   $0x10,0x1678(%ebx,%esi,1)
c0023d44:	10 00 00 00 
        d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c0023d48:	c7 84 33 7c 16 00 00 	movl   $0xff,0x167c(%ebx,%esi,1)
c0023d4f:	ff 00 00 00 
        list_init(&d->free_list);
c0023d53:	83 ec 0c             	sub    $0xc,%esp
c0023d56:	8d 44 37 08          	lea    0x8(%edi,%esi,1),%eax
c0023d5a:	50                   	push   %eax
c0023d5b:	e8 47 54 00 00       	call   c00291a7 <list_init>
        lock_init(&d->lock);
c0023d60:	8d 44 37 18          	lea    0x18(%edi,%esi,1),%eax
c0023d64:	89 04 24             	mov    %eax,(%esp)
c0023d67:	e8 f1 f3 ff ff       	call   c002315d <lock_init>
c0023d6c:	83 c4 10             	add    $0x10,%esp
    for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2) {
c0023d6f:	bf 20 00 00 00       	mov    $0x20,%edi
        d->block_size = block_size;
c0023d74:	8d ab 78 16 00 00    	lea    0x1678(%ebx),%ebp
        struct desc *d = &descs[desc_cnt++];
c0023d7a:	8b b3 58 16 00 00    	mov    0x1658(%ebx),%esi
c0023d80:	8d 46 01             	lea    0x1(%esi),%eax
c0023d83:	89 83 58 16 00 00    	mov    %eax,0x1658(%ebx)
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023d89:	83 f8 0a             	cmp    $0xa,%eax
c0023d8c:	77 47                	ja     c0023dd5 <malloc_init+0xcb>
        d->block_size = block_size;
c0023d8e:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023d91:	89 3c 2e             	mov    %edi,(%esi,%ebp,1)
        d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c0023d94:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023d99:	ba 00 00 00 00       	mov    $0x0,%edx
c0023d9e:	f7 f7                	div    %edi
c0023da0:	89 84 33 7c 16 00 00 	mov    %eax,0x167c(%ebx,%esi,1)
        list_init(&d->free_list);
c0023da7:	83 ec 0c             	sub    $0xc,%esp
c0023daa:	8d 44 2e 08          	lea    0x8(%esi,%ebp,1),%eax
c0023dae:	50                   	push   %eax
c0023daf:	e8 f3 53 00 00       	call   c00291a7 <list_init>
        lock_init(&d->lock);
c0023db4:	8d 44 2e 18          	lea    0x18(%esi,%ebp,1),%eax
c0023db8:	89 04 24             	mov    %eax,(%esp)
c0023dbb:	e8 9d f3 ff ff       	call   c002315d <lock_init>
    for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2) {
c0023dc0:	01 ff                	add    %edi,%edi
c0023dc2:	83 c4 10             	add    $0x10,%esp
c0023dc5:	81 ff ff 07 00 00    	cmp    $0x7ff,%edi
c0023dcb:	76 ad                	jbe    c0023d7a <malloc_init+0x70>
}
c0023dcd:	83 c4 0c             	add    $0xc,%esp
c0023dd0:	5b                   	pop    %ebx
c0023dd1:	5e                   	pop    %esi
c0023dd2:	5f                   	pop    %edi
c0023dd3:	5d                   	pop    %ebp
c0023dd4:	c3                   	ret    
        ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023dd5:	83 ec 0c             	sub    $0xc,%esp
c0023dd8:	8d 83 48 5d ff ff    	lea    -0xa2b8(%ebx),%eax
c0023dde:	50                   	push   %eax
c0023ddf:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0023de5:	50                   	push   %eax
c0023de6:	8d 83 04 41 ff ff    	lea    -0xbefc(%ebx),%eax
c0023dec:	50                   	push   %eax
c0023ded:	6a 4b                	push   $0x4b
c0023def:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0023df5:	50                   	push   %eax
c0023df6:	e8 df 52 00 00       	call   c00290da <debug_panic>

c0023dfb <malloc>:
malloc(size_t size) {
c0023dfb:	55                   	push   %ebp
c0023dfc:	57                   	push   %edi
c0023dfd:	56                   	push   %esi
c0023dfe:	53                   	push   %ebx
c0023dff:	83 ec 1c             	sub    $0x1c,%esp
c0023e02:	e8 f1 b0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023e07:	81 c3 21 73 01 00    	add    $0x17321,%ebx
c0023e0d:	8b 44 24 30          	mov    0x30(%esp),%eax
    if (size == 0)
c0023e11:	85 c0                	test   %eax,%eax
c0023e13:	0f 84 2d 01 00 00    	je     c0023f46 <malloc+0x14b>
    for (d = descs; d < descs + desc_cnt; d++)
c0023e19:	6b 93 58 16 00 00 3c 	imul   $0x3c,0x1658(%ebx),%edx
c0023e20:	8d 8b 78 16 00 00    	lea    0x1678(%ebx),%ecx
c0023e26:	01 ca                	add    %ecx,%edx
c0023e28:	39 ca                	cmp    %ecx,%edx
c0023e2a:	0f 86 c5 00 00 00    	jbe    c0023ef5 <malloc+0xfa>
        if (d->block_size >= size)
c0023e30:	3b 83 78 16 00 00    	cmp    0x1678(%ebx),%eax
c0023e36:	0f 86 11 01 00 00    	jbe    c0023f4d <malloc+0x152>
    for (d = descs; d < descs + desc_cnt; d++)
c0023e3c:	89 ce                	mov    %ecx,%esi
c0023e3e:	83 c6 3c             	add    $0x3c,%esi
c0023e41:	39 d6                	cmp    %edx,%esi
c0023e43:	0f 83 b2 00 00 00    	jae    c0023efb <malloc+0x100>
        if (d->block_size >= size)
c0023e49:	39 06                	cmp    %eax,(%esi)
c0023e4b:	72 f1                	jb     c0023e3e <malloc+0x43>
    lock_acquire(&d->lock);
c0023e4d:	8d 46 18             	lea    0x18(%esi),%eax
c0023e50:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023e54:	83 ec 0c             	sub    $0xc,%esp
c0023e57:	50                   	push   %eax
c0023e58:	e8 ac f3 ff ff       	call   c0023209 <lock_acquire>
    if (list_empty(&d->free_list)) {
c0023e5d:	8d 46 08             	lea    0x8(%esi),%eax
c0023e60:	89 44 24 18          	mov    %eax,0x18(%esp)
c0023e64:	89 04 24             	mov    %eax,(%esp)
c0023e67:	e8 df 59 00 00       	call   c002984b <list_empty>
c0023e6c:	83 c4 10             	add    $0x10,%esp
c0023e6f:	84 c0                	test   %al,%al
c0023e71:	74 52                	je     c0023ec5 <malloc+0xca>
        a = palloc_get_page(0);
c0023e73:	83 ec 0c             	sub    $0xc,%esp
c0023e76:	6a 00                	push   $0x0
c0023e78:	e8 6c fb ff ff       	call   c00239e9 <palloc_get_page>
c0023e7d:	89 c5                	mov    %eax,%ebp
        if (a == NULL) {
c0023e7f:	83 c4 10             	add    $0x10,%esp
c0023e82:	85 c0                	test   %eax,%eax
c0023e84:	0f 84 ab 00 00 00    	je     c0023f35 <malloc+0x13a>
        a->magic = ARENA_MAGIC;
c0023e8a:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
        a->desc = d;
c0023e90:	89 70 04             	mov    %esi,0x4(%eax)
        a->free_cnt = d->blocks_per_arena;
c0023e93:	8b 46 04             	mov    0x4(%esi),%eax
c0023e96:	89 45 08             	mov    %eax,0x8(%ebp)
        for (i = 0; i < d->blocks_per_arena; i++) {
c0023e99:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0023e9d:	74 26                	je     c0023ec5 <malloc+0xca>
c0023e9f:	bf 00 00 00 00       	mov    $0x0,%edi
            struct block *b = arena_to_block(a, i);
c0023ea4:	89 fa                	mov    %edi,%edx
c0023ea6:	89 e8                	mov    %ebp,%eax
c0023ea8:	e8 b9 fc ff ff       	call   c0023b66 <arena_to_block>
            list_push_back(&d->free_list, &b->free_elem);
c0023ead:	83 ec 08             	sub    $0x8,%esp
c0023eb0:	50                   	push   %eax
c0023eb1:	ff 74 24 14          	pushl  0x14(%esp)
c0023eb5:	e8 d2 58 00 00       	call   c002978c <list_push_back>
        for (i = 0; i < d->blocks_per_arena; i++) {
c0023eba:	83 c7 01             	add    $0x1,%edi
c0023ebd:	83 c4 10             	add    $0x10,%esp
c0023ec0:	39 7e 04             	cmp    %edi,0x4(%esi)
c0023ec3:	77 df                	ja     c0023ea4 <malloc+0xa9>
    b = list_entry (list_pop_front(&d->free_list), struct block, free_elem);
c0023ec5:	83 ec 0c             	sub    $0xc,%esp
c0023ec8:	ff 74 24 14          	pushl  0x14(%esp)
c0023ecc:	e8 f1 59 00 00       	call   c00298c2 <list_pop_front>
c0023ed1:	89 c5                	mov    %eax,%ebp
    a = block_to_arena(b);
c0023ed3:	e8 38 fd ff ff       	call   c0023c10 <block_to_arena>
    a->free_cnt--;
c0023ed8:	83 68 08 01          	subl   $0x1,0x8(%eax)
    lock_release(&d->lock);
c0023edc:	83 c4 04             	add    $0x4,%esp
c0023edf:	ff 74 24 18          	pushl  0x18(%esp)
c0023ee3:	e8 22 f5 ff ff       	call   c002340a <lock_release>
    return b;
c0023ee8:	83 c4 10             	add    $0x10,%esp
}
c0023eeb:	89 e8                	mov    %ebp,%eax
c0023eed:	83 c4 1c             	add    $0x1c,%esp
c0023ef0:	5b                   	pop    %ebx
c0023ef1:	5e                   	pop    %esi
c0023ef2:	5f                   	pop    %edi
c0023ef3:	5d                   	pop    %ebp
c0023ef4:	c3                   	ret    
    for (d = descs; d < descs + desc_cnt; d++)
c0023ef5:	8d b3 78 16 00 00    	lea    0x1678(%ebx),%esi
    if (d == descs + desc_cnt) {
c0023efb:	39 f2                	cmp    %esi,%edx
c0023efd:	0f 85 4a ff ff ff    	jne    c0023e4d <malloc+0x52>
        size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023f03:	8d b0 0b 10 00 00    	lea    0x100b(%eax),%esi
c0023f09:	c1 ee 0c             	shr    $0xc,%esi
        a = palloc_get_multiple(0, page_cnt);
c0023f0c:	83 ec 08             	sub    $0x8,%esp
c0023f0f:	56                   	push   %esi
c0023f10:	6a 00                	push   $0x0
c0023f12:	e8 1d fa ff ff       	call   c0023934 <palloc_get_multiple>
c0023f17:	89 c5                	mov    %eax,%ebp
        if (a == NULL)
c0023f19:	83 c4 10             	add    $0x10,%esp
c0023f1c:	85 c0                	test   %eax,%eax
c0023f1e:	74 cb                	je     c0023eeb <malloc+0xf0>
        a->magic = ARENA_MAGIC;
c0023f20:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
        a->desc = NULL;
c0023f26:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        a->free_cnt = page_cnt;
c0023f2d:	89 70 08             	mov    %esi,0x8(%eax)
        return a + 1;
c0023f30:	83 c5 0c             	add    $0xc,%ebp
c0023f33:	eb b6                	jmp    c0023eeb <malloc+0xf0>
            lock_release(&d->lock);
c0023f35:	83 ec 0c             	sub    $0xc,%esp
c0023f38:	ff 74 24 18          	pushl  0x18(%esp)
c0023f3c:	e8 c9 f4 ff ff       	call   c002340a <lock_release>
            return NULL;
c0023f41:	83 c4 10             	add    $0x10,%esp
c0023f44:	eb a5                	jmp    c0023eeb <malloc+0xf0>
        return NULL;
c0023f46:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023f4b:	eb 9e                	jmp    c0023eeb <malloc+0xf0>
    for (d = descs; d < descs + desc_cnt; d++)
c0023f4d:	8d b3 78 16 00 00    	lea    0x1678(%ebx),%esi
    if (d == descs + desc_cnt) {
c0023f53:	e9 f5 fe ff ff       	jmp    c0023e4d <malloc+0x52>

c0023f58 <calloc>:
calloc(size_t a, size_t b) {
c0023f58:	57                   	push   %edi
c0023f59:	56                   	push   %esi
c0023f5a:	53                   	push   %ebx
c0023f5b:	e8 98 af 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023f60:	81 c3 c8 71 01 00    	add    $0x171c8,%ebx
c0023f66:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023f6a:	8b 54 24 14          	mov    0x14(%esp),%edx
    size = a * b;
c0023f6e:	89 c6                	mov    %eax,%esi
c0023f70:	0f af f2             	imul   %edx,%esi
    if (size < a || size < b)
c0023f73:	39 f0                	cmp    %esi,%eax
c0023f75:	77 2b                	ja     c0023fa2 <calloc+0x4a>
c0023f77:	39 f2                	cmp    %esi,%edx
c0023f79:	77 27                	ja     c0023fa2 <calloc+0x4a>
    p = malloc(size);
c0023f7b:	83 ec 0c             	sub    $0xc,%esp
c0023f7e:	56                   	push   %esi
c0023f7f:	e8 77 fe ff ff       	call   c0023dfb <malloc>
c0023f84:	89 c7                	mov    %eax,%edi
    if (p != NULL)
c0023f86:	83 c4 10             	add    $0x10,%esp
c0023f89:	85 c0                	test   %eax,%eax
c0023f8b:	74 0f                	je     c0023f9c <calloc+0x44>
        memset(p, 0, size);
c0023f8d:	83 ec 04             	sub    $0x4,%esp
c0023f90:	56                   	push   %esi
c0023f91:	6a 00                	push   $0x0
c0023f93:	50                   	push   %eax
c0023f94:	e8 b0 46 00 00       	call   c0028649 <memset>
c0023f99:	83 c4 10             	add    $0x10,%esp
}
c0023f9c:	89 f8                	mov    %edi,%eax
c0023f9e:	5b                   	pop    %ebx
c0023f9f:	5e                   	pop    %esi
c0023fa0:	5f                   	pop    %edi
c0023fa1:	c3                   	ret    
        return NULL;
c0023fa2:	bf 00 00 00 00       	mov    $0x0,%edi
c0023fa7:	eb f3                	jmp    c0023f9c <calloc+0x44>

c0023fa9 <free>:
free(void *p) {
c0023fa9:	55                   	push   %ebp
c0023faa:	57                   	push   %edi
c0023fab:	56                   	push   %esi
c0023fac:	53                   	push   %ebx
c0023fad:	83 ec 1c             	sub    $0x1c,%esp
c0023fb0:	e8 43 af 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0023fb5:	81 c3 73 71 01 00    	add    $0x17173,%ebx
c0023fbb:	8b 74 24 30          	mov    0x30(%esp),%esi
    if (p != NULL) {
c0023fbf:	85 f6                	test   %esi,%esi
c0023fc1:	0f 84 96 00 00 00    	je     c002405d <free+0xb4>
        struct arena *a = block_to_arena(b);
c0023fc7:	89 f0                	mov    %esi,%eax
c0023fc9:	e8 42 fc ff ff       	call   c0023c10 <block_to_arena>
c0023fce:	89 c5                	mov    %eax,%ebp
        struct desc *d = a->desc;
c0023fd0:	8b 78 04             	mov    0x4(%eax),%edi
        if (d != NULL) {
c0023fd3:	85 ff                	test   %edi,%edi
c0023fd5:	0f 84 b3 00 00 00    	je     c002408e <free+0xe5>
            memset(b, 0xcc, d->block_size);
c0023fdb:	83 ec 04             	sub    $0x4,%esp
c0023fde:	ff 37                	pushl  (%edi)
c0023fe0:	68 cc 00 00 00       	push   $0xcc
c0023fe5:	56                   	push   %esi
c0023fe6:	e8 5e 46 00 00       	call   c0028649 <memset>
            lock_acquire(&d->lock);
c0023feb:	8d 47 18             	lea    0x18(%edi),%eax
c0023fee:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0023ff2:	89 04 24             	mov    %eax,(%esp)
c0023ff5:	e8 0f f2 ff ff       	call   c0023209 <lock_acquire>
            list_push_front(&d->free_list, &b->free_elem);
c0023ffa:	83 c4 08             	add    $0x8,%esp
c0023ffd:	56                   	push   %esi
c0023ffe:	8d 47 08             	lea    0x8(%edi),%eax
c0024001:	50                   	push   %eax
c0024002:	e8 68 57 00 00       	call   c002976f <list_push_front>
            if (++a->free_cnt >= d->blocks_per_arena) {
c0024007:	8b 45 08             	mov    0x8(%ebp),%eax
c002400a:	83 c0 01             	add    $0x1,%eax
c002400d:	89 45 08             	mov    %eax,0x8(%ebp)
c0024010:	8b 57 04             	mov    0x4(%edi),%edx
c0024013:	83 c4 10             	add    $0x10,%esp
c0024016:	39 d0                	cmp    %edx,%eax
c0024018:	72 34                	jb     c002404e <free+0xa5>
                ASSERT (a->free_cnt == d->blocks_per_arena);
c002401a:	75 49                	jne    c0024065 <free+0xbc>
                for (i = 0; i < d->blocks_per_arena; i++) {
c002401c:	be 00 00 00 00       	mov    $0x0,%esi
c0024021:	85 d2                	test   %edx,%edx
c0024023:	74 1d                	je     c0024042 <free+0x99>
                    struct block *b = arena_to_block(a, i);
c0024025:	89 f2                	mov    %esi,%edx
c0024027:	89 e8                	mov    %ebp,%eax
c0024029:	e8 38 fb ff ff       	call   c0023b66 <arena_to_block>
                    list_remove(&b->free_elem);
c002402e:	83 ec 0c             	sub    $0xc,%esp
c0024031:	50                   	push   %eax
c0024032:	e8 72 57 00 00       	call   c00297a9 <list_remove>
                for (i = 0; i < d->blocks_per_arena; i++) {
c0024037:	83 c6 01             	add    $0x1,%esi
c002403a:	83 c4 10             	add    $0x10,%esp
c002403d:	39 77 04             	cmp    %esi,0x4(%edi)
c0024040:	77 e3                	ja     c0024025 <free+0x7c>
                palloc_free_page(a);
c0024042:	83 ec 0c             	sub    $0xc,%esp
c0024045:	55                   	push   %ebp
c0024046:	e8 09 fb ff ff       	call   c0023b54 <palloc_free_page>
c002404b:	83 c4 10             	add    $0x10,%esp
            lock_release(&d->lock);
c002404e:	83 ec 0c             	sub    $0xc,%esp
c0024051:	ff 74 24 18          	pushl  0x18(%esp)
c0024055:	e8 b0 f3 ff ff       	call   c002340a <lock_release>
c002405a:	83 c4 10             	add    $0x10,%esp
}
c002405d:	83 c4 1c             	add    $0x1c,%esp
c0024060:	5b                   	pop    %ebx
c0024061:	5e                   	pop    %esi
c0024062:	5f                   	pop    %edi
c0024063:	5d                   	pop    %ebp
c0024064:	c3                   	ret    
                ASSERT (a->free_cnt == d->blocks_per_arena);
c0024065:	83 ec 0c             	sub    $0xc,%esp
c0024068:	8d 83 74 5d ff ff    	lea    -0xa28c(%ebx),%eax
c002406e:	50                   	push   %eax
c002406f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0024075:	50                   	push   %eax
c0024076:	8d 83 dc 40 ff ff    	lea    -0xbf24(%ebx),%eax
c002407c:	50                   	push   %eax
c002407d:	68 e2 00 00 00       	push   $0xe2
c0024082:	8d 83 83 5c ff ff    	lea    -0xa37d(%ebx),%eax
c0024088:	50                   	push   %eax
c0024089:	e8 4c 50 00 00       	call   c00290da <debug_panic>
            palloc_free_multiple(a, a->free_cnt);
c002408e:	83 ec 08             	sub    $0x8,%esp
c0024091:	ff 70 08             	pushl  0x8(%eax)
c0024094:	50                   	push   %eax
c0024095:	e8 61 f9 ff ff       	call   c00239fb <palloc_free_multiple>
            return;
c002409a:	83 c4 10             	add    $0x10,%esp
c002409d:	eb be                	jmp    c002405d <free+0xb4>

c002409f <realloc>:
realloc(void *old_block, size_t new_size) {
c002409f:	55                   	push   %ebp
c00240a0:	57                   	push   %edi
c00240a1:	56                   	push   %esi
c00240a2:	53                   	push   %ebx
c00240a3:	83 ec 0c             	sub    $0xc,%esp
c00240a6:	e8 4d ae 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00240ab:	81 c3 7d 70 01 00    	add    $0x1707d,%ebx
c00240b1:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00240b5:	8b 74 24 24          	mov    0x24(%esp),%esi
    if (new_size == 0) {
c00240b9:	85 f6                	test   %esi,%esi
c00240bb:	74 43                	je     c0024100 <realloc+0x61>
        void *new_block = malloc(new_size);
c00240bd:	83 ec 0c             	sub    $0xc,%esp
c00240c0:	56                   	push   %esi
c00240c1:	e8 35 fd ff ff       	call   c0023dfb <malloc>
c00240c6:	89 c5                	mov    %eax,%ebp
        if (old_block != NULL && new_block != NULL) {
c00240c8:	83 c4 10             	add    $0x10,%esp
c00240cb:	85 ff                	test   %edi,%edi
c00240cd:	74 42                	je     c0024111 <realloc+0x72>
c00240cf:	85 c0                	test   %eax,%eax
c00240d1:	74 3e                	je     c0024111 <realloc+0x72>
    struct arena *a = block_to_arena(b);
c00240d3:	89 f8                	mov    %edi,%eax
c00240d5:	e8 36 fb ff ff       	call   c0023c10 <block_to_arena>
    struct desc *d = a->desc;
c00240da:	8b 50 04             	mov    0x4(%eax),%edx
    return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c00240dd:	85 d2                	test   %edx,%edx
c00240df:	74 3a                	je     c002411b <realloc+0x7c>
c00240e1:	8b 02                	mov    (%edx),%eax
            size_t min_size = new_size < old_size ? new_size : old_size;
c00240e3:	39 c6                	cmp    %eax,%esi
c00240e5:	0f 47 f0             	cmova  %eax,%esi
            memcpy(new_block, old_block, min_size);
c00240e8:	83 ec 04             	sub    $0x4,%esp
c00240eb:	56                   	push   %esi
c00240ec:	57                   	push   %edi
c00240ed:	55                   	push   %ebp
c00240ee:	e8 d6 41 00 00       	call   c00282c9 <memcpy>
            free(old_block);
c00240f3:	89 3c 24             	mov    %edi,(%esp)
c00240f6:	e8 ae fe ff ff       	call   c0023fa9 <free>
c00240fb:	83 c4 10             	add    $0x10,%esp
c00240fe:	eb 11                	jmp    c0024111 <realloc+0x72>
        free(old_block);
c0024100:	83 ec 0c             	sub    $0xc,%esp
c0024103:	57                   	push   %edi
c0024104:	e8 a0 fe ff ff       	call   c0023fa9 <free>
        return NULL;
c0024109:	83 c4 10             	add    $0x10,%esp
c002410c:	bd 00 00 00 00       	mov    $0x0,%ebp
}
c0024111:	89 e8                	mov    %ebp,%eax
c0024113:	83 c4 0c             	add    $0xc,%esp
c0024116:	5b                   	pop    %ebx
c0024117:	5e                   	pop    %esi
c0024118:	5f                   	pop    %edi
c0024119:	5d                   	pop    %ebp
c002411a:	c3                   	ret    
    return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c002411b:	8b 40 08             	mov    0x8(%eax),%eax
c002411e:	c1 e0 0c             	shl    $0xc,%eax
c0024121:	89 fa                	mov    %edi,%edx
c0024123:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0024129:	29 d0                	sub    %edx,%eax
c002412b:	eb b6                	jmp    c00240e3 <realloc+0x44>

c002412d <pit_configure_channel>:

     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel(int channel, int mode, int frequency) {
c002412d:	55                   	push   %ebp
c002412e:	57                   	push   %edi
c002412f:	56                   	push   %esi
c0024130:	53                   	push   %ebx
c0024131:	83 ec 0c             	sub    $0xc,%esp
c0024134:	e8 bf ad 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024139:	81 c3 ef 6f 01 00    	add    $0x16fef,%ebx
c002413f:	8b 74 24 20          	mov    0x20(%esp),%esi
c0024143:	8b 6c 24 24          	mov    0x24(%esp),%ebp
c0024147:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    uint16_t count;
    enum intr_level old_level;

    ASSERT (channel == 0 || channel == 2);
c002414b:	f7 c6 fd ff ff ff    	test   $0xfffffffd,%esi
c0024151:	75 69                	jne    c00241bc <pit_configure_channel+0x8f>
    ASSERT (mode == 2 || mode == 3);
c0024153:	8d 45 fe             	lea    -0x2(%ebp),%eax
c0024156:	83 f8 01             	cmp    $0x1,%eax
c0024159:	0f 87 83 00 00 00    	ja     c00241e2 <pit_configure_channel+0xb5>
    if (frequency < 19) {
        /* Frequency is too low: the quotient would overflow the
           16-bit counter.  Force it to 0, which the PIT treats as
           65536, the highest possible count.  This yields a 18.2
           Hz timer, approximately. */
        count = 0;
c002415f:	bf 00 00 00 00       	mov    $0x0,%edi
    if (frequency < 19) {
c0024164:	83 f9 12             	cmp    $0x12,%ecx
c0024167:	7e 20                	jle    c0024189 <pit_configure_channel+0x5c>
        /* Frequency is too high: the quotient would underflow to
           0, which the PIT would interpret as 65536.  A count of 1
           is illegal in mode 2, so we force it to 2, which yields
           a 596.590 kHz timer, approximately.  (This timer rate is
           probably too fast to be useful anyhow.) */
        count = 2;
c0024169:	bf 02 00 00 00       	mov    $0x2,%edi
    } else if (frequency > PIT_HZ) {
c002416e:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c0024174:	7f 13                	jg     c0024189 <pit_configure_channel+0x5c>
    } else
        count = (PIT_HZ + frequency / 2) / frequency;
c0024176:	89 c8                	mov    %ecx,%eax
c0024178:	c1 e8 1f             	shr    $0x1f,%eax
c002417b:	01 c8                	add    %ecx,%eax
c002417d:	d1 f8                	sar    %eax
c002417f:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0024184:	99                   	cltd   
c0024185:	f7 f9                	idiv   %ecx
c0024187:	89 c7                	mov    %eax,%edi

    /* Configure the PIT mode and load its counters. */
    old_level = intr_disable();
c0024189:	e8 81 db ff ff       	call   c0021d0f <intr_disable>
c002418e:	89 c1                	mov    %eax,%ecx
    outb(PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0024190:	89 f0                	mov    %esi,%eax
c0024192:	c1 e0 06             	shl    $0x6,%eax
c0024195:	01 ed                	add    %ebp,%ebp
c0024197:	09 e8                	or     %ebp,%eax
c0024199:	83 c8 30             	or     $0x30,%eax
c002419c:	e6 43                	out    %al,$0x43
    outb(PIT_PORT_COUNTER (channel), count);
c002419e:	8d 56 40             	lea    0x40(%esi),%edx
c00241a1:	89 f8                	mov    %edi,%eax
c00241a3:	ee                   	out    %al,(%dx)
    outb(PIT_PORT_COUNTER (channel), count >> 8);
c00241a4:	89 f8                	mov    %edi,%eax
c00241a6:	66 c1 e8 08          	shr    $0x8,%ax
c00241aa:	ee                   	out    %al,(%dx)
    intr_set_level(old_level);
c00241ab:	83 ec 0c             	sub    $0xc,%esp
c00241ae:	51                   	push   %ecx
c00241af:	e8 62 db ff ff       	call   c0021d16 <intr_set_level>
}
c00241b4:	83 c4 1c             	add    $0x1c,%esp
c00241b7:	5b                   	pop    %ebx
c00241b8:	5e                   	pop    %esi
c00241b9:	5f                   	pop    %edi
c00241ba:	5d                   	pop    %ebp
c00241bb:	c3                   	ret    
    ASSERT (channel == 0 || channel == 2);
c00241bc:	83 ec 0c             	sub    $0xc,%esp
c00241bf:	8d 83 97 5d ff ff    	lea    -0xa269(%ebx),%eax
c00241c5:	50                   	push   %eax
c00241c6:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00241cc:	50                   	push   %eax
c00241cd:	8d 83 10 41 ff ff    	lea    -0xbef0(%ebx),%eax
c00241d3:	50                   	push   %eax
c00241d4:	6a 32                	push   $0x32
c00241d6:	8d 83 b4 5d ff ff    	lea    -0xa24c(%ebx),%eax
c00241dc:	50                   	push   %eax
c00241dd:	e8 f8 4e 00 00       	call   c00290da <debug_panic>
    ASSERT (mode == 2 || mode == 3);
c00241e2:	83 ec 0c             	sub    $0xc,%esp
c00241e5:	8d 83 c8 5d ff ff    	lea    -0xa238(%ebx),%eax
c00241eb:	50                   	push   %eax
c00241ec:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00241f2:	50                   	push   %eax
c00241f3:	8d 83 10 41 ff ff    	lea    -0xbef0(%ebx),%eax
c00241f9:	50                   	push   %eax
c00241fa:	6a 33                	push   $0x33
c00241fc:	8d 83 b4 5d ff ff    	lea    -0xa24c(%ebx),%eax
c0024202:	50                   	push   %eax
c0024203:	e8 d2 4e 00 00       	call   c00290da <debug_panic>

c0024208 <busy_wait>:
   Marked NO_INLINE because code alignment can significantly
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait(int64_t loops) {
c0024208:	56                   	push   %esi
c0024209:	53                   	push   %ebx
    while (loops-- > 0)
c002420a:	89 c1                	mov    %eax,%ecx
c002420c:	89 d3                	mov    %edx,%ebx
c002420e:	83 c1 ff             	add    $0xffffffff,%ecx
c0024211:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024214:	be 00 00 00 00       	mov    $0x0,%esi
c0024219:	39 c6                	cmp    %eax,%esi
c002421b:	19 d6                	sbb    %edx,%esi
c002421d:	7d 0f                	jge    c002422e <busy_wait+0x26>
c002421f:	83 c1 ff             	add    $0xffffffff,%ecx
c0024222:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024225:	89 d8                	mov    %ebx,%eax
c0024227:	21 c8                	and    %ecx,%eax
c0024229:	83 f8 ff             	cmp    $0xffffffff,%eax
c002422c:	75 f1                	jne    c002421f <busy_wait+0x17>
            barrier ();
}
c002422e:	5b                   	pop    %ebx
c002422f:	5e                   	pop    %esi
c0024230:	c3                   	ret    

c0024231 <too_many_loops>:
too_many_loops(unsigned loops) {
c0024231:	55                   	push   %ebp
c0024232:	57                   	push   %edi
c0024233:	56                   	push   %esi
c0024234:	53                   	push   %ebx
c0024235:	83 ec 0c             	sub    $0xc,%esp
c0024238:	e8 bb ac 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002423d:	81 c3 eb 6e 01 00    	add    $0x16eeb,%ebx
c0024243:	89 44 24 04          	mov    %eax,0x4(%esp)
    int64_t start = ticks;
c0024247:	8b ab d8 18 00 00    	mov    0x18d8(%ebx),%ebp
c002424d:	8b 8b dc 18 00 00    	mov    0x18dc(%ebx),%ecx
    while (ticks == start)
c0024253:	8b bb d8 18 00 00    	mov    0x18d8(%ebx),%edi
c0024259:	8b b3 dc 18 00 00    	mov    0x18dc(%ebx),%esi
c002425f:	89 f8                	mov    %edi,%eax
c0024261:	31 e8                	xor    %ebp,%eax
c0024263:	89 f2                	mov    %esi,%edx
c0024265:	31 ca                	xor    %ecx,%edx
c0024267:	09 c2                	or     %eax,%edx
c0024269:	74 e8                	je     c0024253 <too_many_loops+0x22>
    busy_wait(loops);
c002426b:	8b 44 24 04          	mov    0x4(%esp),%eax
c002426f:	ba 00 00 00 00       	mov    $0x0,%edx
c0024274:	e8 8f ff ff ff       	call   c0024208 <busy_wait>
    return start != ticks;
c0024279:	33 bb d8 18 00 00    	xor    0x18d8(%ebx),%edi
c002427f:	33 b3 dc 18 00 00    	xor    0x18dc(%ebx),%esi
c0024285:	09 f7                	or     %esi,%edi
c0024287:	0f 95 c0             	setne  %al
}
c002428a:	83 c4 0c             	add    $0xc,%esp
c002428d:	5b                   	pop    %ebx
c002428e:	5e                   	pop    %esi
c002428f:	5f                   	pop    %edi
c0024290:	5d                   	pop    %ebp
c0024291:	c3                   	ret    

c0024292 <timer_interrupt>:
timer_interrupt(struct intr_frame *args UNUSED) {
c0024292:	56                   	push   %esi
c0024293:	53                   	push   %ebx
c0024294:	83 ec 04             	sub    $0x4,%esp
c0024297:	e8 5c ac 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002429c:	81 c3 8c 6e 01 00    	add    $0x16e8c,%ebx
    ticks++;
c00242a2:	83 83 d8 18 00 00 01 	addl   $0x1,0x18d8(%ebx)
c00242a9:	83 93 dc 18 00 00 00 	adcl   $0x0,0x18dc(%ebx)
    if (thread_mlfqs) {
c00242b0:	c7 c0 80 d0 03 c0    	mov    $0xc003d080,%eax
c00242b6:	80 38 00             	cmpb   $0x0,(%eax)
c00242b9:	75 2b                	jne    c00242e6 <timer_interrupt+0x54>
    enum intr_level old_level = intr_disable();
c00242bb:	e8 4f da ff ff       	call   c0021d0f <intr_disable>
c00242c0:	89 c6                	mov    %eax,%esi
    thread_foreach(thread_blocked_check, NULL);
c00242c2:	83 ec 08             	sub    $0x8,%esp
c00242c5:	6a 00                	push   $0x0
c00242c7:	8d 83 ba 92 fe ff    	lea    -0x16d46(%ebx),%eax
c00242cd:	50                   	push   %eax
c00242ce:	e8 b4 cd ff ff       	call   c0021087 <thread_foreach>
    intr_set_level(old_level);
c00242d3:	89 34 24             	mov    %esi,(%esp)
c00242d6:	e8 3b da ff ff       	call   c0021d16 <intr_set_level>
    thread_tick();
c00242db:	e8 17 cd ff ff       	call   c0020ff7 <thread_tick>
}
c00242e0:	83 c4 14             	add    $0x14,%esp
c00242e3:	5b                   	pop    %ebx
c00242e4:	5e                   	pop    %esi
c00242e5:	c3                   	ret    
        update_cur_thread_cpu();
c00242e6:	e8 b8 ce ff ff       	call   c00211a3 <update_cur_thread_cpu>
        if (ticks % TIMER_FREQ == 0) {
c00242eb:	6a 00                	push   $0x0
c00242ed:	6a 64                	push   $0x64
c00242ef:	ff b3 dc 18 00 00    	pushl  0x18dc(%ebx)
c00242f5:	ff b3 d8 18 00 00    	pushl  0x18d8(%ebx)
c00242fb:	e8 c0 47 00 00       	call   c0028ac0 <__moddi3>
c0024300:	83 c4 10             	add    $0x10,%esp
c0024303:	09 c2                	or     %eax,%edx
c0024305:	74 10                	je     c0024317 <timer_interrupt+0x85>
        if (ticks % 4) {
c0024307:	f6 83 d8 18 00 00 03 	testb  $0x3,0x18d8(%ebx)
c002430e:	74 ab                	je     c00242bb <timer_interrupt+0x29>
            update_all_priority();
c0024310:	e8 50 ce ff ff       	call   c0021165 <update_all_priority>
c0024315:	eb a4                	jmp    c00242bb <timer_interrupt+0x29>
            update_load_avg();
c0024317:	e8 a9 ce ff ff       	call   c00211c5 <update_load_avg>
            update_all_recent_cpu();
c002431c:	e8 63 ce ff ff       	call   c0021184 <update_all_recent_cpu>
c0024321:	eb e4                	jmp    c0024307 <timer_interrupt+0x75>

c0024323 <real_time_delay>:
    }
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay(int64_t num, int32_t denom) {
c0024323:	55                   	push   %ebp
c0024324:	57                   	push   %edi
c0024325:	56                   	push   %esi
c0024326:	53                   	push   %ebx
c0024327:	83 ec 0c             	sub    $0xc,%esp
c002432a:	e8 d5 ab 00 00       	call   c002ef04 <__x86.get_pc_thunk.di>
c002432f:	81 c7 f9 6d 01 00    	add    $0x16df9,%edi
c0024335:	89 c5                	mov    %eax,%ebp
c0024337:	89 d3                	mov    %edx,%ebx
    /* Scale the numerator and denominator down by 1000 to avoid
       the possibility of overflow. */
    ASSERT (denom % 1000 == 0);
c0024339:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c002433e:	89 c8                	mov    %ecx,%eax
c0024340:	f7 ea                	imul   %edx
c0024342:	c1 fa 06             	sar    $0x6,%edx
c0024345:	89 c8                	mov    %ecx,%eax
c0024347:	c1 f8 1f             	sar    $0x1f,%eax
c002434a:	29 c2                	sub    %eax,%edx
c002434c:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
c0024352:	39 d1                	cmp    %edx,%ecx
c0024354:	75 61                	jne    c00243b7 <real_time_delay+0x94>
c0024356:	89 ce                	mov    %ecx,%esi
    busy_wait(loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000));
c0024358:	8b 87 d0 18 00 00    	mov    0x18d0(%edi),%eax
c002435e:	0f af d8             	imul   %eax,%ebx
c0024361:	f7 e5                	mul    %ebp
c0024363:	01 da                	add    %ebx,%edx
c0024365:	6a 00                	push   $0x0
c0024367:	68 e8 03 00 00       	push   $0x3e8
c002436c:	52                   	push   %edx
c002436d:	50                   	push   %eax
c002436e:	89 fb                	mov    %edi,%ebx
c0024370:	e8 2f 47 00 00       	call   c0028aa4 <__divdi3>
c0024375:	83 c4 10             	add    $0x10,%esp
c0024378:	6b ea 64             	imul   $0x64,%edx,%ebp
c002437b:	b9 64 00 00 00       	mov    $0x64,%ecx
c0024380:	f7 e1                	mul    %ecx
c0024382:	89 c1                	mov    %eax,%ecx
c0024384:	89 d3                	mov    %edx,%ebx
c0024386:	01 eb                	add    %ebp,%ebx
c0024388:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c002438d:	89 f0                	mov    %esi,%eax
c002438f:	f7 ea                	imul   %edx
c0024391:	c1 fa 06             	sar    $0x6,%edx
c0024394:	c1 fe 1f             	sar    $0x1f,%esi
c0024397:	29 f2                	sub    %esi,%edx
c0024399:	89 d0                	mov    %edx,%eax
c002439b:	99                   	cltd   
c002439c:	52                   	push   %edx
c002439d:	50                   	push   %eax
c002439e:	53                   	push   %ebx
c002439f:	51                   	push   %ecx
c00243a0:	89 fb                	mov    %edi,%ebx
c00243a2:	e8 fd 46 00 00       	call   c0028aa4 <__divdi3>
c00243a7:	83 c4 10             	add    $0x10,%esp
c00243aa:	e8 59 fe ff ff       	call   c0024208 <busy_wait>
}
c00243af:	83 c4 0c             	add    $0xc,%esp
c00243b2:	5b                   	pop    %ebx
c00243b3:	5e                   	pop    %esi
c00243b4:	5f                   	pop    %edi
c00243b5:	5d                   	pop    %ebp
c00243b6:	c3                   	ret    
    ASSERT (denom % 1000 == 0);
c00243b7:	83 ec 0c             	sub    $0xc,%esp
c00243ba:	8d 87 df 5d ff ff    	lea    -0xa221(%edi),%eax
c00243c0:	50                   	push   %eax
c00243c1:	8d 87 94 4f ff ff    	lea    -0xb06c(%edi),%eax
c00243c7:	50                   	push   %eax
c00243c8:	8d 87 28 41 ff ff    	lea    -0xbed8(%edi),%eax
c00243ce:	50                   	push   %eax
c00243cf:	68 08 01 00 00       	push   $0x108
c00243d4:	8d 87 f1 5d ff ff    	lea    -0xa20f(%edi),%eax
c00243da:	50                   	push   %eax
c00243db:	89 fb                	mov    %edi,%ebx
c00243dd:	e8 f8 4c 00 00       	call   c00290da <debug_panic>

c00243e2 <thread_blocked_check>:
void thread_blocked_check(struct thread *t, void *aux UNUSED) {
c00243e2:	56                   	push   %esi
c00243e3:	53                   	push   %ebx
c00243e4:	83 ec 04             	sub    $0x4,%esp
c00243e7:	e8 1c ab 00 00       	call   c002ef08 <__x86.get_pc_thunk.dx>
c00243ec:	81 c2 3c 6d 01 00    	add    $0x16d3c,%edx
c00243f2:	8b 44 24 10          	mov    0x10(%esp),%eax
    if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c00243f6:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
c00243fa:	74 06                	je     c0024402 <thread_blocked_check+0x20>
}
c00243fc:	83 c4 04             	add    $0x4,%esp
c00243ff:	5b                   	pop    %ebx
c0024400:	5e                   	pop    %esi
c0024401:	c3                   	ret    
    if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c0024402:	8b 88 e4 00 00 00    	mov    0xe4(%eax),%ecx
c0024408:	8b 98 e8 00 00 00    	mov    0xe8(%eax),%ebx
c002440e:	be 00 00 00 00       	mov    $0x0,%esi
c0024413:	39 ce                	cmp    %ecx,%esi
c0024415:	19 de                	sbb    %ebx,%esi
c0024417:	7d e3                	jge    c00243fc <thread_blocked_check+0x1a>
        t->ticks_blocked--;
c0024419:	83 c1 ff             	add    $0xffffffff,%ecx
c002441c:	83 d3 ff             	adc    $0xffffffff,%ebx
c002441f:	89 de                	mov    %ebx,%esi
c0024421:	89 88 e4 00 00 00    	mov    %ecx,0xe4(%eax)
c0024427:	89 b0 e8 00 00 00    	mov    %esi,0xe8(%eax)
        if (t->ticks_blocked == 0) {
c002442d:	89 f3                	mov    %esi,%ebx
c002442f:	09 cb                	or     %ecx,%ebx
c0024431:	75 c9                	jne    c00243fc <thread_blocked_check+0x1a>
            thread_unblock(t);
c0024433:	83 ec 0c             	sub    $0xc,%esp
c0024436:	50                   	push   %eax
c0024437:	89 d3                	mov    %edx,%ebx
c0024439:	e8 85 ca ff ff       	call   c0020ec3 <thread_unblock>
c002443e:	83 c4 10             	add    $0x10,%esp
}
c0024441:	eb b9                	jmp    c00243fc <thread_blocked_check+0x1a>

c0024443 <timer_init>:
timer_init(void) {
c0024443:	53                   	push   %ebx
c0024444:	83 ec 0c             	sub    $0xc,%esp
c0024447:	e8 ac aa 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002444c:	81 c3 dc 6c 01 00    	add    $0x16cdc,%ebx
    pit_configure_channel(0, 2, TIMER_FREQ);
c0024452:	6a 64                	push   $0x64
c0024454:	6a 02                	push   $0x2
c0024456:	6a 00                	push   $0x0
c0024458:	e8 d0 fc ff ff       	call   c002412d <pit_configure_channel>
    intr_register_ext(0x20, timer_interrupt, "8254 Timer");
c002445d:	83 c4 0c             	add    $0xc,%esp
c0024460:	8d 83 07 5e ff ff    	lea    -0xa1f9(%ebx),%eax
c0024466:	50                   	push   %eax
c0024467:	8d 83 6a 91 fe ff    	lea    -0x16e96(%ebx),%eax
c002446d:	50                   	push   %eax
c002446e:	6a 20                	push   $0x20
c0024470:	e8 76 da ff ff       	call   c0021eeb <intr_register_ext>
}
c0024475:	83 c4 18             	add    $0x18,%esp
c0024478:	5b                   	pop    %ebx
c0024479:	c3                   	ret    

c002447a <timer_calibrate>:
timer_calibrate(void) {
c002447a:	55                   	push   %ebp
c002447b:	57                   	push   %edi
c002447c:	56                   	push   %esi
c002447d:	53                   	push   %ebx
c002447e:	83 ec 0c             	sub    $0xc,%esp
c0024481:	e8 72 aa 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024486:	81 c3 a2 6c 01 00    	add    $0x16ca2,%ebx
    ASSERT (intr_get_level() == INTR_ON);
c002448c:	e8 2c d8 ff ff       	call   c0021cbd <intr_get_level>
c0024491:	83 f8 01             	cmp    $0x1,%eax
c0024494:	75 60                	jne    c00244f6 <timer_calibrate+0x7c>
    printf("Calibrating timer...  ");
c0024496:	83 ec 0c             	sub    $0xc,%esp
c0024499:	8d 83 2e 5e ff ff    	lea    -0xa1d2(%ebx),%eax
c002449f:	50                   	push   %eax
c00244a0:	e8 d9 2f 00 00       	call   c002747e <printf>
    loops_per_tick = 1u << 10;
c00244a5:	c7 83 d0 18 00 00 00 	movl   $0x400,0x18d0(%ebx)
c00244ac:	04 00 00 
    while (!too_many_loops(loops_per_tick << 1)) {
c00244af:	83 c4 10             	add    $0x10,%esp
c00244b2:	8b bb d0 18 00 00    	mov    0x18d0(%ebx),%edi
c00244b8:	8d 34 3f             	lea    (%edi,%edi,1),%esi
c00244bb:	89 f0                	mov    %esi,%eax
c00244bd:	e8 6f fd ff ff       	call   c0024231 <too_many_loops>
c00244c2:	84 c0                	test   %al,%al
c00244c4:	75 56                	jne    c002451c <timer_calibrate+0xa2>
        loops_per_tick <<= 1;
c00244c6:	89 b3 d0 18 00 00    	mov    %esi,0x18d0(%ebx)
        ASSERT (loops_per_tick != 0);
c00244cc:	85 f6                	test   %esi,%esi
c00244ce:	75 e2                	jne    c00244b2 <timer_calibrate+0x38>
c00244d0:	83 ec 0c             	sub    $0xc,%esp
c00244d3:	8d 83 45 5e ff ff    	lea    -0xa1bb(%ebx),%eax
c00244d9:	50                   	push   %eax
c00244da:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00244e0:	50                   	push   %eax
c00244e1:	8d 83 54 41 ff ff    	lea    -0xbeac(%ebx),%eax
c00244e7:	50                   	push   %eax
c00244e8:	6a 3c                	push   $0x3c
c00244ea:	8d 83 f1 5d ff ff    	lea    -0xa20f(%ebx),%eax
c00244f0:	50                   	push   %eax
c00244f1:	e8 e4 4b 00 00       	call   c00290da <debug_panic>
    ASSERT (intr_get_level() == INTR_ON);
c00244f6:	83 ec 0c             	sub    $0xc,%esp
c00244f9:	8d 83 12 5e ff ff    	lea    -0xa1ee(%ebx),%eax
c00244ff:	50                   	push   %eax
c0024500:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0024506:	50                   	push   %eax
c0024507:	8d 83 54 41 ff ff    	lea    -0xbeac(%ebx),%eax
c002450d:	50                   	push   %eax
c002450e:	6a 34                	push   $0x34
c0024510:	8d 83 f1 5d ff ff    	lea    -0xa20f(%ebx),%eax
c0024516:	50                   	push   %eax
c0024517:	e8 be 4b 00 00       	call   c00290da <debug_panic>
    for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c002451c:	89 fe                	mov    %edi,%esi
c002451e:	d1 ee                	shr    %esi
c0024520:	89 fd                	mov    %edi,%ebp
c0024522:	c1 ed 0a             	shr    $0xa,%ebp
c0024525:	39 f5                	cmp    %esi,%ebp
c0024527:	75 2a                	jne    c0024553 <timer_calibrate+0xd9>
    printf("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0024529:	83 ec 04             	sub    $0x4,%esp
c002452c:	b8 64 00 00 00       	mov    $0x64,%eax
c0024531:	f7 a3 d0 18 00 00    	mull   0x18d0(%ebx)
c0024537:	52                   	push   %edx
c0024538:	50                   	push   %eax
c0024539:	8d 83 59 5e ff ff    	lea    -0xa1a7(%ebx),%eax
c002453f:	50                   	push   %eax
c0024540:	e8 39 2f 00 00       	call   c002747e <printf>
}
c0024545:	83 c4 1c             	add    $0x1c,%esp
c0024548:	5b                   	pop    %ebx
c0024549:	5e                   	pop    %esi
c002454a:	5f                   	pop    %edi
c002454b:	5d                   	pop    %ebp
c002454c:	c3                   	ret    
    for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c002454d:	d1 ee                	shr    %esi
c002454f:	39 f5                	cmp    %esi,%ebp
c0024551:	74 d6                	je     c0024529 <timer_calibrate+0xaf>
        if (!too_many_loops(high_bit | test_bit))
c0024553:	89 f8                	mov    %edi,%eax
c0024555:	09 f0                	or     %esi,%eax
c0024557:	e8 d5 fc ff ff       	call   c0024231 <too_many_loops>
c002455c:	84 c0                	test   %al,%al
c002455e:	75 ed                	jne    c002454d <timer_calibrate+0xd3>
            loops_per_tick |= test_bit;
c0024560:	09 b3 d0 18 00 00    	or     %esi,0x18d0(%ebx)
c0024566:	eb e5                	jmp    c002454d <timer_calibrate+0xd3>

c0024568 <timer_ticks>:
timer_ticks(void) {
c0024568:	57                   	push   %edi
c0024569:	56                   	push   %esi
c002456a:	53                   	push   %ebx
c002456b:	e8 88 a9 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024570:	81 c3 b8 6b 01 00    	add    $0x16bb8,%ebx
    enum intr_level old_level = intr_disable(); // ensure this process is not interrupted
c0024576:	e8 94 d7 ff ff       	call   c0021d0f <intr_disable>
    int64_t t = ticks;
c002457b:	8b b3 d8 18 00 00    	mov    0x18d8(%ebx),%esi
c0024581:	8b bb dc 18 00 00    	mov    0x18dc(%ebx),%edi
    intr_set_level(old_level);
c0024587:	83 ec 0c             	sub    $0xc,%esp
c002458a:	50                   	push   %eax
c002458b:	e8 86 d7 ff ff       	call   c0021d16 <intr_set_level>
    return t;
c0024590:	83 c4 10             	add    $0x10,%esp
}
c0024593:	89 f0                	mov    %esi,%eax
c0024595:	89 fa                	mov    %edi,%edx
c0024597:	5b                   	pop    %ebx
c0024598:	5e                   	pop    %esi
c0024599:	5f                   	pop    %edi
c002459a:	c3                   	ret    

c002459b <timer_elapsed>:
timer_elapsed(int64_t then) {
c002459b:	57                   	push   %edi
c002459c:	56                   	push   %esi
c002459d:	83 ec 04             	sub    $0x4,%esp
c00245a0:	8b 74 24 10          	mov    0x10(%esp),%esi
c00245a4:	8b 7c 24 14          	mov    0x14(%esp),%edi
    return timer_ticks() - then;
c00245a8:	e8 bb ff ff ff       	call   c0024568 <timer_ticks>
c00245ad:	29 f0                	sub    %esi,%eax
c00245af:	19 fa                	sbb    %edi,%edx
}
c00245b1:	83 c4 04             	add    $0x4,%esp
c00245b4:	5e                   	pop    %esi
c00245b5:	5f                   	pop    %edi
c00245b6:	c3                   	ret    

c00245b7 <timer_sleep>:
timer_sleep(int64_t ticks) {
c00245b7:	55                   	push   %ebp
c00245b8:	57                   	push   %edi
c00245b9:	56                   	push   %esi
c00245ba:	53                   	push   %ebx
c00245bb:	83 ec 0c             	sub    $0xc,%esp
c00245be:	e8 35 a9 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00245c3:	81 c3 65 6b 01 00    	add    $0x16b65,%ebx
c00245c9:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00245cd:	8b 74 24 24          	mov    0x24(%esp),%esi
    if (ticks <= 0) {
c00245d1:	b8 00 00 00 00       	mov    $0x0,%eax
c00245d6:	39 f8                	cmp    %edi,%eax
c00245d8:	19 f0                	sbb    %esi,%eax
c00245da:	7d 38                	jge    c0024614 <timer_sleep+0x5d>
    int64_t start = timer_ticks();
c00245dc:	e8 87 ff ff ff       	call   c0024568 <timer_ticks>
    ASSERT (intr_get_level() == INTR_ON);
c00245e1:	e8 d7 d6 ff ff       	call   c0021cbd <intr_get_level>
c00245e6:	83 f8 01             	cmp    $0x1,%eax
c00245e9:	75 31                	jne    c002461c <timer_sleep+0x65>
    enum intr_level old_level = intr_disable();
c00245eb:	e8 1f d7 ff ff       	call   c0021d0f <intr_disable>
c00245f0:	89 c5                	mov    %eax,%ebp
    struct thread *cur = thread_current();
c00245f2:	e8 7f c9 ff ff       	call   c0020f76 <thread_current>
    cur->ticks_blocked = ticks;
c00245f7:	89 b8 e4 00 00 00    	mov    %edi,0xe4(%eax)
c00245fd:	89 b0 e8 00 00 00    	mov    %esi,0xe8(%eax)
    thread_block();
c0024603:	e8 0d cf ff ff       	call   c0021515 <thread_block>
    intr_set_level(old_level);
c0024608:	83 ec 0c             	sub    $0xc,%esp
c002460b:	55                   	push   %ebp
c002460c:	e8 05 d7 ff ff       	call   c0021d16 <intr_set_level>
c0024611:	83 c4 10             	add    $0x10,%esp
}
c0024614:	83 c4 0c             	add    $0xc,%esp
c0024617:	5b                   	pop    %ebx
c0024618:	5e                   	pop    %esi
c0024619:	5f                   	pop    %edi
c002461a:	5d                   	pop    %ebp
c002461b:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c002461c:	83 ec 0c             	sub    $0xc,%esp
c002461f:	8d 83 12 5e ff ff    	lea    -0xa1ee(%ebx),%eax
c0024625:	50                   	push   %eax
c0024626:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002462c:	50                   	push   %eax
c002462d:	8d 83 48 41 ff ff    	lea    -0xbeb8(%ebx),%eax
c0024633:	50                   	push   %eax
c0024634:	6a 62                	push   $0x62
c0024636:	8d 83 f1 5d ff ff    	lea    -0xa20f(%ebx),%eax
c002463c:	50                   	push   %eax
c002463d:	e8 98 4a 00 00       	call   c00290da <debug_panic>

c0024642 <real_time_sleep>:
real_time_sleep(int64_t num, int32_t denom) {
c0024642:	55                   	push   %ebp
c0024643:	57                   	push   %edi
c0024644:	56                   	push   %esi
c0024645:	53                   	push   %ebx
c0024646:	83 ec 1c             	sub    $0x1c,%esp
c0024649:	e8 aa a8 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002464e:	81 c3 da 6a 01 00    	add    $0x16ada,%ebx
c0024654:	89 c6                	mov    %eax,%esi
c0024656:	89 44 24 08          	mov    %eax,0x8(%esp)
c002465a:	89 54 24 0c          	mov    %edx,0xc(%esp)
c002465e:	89 cd                	mov    %ecx,%ebp
    int64_t ticks = num * TIMER_FREQ / denom;
c0024660:	6b ca 64             	imul   $0x64,%edx,%ecx
c0024663:	b8 64 00 00 00       	mov    $0x64,%eax
c0024668:	f7 e6                	mul    %esi
c002466a:	01 ca                	add    %ecx,%edx
c002466c:	89 ef                	mov    %ebp,%edi
c002466e:	c1 ff 1f             	sar    $0x1f,%edi
c0024671:	57                   	push   %edi
c0024672:	55                   	push   %ebp
c0024673:	52                   	push   %edx
c0024674:	50                   	push   %eax
c0024675:	e8 2a 44 00 00       	call   c0028aa4 <__divdi3>
c002467a:	83 c4 10             	add    $0x10,%esp
c002467d:	89 c6                	mov    %eax,%esi
c002467f:	89 d7                	mov    %edx,%edi
    ASSERT (intr_get_level() == INTR_ON);
c0024681:	e8 37 d6 ff ff       	call   c0021cbd <intr_get_level>
c0024686:	83 f8 01             	cmp    $0x1,%eax
c0024689:	75 20                	jne    c00246ab <real_time_sleep+0x69>
    if (ticks > 0) {
c002468b:	b8 00 00 00 00       	mov    $0x0,%eax
c0024690:	39 f0                	cmp    %esi,%eax
c0024692:	19 f8                	sbb    %edi,%eax
c0024694:	7d 3e                	jge    c00246d4 <real_time_sleep+0x92>
        timer_sleep(ticks);
c0024696:	83 ec 08             	sub    $0x8,%esp
c0024699:	57                   	push   %edi
c002469a:	56                   	push   %esi
c002469b:	e8 17 ff ff ff       	call   c00245b7 <timer_sleep>
c00246a0:	83 c4 10             	add    $0x10,%esp
}
c00246a3:	83 c4 1c             	add    $0x1c,%esp
c00246a6:	5b                   	pop    %ebx
c00246a7:	5e                   	pop    %esi
c00246a8:	5f                   	pop    %edi
c00246a9:	5d                   	pop    %ebp
c00246aa:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c00246ab:	83 ec 0c             	sub    $0xc,%esp
c00246ae:	8d 83 12 5e ff ff    	lea    -0xa1ee(%ebx),%eax
c00246b4:	50                   	push   %eax
c00246b5:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00246bb:	50                   	push   %eax
c00246bc:	8d 83 38 41 ff ff    	lea    -0xbec8(%ebx),%eax
c00246c2:	50                   	push   %eax
c00246c3:	68 f6 00 00 00       	push   $0xf6
c00246c8:	8d 83 f1 5d ff ff    	lea    -0xa20f(%ebx),%eax
c00246ce:	50                   	push   %eax
c00246cf:	e8 06 4a 00 00       	call   c00290da <debug_panic>
        real_time_delay(num, denom);
c00246d4:	89 e9                	mov    %ebp,%ecx
c00246d6:	8b 44 24 08          	mov    0x8(%esp),%eax
c00246da:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00246de:	e8 40 fc ff ff       	call   c0024323 <real_time_delay>
}
c00246e3:	eb be                	jmp    c00246a3 <real_time_sleep+0x61>

c00246e5 <timer_msleep>:
timer_msleep(int64_t ms) {
c00246e5:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(ms, 1000);
c00246e8:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c00246ed:	8b 44 24 10          	mov    0x10(%esp),%eax
c00246f1:	8b 54 24 14          	mov    0x14(%esp),%edx
c00246f5:	e8 48 ff ff ff       	call   c0024642 <real_time_sleep>
}
c00246fa:	83 c4 0c             	add    $0xc,%esp
c00246fd:	c3                   	ret    

c00246fe <timer_usleep>:
timer_usleep(int64_t us) {
c00246fe:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(us, 1000 * 1000);
c0024701:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024706:	8b 44 24 10          	mov    0x10(%esp),%eax
c002470a:	8b 54 24 14          	mov    0x14(%esp),%edx
c002470e:	e8 2f ff ff ff       	call   c0024642 <real_time_sleep>
}
c0024713:	83 c4 0c             	add    $0xc,%esp
c0024716:	c3                   	ret    

c0024717 <timer_nsleep>:
timer_nsleep(int64_t ns) {
c0024717:	83 ec 0c             	sub    $0xc,%esp
    real_time_sleep(ns, 1000 * 1000 * 1000);
c002471a:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c002471f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024723:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024727:	e8 16 ff ff ff       	call   c0024642 <real_time_sleep>
}
c002472c:	83 c4 0c             	add    $0xc,%esp
c002472f:	c3                   	ret    

c0024730 <timer_mdelay>:
timer_mdelay(int64_t ms) {
c0024730:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(ms, 1000);
c0024733:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024738:	8b 44 24 10          	mov    0x10(%esp),%eax
c002473c:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024740:	e8 de fb ff ff       	call   c0024323 <real_time_delay>
}
c0024745:	83 c4 0c             	add    $0xc,%esp
c0024748:	c3                   	ret    

c0024749 <timer_udelay>:
timer_udelay(int64_t us) {
c0024749:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(us, 1000 * 1000);
c002474c:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024751:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024755:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024759:	e8 c5 fb ff ff       	call   c0024323 <real_time_delay>
}
c002475e:	83 c4 0c             	add    $0xc,%esp
c0024761:	c3                   	ret    

c0024762 <timer_ndelay>:
timer_ndelay(int64_t ns) {
c0024762:	83 ec 0c             	sub    $0xc,%esp
    real_time_delay(ns, 1000 * 1000 * 1000);
c0024765:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c002476a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002476e:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024772:	e8 ac fb ff ff       	call   c0024323 <real_time_delay>
}
c0024777:	83 c4 0c             	add    $0xc,%esp
c002477a:	c3                   	ret    

c002477b <timer_print_stats>:
timer_print_stats(void) {
c002477b:	53                   	push   %ebx
c002477c:	83 ec 08             	sub    $0x8,%esp
c002477f:	e8 74 a7 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024784:	81 c3 a4 69 01 00    	add    $0x169a4,%ebx
    printf("Timer: %"PRId64" ticks\n", timer_ticks());
c002478a:	e8 d9 fd ff ff       	call   c0024568 <timer_ticks>
c002478f:	83 ec 04             	sub    $0x4,%esp
c0024792:	52                   	push   %edx
c0024793:	50                   	push   %eax
c0024794:	8d 83 69 5e ff ff    	lea    -0xa197(%ebx),%eax
c002479a:	50                   	push   %eax
c002479b:	e8 de 2c 00 00       	call   c002747e <printf>
}
c00247a0:	83 c4 18             	add    $0x18,%esp
c00247a3:	5b                   	pop    %ebx
c00247a4:	c3                   	ret    

c00247a5 <map_key>:
/* Scans the array of keymaps K for SCANCODE.
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key(const struct keymap k[], unsigned scancode, uint8_t *c) {
c00247a5:	55                   	push   %ebp
c00247a6:	57                   	push   %edi
c00247a7:	56                   	push   %esi
c00247a8:	53                   	push   %ebx
c00247a9:	83 ec 04             	sub    $0x4,%esp
c00247ac:	89 0c 24             	mov    %ecx,(%esp)
    for (; k->first_scancode != 0; k++)
c00247af:	0f b6 18             	movzbl (%eax),%ebx
c00247b2:	84 db                	test   %bl,%bl
c00247b4:	74 50                	je     c0024806 <map_key+0x61>
c00247b6:	89 c6                	mov    %eax,%esi
        if (scancode >= k->first_scancode
            && scancode < k->first_scancode + strlen(k->chars)) {
c00247b8:	b8 00 00 00 00       	mov    $0x0,%eax
c00247bd:	eb 0a                	jmp    c00247c9 <map_key+0x24>
    for (; k->first_scancode != 0; k++)
c00247bf:	83 c6 08             	add    $0x8,%esi
c00247c2:	0f b6 1e             	movzbl (%esi),%ebx
c00247c5:	84 db                	test   %bl,%bl
c00247c7:	74 30                	je     c00247f9 <map_key+0x54>
        if (scancode >= k->first_scancode
c00247c9:	0f b6 db             	movzbl %bl,%ebx
c00247cc:	39 d3                	cmp    %edx,%ebx
c00247ce:	77 ef                	ja     c00247bf <map_key+0x1a>
            && scancode < k->first_scancode + strlen(k->chars)) {
c00247d0:	8b 6e 04             	mov    0x4(%esi),%ebp
c00247d3:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00247d8:	89 ef                	mov    %ebp,%edi
c00247da:	f2 ae                	repnz scas %es:(%edi),%al
c00247dc:	f7 d1                	not    %ecx
c00247de:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c00247e2:	39 d1                	cmp    %edx,%ecx
c00247e4:	76 d9                	jbe    c00247bf <map_key+0x1a>
            *c = k->chars[scancode - k->first_scancode];
c00247e6:	29 da                	sub    %ebx,%edx
c00247e8:	0f b6 44 15 00       	movzbl 0x0(%ebp,%edx,1),%eax
c00247ed:	8b 3c 24             	mov    (%esp),%edi
c00247f0:	88 07                	mov    %al,(%edi)
            return true;
c00247f2:	b8 01 00 00 00       	mov    $0x1,%eax
c00247f7:	eb 05                	jmp    c00247fe <map_key+0x59>
        }

    return false;
c00247f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00247fe:	83 c4 04             	add    $0x4,%esp
c0024801:	5b                   	pop    %ebx
c0024802:	5e                   	pop    %esi
c0024803:	5f                   	pop    %edi
c0024804:	5d                   	pop    %ebp
c0024805:	c3                   	ret    
    return false;
c0024806:	b8 00 00 00 00       	mov    $0x0,%eax
c002480b:	eb f1                	jmp    c00247fe <map_key+0x59>

c002480d <keyboard_interrupt>:
keyboard_interrupt(struct intr_frame *args UNUSED) {
c002480d:	55                   	push   %ebp
c002480e:	57                   	push   %edi
c002480f:	56                   	push   %esi
c0024810:	53                   	push   %ebx
c0024811:	83 ec 2c             	sub    $0x2c,%esp
c0024814:	e8 df a6 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024819:	81 c3 0f 69 01 00    	add    $0x1690f,%ebx
    bool shift = left_shift || right_shift;
c002481f:	ba 01 00 00 00       	mov    $0x1,%edx
c0024824:	80 bb ee 18 00 00 00 	cmpb   $0x0,0x18ee(%ebx)
c002482b:	75 07                	jne    c0024834 <keyboard_interrupt+0x27>
c002482d:	0f b6 93 ed 18 00 00 	movzbl 0x18ed(%ebx),%edx
    bool alt = left_alt || right_alt;
c0024834:	bd 01 00 00 00       	mov    $0x1,%ebp
c0024839:	80 bb ec 18 00 00 00 	cmpb   $0x0,0x18ec(%ebx)
c0024840:	75 07                	jne    c0024849 <keyboard_interrupt+0x3c>
c0024842:	0f b6 ab eb 18 00 00 	movzbl 0x18eb(%ebx),%ebp
    bool ctrl = left_ctrl || right_ctrl;
c0024849:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0024850:	00 
c0024851:	80 bb ea 18 00 00 00 	cmpb   $0x0,0x18ea(%ebx)
c0024858:	75 0b                	jne    c0024865 <keyboard_interrupt+0x58>
c002485a:	0f b6 83 e9 18 00 00 	movzbl 0x18e9(%ebx),%eax
c0024861:	89 44 24 08          	mov    %eax,0x8(%esp)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024865:	e4 60                	in     $0x60,%al
    code = inb(DATA_REG);
c0024867:	0f b6 f0             	movzbl %al,%esi
    if (code == 0xe0)
c002486a:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
c0024870:	74 24                	je     c0024896 <keyboard_interrupt+0x89>
    release = (code & 0x80) != 0;
c0024872:	83 e0 80             	and    $0xffffff80,%eax
c0024875:	0f b6 f8             	movzbl %al,%edi
    code &= ~0x80u;
c0024878:	81 e6 7f ff ff ff    	and    $0xffffff7f,%esi
    if (code == 0x3a) {
c002487e:	83 fe 3a             	cmp    $0x3a,%esi
c0024881:	75 25                	jne    c00248a8 <keyboard_interrupt+0x9b>
        if (!release)
c0024883:	85 ff                	test   %edi,%edi
c0024885:	75 07                	jne    c002488e <keyboard_interrupt+0x81>
            caps_lock = !caps_lock;
c0024887:	80 b3 e8 18 00 00 01 	xorb   $0x1,0x18e8(%ebx)
}
c002488e:	83 c4 2c             	add    $0x2c,%esp
c0024891:	5b                   	pop    %ebx
c0024892:	5e                   	pop    %esi
c0024893:	5f                   	pop    %edi
c0024894:	5d                   	pop    %ebp
c0024895:	c3                   	ret    
c0024896:	e4 60                	in     $0x60,%al
    release = (code & 0x80) != 0;
c0024898:	89 c1                	mov    %eax,%ecx
c002489a:	83 e1 80             	and    $0xffffff80,%ecx
c002489d:	0f b6 f9             	movzbl %cl,%edi
    code &= ~0x80u;
c00248a0:	83 e0 7f             	and    $0x7f,%eax
c00248a3:	80 cc e0             	or     $0xe0,%ah
c00248a6:	89 c6                	mov    %eax,%esi
    bool shift = left_shift || right_shift;
c00248a8:	89 d0                	mov    %edx,%eax
c00248aa:	83 e0 01             	and    $0x1,%eax
c00248ad:	88 44 24 0f          	mov    %al,0xf(%esp)
    } else if (map_key(invariant_keymap, code, &c)
c00248b1:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00248b5:	89 f2                	mov    %esi,%edx
c00248b7:	8d 83 18 78 ff ff    	lea    -0x87e8(%ebx),%eax
c00248bd:	e8 e3 fe ff ff       	call   c00247a5 <map_key>
c00248c2:	84 c0                	test   %al,%al
c00248c4:	75 57                	jne    c002491d <keyboard_interrupt+0x110>
               || (!shift && map_key(unshifted_keymap, code, &c))
c00248c6:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00248cb:	74 3b                	je     c0024908 <keyboard_interrupt+0xfb>
               || (shift && map_key(shifted_keymap, code, &c))) {
c00248cd:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00248d1:	89 f2                	mov    %esi,%edx
c00248d3:	8d 83 98 77 ff ff    	lea    -0x8868(%ebx),%eax
c00248d9:	e8 c7 fe ff ff       	call   c00247a5 <map_key>
c00248de:	84 c0                	test   %al,%al
c00248e0:	75 3b                	jne    c002491d <keyboard_interrupt+0x110>
            if (key->scancode == code) {
c00248e2:	83 fe 2a             	cmp    $0x2a,%esi
c00248e5:	0f 84 da 00 00 00    	je     c00249c5 <keyboard_interrupt+0x1b8>
        for (key = shift_keys; key->scancode != 0; key++)
c00248eb:	8d 83 58 77 ff ff    	lea    -0x88a8(%ebx),%eax
c00248f1:	83 c0 08             	add    $0x8,%eax
c00248f4:	8b 10                	mov    (%eax),%edx
c00248f6:	85 d2                	test   %edx,%edx
c00248f8:	74 94                	je     c002488e <keyboard_interrupt+0x81>
            if (key->scancode == code) {
c00248fa:	39 f2                	cmp    %esi,%edx
c00248fc:	75 f3                	jne    c00248f1 <keyboard_interrupt+0xe4>
                *key->state_var = !release;
c00248fe:	8b 40 04             	mov    0x4(%eax),%eax
c0024901:	85 ff                	test   %edi,%edi
c0024903:	0f 94 00             	sete   (%eax)
                break;
c0024906:	eb 86                	jmp    c002488e <keyboard_interrupt+0x81>
               || (!shift && map_key(unshifted_keymap, code, &c))
c0024908:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c002490c:	89 f2                	mov    %esi,%edx
c002490e:	8d 83 d8 77 ff ff    	lea    -0x8828(%ebx),%eax
c0024914:	e8 8c fe ff ff       	call   c00247a5 <map_key>
c0024919:	84 c0                	test   %al,%al
c002491b:	74 c5                	je     c00248e2 <keyboard_interrupt+0xd5>
        if (!release) {
c002491d:	85 ff                	test   %edi,%edi
c002491f:	0f 85 69 ff ff ff    	jne    c002488e <keyboard_interrupt+0x81>
            if (c == 0177 && ctrl && alt)
c0024925:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
c002492a:	3c 7f                	cmp    $0x7f,%al
c002492c:	74 5a                	je     c0024988 <keyboard_interrupt+0x17b>
            if (ctrl && c >= 0x40 && c < 0x60) {
c002492e:	8d 50 c0             	lea    -0x40(%eax),%edx
c0024931:	80 fa 1f             	cmp    $0x1f,%dl
c0024934:	77 07                	ja     c002493d <keyboard_interrupt+0x130>
c0024936:	f6 44 24 08 01       	testb  $0x1,0x8(%esp)
c002493b:	75 6d                	jne    c00249aa <keyboard_interrupt+0x19d>
            } else if (shift == caps_lock)
c002493d:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024942:	38 8b e8 18 00 00    	cmp    %cl,0x18e8(%ebx)
c0024948:	74 66                	je     c00249b0 <keyboard_interrupt+0x1a3>
            if (alt)
c002494a:	f7 c5 01 00 00 00    	test   $0x1,%ebp
c0024950:	74 05                	je     c0024957 <keyboard_interrupt+0x14a>
                c += 0x80;
c0024952:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
            if (!input_full()) {
c0024957:	e8 9a 1c 00 00       	call   c00265f6 <input_full>
c002495c:	84 c0                	test   %al,%al
c002495e:	0f 85 2a ff ff ff    	jne    c002488e <keyboard_interrupt+0x81>
                key_cnt++;
c0024964:	83 83 e0 18 00 00 01 	addl   $0x1,0x18e0(%ebx)
c002496b:	83 93 e4 18 00 00 00 	adcl   $0x0,0x18e4(%ebx)
                input_putc(c);
c0024972:	83 ec 0c             	sub    $0xc,%esp
c0024975:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c002497a:	50                   	push   %eax
c002497b:	e8 9b 1b 00 00       	call   c002651b <input_putc>
c0024980:	83 c4 10             	add    $0x10,%esp
c0024983:	e9 06 ff ff ff       	jmp    c002488e <keyboard_interrupt+0x81>
            if (c == 0177 && ctrl && alt)
c0024988:	8b 54 24 08          	mov    0x8(%esp),%edx
c002498c:	21 ea                	and    %ebp,%edx
c002498e:	f6 c2 01             	test   $0x1,%dl
c0024991:	75 12                	jne    c00249a5 <keyboard_interrupt+0x198>
            } else if (shift == caps_lock)
c0024993:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024998:	3a 8b e8 18 00 00    	cmp    0x18e8(%ebx),%cl
c002499e:	75 aa                	jne    c002494a <keyboard_interrupt+0x13d>
                c = tolower(c);
c00249a0:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c00249a3:	eb 1a                	jmp    c00249bf <keyboard_interrupt+0x1b2>
                shutdown_reboot();
c00249a5:	e8 3f 22 00 00       	call   c0026be9 <shutdown_reboot>
                c -= 0x40;
c00249aa:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c00249ae:	eb 9a                	jmp    c002494a <keyboard_interrupt+0x13d>
                c = tolower(c);
c00249b0:	0f b6 c0             	movzbl %al,%eax
c00249b3:	8d 48 bf             	lea    -0x41(%eax),%ecx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c00249b6:	8d 50 20             	lea    0x20(%eax),%edx
c00249b9:	83 f9 1a             	cmp    $0x1a,%ecx
c00249bc:	0f 42 c2             	cmovb  %edx,%eax
c00249bf:	88 44 24 1f          	mov    %al,0x1f(%esp)
c00249c3:	eb 85                	jmp    c002494a <keyboard_interrupt+0x13d>
        for (key = shift_keys; key->scancode != 0; key++)
c00249c5:	8d 83 58 77 ff ff    	lea    -0x88a8(%ebx),%eax
c00249cb:	e9 2e ff ff ff       	jmp    c00248fe <keyboard_interrupt+0xf1>

c00249d0 <kbd_init>:
kbd_init(void) {
c00249d0:	53                   	push   %ebx
c00249d1:	83 ec 0c             	sub    $0xc,%esp
c00249d4:	e8 1f a5 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00249d9:	81 c3 4f 67 01 00    	add    $0x1674f,%ebx
    intr_register_ext(0x21, keyboard_interrupt, "8042 Keyboard");
c00249df:	8d 83 7c 5e ff ff    	lea    -0xa184(%ebx),%eax
c00249e5:	50                   	push   %eax
c00249e6:	8d 83 e5 96 fe ff    	lea    -0x1691b(%ebx),%eax
c00249ec:	50                   	push   %eax
c00249ed:	6a 21                	push   $0x21
c00249ef:	e8 f7 d4 ff ff       	call   c0021eeb <intr_register_ext>
}
c00249f4:	83 c4 18             	add    $0x18,%esp
c00249f7:	5b                   	pop    %ebx
c00249f8:	c3                   	ret    

c00249f9 <kbd_print_stats>:
kbd_print_stats(void) {
c00249f9:	53                   	push   %ebx
c00249fa:	83 ec 0c             	sub    $0xc,%esp
c00249fd:	e8 f6 a4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024a02:	81 c3 26 67 01 00    	add    $0x16726,%ebx
    printf("Keyboard: %lld keys pressed\n", key_cnt);
c0024a08:	ff b3 e4 18 00 00    	pushl  0x18e4(%ebx)
c0024a0e:	ff b3 e0 18 00 00    	pushl  0x18e0(%ebx)
c0024a14:	8d 83 8a 5e ff ff    	lea    -0xa176(%ebx),%eax
c0024a1a:	50                   	push   %eax
c0024a1b:	e8 5e 2a 00 00       	call   c002747e <printf>
}
c0024a20:	83 c4 18             	add    $0x18,%esp
c0024a23:	5b                   	pop    %ebx
c0024a24:	c3                   	ret    

c0024a25 <move_cursor>:
    }
}

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor(void) {
c0024a25:	e8 d2 a4 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0024a2a:	05 fe 66 01 00       	add    $0x166fe,%eax
    /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
    uint16_t cp = cx + COL_CNT * cy;
c0024a2f:	8b 88 f8 18 00 00    	mov    0x18f8(%eax),%ecx
c0024a35:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0024a38:	c1 e1 04             	shl    $0x4,%ecx
c0024a3b:	66 03 88 fc 18 00 00 	add    0x18fc(%eax),%cx
    outw(0x3d4, 0x0e | (cp & 0xff00));
c0024a42:	89 c8                	mov    %ecx,%eax
c0024a44:	b0 00                	mov    $0x0,%al
c0024a46:	83 c8 0e             	or     $0xe,%eax

/* Writes the 16-bit DATA to PORT. */
static inline void
outw(uint16_t port, uint16_t data) {
    /* See [IA32-v2b] "OUT". */
    asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024a49:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024a4e:	66 ef                	out    %ax,(%dx)
    outw(0x3d4, 0x0f | (cp << 8));
c0024a50:	89 c8                	mov    %ecx,%eax
c0024a52:	c1 e0 08             	shl    $0x8,%eax
c0024a55:	83 c8 0f             	or     $0xf,%eax
c0024a58:	66 ef                	out    %ax,(%dx)
}
c0024a5a:	c3                   	ret    

c0024a5b <newline>:
newline(void) {
c0024a5b:	56                   	push   %esi
c0024a5c:	53                   	push   %ebx
c0024a5d:	83 ec 04             	sub    $0x4,%esp
c0024a60:	e8 93 a4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024a65:	81 c3 c3 66 01 00    	add    $0x166c3,%ebx
    cx = 0;
c0024a6b:	c7 83 fc 18 00 00 00 	movl   $0x0,0x18fc(%ebx)
c0024a72:	00 00 00 
    cy++;
c0024a75:	8b 83 f8 18 00 00    	mov    0x18f8(%ebx),%eax
c0024a7b:	83 c0 01             	add    $0x1,%eax
    if (cy >= ROW_CNT) {
c0024a7e:	83 f8 18             	cmp    $0x18,%eax
c0024a81:	77 0c                	ja     c0024a8f <newline+0x34>
    cy++;
c0024a83:	89 83 f8 18 00 00    	mov    %eax,0x18f8(%ebx)
}
c0024a89:	83 c4 04             	add    $0x4,%esp
c0024a8c:	5b                   	pop    %ebx
c0024a8d:	5e                   	pop    %esi
c0024a8e:	c3                   	ret    
        cy = ROW_CNT - 1;
c0024a8f:	c7 83 f8 18 00 00 18 	movl   $0x18,0x18f8(%ebx)
c0024a96:	00 00 00 
        memmove(&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024a99:	8b b3 f4 18 00 00    	mov    0x18f4(%ebx),%esi
c0024a9f:	83 ec 04             	sub    $0x4,%esp
c0024aa2:	68 00 0f 00 00       	push   $0xf00
c0024aa7:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0024aad:	50                   	push   %eax
c0024aae:	56                   	push   %esi
c0024aaf:	e8 41 38 00 00       	call   c00282f5 <memmove>
    for (x = 0; x < COL_CNT; x++) {
c0024ab4:	8d 86 00 0f 00 00    	lea    0xf00(%esi),%eax
c0024aba:	81 c6 a0 0f 00 00    	add    $0xfa0,%esi
c0024ac0:	83 c4 10             	add    $0x10,%esp
        fb[y][x][0] = ' ';
c0024ac3:	c6 00 20             	movb   $0x20,(%eax)
        fb[y][x][1] = GRAY_ON_BLACK;
c0024ac6:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024aca:	83 c0 02             	add    $0x2,%eax
    for (x = 0; x < COL_CNT; x++) {
c0024acd:	39 f0                	cmp    %esi,%eax
c0024acf:	75 f2                	jne    c0024ac3 <newline+0x68>
c0024ad1:	eb b6                	jmp    c0024a89 <newline+0x2e>

c0024ad3 <vga_putc>:
vga_putc(int c) {
c0024ad3:	55                   	push   %ebp
c0024ad4:	57                   	push   %edi
c0024ad5:	56                   	push   %esi
c0024ad6:	53                   	push   %ebx
c0024ad7:	83 ec 0c             	sub    $0xc,%esp
c0024ada:	e8 19 a4 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024adf:	81 c3 49 66 01 00    	add    $0x16649,%ebx
    enum intr_level old_level = intr_disable();
c0024ae5:	e8 25 d2 ff ff       	call   c0021d0f <intr_disable>
c0024aea:	89 c6                	mov    %eax,%esi
    if (!inited) {
c0024aec:	80 bb f0 18 00 00 00 	cmpb   $0x0,0x18f0(%ebx)
c0024af3:	74 1b                	je     c0024b10 <vga_putc+0x3d>
    switch (c) {
c0024af5:	8b 44 24 20          	mov    0x20(%esp),%eax
c0024af9:	83 e8 07             	sub    $0x7,%eax
c0024afc:	83 f8 06             	cmp    $0x6,%eax
c0024aff:	0f 87 23 01 00 00    	ja     c0024c28 <.L11>
c0024b05:	89 df                	mov    %ebx,%edi
c0024b07:	03 bc 83 64 41 ff ff 	add    -0xbe9c(%ebx,%eax,4),%edi
c0024b0e:	ff e7                	jmp    *%edi
        fb = ptov(0xb8000);
c0024b10:	c7 83 f4 18 00 00 00 	movl   $0xc00b8000,0x18f4(%ebx)
c0024b17:	80 0b c0 
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024b1a:	bd d4 03 00 00       	mov    $0x3d4,%ebp
c0024b1f:	b8 0e 00 00 00       	mov    $0xe,%eax
c0024b24:	89 ea                	mov    %ebp,%edx
c0024b26:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024b27:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0024b2c:	89 ca                	mov    %ecx,%edx
c0024b2e:	ec                   	in     (%dx),%al
find_cursor(size_t *x, size_t *y) {
    /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
    uint16_t cp;

    outb(0x3d4, 0x0e);
    cp = inb(0x3d5) << 8;
c0024b2f:	89 c7                	mov    %eax,%edi
c0024b31:	c1 e7 08             	shl    $0x8,%edi
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024b34:	b8 0f 00 00 00       	mov    $0xf,%eax
c0024b39:	89 ea                	mov    %ebp,%edx
c0024b3b:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024b3c:	89 ca                	mov    %ecx,%edx
c0024b3e:	ec                   	in     (%dx),%al

    outb(0x3d4, 0x0f);
    cp |= inb(0x3d5);
c0024b3f:	0f b6 c0             	movzbl %al,%eax
c0024b42:	09 c7                	or     %eax,%edi

    *x = cp % COL_CNT;
c0024b44:	0f b7 c7             	movzwl %di,%eax
c0024b47:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c0024b4d:	c1 e8 16             	shr    $0x16,%eax
c0024b50:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0024b53:	c1 e2 04             	shl    $0x4,%edx
c0024b56:	29 d7                	sub    %edx,%edi
c0024b58:	0f b7 ff             	movzwl %di,%edi
c0024b5b:	89 bb fc 18 00 00    	mov    %edi,0x18fc(%ebx)
    *y = cp / COL_CNT;
c0024b61:	0f b7 c0             	movzwl %ax,%eax
c0024b64:	89 83 f8 18 00 00    	mov    %eax,0x18f8(%ebx)
        inited = true;
c0024b6a:	c6 83 f0 18 00 00 01 	movb   $0x1,0x18f0(%ebx)
c0024b71:	eb 82                	jmp    c0024af5 <vga_putc+0x22>

c0024b73 <.L14>:
c0024b73:	8b 8b f4 18 00 00    	mov    0x18f4(%ebx),%ecx
c0024b79:	8d b9 a0 0f 00 00    	lea    0xfa0(%ecx),%edi
vga_putc(int c) {
c0024b7f:	89 c8                	mov    %ecx,%eax
c0024b81:	8d 91 a0 00 00 00    	lea    0xa0(%ecx),%edx
        fb[y][x][0] = ' ';
c0024b87:	c6 00 20             	movb   $0x20,(%eax)
        fb[y][x][1] = GRAY_ON_BLACK;
c0024b8a:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024b8e:	83 c0 02             	add    $0x2,%eax
    for (x = 0; x < COL_CNT; x++) {
c0024b91:	39 d0                	cmp    %edx,%eax
c0024b93:	75 f2                	jne    c0024b87 <.L14+0x14>
c0024b95:	89 d1                	mov    %edx,%ecx
    for (y = 0; y < ROW_CNT; y++)
c0024b97:	39 d7                	cmp    %edx,%edi
c0024b99:	75 e4                	jne    c0024b7f <.L14+0xc>
    cx = cy = 0;
c0024b9b:	c7 83 f8 18 00 00 00 	movl   $0x0,0x18f8(%ebx)
c0024ba2:	00 00 00 
c0024ba5:	c7 83 fc 18 00 00 00 	movl   $0x0,0x18fc(%ebx)
c0024bac:	00 00 00 
    move_cursor();
c0024baf:	e8 71 fe ff ff       	call   c0024a25 <move_cursor>
c0024bb4:	eb 05                	jmp    c0024bbb <.L15+0x5>

c0024bb6 <.L15>:
            newline();
c0024bb6:	e8 a0 fe ff ff       	call   c0024a5b <newline>
    move_cursor();
c0024bbb:	e8 65 fe ff ff       	call   c0024a25 <move_cursor>
    intr_set_level(old_level);
c0024bc0:	83 ec 0c             	sub    $0xc,%esp
c0024bc3:	56                   	push   %esi
c0024bc4:	e8 4d d1 ff ff       	call   c0021d16 <intr_set_level>
}
c0024bc9:	83 c4 1c             	add    $0x1c,%esp
c0024bcc:	5b                   	pop    %ebx
c0024bcd:	5e                   	pop    %esi
c0024bce:	5f                   	pop    %edi
c0024bcf:	5d                   	pop    %ebp
c0024bd0:	c3                   	ret    

c0024bd1 <.L17>:
            if (cx > 0)
c0024bd1:	8b 83 fc 18 00 00    	mov    0x18fc(%ebx),%eax
c0024bd7:	85 c0                	test   %eax,%eax
c0024bd9:	74 e0                	je     c0024bbb <.L15+0x5>
                cx--;
c0024bdb:	83 e8 01             	sub    $0x1,%eax
c0024bde:	89 83 fc 18 00 00    	mov    %eax,0x18fc(%ebx)
c0024be4:	eb d5                	jmp    c0024bbb <.L15+0x5>

c0024be6 <.L12>:
            cx = 0;
c0024be6:	c7 83 fc 18 00 00 00 	movl   $0x0,0x18fc(%ebx)
c0024bed:	00 00 00 
            break;
c0024bf0:	eb c9                	jmp    c0024bbb <.L15+0x5>

c0024bf2 <.L16>:
            cx = ROUND_UP (cx + 1, 8);
c0024bf2:	8b 83 fc 18 00 00    	mov    0x18fc(%ebx),%eax
c0024bf8:	83 c0 08             	add    $0x8,%eax
c0024bfb:	83 e0 f8             	and    $0xfffffff8,%eax
c0024bfe:	89 83 fc 18 00 00    	mov    %eax,0x18fc(%ebx)
            if (cx >= COL_CNT)
c0024c04:	83 f8 4f             	cmp    $0x4f,%eax
c0024c07:	76 b2                	jbe    c0024bbb <.L15+0x5>
                newline();
c0024c09:	e8 4d fe ff ff       	call   c0024a5b <newline>
c0024c0e:	eb ab                	jmp    c0024bbb <.L15+0x5>

c0024c10 <.L18>:
            intr_set_level(old_level);
c0024c10:	83 ec 0c             	sub    $0xc,%esp
c0024c13:	56                   	push   %esi
c0024c14:	e8 fd d0 ff ff       	call   c0021d16 <intr_set_level>
            speaker_beep();
c0024c19:	e8 92 21 00 00       	call   c0026db0 <speaker_beep>
            intr_disable();
c0024c1e:	e8 ec d0 ff ff       	call   c0021d0f <intr_disable>
            break;
c0024c23:	83 c4 10             	add    $0x10,%esp
c0024c26:	eb 93                	jmp    c0024bbb <.L15+0x5>

c0024c28 <.L11>:
            fb[cy][cx][0] = c;
c0024c28:	8b bb f4 18 00 00    	mov    0x18f4(%ebx),%edi
c0024c2e:	8b 83 f8 18 00 00    	mov    0x18f8(%ebx),%eax
c0024c34:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024c37:	c1 e0 05             	shl    $0x5,%eax
c0024c3a:	01 f8                	add    %edi,%eax
c0024c3c:	8b 8b fc 18 00 00    	mov    0x18fc(%ebx),%ecx
c0024c42:	0f b6 54 24 20       	movzbl 0x20(%esp),%edx
c0024c47:	88 14 48             	mov    %dl,(%eax,%ecx,2)
            fb[cy][cx][1] = GRAY_ON_BLACK;
c0024c4a:	8b 83 f8 18 00 00    	mov    0x18f8(%ebx),%eax
c0024c50:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024c53:	c1 e0 05             	shl    $0x5,%eax
c0024c56:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0024c59:	8b 83 fc 18 00 00    	mov    0x18fc(%ebx),%eax
c0024c5f:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
            if (++cx >= COL_CNT)
c0024c64:	8b 83 fc 18 00 00    	mov    0x18fc(%ebx),%eax
c0024c6a:	83 c0 01             	add    $0x1,%eax
c0024c6d:	89 83 fc 18 00 00    	mov    %eax,0x18fc(%ebx)
c0024c73:	83 f8 4f             	cmp    $0x4f,%eax
c0024c76:	0f 86 3f ff ff ff    	jbe    c0024bbb <.L15+0x5>
                newline();
c0024c7c:	e8 da fd ff ff       	call   c0024a5b <newline>
c0024c81:	e9 35 ff ff ff       	jmp    c0024bbb <.L15+0x5>

c0024c86 <init_poll>:
/* Initializes the serial port device for polling mode.
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll(void) {
c0024c86:	57                   	push   %edi
c0024c87:	56                   	push   %esi
c0024c88:	53                   	push   %ebx
c0024c89:	e8 6a a2 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024c8e:	81 c3 9a 64 01 00    	add    $0x1649a,%ebx
    ASSERT (mode == UNINIT);
c0024c94:	83 bb 8c 19 00 00 00 	cmpl   $0x0,0x198c(%ebx)
c0024c9b:	75 65                	jne    c0024d02 <init_poll+0x7c>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024c9d:	b9 00 00 00 00       	mov    $0x0,%ecx
c0024ca2:	bf f9 03 00 00       	mov    $0x3f9,%edi
c0024ca7:	89 c8                	mov    %ecx,%eax
c0024ca9:	89 fa                	mov    %edi,%edx
c0024cab:	ee                   	out    %al,(%dx)
c0024cac:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024cb1:	ee                   	out    %al,(%dx)
c0024cb2:	be fb 03 00 00       	mov    $0x3fb,%esi
c0024cb7:	b8 83 ff ff ff       	mov    $0xffffff83,%eax
c0024cbc:	89 f2                	mov    %esi,%edx
c0024cbe:	ee                   	out    %al,(%dx)
c0024cbf:	b8 0c 00 00 00       	mov    $0xc,%eax
c0024cc4:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024cc9:	ee                   	out    %al,(%dx)
c0024cca:	89 c8                	mov    %ecx,%eax
c0024ccc:	89 fa                	mov    %edi,%edx
c0024cce:	ee                   	out    %al,(%dx)
c0024ccf:	b8 03 00 00 00       	mov    $0x3,%eax
c0024cd4:	89 f2                	mov    %esi,%edx
c0024cd6:	ee                   	out    %al,(%dx)
c0024cd7:	b8 08 00 00 00       	mov    $0x8,%eax
c0024cdc:	ba fc 03 00 00       	mov    $0x3fc,%edx
c0024ce1:	ee                   	out    %al,(%dx)
    outb(IER_REG, 0);                    /* Turn off all interrupts. */
    outb(FCR_REG, 0);                    /* Disable FIFO. */
    set_serial(9600);                    /* 9.6 kbps, N-8-1. */
    outb(MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
    intq_init(&txq);
c0024ce2:	83 ec 0c             	sub    $0xc,%esp
c0024ce5:	8d 83 18 19 00 00    	lea    0x1918(%ebx),%eax
c0024ceb:	50                   	push   %eax
c0024cec:	e8 57 19 00 00       	call   c0026648 <intq_init>
    mode = POLL;
c0024cf1:	c7 83 8c 19 00 00 01 	movl   $0x1,0x198c(%ebx)
c0024cf8:	00 00 00 
}
c0024cfb:	83 c4 10             	add    $0x10,%esp
c0024cfe:	5b                   	pop    %ebx
c0024cff:	5e                   	pop    %esi
c0024d00:	5f                   	pop    %edi
c0024d01:	c3                   	ret    
    ASSERT (mode == UNINIT);
c0024d02:	83 ec 0c             	sub    $0xc,%esp
c0024d05:	8d 83 03 5f ff ff    	lea    -0xa0fd(%ebx),%eax
c0024d0b:	50                   	push   %eax
c0024d0c:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0024d12:	50                   	push   %eax
c0024d13:	8d 83 a8 41 ff ff    	lea    -0xbe58(%ebx),%eax
c0024d19:	50                   	push   %eax
c0024d1a:	6a 49                	push   $0x49
c0024d1c:	8d 83 12 5f ff ff    	lea    -0xa0ee(%ebx),%eax
c0024d22:	50                   	push   %eax
c0024d23:	e8 b2 43 00 00       	call   c00290da <debug_panic>

c0024d28 <write_ier>:
    outb(LCR_REG, LCR_N81);
}

/* Update interrupt enable register. */
static void
write_ier(void) {
c0024d28:	56                   	push   %esi
c0024d29:	53                   	push   %ebx
c0024d2a:	83 ec 04             	sub    $0x4,%esp
c0024d2d:	e8 c6 a1 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024d32:	81 c3 f6 63 01 00    	add    $0x163f6,%ebx
    uint8_t ier = 0;

    ASSERT (intr_get_level() == INTR_OFF);
c0024d38:	e8 80 cf ff ff       	call   c0021cbd <intr_get_level>
c0024d3d:	85 c0                	test   %eax,%eax
c0024d3f:	75 37                	jne    c0024d78 <write_ier+0x50>

    /* Enable transmit interrupt if we have any characters to
       transmit. */
    if (!intq_empty(&txq))
c0024d41:	83 ec 0c             	sub    $0xc,%esp
c0024d44:	8d 83 18 19 00 00    	lea    0x1918(%ebx),%eax
c0024d4a:	50                   	push   %eax
c0024d4b:	e8 34 19 00 00       	call   c0026684 <intq_empty>
c0024d50:	83 c4 10             	add    $0x10,%esp
        ier |= IER_XMIT;
c0024d53:	84 c0                	test   %al,%al
c0024d55:	0f 94 c0             	sete   %al
c0024d58:	8d 34 00             	lea    (%eax,%eax,1),%esi

    /* Enable receive interrupt if we have room to store any
       characters we receive. */
    if (!input_full())
c0024d5b:	e8 96 18 00 00       	call   c00265f6 <input_full>
        ier |= IER_RECV;
c0024d60:	89 f2                	mov    %esi,%edx
c0024d62:	83 ca 01             	or     $0x1,%edx
c0024d65:	84 c0                	test   %al,%al
c0024d67:	0f 44 f2             	cmove  %edx,%esi
c0024d6a:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0024d6f:	89 f0                	mov    %esi,%eax
c0024d71:	ee                   	out    %al,(%dx)

    outb(IER_REG, ier);
}
c0024d72:	83 c4 04             	add    $0x4,%esp
c0024d75:	5b                   	pop    %ebx
c0024d76:	5e                   	pop    %esi
c0024d77:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0024d78:	83 ec 0c             	sub    $0xc,%esp
c0024d7b:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0024d81:	50                   	push   %eax
c0024d82:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0024d88:	50                   	push   %eax
c0024d89:	8d 83 9c 41 ff ff    	lea    -0xbe64(%ebx),%eax
c0024d8f:	50                   	push   %eax
c0024d90:	68 af 00 00 00       	push   $0xaf
c0024d95:	8d 83 12 5f ff ff    	lea    -0xa0ee(%ebx),%eax
c0024d9b:	50                   	push   %eax
c0024d9c:	e8 39 43 00 00       	call   c00290da <debug_panic>

c0024da1 <serial_interrupt>:
    outb(THR_REG, byte);
}

/* Serial interrupt handler. */
static void
serial_interrupt(struct intr_frame *f UNUSED) {
c0024da1:	57                   	push   %edi
c0024da2:	56                   	push   %esi
c0024da3:	53                   	push   %ebx
c0024da4:	e8 4f a1 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024da9:	81 c3 7f 63 01 00    	add    $0x1637f,%ebx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024daf:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024db4:	ec                   	in     (%dx),%al
c0024db5:	be fd 03 00 00       	mov    $0x3fd,%esi
c0024dba:	bf f8 03 00 00       	mov    $0x3f8,%edi
       occasionally miss an interrupt running under QEMU. */
    inb(IIR_REG);

    /* As long as we have room to receive a byte, and the hardware
       has a byte for us, receive a byte.  */
    while (!input_full() && (inb(LSR_REG) & LSR_DR) != 0)
c0024dbf:	e8 32 18 00 00       	call   c00265f6 <input_full>
c0024dc4:	84 c0                	test   %al,%al
c0024dc6:	75 4d                	jne    c0024e15 <serial_interrupt+0x74>
c0024dc8:	89 f2                	mov    %esi,%edx
c0024dca:	ec                   	in     (%dx),%al
c0024dcb:	a8 01                	test   $0x1,%al
c0024dcd:	74 46                	je     c0024e15 <serial_interrupt+0x74>
c0024dcf:	89 fa                	mov    %edi,%edx
c0024dd1:	ec                   	in     (%dx),%al
        input_putc(inb(RBR_REG));
c0024dd2:	83 ec 0c             	sub    $0xc,%esp
c0024dd5:	0f b6 c0             	movzbl %al,%eax
c0024dd8:	50                   	push   %eax
c0024dd9:	e8 3d 17 00 00       	call   c002651b <input_putc>
c0024dde:	83 c4 10             	add    $0x10,%esp
c0024de1:	eb dc                	jmp    c0024dbf <serial_interrupt+0x1e>

    /* As long as we have a byte to transmit, and the hardware is
       ready to accept a byte for transmission, transmit a byte. */
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
        outb(THR_REG, intq_getc(&txq));
c0024de3:	83 ec 0c             	sub    $0xc,%esp
c0024de6:	56                   	push   %esi
c0024de7:	e8 da 1a 00 00       	call   c00268c6 <intq_getc>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024dec:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024df1:	ee                   	out    %al,(%dx)
c0024df2:	83 c4 10             	add    $0x10,%esp
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c0024df5:	83 ec 0c             	sub    $0xc,%esp
c0024df8:	56                   	push   %esi
c0024df9:	e8 86 18 00 00       	call   c0026684 <intq_empty>
c0024dfe:	83 c4 10             	add    $0x10,%esp
c0024e01:	84 c0                	test   %al,%al
c0024e03:	75 07                	jne    c0024e0c <serial_interrupt+0x6b>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024e05:	89 fa                	mov    %edi,%edx
c0024e07:	ec                   	in     (%dx),%al
c0024e08:	a8 20                	test   $0x20,%al
c0024e0a:	75 d7                	jne    c0024de3 <serial_interrupt+0x42>

    /* Update interrupt enable register based on queue status. */
    write_ier();
c0024e0c:	e8 17 ff ff ff       	call   c0024d28 <write_ier>
}
c0024e11:	5b                   	pop    %ebx
c0024e12:	5e                   	pop    %esi
c0024e13:	5f                   	pop    %edi
c0024e14:	c3                   	ret    
    while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c0024e15:	8d b3 18 19 00 00    	lea    0x1918(%ebx),%esi
c0024e1b:	bf fd 03 00 00       	mov    $0x3fd,%edi
c0024e20:	eb d3                	jmp    c0024df5 <serial_interrupt+0x54>

c0024e22 <putc_poll>:
putc_poll(uint8_t byte) {
c0024e22:	56                   	push   %esi
c0024e23:	53                   	push   %ebx
c0024e24:	83 ec 04             	sub    $0x4,%esp
c0024e27:	e8 cc a0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024e2c:	81 c3 fc 62 01 00    	add    $0x162fc,%ebx
c0024e32:	89 c6                	mov    %eax,%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0024e34:	e8 84 ce ff ff       	call   c0021cbd <intr_get_level>
c0024e39:	85 c0                	test   %eax,%eax
c0024e3b:	75 18                	jne    c0024e55 <putc_poll+0x33>
c0024e3d:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024e42:	ec                   	in     (%dx),%al
    while ((inb(LSR_REG) & LSR_THRE) == 0)
c0024e43:	a8 20                	test   $0x20,%al
c0024e45:	74 fb                	je     c0024e42 <putc_poll+0x20>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024e47:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024e4c:	89 f0                	mov    %esi,%eax
c0024e4e:	ee                   	out    %al,(%dx)
}
c0024e4f:	83 c4 04             	add    $0x4,%esp
c0024e52:	5b                   	pop    %ebx
c0024e53:	5e                   	pop    %esi
c0024e54:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0024e55:	83 ec 0c             	sub    $0xc,%esp
c0024e58:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0024e5e:	50                   	push   %eax
c0024e5f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0024e65:	50                   	push   %eax
c0024e66:	8d 83 90 41 ff ff    	lea    -0xbe70(%ebx),%eax
c0024e6c:	50                   	push   %eax
c0024e6d:	68 c2 00 00 00       	push   $0xc2
c0024e72:	8d 83 12 5f ff ff    	lea    -0xa0ee(%ebx),%eax
c0024e78:	50                   	push   %eax
c0024e79:	e8 5c 42 00 00       	call   c00290da <debug_panic>

c0024e7e <serial_init_queue>:
serial_init_queue(void) {
c0024e7e:	56                   	push   %esi
c0024e7f:	53                   	push   %ebx
c0024e80:	83 ec 04             	sub    $0x4,%esp
c0024e83:	e8 70 a0 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024e88:	81 c3 a0 62 01 00    	add    $0x162a0,%ebx
    if (mode == UNINIT)
c0024e8e:	83 bb 8c 19 00 00 00 	cmpl   $0x0,0x198c(%ebx)
c0024e95:	74 45                	je     c0024edc <serial_init_queue+0x5e>
    ASSERT (mode == POLL);
c0024e97:	83 bb 8c 19 00 00 01 	cmpl   $0x1,0x198c(%ebx)
c0024e9e:	75 43                	jne    c0024ee3 <serial_init_queue+0x65>
    intr_register_ext(0x20 + 4, serial_interrupt, "serial");
c0024ea0:	83 ec 04             	sub    $0x4,%esp
c0024ea3:	8d 83 36 5f ff ff    	lea    -0xa0ca(%ebx),%eax
c0024ea9:	50                   	push   %eax
c0024eaa:	8d 83 79 9c fe ff    	lea    -0x16387(%ebx),%eax
c0024eb0:	50                   	push   %eax
c0024eb1:	6a 24                	push   $0x24
c0024eb3:	e8 33 d0 ff ff       	call   c0021eeb <intr_register_ext>
    mode = QUEUE;
c0024eb8:	c7 83 8c 19 00 00 02 	movl   $0x2,0x198c(%ebx)
c0024ebf:	00 00 00 
    old_level = intr_disable();
c0024ec2:	e8 48 ce ff ff       	call   c0021d0f <intr_disable>
c0024ec7:	89 c6                	mov    %eax,%esi
    write_ier();
c0024ec9:	e8 5a fe ff ff       	call   c0024d28 <write_ier>
    intr_set_level(old_level);
c0024ece:	89 34 24             	mov    %esi,(%esp)
c0024ed1:	e8 40 ce ff ff       	call   c0021d16 <intr_set_level>
}
c0024ed6:	83 c4 14             	add    $0x14,%esp
c0024ed9:	5b                   	pop    %ebx
c0024eda:	5e                   	pop    %esi
c0024edb:	c3                   	ret    
        init_poll();
c0024edc:	e8 a5 fd ff ff       	call   c0024c86 <init_poll>
c0024ee1:	eb b4                	jmp    c0024e97 <serial_init_queue+0x19>
    ASSERT (mode == POLL);
c0024ee3:	83 ec 0c             	sub    $0xc,%esp
c0024ee6:	8d 83 29 5f ff ff    	lea    -0xa0d7(%ebx),%eax
c0024eec:	50                   	push   %eax
c0024eed:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0024ef3:	50                   	push   %eax
c0024ef4:	8d 83 b4 41 ff ff    	lea    -0xbe4c(%ebx),%eax
c0024efa:	50                   	push   %eax
c0024efb:	6a 5b                	push   $0x5b
c0024efd:	8d 83 12 5f ff ff    	lea    -0xa0ee(%ebx),%eax
c0024f03:	50                   	push   %eax
c0024f04:	e8 d1 41 00 00       	call   c00290da <debug_panic>

c0024f09 <serial_putc>:
serial_putc(uint8_t byte) {
c0024f09:	57                   	push   %edi
c0024f0a:	56                   	push   %esi
c0024f0b:	53                   	push   %ebx
c0024f0c:	e8 e7 9f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024f11:	81 c3 17 62 01 00    	add    $0x16217,%ebx
c0024f17:	8b 74 24 10          	mov    0x10(%esp),%esi
    enum intr_level old_level = intr_disable();
c0024f1b:	e8 ef cd ff ff       	call   c0021d0f <intr_disable>
c0024f20:	89 c7                	mov    %eax,%edi
    if (mode != QUEUE) {
c0024f22:	8b 83 8c 19 00 00    	mov    0x198c(%ebx),%eax
c0024f28:	83 f8 02             	cmp    $0x2,%eax
c0024f2b:	74 25                	je     c0024f52 <serial_putc+0x49>
        if (mode == UNINIT)
c0024f2d:	85 c0                	test   %eax,%eax
c0024f2f:	74 1a                	je     c0024f4b <serial_putc+0x42>
        putc_poll(byte);
c0024f31:	89 f0                	mov    %esi,%eax
c0024f33:	0f b6 c0             	movzbl %al,%eax
c0024f36:	e8 e7 fe ff ff       	call   c0024e22 <putc_poll>
    intr_set_level(old_level);
c0024f3b:	83 ec 0c             	sub    $0xc,%esp
c0024f3e:	57                   	push   %edi
c0024f3f:	e8 d2 cd ff ff       	call   c0021d16 <intr_set_level>
}
c0024f44:	83 c4 10             	add    $0x10,%esp
c0024f47:	5b                   	pop    %ebx
c0024f48:	5e                   	pop    %esi
c0024f49:	5f                   	pop    %edi
c0024f4a:	c3                   	ret    
            init_poll();
c0024f4b:	e8 36 fd ff ff       	call   c0024c86 <init_poll>
c0024f50:	eb df                	jmp    c0024f31 <serial_putc+0x28>
        if (old_level == INTR_OFF && intq_full(&txq)) {
c0024f52:	85 ff                	test   %edi,%edi
c0024f54:	74 1f                	je     c0024f75 <serial_putc+0x6c>
        intq_putc(&txq, byte);
c0024f56:	83 ec 08             	sub    $0x8,%esp
c0024f59:	89 f0                	mov    %esi,%eax
c0024f5b:	0f b6 f0             	movzbl %al,%esi
c0024f5e:	56                   	push   %esi
c0024f5f:	8d 83 18 19 00 00    	lea    0x1918(%ebx),%eax
c0024f65:	50                   	push   %eax
c0024f66:	e8 26 1a 00 00       	call   c0026991 <intq_putc>
        write_ier();
c0024f6b:	e8 b8 fd ff ff       	call   c0024d28 <write_ier>
c0024f70:	83 c4 10             	add    $0x10,%esp
c0024f73:	eb c6                	jmp    c0024f3b <serial_putc+0x32>
        if (old_level == INTR_OFF && intq_full(&txq)) {
c0024f75:	83 ec 0c             	sub    $0xc,%esp
c0024f78:	8d 83 18 19 00 00    	lea    0x1918(%ebx),%eax
c0024f7e:	50                   	push   %eax
c0024f7f:	e8 52 17 00 00       	call   c00266d6 <intq_full>
c0024f84:	83 c4 10             	add    $0x10,%esp
c0024f87:	84 c0                	test   %al,%al
c0024f89:	74 cb                	je     c0024f56 <serial_putc+0x4d>
            putc_poll(intq_getc(&txq));
c0024f8b:	83 ec 0c             	sub    $0xc,%esp
c0024f8e:	8d 83 18 19 00 00    	lea    0x1918(%ebx),%eax
c0024f94:	50                   	push   %eax
c0024f95:	e8 2c 19 00 00       	call   c00268c6 <intq_getc>
c0024f9a:	0f b6 c0             	movzbl %al,%eax
c0024f9d:	e8 80 fe ff ff       	call   c0024e22 <putc_poll>
c0024fa2:	83 c4 10             	add    $0x10,%esp
c0024fa5:	eb af                	jmp    c0024f56 <serial_putc+0x4d>

c0024fa7 <serial_flush>:
serial_flush(void) {
c0024fa7:	57                   	push   %edi
c0024fa8:	56                   	push   %esi
c0024fa9:	53                   	push   %ebx
c0024faa:	e8 49 9f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0024faf:	81 c3 79 61 01 00    	add    $0x16179,%ebx
    enum intr_level old_level = intr_disable();
c0024fb5:	e8 55 cd ff ff       	call   c0021d0f <intr_disable>
c0024fba:	89 c7                	mov    %eax,%edi
    while (!intq_empty(&txq))
c0024fbc:	8d b3 18 19 00 00    	lea    0x1918(%ebx),%esi
c0024fc2:	83 ec 0c             	sub    $0xc,%esp
c0024fc5:	56                   	push   %esi
c0024fc6:	e8 b9 16 00 00       	call   c0026684 <intq_empty>
c0024fcb:	83 c4 10             	add    $0x10,%esp
c0024fce:	84 c0                	test   %al,%al
c0024fd0:	75 16                	jne    c0024fe8 <serial_flush+0x41>
        putc_poll(intq_getc(&txq));
c0024fd2:	83 ec 0c             	sub    $0xc,%esp
c0024fd5:	56                   	push   %esi
c0024fd6:	e8 eb 18 00 00       	call   c00268c6 <intq_getc>
c0024fdb:	0f b6 c0             	movzbl %al,%eax
c0024fde:	e8 3f fe ff ff       	call   c0024e22 <putc_poll>
c0024fe3:	83 c4 10             	add    $0x10,%esp
c0024fe6:	eb da                	jmp    c0024fc2 <serial_flush+0x1b>
    intr_set_level(old_level);
c0024fe8:	83 ec 0c             	sub    $0xc,%esp
c0024feb:	57                   	push   %edi
c0024fec:	e8 25 cd ff ff       	call   c0021d16 <intr_set_level>
}
c0024ff1:	83 c4 10             	add    $0x10,%esp
c0024ff4:	5b                   	pop    %ebx
c0024ff5:	5e                   	pop    %esi
c0024ff6:	5f                   	pop    %edi
c0024ff7:	c3                   	ret    

c0024ff8 <serial_notify>:
serial_notify(void) {
c0024ff8:	53                   	push   %ebx
c0024ff9:	83 ec 08             	sub    $0x8,%esp
c0024ffc:	e8 f7 9e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025001:	81 c3 27 61 01 00    	add    $0x16127,%ebx
    ASSERT (intr_get_level() == INTR_OFF);
c0025007:	e8 b1 cc ff ff       	call   c0021cbd <intr_get_level>
c002500c:	85 c0                	test   %eax,%eax
c002500e:	75 0e                	jne    c002501e <serial_notify+0x26>
    if (mode == QUEUE)
c0025010:	83 bb 8c 19 00 00 02 	cmpl   $0x2,0x198c(%ebx)
c0025017:	74 2e                	je     c0025047 <serial_notify+0x4f>
}
c0025019:	83 c4 08             	add    $0x8,%esp
c002501c:	5b                   	pop    %ebx
c002501d:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c002501e:	83 ec 0c             	sub    $0xc,%esp
c0025021:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0025027:	50                   	push   %eax
c0025028:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002502e:	50                   	push   %eax
c002502f:	8d 83 80 41 ff ff    	lea    -0xbe80(%ebx),%eax
c0025035:	50                   	push   %eax
c0025036:	68 92 00 00 00       	push   $0x92
c002503b:	8d 83 12 5f ff ff    	lea    -0xa0ee(%ebx),%eax
c0025041:	50                   	push   %eax
c0025042:	e8 93 40 00 00       	call   c00290da <debug_panic>
        write_ier();
c0025047:	e8 dc fc ff ff       	call   c0024d28 <write_ier>
}
c002504c:	eb cb                	jmp    c0025019 <serial_notify+0x21>

c002504e <check_sector>:
}

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector(struct block *block, block_sector_t sector) {
c002504e:	53                   	push   %ebx
c002504f:	83 ec 08             	sub    $0x8,%esp
c0025052:	e8 b5 9e 00 00       	call   c002ef0c <__x86.get_pc_thunk.cx>
c0025057:	81 c1 d1 60 01 00    	add    $0x160d1,%ecx
    if (sector >= block->size) {
c002505d:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0025060:	39 d3                	cmp    %edx,%ebx
c0025062:	76 05                	jbe    c0025069 <check_sector+0x1b>
                       ", "
                       "size=%"
                       PRDSNu
                       ")\n", block_name(block), sector, block->size);
    }
}
c0025064:	83 c4 08             	add    $0x8,%esp
c0025067:	5b                   	pop    %ebx
c0025068:	c3                   	ret    
        PANIC ("Access past end of device %s (sector=%"
c0025069:	83 ec 04             	sub    $0x4,%esp
c002506c:	53                   	push   %ebx
c002506d:	52                   	push   %edx
}

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name(struct block *block) {
    return block->name;
c002506e:	83 c0 08             	add    $0x8,%eax
        PANIC ("Access past end of device %s (sector=%"
c0025071:	50                   	push   %eax
c0025072:	8d 81 40 5f ff ff    	lea    -0xa0c0(%ecx),%eax
c0025078:	50                   	push   %eax
c0025079:	8d 81 e4 41 ff ff    	lea    -0xbe1c(%ecx),%eax
c002507f:	50                   	push   %eax
c0025080:	6a 6a                	push   $0x6a
c0025082:	8d 81 ce 5f ff ff    	lea    -0xa032(%ecx),%eax
c0025088:	50                   	push   %eax
c0025089:	89 cb                	mov    %ecx,%ebx
c002508b:	e8 4a 40 00 00       	call   c00290da <debug_panic>

c0025090 <block_type_name>:
block_type_name(enum block_type type) {
c0025090:	53                   	push   %ebx
c0025091:	83 ec 08             	sub    $0x8,%esp
c0025094:	e8 5f 9e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025099:	81 c3 8f 60 01 00    	add    $0x1608f,%ebx
c002509f:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (type < BLOCK_CNT);
c00250a3:	83 f8 05             	cmp    $0x5,%eax
c00250a6:	77 0c                	ja     c00250b4 <block_type_name+0x24>
    return block_type_names[type];
c00250a8:	8b 84 83 68 78 ff ff 	mov    -0x8798(%ebx,%eax,4),%eax
}
c00250af:	83 c4 08             	add    $0x8,%esp
c00250b2:	5b                   	pop    %ebx
c00250b3:	c3                   	ret    
    ASSERT (type < BLOCK_CNT);
c00250b4:	83 ec 0c             	sub    $0xc,%esp
c00250b7:	8d 83 e4 5f ff ff    	lea    -0xa01c(%ebx),%eax
c00250bd:	50                   	push   %eax
c00250be:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00250c4:	50                   	push   %eax
c00250c5:	8d 83 14 42 ff ff    	lea    -0xbdec(%ebx),%eax
c00250cb:	50                   	push   %eax
c00250cc:	6a 2d                	push   $0x2d
c00250ce:	8d 83 ce 5f ff ff    	lea    -0xa032(%ebx),%eax
c00250d4:	50                   	push   %eax
c00250d5:	e8 00 40 00 00       	call   c00290da <debug_panic>

c00250da <block_get_role>:
block_get_role(enum block_type role) {
c00250da:	53                   	push   %ebx
c00250db:	83 ec 08             	sub    $0x8,%esp
c00250de:	e8 15 9e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00250e3:	81 c3 45 60 01 00    	add    $0x16045,%ebx
c00250e9:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (role < BLOCK_ROLE_CNT);
c00250ed:	83 f8 03             	cmp    $0x3,%eax
c00250f0:	77 0c                	ja     c00250fe <block_get_role+0x24>
    return block_by_role[role];
c00250f2:	8b 84 83 90 19 00 00 	mov    0x1990(%ebx,%eax,4),%eax
}
c00250f9:	83 c4 08             	add    $0x8,%esp
c00250fc:	5b                   	pop    %ebx
c00250fd:	c3                   	ret    
    ASSERT (role < BLOCK_ROLE_CNT);
c00250fe:	83 ec 0c             	sub    $0xc,%esp
c0025101:	8d 83 f5 5f ff ff    	lea    -0xa00b(%ebx),%eax
c0025107:	50                   	push   %eax
c0025108:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002510e:	50                   	push   %eax
c002510f:	8d 83 04 42 ff ff    	lea    -0xbdfc(%ebx),%eax
c0025115:	50                   	push   %eax
c0025116:	6a 35                	push   $0x35
c0025118:	8d 83 ce 5f ff ff    	lea    -0xa032(%ebx),%eax
c002511e:	50                   	push   %eax
c002511f:	e8 b6 3f 00 00       	call   c00290da <debug_panic>

c0025124 <block_set_role>:
block_set_role(enum block_type role, struct block *block) {
c0025124:	53                   	push   %ebx
c0025125:	83 ec 08             	sub    $0x8,%esp
c0025128:	e8 cb 9d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002512d:	81 c3 fb 5f 01 00    	add    $0x15ffb,%ebx
c0025133:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (role < BLOCK_ROLE_CNT);
c0025137:	83 f8 03             	cmp    $0x3,%eax
c002513a:	77 10                	ja     c002514c <block_set_role+0x28>
    block_by_role[role] = block;
c002513c:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0025140:	89 8c 83 90 19 00 00 	mov    %ecx,0x1990(%ebx,%eax,4)
}
c0025147:	83 c4 08             	add    $0x8,%esp
c002514a:	5b                   	pop    %ebx
c002514b:	c3                   	ret    
    ASSERT (role < BLOCK_ROLE_CNT);
c002514c:	83 ec 0c             	sub    $0xc,%esp
c002514f:	8d 83 f5 5f ff ff    	lea    -0xa00b(%ebx),%eax
c0025155:	50                   	push   %eax
c0025156:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002515c:	50                   	push   %eax
c002515d:	8d 83 f4 41 ff ff    	lea    -0xbe0c(%ebx),%eax
c0025163:	50                   	push   %eax
c0025164:	6a 3c                	push   $0x3c
c0025166:	8d 83 ce 5f ff ff    	lea    -0xa032(%ebx),%eax
c002516c:	50                   	push   %eax
c002516d:	e8 68 3f 00 00       	call   c00290da <debug_panic>

c0025172 <block_first>:
block_first(void) {
c0025172:	57                   	push   %edi
c0025173:	56                   	push   %esi
c0025174:	53                   	push   %ebx
c0025175:	e8 7e 9d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002517a:	81 c3 ae 5f 01 00    	add    $0x15fae,%ebx
    return list_elem_to_block(list_begin(&all_blocks));
c0025180:	83 ec 0c             	sub    $0xc,%esp
c0025183:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c0025189:	57                   	push   %edi
c002518a:	e8 70 40 00 00       	call   c00291ff <list_begin>
c002518f:	89 c6                	mov    %eax,%esi

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block(struct list_elem *list_elem) {
    return (list_elem != list_end(&all_blocks)
c0025191:	89 3c 24             	mov    %edi,(%esp)
c0025194:	e8 08 41 00 00       	call   c00292a1 <list_end>
            ? list_entry (list_elem, struct block, list_elem)
            : NULL);
c0025199:	83 c4 10             	add    $0x10,%esp
c002519c:	39 c6                	cmp    %eax,%esi
c002519e:	b8 00 00 00 00       	mov    $0x0,%eax
c00251a3:	0f 44 f0             	cmove  %eax,%esi
}
c00251a6:	89 f0                	mov    %esi,%eax
c00251a8:	5b                   	pop    %ebx
c00251a9:	5e                   	pop    %esi
c00251aa:	5f                   	pop    %edi
c00251ab:	c3                   	ret    

c00251ac <block_next>:
block_next(struct block *block) {
c00251ac:	56                   	push   %esi
c00251ad:	53                   	push   %ebx
c00251ae:	83 ec 10             	sub    $0x10,%esp
c00251b1:	e8 42 9d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00251b6:	81 c3 72 5f 01 00    	add    $0x15f72,%ebx
    return list_elem_to_block(list_next(&block->list_elem));
c00251bc:	ff 74 24 1c          	pushl  0x1c(%esp)
c00251c0:	e8 7f 40 00 00       	call   c0029244 <list_next>
c00251c5:	89 c6                	mov    %eax,%esi
    return (list_elem != list_end(&all_blocks)
c00251c7:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c00251cd:	89 04 24             	mov    %eax,(%esp)
c00251d0:	e8 cc 40 00 00       	call   c00292a1 <list_end>
            : NULL);
c00251d5:	39 c6                	cmp    %eax,%esi
c00251d7:	b8 00 00 00 00       	mov    $0x0,%eax
c00251dc:	0f 44 f0             	cmove  %eax,%esi
}
c00251df:	89 f0                	mov    %esi,%eax
c00251e1:	83 c4 14             	add    $0x14,%esp
c00251e4:	5b                   	pop    %ebx
c00251e5:	5e                   	pop    %esi
c00251e6:	c3                   	ret    

c00251e7 <block_get_by_name>:
block_get_by_name(const char *name) {
c00251e7:	55                   	push   %ebp
c00251e8:	57                   	push   %edi
c00251e9:	56                   	push   %esi
c00251ea:	53                   	push   %ebx
c00251eb:	83 ec 18             	sub    $0x18,%esp
c00251ee:	e8 05 9d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00251f3:	81 c3 35 5f 01 00    	add    $0x15f35,%ebx
c00251f9:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    for (e = list_begin(&all_blocks); e != list_end(&all_blocks);
c00251fd:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c0025203:	50                   	push   %eax
c0025204:	e8 f6 3f 00 00       	call   c00291ff <list_begin>
c0025209:	89 c6                	mov    %eax,%esi
c002520b:	83 c4 10             	add    $0x10,%esp
c002520e:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c0025214:	83 ec 0c             	sub    $0xc,%esp
c0025217:	57                   	push   %edi
c0025218:	e8 84 40 00 00       	call   c00292a1 <list_end>
c002521d:	83 c4 10             	add    $0x10,%esp
c0025220:	39 f0                	cmp    %esi,%eax
c0025222:	74 24                	je     c0025248 <block_get_by_name+0x61>
        if (!strcmp(name, block->name))
c0025224:	8d 46 08             	lea    0x8(%esi),%eax
c0025227:	83 ec 08             	sub    $0x8,%esp
c002522a:	50                   	push   %eax
c002522b:	55                   	push   %ebp
c002522c:	e8 5f 31 00 00       	call   c0028390 <strcmp>
c0025231:	83 c4 10             	add    $0x10,%esp
c0025234:	85 c0                	test   %eax,%eax
c0025236:	74 15                	je     c002524d <block_get_by_name+0x66>
         e = list_next(e)) {
c0025238:	83 ec 0c             	sub    $0xc,%esp
c002523b:	56                   	push   %esi
c002523c:	e8 03 40 00 00       	call   c0029244 <list_next>
c0025241:	89 c6                	mov    %eax,%esi
c0025243:	83 c4 10             	add    $0x10,%esp
c0025246:	eb cc                	jmp    c0025214 <block_get_by_name+0x2d>
    return NULL;
c0025248:	be 00 00 00 00       	mov    $0x0,%esi
}
c002524d:	89 f0                	mov    %esi,%eax
c002524f:	83 c4 0c             	add    $0xc,%esp
c0025252:	5b                   	pop    %ebx
c0025253:	5e                   	pop    %esi
c0025254:	5f                   	pop    %edi
c0025255:	5d                   	pop    %ebp
c0025256:	c3                   	ret    

c0025257 <block_read>:
block_read(struct block *block, block_sector_t sector, void *buffer) {
c0025257:	56                   	push   %esi
c0025258:	53                   	push   %ebx
c0025259:	83 ec 04             	sub    $0x4,%esp
c002525c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0025260:	8b 74 24 14          	mov    0x14(%esp),%esi
    check_sector(block, sector);
c0025264:	89 f2                	mov    %esi,%edx
c0025266:	89 d8                	mov    %ebx,%eax
c0025268:	e8 e1 fd ff ff       	call   c002504e <check_sector>
    block->ops->read(block->aux, sector, buffer);
c002526d:	83 ec 04             	sub    $0x4,%esp
c0025270:	8b 43 20             	mov    0x20(%ebx),%eax
c0025273:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025277:	56                   	push   %esi
c0025278:	ff 73 24             	pushl  0x24(%ebx)
c002527b:	ff 10                	call   *(%eax)
    block->read_cnt++;
c002527d:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c0025281:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c0025285:	83 c4 14             	add    $0x14,%esp
c0025288:	5b                   	pop    %ebx
c0025289:	5e                   	pop    %esi
c002528a:	c3                   	ret    

c002528b <block_write>:
block_write(struct block *block, block_sector_t sector, const void *buffer) {
c002528b:	57                   	push   %edi
c002528c:	56                   	push   %esi
c002528d:	53                   	push   %ebx
c002528e:	e8 65 9c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025293:	81 c3 95 5e 01 00    	add    $0x15e95,%ebx
c0025299:	8b 74 24 10          	mov    0x10(%esp),%esi
c002529d:	8b 7c 24 14          	mov    0x14(%esp),%edi
    check_sector(block, sector);
c00252a1:	89 fa                	mov    %edi,%edx
c00252a3:	89 f0                	mov    %esi,%eax
c00252a5:	e8 a4 fd ff ff       	call   c002504e <check_sector>
    ASSERT (block->type != BLOCK_FOREIGN);
c00252aa:	83 7e 18 05          	cmpl   $0x5,0x18(%esi)
c00252ae:	74 20                	je     c00252d0 <block_write+0x45>
    block->ops->write(block->aux, sector, buffer);
c00252b0:	83 ec 04             	sub    $0x4,%esp
c00252b3:	8b 46 20             	mov    0x20(%esi),%eax
c00252b6:	ff 74 24 1c          	pushl  0x1c(%esp)
c00252ba:	57                   	push   %edi
c00252bb:	ff 76 24             	pushl  0x24(%esi)
c00252be:	ff 50 04             	call   *0x4(%eax)
    block->write_cnt++;
c00252c1:	83 46 30 01          	addl   $0x1,0x30(%esi)
c00252c5:	83 56 34 00          	adcl   $0x0,0x34(%esi)
}
c00252c9:	83 c4 10             	add    $0x10,%esp
c00252cc:	5b                   	pop    %ebx
c00252cd:	5e                   	pop    %esi
c00252ce:	5f                   	pop    %edi
c00252cf:	c3                   	ret    
    ASSERT (block->type != BLOCK_FOREIGN);
c00252d0:	83 ec 0c             	sub    $0xc,%esp
c00252d3:	8d 83 0b 60 ff ff    	lea    -0x9ff5(%ebx),%eax
c00252d9:	50                   	push   %eax
c00252da:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00252e0:	50                   	push   %eax
c00252e1:	8d 83 d8 41 ff ff    	lea    -0xbe28(%ebx),%eax
c00252e7:	50                   	push   %eax
c00252e8:	68 81 00 00 00       	push   $0x81
c00252ed:	8d 83 ce 5f ff ff    	lea    -0xa032(%ebx),%eax
c00252f3:	50                   	push   %eax
c00252f4:	e8 e1 3d 00 00       	call   c00290da <debug_panic>

c00252f9 <block_size>:
    return block->size;
c00252f9:	8b 44 24 04          	mov    0x4(%esp),%eax
c00252fd:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0025300:	c3                   	ret    

c0025301 <block_name>:
    return block->name;
c0025301:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025305:	83 c0 08             	add    $0x8,%eax
}
c0025308:	c3                   	ret    

c0025309 <block_type>:
    return block->type;
c0025309:	8b 44 24 04          	mov    0x4(%esp),%eax
c002530d:	8b 40 18             	mov    0x18(%eax),%eax
}
c0025310:	c3                   	ret    

c0025311 <block_print_stats>:
block_print_stats(void) {
c0025311:	55                   	push   %ebp
c0025312:	57                   	push   %edi
c0025313:	56                   	push   %esi
c0025314:	53                   	push   %ebx
c0025315:	83 ec 1c             	sub    $0x1c,%esp
c0025318:	e8 db 9b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002531d:	81 c3 0b 5e 01 00    	add    $0x15e0b,%ebx
    for (i = 0; i < BLOCK_ROLE_CNT; i++) {
c0025323:	8d bb 90 19 00 00    	lea    0x1990(%ebx),%edi
c0025329:	8d 6f 10             	lea    0x10(%edi),%ebp
            printf("%s (%s): %llu reads, %llu writes\n",
c002532c:	8d 83 74 5f ff ff    	lea    -0xa08c(%ebx),%eax
c0025332:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0025336:	eb 32                	jmp    c002536a <block_print_stats+0x59>
c0025338:	83 ec 0c             	sub    $0xc,%esp
c002533b:	ff 76 18             	pushl  0x18(%esi)
c002533e:	e8 4d fd ff ff       	call   c0025090 <block_type_name>
c0025343:	83 c4 0c             	add    $0xc,%esp
c0025346:	ff 76 34             	pushl  0x34(%esi)
c0025349:	ff 76 30             	pushl  0x30(%esi)
c002534c:	ff 76 2c             	pushl  0x2c(%esi)
c002534f:	ff 76 28             	pushl  0x28(%esi)
c0025352:	50                   	push   %eax
c0025353:	83 c6 08             	add    $0x8,%esi
c0025356:	56                   	push   %esi
c0025357:	ff 74 24 28          	pushl  0x28(%esp)
c002535b:	e8 1e 21 00 00       	call   c002747e <printf>
c0025360:	83 c4 20             	add    $0x20,%esp
c0025363:	83 c7 04             	add    $0x4,%edi
    for (i = 0; i < BLOCK_ROLE_CNT; i++) {
c0025366:	39 ef                	cmp    %ebp,%edi
c0025368:	74 08                	je     c0025372 <block_print_stats+0x61>
        struct block *block = block_by_role[i];
c002536a:	8b 37                	mov    (%edi),%esi
        if (block != NULL) {
c002536c:	85 f6                	test   %esi,%esi
c002536e:	75 c8                	jne    c0025338 <block_print_stats+0x27>
c0025370:	eb f1                	jmp    c0025363 <block_print_stats+0x52>
}
c0025372:	83 c4 1c             	add    $0x1c,%esp
c0025375:	5b                   	pop    %ebx
c0025376:	5e                   	pop    %esi
c0025377:	5f                   	pop    %edi
c0025378:	5d                   	pop    %ebp
c0025379:	c3                   	ret    

c002537a <block_register>:
               const struct block_operations *ops, void *aux) {
c002537a:	55                   	push   %ebp
c002537b:	57                   	push   %edi
c002537c:	56                   	push   %esi
c002537d:	53                   	push   %ebx
c002537e:	83 ec 18             	sub    $0x18,%esp
c0025381:	e8 72 9b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025386:	81 c3 a2 5d 01 00    	add    $0x15da2,%ebx
c002538c:	8b 7c 24 38          	mov    0x38(%esp),%edi
    struct block *block = malloc(sizeof *block);
c0025390:	6a 38                	push   $0x38
c0025392:	e8 64 ea ff ff       	call   c0023dfb <malloc>
    if (block == NULL)
c0025397:	83 c4 10             	add    $0x10,%esp
c002539a:	85 c0                	test   %eax,%eax
c002539c:	0f 84 c6 00 00 00    	je     c0025468 <block_register+0xee>
c00253a2:	89 c6                	mov    %eax,%esi
    list_push_back(&all_blocks, &block->list_elem);
c00253a4:	83 ec 08             	sub    $0x8,%esp
c00253a7:	50                   	push   %eax
c00253a8:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c00253ae:	50                   	push   %eax
c00253af:	e8 d8 43 00 00       	call   c002978c <list_push_back>
    strlcpy(block->name, name, sizeof block->name);
c00253b4:	8d 6e 08             	lea    0x8(%esi),%ebp
c00253b7:	83 c4 0c             	add    $0xc,%esp
c00253ba:	6a 10                	push   $0x10
c00253bc:	ff 74 24 28          	pushl  0x28(%esp)
c00253c0:	55                   	push   %ebp
c00253c1:	e8 56 33 00 00       	call   c002871c <strlcpy>
    block->type = type;
c00253c6:	8b 44 24 34          	mov    0x34(%esp),%eax
c00253ca:	89 46 18             	mov    %eax,0x18(%esi)
    block->size = size;
c00253cd:	89 7e 1c             	mov    %edi,0x1c(%esi)
    block->ops = ops;
c00253d0:	8b 44 24 40          	mov    0x40(%esp),%eax
c00253d4:	89 46 20             	mov    %eax,0x20(%esi)
    block->aux = aux;
c00253d7:	8b 44 24 44          	mov    0x44(%esp),%eax
c00253db:	89 46 24             	mov    %eax,0x24(%esi)
    block->read_cnt = 0;
c00253de:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c00253e5:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
    block->write_cnt = 0;
c00253ec:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
c00253f3:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
    printf("%s: %'"PRDSNu" sectors (", block->name, block->size);
c00253fa:	83 c4 0c             	add    $0xc,%esp
c00253fd:	57                   	push   %edi
c00253fe:	55                   	push   %ebp
c00253ff:	8d 83 28 60 ff ff    	lea    -0x9fd8(%ebx),%eax
c0025405:	50                   	push   %eax
c0025406:	e8 73 20 00 00       	call   c002747e <printf>
    print_human_readable_size((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c002540b:	83 c4 08             	add    $0x8,%esp
c002540e:	8b 7e 1c             	mov    0x1c(%esi),%edi
c0025411:	bd 00 00 00 00       	mov    $0x0,%ebp
c0025416:	89 f8                	mov    %edi,%eax
c0025418:	89 ea                	mov    %ebp,%edx
c002541a:	0f a4 fa 09          	shld   $0x9,%edi,%edx
c002541e:	c1 e0 09             	shl    $0x9,%eax
c0025421:	52                   	push   %edx
c0025422:	50                   	push   %eax
c0025423:	e8 1c 2a 00 00       	call   c0027e44 <print_human_readable_size>
    printf(")");
c0025428:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c002542f:	e8 ee 5c 00 00       	call   c002b122 <putchar>
    if (extra_info != NULL)
c0025434:	83 c4 10             	add    $0x10,%esp
c0025437:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c002543c:	74 16                	je     c0025454 <block_register+0xda>
        printf(", %s", extra_info);
c002543e:	83 ec 08             	sub    $0x8,%esp
c0025441:	ff 74 24 30          	pushl  0x30(%esp)
c0025445:	8d 83 3a 60 ff ff    	lea    -0x9fc6(%ebx),%eax
c002544b:	50                   	push   %eax
c002544c:	e8 2d 20 00 00       	call   c002747e <printf>
c0025451:	83 c4 10             	add    $0x10,%esp
    printf("\n");
c0025454:	83 ec 0c             	sub    $0xc,%esp
c0025457:	6a 0a                	push   $0xa
c0025459:	e8 c4 5c 00 00       	call   c002b122 <putchar>
}
c002545e:	89 f0                	mov    %esi,%eax
c0025460:	83 c4 1c             	add    $0x1c,%esp
c0025463:	5b                   	pop    %ebx
c0025464:	5e                   	pop    %esi
c0025465:	5f                   	pop    %edi
c0025466:	5d                   	pop    %ebp
c0025467:	c3                   	ret    
        PANIC ("Failed to allocate memory for block device descriptor");
c0025468:	8d 83 98 5f ff ff    	lea    -0xa068(%ebx),%eax
c002546e:	50                   	push   %eax
c002546f:	8d 83 c8 41 ff ff    	lea    -0xbe38(%ebx),%eax
c0025475:	50                   	push   %eax
c0025476:	68 b2 00 00 00       	push   $0xb2
c002547b:	8d 83 ce 5f ff ff    	lea    -0xa032(%ebx),%eax
c0025481:	50                   	push   %eax
c0025482:	e8 53 3c 00 00       	call   c00290da <debug_panic>

c0025487 <partition_read>:
}

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read(void *p_, block_sector_t sector, void *buffer) {
c0025487:	53                   	push   %ebx
c0025488:	83 ec 0c             	sub    $0xc,%esp
c002548b:	e8 68 9a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025490:	81 c3 98 5c 01 00    	add    $0x15c98,%ebx
c0025496:	8b 54 24 14          	mov    0x14(%esp),%edx
    struct partition *p = p_;
    block_read(p->block, p->start + sector, buffer);
c002549a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002549e:	8b 42 04             	mov    0x4(%edx),%eax
c00254a1:	03 44 24 1c          	add    0x1c(%esp),%eax
c00254a5:	50                   	push   %eax
c00254a6:	ff 32                	pushl  (%edx)
c00254a8:	e8 aa fd ff ff       	call   c0025257 <block_read>
}
c00254ad:	83 c4 18             	add    $0x18,%esp
c00254b0:	5b                   	pop    %ebx
c00254b1:	c3                   	ret    

c00254b2 <read_partition_table>:
                     int *part_nr) {
c00254b2:	55                   	push   %ebp
c00254b3:	57                   	push   %edi
c00254b4:	56                   	push   %esi
c00254b5:	53                   	push   %ebx
c00254b6:	81 ec d8 00 00 00    	sub    $0xd8,%esp
c00254bc:	e8 37 9a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00254c1:	81 c3 67 5c 01 00    	add    $0x15c67,%ebx
c00254c7:	89 c6                	mov    %eax,%esi
c00254c9:	89 d7                	mov    %edx,%edi
c00254cb:	89 54 24 10          	mov    %edx,0x10(%esp)
c00254cf:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    if (sector >= block_size(block)) {
c00254d3:	50                   	push   %eax
c00254d4:	e8 20 fe ff ff       	call   c00252f9 <block_size>
c00254d9:	83 c4 10             	add    $0x10,%esp
c00254dc:	39 f8                	cmp    %edi,%eax
c00254de:	76 65                	jbe    c0025545 <read_partition_table+0x93>
    pt = malloc(sizeof *pt);
c00254e0:	83 ec 0c             	sub    $0xc,%esp
c00254e3:	68 00 02 00 00       	push   $0x200
c00254e8:	e8 0e e9 ff ff       	call   c0023dfb <malloc>
c00254ed:	89 c5                	mov    %eax,%ebp
    if (pt == NULL)
c00254ef:	83 c4 10             	add    $0x10,%esp
c00254f2:	85 c0                	test   %eax,%eax
c00254f4:	74 7a                	je     c0025570 <read_partition_table+0xbe>
    block_read(block, 0, pt);
c00254f6:	83 ec 04             	sub    $0x4,%esp
c00254f9:	50                   	push   %eax
c00254fa:	6a 00                	push   $0x0
c00254fc:	56                   	push   %esi
c00254fd:	e8 55 fd ff ff       	call   c0025257 <block_read>
    if (pt->signature != 0xaa55) {
c0025502:	83 c4 10             	add    $0x10,%esp
c0025505:	66 81 bd fe 01 00 00 	cmpw   $0xaa55,0x1fe(%ebp)
c002550c:	55 aa 
c002550e:	0f 84 9a 00 00 00    	je     c00255ae <read_partition_table+0xfc>
        if (primary_extended_sector == 0)
c0025514:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0025519:	75 71                	jne    c002558c <read_partition_table+0xda>
            printf("%s: Invalid partition table signature\n", block_name(block));
c002551b:	83 ec 0c             	sub    $0xc,%esp
c002551e:	56                   	push   %esi
c002551f:	e8 dd fd ff ff       	call   c0025301 <block_name>
c0025524:	83 c4 08             	add    $0x8,%esp
c0025527:	50                   	push   %eax
c0025528:	8d 83 4c 65 ff ff    	lea    -0x9ab4(%ebx),%eax
c002552e:	50                   	push   %eax
c002552f:	e8 4a 1f 00 00       	call   c002747e <printf>
c0025534:	83 c4 10             	add    $0x10,%esp
        free(pt);
c0025537:	83 ec 0c             	sub    $0xc,%esp
c002553a:	55                   	push   %ebp
c002553b:	e8 69 ea ff ff       	call   c0023fa9 <free>
        return;
c0025540:	83 c4 10             	add    $0x10,%esp
c0025543:	eb 20                	jmp    c0025565 <read_partition_table+0xb3>
        printf("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025545:	83 ec 0c             	sub    $0xc,%esp
c0025548:	56                   	push   %esi
c0025549:	e8 b3 fd ff ff       	call   c0025301 <block_name>
c002554e:	83 c4 0c             	add    $0xc,%esp
c0025551:	ff 74 24 08          	pushl  0x8(%esp)
c0025555:	50                   	push   %eax
c0025556:	8d 83 e4 64 ff ff    	lea    -0x9b1c(%ebx),%eax
c002555c:	50                   	push   %eax
c002555d:	e8 1c 1f 00 00       	call   c002747e <printf>
        return;
c0025562:	83 c4 10             	add    $0x10,%esp
}
c0025565:	81 c4 cc 00 00 00    	add    $0xcc,%esp
c002556b:	5b                   	pop    %ebx
c002556c:	5e                   	pop    %esi
c002556d:	5f                   	pop    %edi
c002556e:	5d                   	pop    %ebp
c002556f:	c3                   	ret    
        PANIC ("Failed to allocate memory for partition table.");
c0025570:	8d 83 1c 65 ff ff    	lea    -0x9ae4(%ebx),%eax
c0025576:	50                   	push   %eax
c0025577:	8d 83 34 42 ff ff    	lea    -0xbdcc(%ebx),%eax
c002557d:	50                   	push   %eax
c002557e:	6a 56                	push   $0x56
c0025580:	8d 83 53 60 ff ff    	lea    -0x9fad(%ebx),%eax
c0025586:	50                   	push   %eax
c0025587:	e8 4e 3b 00 00       	call   c00290da <debug_panic>
            printf("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c002558c:	83 ec 0c             	sub    $0xc,%esp
c002558f:	56                   	push   %esi
c0025590:	e8 6c fd ff ff       	call   c0025301 <block_name>
c0025595:	83 c4 0c             	add    $0xc,%esp
c0025598:	ff 74 24 08          	pushl  0x8(%esp)
c002559c:	50                   	push   %eax
c002559d:	8d 83 74 65 ff ff    	lea    -0x9a8c(%ebx),%eax
c00255a3:	50                   	push   %eax
c00255a4:	e8 d5 1e 00 00       	call   c002747e <printf>
c00255a9:	83 c4 10             	add    $0x10,%esp
c00255ac:	eb 89                	jmp    c0025537 <read_partition_table+0x85>
c00255ae:	8d bd c2 01 00 00    	lea    0x1c2(%ebp),%edi
c00255b4:	8d 85 02 02 00 00    	lea    0x202(%ebp),%eax
c00255ba:	89 44 24 08          	mov    %eax,0x8(%esp)
            printf("%s: Extended partition in sector %"PRDSNu"\n",
c00255be:	8d 83 a8 65 ff ff    	lea    -0x9a58(%ebx),%eax
c00255c4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        printf("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c00255c8:	8d 83 08 66 ff ff    	lea    -0x99f8(%ebx),%eax
c00255ce:	89 44 24 20          	mov    %eax,0x20(%esp)
c00255d2:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c00255d6:	89 74 24 14          	mov    %esi,0x14(%esp)
c00255da:	eb 30                	jmp    c002560c <read_partition_table+0x15a>
                read_partition_table(block, e->offset + primary_extended_sector,
c00255dc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00255e0:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00255e4:	89 ca                	mov    %ecx,%edx
c00255e6:	03 50 04             	add    0x4(%eax),%edx
c00255e9:	83 ec 0c             	sub    $0xc,%esp
c00255ec:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c00255f3:	8b 44 24 24          	mov    0x24(%esp),%eax
c00255f7:	e8 b6 fe ff ff       	call   c00254b2 <read_partition_table>
c00255fc:	83 c4 10             	add    $0x10,%esp
c00255ff:	83 c7 10             	add    $0x10,%edi
    for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++) {
c0025602:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c0025606:	0f 84 f0 01 00 00    	je     c00257fc <read_partition_table+0x34a>
        if (e->size == 0 || e->type == 0) {
c002560c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0025610:	8b 77 08             	mov    0x8(%edi),%esi
c0025613:	85 f6                	test   %esi,%esi
c0025615:	74 e8                	je     c00255ff <read_partition_table+0x14d>
c0025617:	0f b6 2f             	movzbl (%edi),%ebp
c002561a:	89 e8                	mov    %ebp,%eax
c002561c:	84 c0                	test   %al,%al
c002561e:	74 df                	je     c00255ff <read_partition_table+0x14d>
                   || e->type == 0x0f    /* Windows 98 extended partition. */
c0025620:	3c 0f                	cmp    $0xf,%al
c0025622:	0f 94 c2             	sete   %dl
                   || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025625:	3c c5                	cmp    $0xc5,%al
c0025627:	0f 94 c0             	sete   %al
c002562a:	08 c2                	or     %al,%dl
c002562c:	75 09                	jne    c0025637 <read_partition_table+0x185>
                   || e->type == 0x0f    /* Windows 98 extended partition. */
c002562e:	89 e8                	mov    %ebp,%eax
c0025630:	83 e0 7f             	and    $0x7f,%eax
                   || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025633:	3c 05                	cmp    $0x5,%al
c0025635:	75 4c                	jne    c0025683 <read_partition_table+0x1d1>
            printf("%s: Extended partition in sector %"PRDSNu"\n",
c0025637:	83 ec 0c             	sub    $0xc,%esp
c002563a:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002563e:	55                   	push   %ebp
c002563f:	e8 bd fc ff ff       	call   c0025301 <block_name>
c0025644:	83 c4 0c             	add    $0xc,%esp
c0025647:	8b 74 24 08          	mov    0x8(%esp),%esi
c002564b:	56                   	push   %esi
c002564c:	50                   	push   %eax
c002564d:	ff 74 24 28          	pushl  0x28(%esp)
c0025651:	e8 28 1e 00 00       	call   c002747e <printf>
            if (sector == 0)
c0025656:	83 c4 10             	add    $0x10,%esp
c0025659:	85 f6                	test   %esi,%esi
c002565b:	0f 85 7b ff ff ff    	jne    c00255dc <read_partition_table+0x12a>
                read_partition_table(block, e->offset, e->offset, part_nr);
c0025661:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0025665:	8b 50 04             	mov    0x4(%eax),%edx
c0025668:	83 ec 0c             	sub    $0xc,%esp
c002566b:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c0025672:	89 d1                	mov    %edx,%ecx
c0025674:	89 e8                	mov    %ebp,%eax
c0025676:	e8 37 fe ff ff       	call   c00254b2 <read_partition_table>
c002567b:	83 c4 10             	add    $0x10,%esp
c002567e:	e9 7c ff ff ff       	jmp    c00255ff <read_partition_table+0x14d>
            ++*part_nr;
c0025683:	8b 84 24 e0 00 00 00 	mov    0xe0(%esp),%eax
c002568a:	8b 00                	mov    (%eax),%eax
c002568c:	83 c0 01             	add    $0x1,%eax
c002568f:	89 44 24 24          	mov    %eax,0x24(%esp)
c0025693:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
c002569a:	89 01                	mov    %eax,(%ecx)
            found_partition(block, e->type, e->offset + sector,
c002569c:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c00256a0:	8b 44 24 04          	mov    0x4(%esp),%eax
c00256a4:	03 41 04             	add    0x4(%ecx),%eax
c00256a7:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (start >= block_size(block))
c00256ab:	83 ec 0c             	sub    $0xc,%esp
c00256ae:	ff 74 24 20          	pushl  0x20(%esp)
c00256b2:	e8 42 fc ff ff       	call   c00252f9 <block_size>
c00256b7:	83 c4 10             	add    $0x10,%esp
c00256ba:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c00256be:	73 55                	jae    c0025715 <read_partition_table+0x263>
    else if (start + size < start || start + size > block_size(block))
c00256c0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00256c4:	01 f0                	add    %esi,%eax
c00256c6:	89 44 24 28          	mov    %eax,0x28(%esp)
c00256ca:	72 15                	jb     c00256e1 <read_partition_table+0x22f>
c00256cc:	83 ec 0c             	sub    $0xc,%esp
c00256cf:	ff 74 24 20          	pushl  0x20(%esp)
c00256d3:	e8 21 fc ff ff       	call   c00252f9 <block_size>
c00256d8:	83 c4 10             	add    $0x10,%esp
c00256db:	39 44 24 28          	cmp    %eax,0x28(%esp)
c00256df:	76 5d                	jbe    c002573e <read_partition_table+0x28c>
        printf("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c00256e1:	83 ec 0c             	sub    $0xc,%esp
c00256e4:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c00256e8:	55                   	push   %ebp
c00256e9:	e8 0b fc ff ff       	call   c00252f9 <block_size>
c00256ee:	89 c6                	mov    %eax,%esi
c00256f0:	89 2c 24             	mov    %ebp,(%esp)
c00256f3:	e8 09 fc ff ff       	call   c0025301 <block_name>
c00256f8:	89 34 24             	mov    %esi,(%esp)
c00256fb:	ff 74 24 38          	pushl  0x38(%esp)
c00256ff:	ff 74 24 38          	pushl  0x38(%esp)
c0025703:	50                   	push   %eax
c0025704:	ff 74 24 3c          	pushl  0x3c(%esp)
c0025708:	e8 71 1d 00 00       	call   c002747e <printf>
c002570d:	83 c4 20             	add    $0x20,%esp
c0025710:	e9 ea fe ff ff       	jmp    c00255ff <read_partition_table+0x14d>
        printf("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025715:	83 ec 0c             	sub    $0xc,%esp
c0025718:	ff 74 24 20          	pushl  0x20(%esp)
c002571c:	e8 e0 fb ff ff       	call   c0025301 <block_name>
c0025721:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025725:	ff 74 24 38          	pushl  0x38(%esp)
c0025729:	50                   	push   %eax
c002572a:	8d 83 d0 65 ff ff    	lea    -0x9a30(%ebx),%eax
c0025730:	50                   	push   %eax
c0025731:	e8 48 1d 00 00       	call   c002747e <printf>
c0025736:	83 c4 20             	add    $0x20,%esp
c0025739:	e9 c1 fe ff ff       	jmp    c00255ff <read_partition_table+0x14d>
            found_partition(block, e->type, e->offset + sector,
c002573e:	89 e8                	mov    %ebp,%eax
c0025740:	0f b6 c0             	movzbl %al,%eax
c0025743:	89 44 24 28          	mov    %eax,0x28(%esp)
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c0025747:	89 e8                	mov    %ebp,%eax
c0025749:	3c 20                	cmp    $0x20,%al
c002574b:	0f 84 c0 00 00 00    	je     c0025811 <read_partition_table+0x35f>
c0025751:	3c 21                	cmp    $0x21,%al
c0025753:	0f 84 5b 01 00 00    	je     c00258b4 <read_partition_table+0x402>
c0025759:	3c 22                	cmp    $0x22,%al
c002575b:	0f 84 60 01 00 00    	je     c00258c1 <read_partition_table+0x40f>
c0025761:	3c 23                	cmp    $0x23,%al
c0025763:	0f 84 65 01 00 00    	je     c00258ce <read_partition_table+0x41c>
        p = malloc(sizeof *p);
c0025769:	83 ec 0c             	sub    $0xc,%esp
c002576c:	6a 08                	push   $0x8
c002576e:	e8 88 e6 ff ff       	call   c0023dfb <malloc>
c0025773:	89 c5                	mov    %eax,%ebp
        if (p == NULL)
c0025775:	83 c4 10             	add    $0x10,%esp
c0025778:	85 c0                	test   %eax,%eax
c002577a:	74 57                	je     c00257d3 <read_partition_table+0x321>
        p->block = block;
c002577c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025780:	89 45 00             	mov    %eax,0x0(%ebp)
        p->start = start;
c0025783:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0025787:	89 55 04             	mov    %edx,0x4(%ebp)
        snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c002578a:	83 ec 0c             	sub    $0xc,%esp
c002578d:	50                   	push   %eax
c002578e:	e8 6e fb ff ff       	call   c0025301 <block_name>
c0025793:	83 c4 04             	add    $0x4,%esp
c0025796:	ff 74 24 30          	pushl  0x30(%esp)
c002579a:	50                   	push   %eax
c002579b:	8d 83 6d 60 ff ff    	lea    -0x9f93(%ebx),%eax
c00257a1:	50                   	push   %eax
c00257a2:	6a 10                	push   $0x10
c00257a4:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c00257a8:	50                   	push   %eax
c00257a9:	e8 61 24 00 00       	call   c0027c0f <snprintf>
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c00257ae:	8b 44 24 48          	mov    0x48(%esp),%eax
c00257b2:	8b 84 83 98 78 ff ff 	mov    -0x8768(%ebx,%eax,4),%eax
c00257b9:	83 c4 20             	add    $0x20,%esp
c00257bc:	85 c0                	test   %eax,%eax
c00257be:	75 32                	jne    c00257f2 <read_partition_table+0x340>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c00257c0:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c00257c7:	00 
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c00257c8:	8d 83 4b 60 ff ff    	lea    -0x9fb5(%ebx),%eax
c00257ce:	e9 99 00 00 00       	jmp    c002586c <read_partition_table+0x3ba>
            PANIC ("Failed to allocate memory for partition descriptor");
c00257d3:	8d 83 3c 66 ff ff    	lea    -0x99c4(%ebx),%eax
c00257d9:	50                   	push   %eax
c00257da:	8d 83 24 42 ff ff    	lea    -0xbddc(%ebx),%eax
c00257e0:	50                   	push   %eax
c00257e1:	68 a6 00 00 00       	push   $0xa6
c00257e6:	8d 83 53 60 ff ff    	lea    -0x9fad(%ebx),%eax
c00257ec:	50                   	push   %eax
c00257ed:	e8 e8 38 00 00       	call   c00290da <debug_panic>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c00257f2:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c00257f9:	00 
c00257fa:	eb 70                	jmp    c002586c <read_partition_table+0x3ba>
c00257fc:	8b 6c 24 18          	mov    0x18(%esp),%ebp
    free(pt);
c0025800:	83 ec 0c             	sub    $0xc,%esp
c0025803:	55                   	push   %ebp
c0025804:	e8 a0 e7 ff ff       	call   c0023fa9 <free>
c0025809:	83 c4 10             	add    $0x10,%esp
c002580c:	e9 54 fd ff ff       	jmp    c0025565 <read_partition_table+0xb3>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c0025811:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
c0025818:	00 
        p = malloc(sizeof *p);
c0025819:	83 ec 0c             	sub    $0xc,%esp
c002581c:	6a 08                	push   $0x8
c002581e:	e8 d8 e5 ff ff       	call   c0023dfb <malloc>
c0025823:	89 c5                	mov    %eax,%ebp
        if (p == NULL)
c0025825:	83 c4 10             	add    $0x10,%esp
c0025828:	85 c0                	test   %eax,%eax
c002582a:	74 a7                	je     c00257d3 <read_partition_table+0x321>
        p->block = block;
c002582c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025830:	89 45 00             	mov    %eax,0x0(%ebp)
        p->start = start;
c0025833:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0025837:	89 4d 04             	mov    %ecx,0x4(%ebp)
        snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c002583a:	83 ec 0c             	sub    $0xc,%esp
c002583d:	50                   	push   %eax
c002583e:	e8 be fa ff ff       	call   c0025301 <block_name>
c0025843:	83 c4 04             	add    $0x4,%esp
c0025846:	ff 74 24 30          	pushl  0x30(%esp)
c002584a:	50                   	push   %eax
c002584b:	8d 83 6d 60 ff ff    	lea    -0x9f93(%ebx),%eax
c0025851:	50                   	push   %eax
c0025852:	6a 10                	push   $0x10
c0025854:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025858:	50                   	push   %eax
c0025859:	e8 b1 23 00 00       	call   c0027c0f <snprintf>
    return type_names[type] != NULL ? type_names[type] : "Unknown";
c002585e:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025862:	8b 84 83 98 78 ff ff 	mov    -0x8768(%ebx,%eax,4),%eax
c0025869:	83 c4 20             	add    $0x20,%esp
        snprintf(extra_info, sizeof extra_info, "%s (%02x)",
c002586c:	83 ec 0c             	sub    $0xc,%esp
c002586f:	ff 74 24 34          	pushl  0x34(%esp)
c0025873:	50                   	push   %eax
c0025874:	8d 83 72 60 ff ff    	lea    -0x9f8e(%ebx),%eax
c002587a:	50                   	push   %eax
c002587b:	68 80 00 00 00       	push   $0x80
c0025880:	8d 44 24 5c          	lea    0x5c(%esp),%eax
c0025884:	89 44 24 28          	mov    %eax,0x28(%esp)
c0025888:	50                   	push   %eax
c0025889:	e8 81 23 00 00       	call   c0027c0f <snprintf>
        block_register(name, type, extra_info, size, &partition_operations, p);
c002588e:	83 c4 18             	add    $0x18,%esp
c0025891:	55                   	push   %ebp
c0025892:	8d 83 d4 ff ff ff    	lea    -0x2c(%ebx),%eax
c0025898:	50                   	push   %eax
c0025899:	56                   	push   %esi
c002589a:	ff 74 24 20          	pushl  0x20(%esp)
c002589e:	ff 74 24 44          	pushl  0x44(%esp)
c00258a2:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c00258a6:	50                   	push   %eax
c00258a7:	e8 ce fa ff ff       	call   c002537a <block_register>
c00258ac:	83 c4 20             	add    $0x20,%esp
c00258af:	e9 4b fd ff ff       	jmp    c00255ff <read_partition_table+0x14d>
                                                  : part_type == 0x21 ? BLOCK_FILESYS
c00258b4:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c00258bb:	00 
c00258bc:	e9 58 ff ff ff       	jmp    c0025819 <read_partition_table+0x367>
c00258c1:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c00258c8:	00 
c00258c9:	e9 4b ff ff ff       	jmp    c0025819 <read_partition_table+0x367>
c00258ce:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c00258d5:	00 
c00258d6:	e9 3e ff ff ff       	jmp    c0025819 <read_partition_table+0x367>

c00258db <partition_write>:

/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write(void *p_, block_sector_t sector, const void *buffer) {
c00258db:	53                   	push   %ebx
c00258dc:	83 ec 0c             	sub    $0xc,%esp
c00258df:	e8 14 96 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00258e4:	81 c3 44 58 01 00    	add    $0x15844,%ebx
c00258ea:	8b 54 24 14          	mov    0x14(%esp),%edx
    struct partition *p = p_;
    block_write(p->block, p->start + sector, buffer);
c00258ee:	ff 74 24 1c          	pushl  0x1c(%esp)
c00258f2:	8b 42 04             	mov    0x4(%edx),%eax
c00258f5:	03 44 24 1c          	add    0x1c(%esp),%eax
c00258f9:	50                   	push   %eax
c00258fa:	ff 32                	pushl  (%edx)
c00258fc:	e8 8a f9 ff ff       	call   c002528b <block_write>
}
c0025901:	83 c4 18             	add    $0x18,%esp
c0025904:	5b                   	pop    %ebx
c0025905:	c3                   	ret    

c0025906 <partition_scan>:
partition_scan(struct block *block) {
c0025906:	56                   	push   %esi
c0025907:	53                   	push   %ebx
c0025908:	83 ec 20             	sub    $0x20,%esp
c002590b:	e8 e8 95 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025910:	81 c3 18 58 01 00    	add    $0x15818,%ebx
c0025916:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    int part_nr = 0;
c002591a:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0025921:	00 
    read_partition_table(block, 0, 0, &part_nr);
c0025922:	8d 44 24 18          	lea    0x18(%esp),%eax
c0025926:	50                   	push   %eax
c0025927:	b9 00 00 00 00       	mov    $0x0,%ecx
c002592c:	ba 00 00 00 00       	mov    $0x0,%edx
c0025931:	89 f0                	mov    %esi,%eax
c0025933:	e8 7a fb ff ff       	call   c00254b2 <read_partition_table>
    if (part_nr == 0)
c0025938:	83 c4 10             	add    $0x10,%esp
c002593b:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0025940:	74 06                	je     c0025948 <partition_scan+0x42>
}
c0025942:	83 c4 14             	add    $0x14,%esp
c0025945:	5b                   	pop    %ebx
c0025946:	5e                   	pop    %esi
c0025947:	c3                   	ret    
        printf("%s: Device contains no partitions\n", block_name(block));
c0025948:	83 ec 0c             	sub    $0xc,%esp
c002594b:	56                   	push   %esi
c002594c:	e8 b0 f9 ff ff       	call   c0025301 <block_name>
c0025951:	83 c4 08             	add    $0x8,%esp
c0025954:	50                   	push   %eax
c0025955:	8d 83 70 66 ff ff    	lea    -0x9990(%ebx),%eax
c002595b:	50                   	push   %eax
c002595c:	e8 1d 1b 00 00       	call   c002747e <printf>
c0025961:	83 c4 10             	add    $0x10,%esp
}
c0025964:	eb dc                	jmp    c0025942 <partition_scan+0x3c>

c0025966 <descramble_ata_string>:

/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string(char *string, int size) {
c0025966:	57                   	push   %edi
c0025967:	56                   	push   %esi
c0025968:	53                   	push   %ebx
c0025969:	89 d7                	mov    %edx,%edi
    int i;

    /* Swap all pairs of bytes. */
    for (i = 0; i + 1 < size; i += 2) {
c002596b:	83 fa 01             	cmp    $0x1,%edx
c002596e:	7e 24                	jle    c0025994 <descramble_ata_string+0x2e>
c0025970:	89 c1                	mov    %eax,%ecx
c0025972:	8d 5a fe             	lea    -0x2(%edx),%ebx
c0025975:	83 e3 fe             	and    $0xfffffffe,%ebx
c0025978:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
        char tmp = string[i];
c002597c:	0f b6 19             	movzbl (%ecx),%ebx
        string[i] = string[i + 1];
c002597f:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
c0025983:	88 11                	mov    %dl,(%ecx)
        string[i + 1] = tmp;
c0025985:	88 59 01             	mov    %bl,0x1(%ecx)
c0025988:	83 c1 02             	add    $0x2,%ecx
    for (i = 0; i + 1 < size; i += 2) {
c002598b:	39 f1                	cmp    %esi,%ecx
c002598d:	75 ed                	jne    c002597c <descramble_ata_string+0x16>
    }

    /* Find the last non-white, non-null character. */
    for (size--; size > 0; size--) {
c002598f:	8d 57 ff             	lea    -0x1(%edi),%edx
c0025992:	eb 0c                	jmp    c00259a0 <descramble_ata_string+0x3a>
c0025994:	8d 52 ff             	lea    -0x1(%edx),%edx
c0025997:	eb 19                	jmp    c00259b2 <descramble_ata_string+0x4c>
c0025999:	83 ea 01             	sub    $0x1,%edx
c002599c:	85 d2                	test   %edx,%edx
c002599e:	7e 12                	jle    c00259b2 <descramble_ata_string+0x4c>
        int c = string[size - 1];
c00259a0:	0f b6 4c 10 ff       	movzbl -0x1(%eax,%edx,1),%ecx
        if (c != '\0' && !isspace(c))
c00259a5:	f6 c1 df             	test   $0xdf,%cl
c00259a8:	74 ef                	je     c0025999 <descramble_ata_string+0x33>
          || c == '\r' || c == '\t' || c == '\v');
c00259aa:	83 e9 09             	sub    $0x9,%ecx
c00259ad:	80 f9 04             	cmp    $0x4,%cl
c00259b0:	76 e7                	jbe    c0025999 <descramble_ata_string+0x33>
            break;
    }
    string[size] = '\0';
c00259b2:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

    return string;
}
c00259b6:	5b                   	pop    %ebx
c00259b7:	5e                   	pop    %esi
c00259b8:	5f                   	pop    %edi
c00259b9:	c3                   	ret    

c00259ba <interrupt_handler>:
    wait_until_idle(d);
}

/* ATA interrupt handler. */
static void
interrupt_handler(struct intr_frame *f) {
c00259ba:	53                   	push   %ebx
c00259bb:	83 ec 08             	sub    $0x8,%esp
c00259be:	e8 35 95 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00259c3:	81 c3 65 57 01 00    	add    $0x15765,%ebx
    struct channel *c;

    for (c = channels; c < channels + CHANNEL_CNT; c++)
        if (f->vec_no == c->irq) {
c00259c9:	8b 44 24 10          	mov    0x10(%esp),%eax
c00259cd:	8b 40 30             	mov    0x30(%eax),%eax
c00259d0:	0f b6 93 c2 19 00 00 	movzbl 0x19c2(%ebx),%edx
c00259d7:	39 d0                	cmp    %edx,%eax
c00259d9:	74 30                	je     c0025a0b <interrupt_handler+0x51>
c00259db:	0f b6 93 32 1a 00 00 	movzbl 0x1a32(%ebx),%edx
c00259e2:	8d 8b 28 1a 00 00    	lea    0x1a28(%ebx),%ecx
c00259e8:	39 c2                	cmp    %eax,%edx
c00259ea:	74 25                	je     c0025a11 <interrupt_handler+0x57>
            } else
                printf("%s: unexpected interrupt\n", c->name);
            return;
        }

    NOT_REACHED ();
c00259ec:	8d 83 d0 55 ff ff    	lea    -0xaa30(%ebx),%eax
c00259f2:	50                   	push   %eax
c00259f3:	8d 83 9c 42 ff ff    	lea    -0xbd64(%ebx),%eax
c00259f9:	50                   	push   %eax
c00259fa:	68 f0 01 00 00       	push   $0x1f0
c00259ff:	8d 83 ad 66 ff ff    	lea    -0x9953(%ebx),%eax
c0025a05:	50                   	push   %eax
c0025a06:	e8 cf 36 00 00       	call   c00290da <debug_panic>
    for (c = channels; c < channels + CHANNEL_CNT; c++)
c0025a0b:	8d 8b b8 19 00 00    	lea    0x19b8(%ebx),%ecx
            if (c->expecting_interrupt) {
c0025a11:	80 79 30 00          	cmpb   $0x0,0x30(%ecx)
c0025a15:	74 1c                	je     c0025a33 <interrupt_handler+0x79>
                inb(reg_status (c));               /* Acknowledge interrupt. */
c0025a17:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
c0025a1b:	8d 50 07             	lea    0x7(%eax),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025a1e:	ec                   	in     (%dx),%al
                sema_up(&c->completion_wait);      /* Wake up waiter. */
c0025a1f:	83 ec 0c             	sub    $0xc,%esp
c0025a22:	83 c1 34             	add    $0x34,%ecx
c0025a25:	51                   	push   %ecx
c0025a26:	e8 e0 d5 ff ff       	call   c002300b <sema_up>
c0025a2b:	83 c4 10             	add    $0x10,%esp
}
c0025a2e:	83 c4 08             	add    $0x8,%esp
c0025a31:	5b                   	pop    %ebx
c0025a32:	c3                   	ret    
                printf("%s: unexpected interrupt\n", c->name);
c0025a33:	83 ec 08             	sub    $0x8,%esp
c0025a36:	51                   	push   %ecx
c0025a37:	8d 83 93 66 ff ff    	lea    -0x996d(%ebx),%eax
c0025a3d:	50                   	push   %eax
c0025a3e:	e8 3b 1a 00 00       	call   c002747e <printf>
c0025a43:	83 c4 10             	add    $0x10,%esp
            return;
c0025a46:	eb e6                	jmp    c0025a2e <interrupt_handler+0x74>

c0025a48 <wait_until_idle>:
wait_until_idle(const struct ata_disk *d) {
c0025a48:	57                   	push   %edi
c0025a49:	56                   	push   %esi
c0025a4a:	53                   	push   %ebx
c0025a4b:	e8 a8 94 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025a50:	81 c3 d8 56 01 00    	add    $0x156d8,%ebx
c0025a56:	89 c7                	mov    %eax,%edi
        if ((inb(reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025a58:	8b 40 08             	mov    0x8(%eax),%eax
c0025a5b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025a5f:	8d 50 07             	lea    0x7(%eax),%edx
c0025a62:	ec                   	in     (%dx),%al
c0025a63:	a8 88                	test   $0x88,%al
c0025a65:	74 4a                	je     c0025ab1 <wait_until_idle+0x69>
        timer_usleep(10);
c0025a67:	83 ec 08             	sub    $0x8,%esp
c0025a6a:	6a 00                	push   $0x0
c0025a6c:	6a 0a                	push   $0xa
c0025a6e:	e8 8b ec ff ff       	call   c00246fe <timer_usleep>
c0025a73:	83 c4 10             	add    $0x10,%esp
c0025a76:	be e7 03 00 00       	mov    $0x3e7,%esi
        if ((inb(reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025a7b:	8b 47 08             	mov    0x8(%edi),%eax
c0025a7e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025a82:	8d 50 07             	lea    0x7(%eax),%edx
c0025a85:	ec                   	in     (%dx),%al
c0025a86:	a8 88                	test   $0x88,%al
c0025a88:	74 27                	je     c0025ab1 <wait_until_idle+0x69>
        timer_usleep(10);
c0025a8a:	83 ec 08             	sub    $0x8,%esp
c0025a8d:	6a 00                	push   $0x0
c0025a8f:	6a 0a                	push   $0xa
c0025a91:	e8 68 ec ff ff       	call   c00246fe <timer_usleep>
    for (i = 0; i < 1000; i++) {
c0025a96:	83 c4 10             	add    $0x10,%esp
c0025a99:	83 ee 01             	sub    $0x1,%esi
c0025a9c:	75 dd                	jne    c0025a7b <wait_until_idle+0x33>
    printf("%s: idle timeout\n", d->name);
c0025a9e:	83 ec 08             	sub    $0x8,%esp
c0025aa1:	57                   	push   %edi
c0025aa2:	8d 83 c1 66 ff ff    	lea    -0x993f(%ebx),%eax
c0025aa8:	50                   	push   %eax
c0025aa9:	e8 d0 19 00 00       	call   c002747e <printf>
c0025aae:	83 c4 10             	add    $0x10,%esp
}
c0025ab1:	5b                   	pop    %ebx
c0025ab2:	5e                   	pop    %esi
c0025ab3:	5f                   	pop    %edi
c0025ab4:	c3                   	ret    

c0025ab5 <select_device>:
select_device(const struct ata_disk *d) {
c0025ab5:	53                   	push   %ebx
c0025ab6:	83 ec 10             	sub    $0x10,%esp
c0025ab9:	e8 3a 94 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025abe:	81 c3 6a 56 01 00    	add    $0x1566a,%ebx
    struct channel *c = d->channel;
c0025ac4:	8b 50 08             	mov    0x8(%eax),%edx
    if (d->dev_no == 1)
c0025ac7:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
        dev |= DEV_DEV;
c0025acb:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
c0025ad0:	b9 b0 ff ff ff       	mov    $0xffffffb0,%ecx
c0025ad5:	0f 44 c1             	cmove  %ecx,%eax
    outb(reg_device (c), dev);
c0025ad8:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
c0025adc:	8d 51 06             	lea    0x6(%ecx),%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025adf:	ee                   	out    %al,(%dx)
    inb(reg_alt_status (c));
c0025ae0:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025ae6:	ec                   	in     (%dx),%al
    timer_nsleep(400);
c0025ae7:	6a 00                	push   $0x0
c0025ae9:	68 90 01 00 00       	push   $0x190
c0025aee:	e8 24 ec ff ff       	call   c0024717 <timer_nsleep>
}
c0025af3:	83 c4 18             	add    $0x18,%esp
c0025af6:	5b                   	pop    %ebx
c0025af7:	c3                   	ret    

c0025af8 <check_device_type>:
check_device_type(struct ata_disk *d) {
c0025af8:	55                   	push   %ebp
c0025af9:	57                   	push   %edi
c0025afa:	56                   	push   %esi
c0025afb:	53                   	push   %ebx
c0025afc:	83 ec 0c             	sub    $0xc,%esp
c0025aff:	89 c6                	mov    %eax,%esi
    struct channel *c = d->channel;
c0025b01:	8b 58 08             	mov    0x8(%eax),%ebx
    select_device(d);
c0025b04:	e8 ac ff ff ff       	call   c0025ab5 <select_device>
    error = inb(reg_error (c));
c0025b09:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c0025b0d:	8d 51 01             	lea    0x1(%ecx),%edx
c0025b10:	ec                   	in     (%dx),%al
c0025b11:	89 c3                	mov    %eax,%ebx
    lbam = inb(reg_lbam (c));
c0025b13:	8d 51 04             	lea    0x4(%ecx),%edx
c0025b16:	ec                   	in     (%dx),%al
c0025b17:	89 c5                	mov    %eax,%ebp
    lbah = inb(reg_lbah (c));
c0025b19:	8d 51 05             	lea    0x5(%ecx),%edx
c0025b1c:	ec                   	in     (%dx),%al
c0025b1d:	89 c7                	mov    %eax,%edi
    status = inb(reg_status (c));
c0025b1f:	8d 51 07             	lea    0x7(%ecx),%edx
c0025b22:	ec                   	in     (%dx),%al
    if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025b23:	80 fb 01             	cmp    $0x1,%bl
c0025b26:	74 0b                	je     c0025b33 <check_device_type+0x3b>
c0025b28:	80 fb 81             	cmp    $0x81,%bl
c0025b2b:	75 3b                	jne    c0025b68 <check_device_type+0x70>
c0025b2d:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0025b31:	74 35                	je     c0025b68 <check_device_type+0x70>
        || (status & STA_DRDY) == 0
c0025b33:	a8 40                	test   $0x40,%al
c0025b35:	74 31                	je     c0025b68 <check_device_type+0x70>
        || (status & STA_BSY) != 0) {
c0025b37:	84 c0                	test   %al,%al
c0025b39:	78 2d                	js     c0025b68 <check_device_type+0x70>
        d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025b3b:	b8 01 00 00 00       	mov    $0x1,%eax
c0025b40:	89 f9                	mov    %edi,%ecx
c0025b42:	89 eb                	mov    %ebp,%ebx
c0025b44:	08 d9                	or     %bl,%cl
c0025b46:	74 12                	je     c0025b5a <check_device_type+0x62>
c0025b48:	80 fb 3c             	cmp    $0x3c,%bl
c0025b4b:	0f 94 c2             	sete   %dl
c0025b4e:	89 f8                	mov    %edi,%eax
c0025b50:	3c c3                	cmp    $0xc3,%al
c0025b52:	0f 94 c0             	sete   %al
c0025b55:	0f b6 c0             	movzbl %al,%eax
c0025b58:	21 d0                	and    %edx,%eax
c0025b5a:	88 46 10             	mov    %al,0x10(%esi)
c0025b5d:	80 66 10 01          	andb   $0x1,0x10(%esi)
        return true;
c0025b61:	b8 01 00 00 00       	mov    $0x1,%eax
c0025b66:	eb 0a                	jmp    c0025b72 <check_device_type+0x7a>
        d->is_ata = false;
c0025b68:	c6 46 10 00          	movb   $0x0,0x10(%esi)
        return error != 0x81;
c0025b6c:	80 fb 81             	cmp    $0x81,%bl
c0025b6f:	0f 95 c0             	setne  %al
}
c0025b72:	83 c4 0c             	add    $0xc,%esp
c0025b75:	5b                   	pop    %ebx
c0025b76:	5e                   	pop    %esi
c0025b77:	5f                   	pop    %edi
c0025b78:	5d                   	pop    %ebp
c0025b79:	c3                   	ret    

c0025b7a <select_sector>:
select_sector(struct ata_disk *d, block_sector_t sec_no) {
c0025b7a:	55                   	push   %ebp
c0025b7b:	57                   	push   %edi
c0025b7c:	56                   	push   %esi
c0025b7d:	53                   	push   %ebx
c0025b7e:	83 ec 0c             	sub    $0xc,%esp
c0025b81:	e8 72 93 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025b86:	81 c3 a2 55 01 00    	add    $0x155a2,%ebx
    struct channel *c = d->channel;
c0025b8c:	8b 68 08             	mov    0x8(%eax),%ebp
    ASSERT (sec_no < (1UL << 28));
c0025b8f:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0025b95:	77 5e                	ja     c0025bf5 <select_sector+0x7b>
c0025b97:	89 c7                	mov    %eax,%edi
c0025b99:	89 d6                	mov    %edx,%esi
    wait_until_idle(d);
c0025b9b:	e8 a8 fe ff ff       	call   c0025a48 <wait_until_idle>
    select_device(d);
c0025ba0:	89 f8                	mov    %edi,%eax
c0025ba2:	e8 0e ff ff ff       	call   c0025ab5 <select_device>
    wait_until_idle(d);
c0025ba7:	89 f8                	mov    %edi,%eax
c0025ba9:	e8 9a fe ff ff       	call   c0025a48 <wait_until_idle>
    outb(reg_nsect (c), 1);
c0025bae:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
c0025bb2:	8d 51 02             	lea    0x2(%ecx),%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025bb5:	b8 01 00 00 00       	mov    $0x1,%eax
c0025bba:	ee                   	out    %al,(%dx)
    outb(reg_lbal (c), sec_no);
c0025bbb:	8d 51 03             	lea    0x3(%ecx),%edx
c0025bbe:	89 f0                	mov    %esi,%eax
c0025bc0:	ee                   	out    %al,(%dx)
    outb(reg_lbam (c), sec_no >> 8);
c0025bc1:	89 f0                	mov    %esi,%eax
c0025bc3:	c1 e8 08             	shr    $0x8,%eax
c0025bc6:	8d 51 04             	lea    0x4(%ecx),%edx
c0025bc9:	ee                   	out    %al,(%dx)
    outb(reg_lbah (c), (sec_no >> 16));
c0025bca:	89 f0                	mov    %esi,%eax
c0025bcc:	c1 e8 10             	shr    $0x10,%eax
c0025bcf:	8d 51 05             	lea    0x5(%ecx),%edx
c0025bd2:	ee                   	out    %al,(%dx)
         DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0025bd3:	83 7f 0c 01          	cmpl   $0x1,0xc(%edi)
c0025bd7:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
c0025bdc:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c0025be1:	0f 45 c2             	cmovne %edx,%eax
c0025be4:	c1 ee 18             	shr    $0x18,%esi
c0025be7:	09 f0                	or     %esi,%eax
    outb(reg_device (c),
c0025be9:	8d 51 06             	lea    0x6(%ecx),%edx
c0025bec:	ee                   	out    %al,(%dx)
}
c0025bed:	83 c4 0c             	add    $0xc,%esp
c0025bf0:	5b                   	pop    %ebx
c0025bf1:	5e                   	pop    %esi
c0025bf2:	5f                   	pop    %edi
c0025bf3:	5d                   	pop    %ebp
c0025bf4:	c3                   	ret    
    ASSERT (sec_no < (1UL << 28));
c0025bf5:	83 ec 0c             	sub    $0xc,%esp
c0025bf8:	8d 83 d3 66 ff ff    	lea    -0x992d(%ebx),%eax
c0025bfe:	50                   	push   %eax
c0025bff:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0025c05:	50                   	push   %eax
c0025c06:	8d 83 6c 42 ff ff    	lea    -0xbd94(%ebx),%eax
c0025c0c:	50                   	push   %eax
c0025c0d:	68 7b 01 00 00       	push   $0x17b
c0025c12:	8d 83 ad 66 ff ff    	lea    -0x9953(%ebx),%eax
c0025c18:	50                   	push   %eax
c0025c19:	e8 bc 34 00 00       	call   c00290da <debug_panic>

c0025c1e <wait_while_busy>:
wait_while_busy(const struct ata_disk *d) {
c0025c1e:	55                   	push   %ebp
c0025c1f:	57                   	push   %edi
c0025c20:	56                   	push   %esi
c0025c21:	53                   	push   %ebx
c0025c22:	83 ec 1c             	sub    $0x1c,%esp
c0025c25:	e8 ce 92 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025c2a:	81 c3 fe 54 01 00    	add    $0x154fe,%ebx
c0025c30:	89 c5                	mov    %eax,%ebp
    struct channel *c = d->channel;
c0025c32:	8b 78 08             	mov    0x8(%eax),%edi
    for (i = 0; i < 3000; i++) {
c0025c35:	be 00 00 00 00       	mov    $0x0,%esi
            printf("%s: busy, waiting...", d->name);
c0025c3a:	8d 83 e8 66 ff ff    	lea    -0x9918(%ebx),%eax
c0025c40:	89 44 24 0c          	mov    %eax,0xc(%esp)
        if (!(inb(reg_alt_status (c)) & STA_BSY)) {
c0025c44:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025c48:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025c4e:	ec                   	in     (%dx),%al
c0025c4f:	84 c0                	test   %al,%al
c0025c51:	79 34                	jns    c0025c87 <wait_while_busy+0x69>
        timer_msleep(10);
c0025c53:	83 ec 08             	sub    $0x8,%esp
c0025c56:	6a 00                	push   $0x0
c0025c58:	6a 0a                	push   $0xa
c0025c5a:	e8 86 ea ff ff       	call   c00246e5 <timer_msleep>
    for (i = 0; i < 3000; i++) {
c0025c5f:	83 c6 01             	add    $0x1,%esi
c0025c62:	83 c4 10             	add    $0x10,%esp
c0025c65:	81 fe b8 0b 00 00    	cmp    $0xbb8,%esi
c0025c6b:	74 4f                	je     c0025cbc <wait_while_busy+0x9e>
        if (i == 700)
c0025c6d:	81 fe bc 02 00 00    	cmp    $0x2bc,%esi
c0025c73:	75 cf                	jne    c0025c44 <wait_while_busy+0x26>
            printf("%s: busy, waiting...", d->name);
c0025c75:	83 ec 08             	sub    $0x8,%esp
c0025c78:	55                   	push   %ebp
c0025c79:	ff 74 24 18          	pushl  0x18(%esp)
c0025c7d:	e8 fc 17 00 00       	call   c002747e <printf>
c0025c82:	83 c4 10             	add    $0x10,%esp
c0025c85:	eb bd                	jmp    c0025c44 <wait_while_busy+0x26>
            if (i >= 700)
c0025c87:	81 fe bb 02 00 00    	cmp    $0x2bb,%esi
c0025c8d:	7f 19                	jg     c0025ca8 <wait_while_busy+0x8a>
            return (inb(reg_alt_status (c)) & STA_DRQ) != 0;
c0025c8f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025c93:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025c99:	ec                   	in     (%dx),%al
c0025c9a:	c0 e8 03             	shr    $0x3,%al
c0025c9d:	83 e0 01             	and    $0x1,%eax
}
c0025ca0:	83 c4 1c             	add    $0x1c,%esp
c0025ca3:	5b                   	pop    %ebx
c0025ca4:	5e                   	pop    %esi
c0025ca5:	5f                   	pop    %edi
c0025ca6:	5d                   	pop    %ebp
c0025ca7:	c3                   	ret    
                printf("ok\n");
c0025ca8:	83 ec 0c             	sub    $0xc,%esp
c0025cab:	8d 83 fd 66 ff ff    	lea    -0x9903(%ebx),%eax
c0025cb1:	50                   	push   %eax
c0025cb2:	e8 f9 53 00 00       	call   c002b0b0 <puts>
c0025cb7:	83 c4 10             	add    $0x10,%esp
c0025cba:	eb d3                	jmp    c0025c8f <wait_while_busy+0x71>
    printf("failed\n");
c0025cbc:	83 ec 0c             	sub    $0xc,%esp
c0025cbf:	8d 83 1c 75 ff ff    	lea    -0x8ae4(%ebx),%eax
c0025cc5:	50                   	push   %eax
c0025cc6:	e8 e5 53 00 00       	call   c002b0b0 <puts>
    return false;
c0025ccb:	83 c4 10             	add    $0x10,%esp
c0025cce:	b8 00 00 00 00       	mov    $0x0,%eax
c0025cd3:	eb cb                	jmp    c0025ca0 <wait_while_busy+0x82>

c0025cd5 <issue_pio_command>:
issue_pio_command(struct channel *c, uint8_t command) {
c0025cd5:	57                   	push   %edi
c0025cd6:	56                   	push   %esi
c0025cd7:	53                   	push   %ebx
c0025cd8:	e8 1b 92 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025cdd:	81 c3 4b 54 01 00    	add    $0x1544b,%ebx
c0025ce3:	89 c7                	mov    %eax,%edi
c0025ce5:	89 d6                	mov    %edx,%esi
    ASSERT (intr_get_level() == INTR_ON);
c0025ce7:	e8 d1 bf ff ff       	call   c0021cbd <intr_get_level>
c0025cec:	83 f8 01             	cmp    $0x1,%eax
c0025cef:	75 12                	jne    c0025d03 <issue_pio_command+0x2e>
    c->expecting_interrupt = true;
c0025cf1:	c6 47 30 01          	movb   $0x1,0x30(%edi)
    outb(reg_command (c), command);
c0025cf5:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025cf9:	83 c2 07             	add    $0x7,%edx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025cfc:	89 f0                	mov    %esi,%eax
c0025cfe:	ee                   	out    %al,(%dx)
}
c0025cff:	5b                   	pop    %ebx
c0025d00:	5e                   	pop    %esi
c0025d01:	5f                   	pop    %edi
c0025d02:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_ON);
c0025d03:	83 ec 0c             	sub    $0xc,%esp
c0025d06:	8d 83 12 5e ff ff    	lea    -0xa1ee(%ebx),%eax
c0025d0c:	50                   	push   %eax
c0025d0d:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0025d13:	50                   	push   %eax
c0025d14:	8d 83 4c 42 ff ff    	lea    -0xbdb4(%ebx),%eax
c0025d1a:	50                   	push   %eax
c0025d1b:	68 8c 01 00 00       	push   $0x18c
c0025d20:	8d 83 ad 66 ff ff    	lea    -0x9953(%ebx),%eax
c0025d26:	50                   	push   %eax
c0025d27:	e8 ae 33 00 00       	call   c00290da <debug_panic>

c0025d2c <ide_write>:
ide_write(void *d_, block_sector_t sec_no, const void *buffer) {
c0025d2c:	55                   	push   %ebp
c0025d2d:	57                   	push   %edi
c0025d2e:	56                   	push   %esi
c0025d2f:	53                   	push   %ebx
c0025d30:	83 ec 18             	sub    $0x18,%esp
c0025d33:	e8 c0 91 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025d38:	81 c3 f0 53 01 00    	add    $0x153f0,%ebx
c0025d3e:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    struct channel *c = d->channel;
c0025d42:	8b 7e 08             	mov    0x8(%esi),%edi
    lock_acquire(&c->lock);
c0025d45:	8d 6f 0c             	lea    0xc(%edi),%ebp
c0025d48:	55                   	push   %ebp
c0025d49:	e8 bb d4 ff ff       	call   c0023209 <lock_acquire>
    select_sector(d, sec_no);
c0025d4e:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025d52:	89 f0                	mov    %esi,%eax
c0025d54:	e8 21 fe ff ff       	call   c0025b7a <select_sector>
    issue_pio_command(c, CMD_WRITE_SECTOR_RETRY);
c0025d59:	ba 30 00 00 00       	mov    $0x30,%edx
c0025d5e:	89 f8                	mov    %edi,%eax
c0025d60:	e8 70 ff ff ff       	call   c0025cd5 <issue_pio_command>
    if (!wait_while_busy(d))
c0025d65:	89 f0                	mov    %esi,%eax
c0025d67:	e8 b2 fe ff ff       	call   c0025c1e <wait_while_busy>
c0025d6c:	83 c4 10             	add    $0x10,%esp
c0025d6f:	84 c0                	test   %al,%al
c0025d71:	74 2c                	je     c0025d9f <ide_write+0x73>
/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw(uint16_t port, const void *addr, size_t cnt) {
    /* See [IA32-v2b] "OUTS". */
    asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025d73:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025d77:	8b 74 24 28          	mov    0x28(%esp),%esi
c0025d7b:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025d80:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
    sema_down(&c->completion_wait);
c0025d83:	83 ec 0c             	sub    $0xc,%esp
c0025d86:	83 c7 34             	add    $0x34,%edi
c0025d89:	57                   	push   %edi
c0025d8a:	e8 51 d1 ff ff       	call   c0022ee0 <sema_down>
    lock_release(&c->lock);
c0025d8f:	89 2c 24             	mov    %ebp,(%esp)
c0025d92:	e8 73 d6 ff ff       	call   c002340a <lock_release>
}
c0025d97:	83 c4 1c             	add    $0x1c,%esp
c0025d9a:	5b                   	pop    %ebx
c0025d9b:	5e                   	pop    %esi
c0025d9c:	5f                   	pop    %edi
c0025d9d:	5d                   	pop    %ebp
c0025d9e:	c3                   	ret    
        PANIC ("%s: disk write failed, sector=%"
c0025d9f:	83 ec 08             	sub    $0x8,%esp
c0025da2:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025da6:	56                   	push   %esi
c0025da7:	8d 83 4c 67 ff ff    	lea    -0x98b4(%ebx),%eax
c0025dad:	50                   	push   %eax
c0025dae:	8d 83 7c 42 ff ff    	lea    -0xbd84(%ebx),%eax
c0025db4:	50                   	push   %eax
c0025db5:	68 68 01 00 00       	push   $0x168
c0025dba:	8d 83 ad 66 ff ff    	lea    -0x9953(%ebx),%eax
c0025dc0:	50                   	push   %eax
c0025dc1:	e8 14 33 00 00       	call   c00290da <debug_panic>

c0025dc6 <identify_ata_device>:
identify_ata_device(struct ata_disk *d) {
c0025dc6:	55                   	push   %ebp
c0025dc7:	57                   	push   %edi
c0025dc8:	56                   	push   %esi
c0025dc9:	53                   	push   %ebx
c0025dca:	81 ec 8c 02 00 00    	sub    $0x28c,%esp
c0025dd0:	e8 23 91 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025dd5:	81 c3 53 53 01 00    	add    $0x15353,%ebx
    struct channel *c = d->channel;
c0025ddb:	8b 78 08             	mov    0x8(%eax),%edi
    ASSERT (d->is_ata);
c0025dde:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c0025de2:	74 4a                	je     c0025e2e <identify_ata_device+0x68>
c0025de4:	89 c6                	mov    %eax,%esi
    wait_until_idle(d);
c0025de6:	e8 5d fc ff ff       	call   c0025a48 <wait_until_idle>
    select_device(d);
c0025deb:	89 f0                	mov    %esi,%eax
c0025ded:	e8 c3 fc ff ff       	call   c0025ab5 <select_device>
    wait_until_idle(d);
c0025df2:	89 f0                	mov    %esi,%eax
c0025df4:	e8 4f fc ff ff       	call   c0025a48 <wait_until_idle>
    issue_pio_command(c, CMD_IDENTIFY_DEVICE);
c0025df9:	ba ec 00 00 00       	mov    $0xec,%edx
c0025dfe:	89 f8                	mov    %edi,%eax
c0025e00:	e8 d0 fe ff ff       	call   c0025cd5 <issue_pio_command>
    sema_down(&c->completion_wait);
c0025e05:	83 ec 0c             	sub    $0xc,%esp
c0025e08:	8d 47 34             	lea    0x34(%edi),%eax
c0025e0b:	50                   	push   %eax
c0025e0c:	e8 cf d0 ff ff       	call   c0022ee0 <sema_down>
    if (!wait_while_busy(d)) {
c0025e11:	89 f0                	mov    %esi,%eax
c0025e13:	e8 06 fe ff ff       	call   c0025c1e <wait_while_busy>
c0025e18:	83 c4 10             	add    $0x10,%esp
c0025e1b:	84 c0                	test   %al,%al
c0025e1d:	75 38                	jne    c0025e57 <identify_ata_device+0x91>
        d->is_ata = false;
c0025e1f:	c6 46 10 00          	movb   $0x0,0x10(%esi)
}
c0025e23:	81 c4 8c 02 00 00    	add    $0x28c,%esp
c0025e29:	5b                   	pop    %ebx
c0025e2a:	5e                   	pop    %esi
c0025e2b:	5f                   	pop    %edi
c0025e2c:	5d                   	pop    %ebp
c0025e2d:	c3                   	ret    
    ASSERT (d->is_ata);
c0025e2e:	83 ec 0c             	sub    $0xc,%esp
c0025e31:	8d 83 00 67 ff ff    	lea    -0x9900(%ebx),%eax
c0025e37:	50                   	push   %eax
c0025e38:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0025e3e:	50                   	push   %eax
c0025e3f:	8d 83 88 42 ff ff    	lea    -0xbd78(%ebx),%eax
c0025e45:	50                   	push   %eax
c0025e46:	68 05 01 00 00       	push   $0x105
c0025e4b:	8d 83 ad 66 ff ff    	lea    -0x9953(%ebx),%eax
c0025e51:	50                   	push   %eax
c0025e52:	e8 83 32 00 00       	call   c00290da <debug_panic>
    asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025e57:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025e5b:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025e62:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025e67:	66 f3 6d             	rep insw (%dx),%es:(%edi)
    capacity = *(uint32_t *) &id[60 * 2];
c0025e6a:	8b bc 24 f8 00 00 00 	mov    0xf8(%esp),%edi
    model = descramble_ata_string(&id[10 * 2], 20);
c0025e71:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0025e78:	ba 14 00 00 00       	mov    $0x14,%edx
c0025e7d:	e8 e4 fa ff ff       	call   c0025966 <descramble_ata_string>
c0025e82:	89 c5                	mov    %eax,%ebp
    serial = descramble_ata_string(&id[27 * 2], 40);
c0025e84:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0025e8b:	ba 28 00 00 00       	mov    $0x28,%edx
c0025e90:	e8 d1 fa ff ff       	call   c0025966 <descramble_ata_string>
    snprintf(extra_info, sizeof extra_info,
c0025e95:	83 ec 0c             	sub    $0xc,%esp
c0025e98:	50                   	push   %eax
c0025e99:	55                   	push   %ebp
c0025e9a:	8d 83 0a 67 ff ff    	lea    -0x98f6(%ebx),%eax
c0025ea0:	50                   	push   %eax
c0025ea1:	68 80 00 00 00       	push   $0x80
c0025ea6:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0025eaa:	50                   	push   %eax
c0025eab:	e8 5f 1d 00 00       	call   c0027c0f <snprintf>
    if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE) {
c0025eb0:	83 c4 20             	add    $0x20,%esp
c0025eb3:	81 ff ff ff 1f 00    	cmp    $0x1fffff,%edi
c0025eb9:	77 2a                	ja     c0025ee5 <identify_ata_device+0x11f>
    block = block_register(d->name, BLOCK_RAW, extra_info, capacity,
c0025ebb:	83 ec 08             	sub    $0x8,%esp
c0025ebe:	56                   	push   %esi
c0025ebf:	8d 83 dc ff ff ff    	lea    -0x24(%ebx),%eax
c0025ec5:	50                   	push   %eax
c0025ec6:	57                   	push   %edi
c0025ec7:	8d 44 24 14          	lea    0x14(%esp),%eax
c0025ecb:	50                   	push   %eax
c0025ecc:	6a 04                	push   $0x4
c0025ece:	56                   	push   %esi
c0025ecf:	e8 a6 f4 ff ff       	call   c002537a <block_register>
    partition_scan(block);
c0025ed4:	83 c4 14             	add    $0x14,%esp
c0025ed7:	50                   	push   %eax
c0025ed8:	e8 29 fa ff ff       	call   c0025906 <partition_scan>
c0025edd:	83 c4 10             	add    $0x10,%esp
c0025ee0:	e9 3e ff ff ff       	jmp    c0025e23 <identify_ata_device+0x5d>
        printf("%s: ignoring ", d->name);
c0025ee5:	83 ec 08             	sub    $0x8,%esp
c0025ee8:	56                   	push   %esi
c0025ee9:	8d 83 22 67 ff ff    	lea    -0x98de(%ebx),%eax
c0025eef:	50                   	push   %eax
c0025ef0:	e8 89 15 00 00       	call   c002747e <printf>
        print_human_readable_size(capacity * 512);
c0025ef5:	83 c4 08             	add    $0x8,%esp
c0025ef8:	c1 e7 09             	shl    $0x9,%edi
c0025efb:	ba 00 00 00 00       	mov    $0x0,%edx
c0025f00:	52                   	push   %edx
c0025f01:	57                   	push   %edi
c0025f02:	e8 3d 1f 00 00       	call   c0027e44 <print_human_readable_size>
        printf("disk for safety\n");
c0025f07:	8d 83 30 67 ff ff    	lea    -0x98d0(%ebx),%eax
c0025f0d:	89 04 24             	mov    %eax,(%esp)
c0025f10:	e8 9b 51 00 00       	call   c002b0b0 <puts>
        d->is_ata = false;
c0025f15:	c6 46 10 00          	movb   $0x0,0x10(%esi)
        return;
c0025f19:	83 c4 10             	add    $0x10,%esp
c0025f1c:	e9 02 ff ff ff       	jmp    c0025e23 <identify_ata_device+0x5d>

c0025f21 <ide_read>:
ide_read(void *d_, block_sector_t sec_no, void *buffer) {
c0025f21:	55                   	push   %ebp
c0025f22:	57                   	push   %edi
c0025f23:	56                   	push   %esi
c0025f24:	53                   	push   %ebx
c0025f25:	83 ec 18             	sub    $0x18,%esp
c0025f28:	e8 cb 8f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025f2d:	81 c3 fb 51 01 00    	add    $0x151fb,%ebx
c0025f33:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    struct channel *c = d->channel;
c0025f37:	8b 77 08             	mov    0x8(%edi),%esi
    lock_acquire(&c->lock);
c0025f3a:	8d 6e 0c             	lea    0xc(%esi),%ebp
c0025f3d:	55                   	push   %ebp
c0025f3e:	e8 c6 d2 ff ff       	call   c0023209 <lock_acquire>
    select_sector(d, sec_no);
c0025f43:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025f47:	89 f8                	mov    %edi,%eax
c0025f49:	e8 2c fc ff ff       	call   c0025b7a <select_sector>
    issue_pio_command(c, CMD_READ_SECTOR_RETRY);
c0025f4e:	ba 20 00 00 00       	mov    $0x20,%edx
c0025f53:	89 f0                	mov    %esi,%eax
c0025f55:	e8 7b fd ff ff       	call   c0025cd5 <issue_pio_command>
    sema_down(&c->completion_wait);
c0025f5a:	8d 46 34             	lea    0x34(%esi),%eax
c0025f5d:	89 04 24             	mov    %eax,(%esp)
c0025f60:	e8 7b cf ff ff       	call   c0022ee0 <sema_down>
    if (!wait_while_busy(d))
c0025f65:	89 f8                	mov    %edi,%eax
c0025f67:	e8 b2 fc ff ff       	call   c0025c1e <wait_while_busy>
c0025f6c:	83 c4 10             	add    $0x10,%esp
c0025f6f:	84 c0                	test   %al,%al
c0025f71:	74 21                	je     c0025f94 <ide_read+0x73>
c0025f73:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0025f77:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0025f7b:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025f80:	66 f3 6d             	rep insw (%dx),%es:(%edi)
    lock_release(&c->lock);
c0025f83:	83 ec 0c             	sub    $0xc,%esp
c0025f86:	55                   	push   %ebp
c0025f87:	e8 7e d4 ff ff       	call   c002340a <lock_release>
}
c0025f8c:	83 c4 1c             	add    $0x1c,%esp
c0025f8f:	5b                   	pop    %ebx
c0025f90:	5e                   	pop    %esi
c0025f91:	5f                   	pop    %edi
c0025f92:	5d                   	pop    %ebp
c0025f93:	c3                   	ret    
        PANIC ("%s: disk read failed, sector=%"
c0025f94:	83 ec 08             	sub    $0x8,%esp
c0025f97:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025f9b:	57                   	push   %edi
c0025f9c:	8d 83 70 67 ff ff    	lea    -0x9890(%ebx),%eax
c0025fa2:	50                   	push   %eax
c0025fa3:	8d 83 60 42 ff ff    	lea    -0xbda0(%ebx),%eax
c0025fa9:	50                   	push   %eax
c0025faa:	68 55 01 00 00       	push   $0x155
c0025faf:	8d 83 ad 66 ff ff    	lea    -0x9953(%ebx),%eax
c0025fb5:	50                   	push   %eax
c0025fb6:	e8 1f 31 00 00       	call   c00290da <debug_panic>

c0025fbb <ide_init>:
ide_init(void) {
c0025fbb:	55                   	push   %ebp
c0025fbc:	57                   	push   %edi
c0025fbd:	56                   	push   %esi
c0025fbe:	53                   	push   %ebx
c0025fbf:	83 ec 2c             	sub    $0x2c,%esp
c0025fc2:	e8 31 8f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0025fc7:	81 c3 61 51 01 00    	add    $0x15161,%ebx
        snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c0025fcd:	6a 00                	push   $0x0
c0025fcf:	8d 83 40 67 ff ff    	lea    -0x98c0(%ebx),%eax
c0025fd5:	50                   	push   %eax
c0025fd6:	6a 08                	push   $0x8
c0025fd8:	8d b3 b8 19 00 00    	lea    0x19b8(%ebx),%esi
c0025fde:	56                   	push   %esi
c0025fdf:	e8 2b 1c 00 00       	call   c0027c0f <snprintf>
                c->reg_base = 0x1f0;
c0025fe4:	66 c7 83 c0 19 00 00 	movw   $0x1f0,0x19c0(%ebx)
c0025feb:	f0 01 
                c->irq = 14 + 0x20;
c0025fed:	c6 83 c2 19 00 00 2e 	movb   $0x2e,0x19c2(%ebx)
        lock_init(&c->lock);
c0025ff4:	8d 83 c4 19 00 00    	lea    0x19c4(%ebx),%eax
c0025ffa:	89 04 24             	mov    %eax,(%esp)
c0025ffd:	e8 5b d1 ff ff       	call   c002315d <lock_init>
        c->expecting_interrupt = false;
c0026002:	c6 83 e8 19 00 00 00 	movb   $0x0,0x19e8(%ebx)
        sema_init(&c->completion_wait, 0);
c0026009:	83 c4 08             	add    $0x8,%esp
c002600c:	6a 00                	push   $0x0
c002600e:	8d 83 ec 19 00 00    	lea    0x19ec(%ebx),%eax
c0026014:	50                   	push   %eax
c0026015:	e8 72 ce ff ff       	call   c0022e8c <sema_init>
            snprintf(d->name, sizeof d->name,
c002601a:	6a 61                	push   $0x61
c002601c:	8d bb 47 67 ff ff    	lea    -0x98b9(%ebx),%edi
c0026022:	57                   	push   %edi
c0026023:	6a 08                	push   $0x8
c0026025:	8d ab 00 1a 00 00    	lea    0x1a00(%ebx),%ebp
c002602b:	55                   	push   %ebp
c002602c:	e8 de 1b 00 00       	call   c0027c0f <snprintf>
            d->channel = c;
c0026031:	89 b3 08 1a 00 00    	mov    %esi,0x1a08(%ebx)
            d->dev_no = dev_no;
c0026037:	c7 83 0c 1a 00 00 00 	movl   $0x0,0x1a0c(%ebx)
c002603e:	00 00 00 
            d->is_ata = false;
c0026041:	c6 83 10 1a 00 00 00 	movb   $0x0,0x1a10(%ebx)
            snprintf(d->name, sizeof d->name,
c0026048:	83 c4 20             	add    $0x20,%esp
c002604b:	6a 62                	push   $0x62
c002604d:	57                   	push   %edi
c002604e:	6a 08                	push   $0x8
c0026050:	8d 83 14 1a 00 00    	lea    0x1a14(%ebx),%eax
c0026056:	50                   	push   %eax
c0026057:	e8 b3 1b 00 00       	call   c0027c0f <snprintf>
            d->channel = c;
c002605c:	89 b3 1c 1a 00 00    	mov    %esi,0x1a1c(%ebx)
            d->dev_no = dev_no;
c0026062:	c7 83 20 1a 00 00 01 	movl   $0x1,0x1a20(%ebx)
c0026069:	00 00 00 
            d->is_ata = false;
c002606c:	c6 83 24 1a 00 00 00 	movb   $0x0,0x1a24(%ebx)
        intr_register_ext(c->irq, interrupt_handler, c->name);
c0026073:	83 c4 0c             	add    $0xc,%esp
c0026076:	56                   	push   %esi
c0026077:	8d 83 92 a8 fe ff    	lea    -0x1576e(%ebx),%eax
c002607d:	50                   	push   %eax
c002607e:	0f b6 83 c2 19 00 00 	movzbl 0x19c2(%ebx),%eax
c0026085:	50                   	push   %eax
c0026086:	e8 60 be ff ff       	call   c0021eeb <intr_register_ext>
        select_device(d);
c002608b:	89 e8                	mov    %ebp,%eax
c002608d:	e8 23 fa ff ff       	call   c0025ab5 <select_device>
        outb(reg_nsect (c), 0x55);
c0026092:	0f b7 8b c0 19 00 00 	movzwl 0x19c0(%ebx),%ecx
c0026099:	8d 69 02             	lea    0x2(%ecx),%ebp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002609c:	bf 55 00 00 00       	mov    $0x55,%edi
c00260a1:	89 f8                	mov    %edi,%eax
c00260a3:	89 ea                	mov    %ebp,%edx
c00260a5:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c00260a6:	83 c1 03             	add    $0x3,%ecx
c00260a9:	be aa ff ff ff       	mov    $0xffffffaa,%esi
c00260ae:	89 f0                	mov    %esi,%eax
c00260b0:	89 ca                	mov    %ecx,%edx
c00260b2:	ee                   	out    %al,(%dx)
c00260b3:	89 ea                	mov    %ebp,%edx
c00260b5:	ee                   	out    %al,(%dx)
c00260b6:	89 f8                	mov    %edi,%eax
c00260b8:	89 ca                	mov    %ecx,%edx
c00260ba:	ee                   	out    %al,(%dx)
c00260bb:	89 ea                	mov    %ebp,%edx
c00260bd:	ee                   	out    %al,(%dx)
c00260be:	89 f0                	mov    %esi,%eax
c00260c0:	89 ca                	mov    %ecx,%edx
c00260c2:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00260c3:	89 ea                	mov    %ebp,%edx
c00260c5:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c00260c6:	83 c4 10             	add    $0x10,%esp
c00260c9:	ba 00 00 00 00       	mov    $0x0,%edx
c00260ce:	3c 55                	cmp    $0x55,%al
c00260d0:	0f 84 d6 01 00 00    	je     c00262ac <ide_init+0x2f1>
c00260d6:	89 d0                	mov    %edx,%eax
c00260d8:	83 e0 01             	and    $0x1,%eax
c00260db:	88 44 24 08          	mov    %al,0x8(%esp)
        present[dev_no] = (inb(reg_nsect (c)) == 0x55
c00260df:	88 44 24 1e          	mov    %al,0x1e(%esp)
        select_device(d);
c00260e3:	8d 83 14 1a 00 00    	lea    0x1a14(%ebx),%eax
c00260e9:	e8 c7 f9 ff ff       	call   c0025ab5 <select_device>
        outb(reg_nsect (c), 0x55);
c00260ee:	0f b7 ab c0 19 00 00 	movzwl 0x19c0(%ebx),%ebp
c00260f5:	8d 4d 02             	lea    0x2(%ebp),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00260f8:	b8 55 00 00 00       	mov    $0x55,%eax
c00260fd:	89 ca                	mov    %ecx,%edx
c00260ff:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c0026100:	8d 75 03             	lea    0x3(%ebp),%esi
c0026103:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c0026108:	89 f8                	mov    %edi,%eax
c002610a:	89 f2                	mov    %esi,%edx
c002610c:	ee                   	out    %al,(%dx)
c002610d:	89 ca                	mov    %ecx,%edx
c002610f:	ee                   	out    %al,(%dx)
c0026110:	b8 55 00 00 00       	mov    $0x55,%eax
c0026115:	89 f2                	mov    %esi,%edx
c0026117:	ee                   	out    %al,(%dx)
c0026118:	89 ca                	mov    %ecx,%edx
c002611a:	ee                   	out    %al,(%dx)
c002611b:	89 f8                	mov    %edi,%eax
c002611d:	89 f2                	mov    %esi,%edx
c002611f:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026120:	89 ca                	mov    %ecx,%edx
c0026122:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c0026123:	ba 00 00 00 00       	mov    $0x0,%edx
c0026128:	3c 55                	cmp    $0x55,%al
c002612a:	0f 84 8c 01 00 00    	je     c00262bc <ide_init+0x301>
c0026130:	89 d6                	mov    %edx,%esi
c0026132:	83 e6 01             	and    $0x1,%esi
        present[dev_no] = (inb(reg_nsect (c)) == 0x55
c0026135:	89 f0                	mov    %esi,%eax
c0026137:	88 44 24 1f          	mov    %al,0x1f(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002613b:	bf 00 00 00 00       	mov    $0x0,%edi
    outb(reg_ctl (c), 0);
c0026140:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c0026146:	89 f8                	mov    %edi,%eax
c0026148:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c0026149:	83 ec 08             	sub    $0x8,%esp
c002614c:	6a 00                	push   $0x0
c002614e:	6a 0a                	push   $0xa
c0026150:	e8 a9 e5 ff ff       	call   c00246fe <timer_usleep>
    outb(reg_ctl (c), CTL_SRST);
c0026155:	0f b7 93 c0 19 00 00 	movzwl 0x19c0(%ebx),%edx
c002615c:	66 81 c2 06 02       	add    $0x206,%dx
c0026161:	b8 04 00 00 00       	mov    $0x4,%eax
c0026166:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c0026167:	83 c4 08             	add    $0x8,%esp
c002616a:	6a 00                	push   $0x0
c002616c:	6a 0a                	push   $0xa
c002616e:	e8 8b e5 ff ff       	call   c00246fe <timer_usleep>
    outb(reg_ctl (c), 0);
c0026173:	0f b7 93 c0 19 00 00 	movzwl 0x19c0(%ebx),%edx
c002617a:	66 81 c2 06 02       	add    $0x206,%dx
c002617f:	89 f8                	mov    %edi,%eax
c0026181:	ee                   	out    %al,(%dx)
    timer_msleep(150);
c0026182:	83 c4 08             	add    $0x8,%esp
c0026185:	6a 00                	push   $0x0
c0026187:	68 96 00 00 00       	push   $0x96
c002618c:	e8 54 e5 ff ff       	call   c00246e5 <timer_msleep>
    if (present[0]) {
c0026191:	83 c4 10             	add    $0x10,%esp
c0026194:	80 7c 24 08 00       	cmpb   $0x0,0x8(%esp)
c0026199:	0f 85 2d 01 00 00    	jne    c00262cc <ide_init+0x311>
    if (present[1]) {
c002619f:	89 f0                	mov    %esi,%eax
c00261a1:	84 c0                	test   %al,%al
c00261a3:	0f 85 3e 01 00 00    	jne    c00262e7 <ide_init+0x32c>
        if (check_device_type(&c->devices[0]))
c00261a9:	8d 83 00 1a 00 00    	lea    0x1a00(%ebx),%eax
c00261af:	e8 44 f9 ff ff       	call   c0025af8 <check_device_type>
c00261b4:	84 c0                	test   %al,%al
c00261b6:	0f 85 78 01 00 00    	jne    c0026334 <ide_init+0x379>
            if (c->devices[dev_no].is_ata)
c00261bc:	80 bb 10 1a 00 00 00 	cmpb   $0x0,0x1a10(%ebx)
c00261c3:	0f 85 7b 01 00 00    	jne    c0026344 <ide_init+0x389>
c00261c9:	80 bb 24 1a 00 00 00 	cmpb   $0x0,0x1a24(%ebx)
c00261d0:	0f 85 7e 01 00 00    	jne    c0026354 <ide_init+0x399>
        snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c00261d6:	6a 01                	push   $0x1
c00261d8:	8d 83 40 67 ff ff    	lea    -0x98c0(%ebx),%eax
c00261de:	50                   	push   %eax
c00261df:	6a 08                	push   $0x8
c00261e1:	8d b3 28 1a 00 00    	lea    0x1a28(%ebx),%esi
c00261e7:	56                   	push   %esi
c00261e8:	e8 22 1a 00 00       	call   c0027c0f <snprintf>
                c->reg_base = 0x170;
c00261ed:	66 c7 83 30 1a 00 00 	movw   $0x170,0x1a30(%ebx)
c00261f4:	70 01 
                c->irq = 15 + 0x20;
c00261f6:	c6 83 32 1a 00 00 2f 	movb   $0x2f,0x1a32(%ebx)
        lock_init(&c->lock);
c00261fd:	8d 83 34 1a 00 00    	lea    0x1a34(%ebx),%eax
c0026203:	89 04 24             	mov    %eax,(%esp)
c0026206:	e8 52 cf ff ff       	call   c002315d <lock_init>
        c->expecting_interrupt = false;
c002620b:	c6 83 58 1a 00 00 00 	movb   $0x0,0x1a58(%ebx)
        sema_init(&c->completion_wait, 0);
c0026212:	83 c4 08             	add    $0x8,%esp
c0026215:	6a 00                	push   $0x0
c0026217:	8d 83 5c 1a 00 00    	lea    0x1a5c(%ebx),%eax
c002621d:	50                   	push   %eax
c002621e:	e8 69 cc ff ff       	call   c0022e8c <sema_init>
            snprintf(d->name, sizeof d->name,
c0026223:	6a 63                	push   $0x63
c0026225:	8d bb 47 67 ff ff    	lea    -0x98b9(%ebx),%edi
c002622b:	57                   	push   %edi
c002622c:	6a 08                	push   $0x8
c002622e:	8d ab 70 1a 00 00    	lea    0x1a70(%ebx),%ebp
c0026234:	55                   	push   %ebp
c0026235:	e8 d5 19 00 00       	call   c0027c0f <snprintf>
            d->channel = c;
c002623a:	89 b3 78 1a 00 00    	mov    %esi,0x1a78(%ebx)
            d->dev_no = dev_no;
c0026240:	c7 83 7c 1a 00 00 00 	movl   $0x0,0x1a7c(%ebx)
c0026247:	00 00 00 
            d->is_ata = false;
c002624a:	c6 83 80 1a 00 00 00 	movb   $0x0,0x1a80(%ebx)
            snprintf(d->name, sizeof d->name,
c0026251:	83 c4 20             	add    $0x20,%esp
c0026254:	6a 64                	push   $0x64
c0026256:	57                   	push   %edi
c0026257:	6a 08                	push   $0x8
c0026259:	8d 83 84 1a 00 00    	lea    0x1a84(%ebx),%eax
c002625f:	50                   	push   %eax
c0026260:	e8 aa 19 00 00       	call   c0027c0f <snprintf>
            d->channel = c;
c0026265:	89 b3 8c 1a 00 00    	mov    %esi,0x1a8c(%ebx)
            d->dev_no = dev_no;
c002626b:	c7 83 90 1a 00 00 01 	movl   $0x1,0x1a90(%ebx)
c0026272:	00 00 00 
            d->is_ata = false;
c0026275:	c6 83 94 1a 00 00 00 	movb   $0x0,0x1a94(%ebx)
        intr_register_ext(c->irq, interrupt_handler, c->name);
c002627c:	83 c4 0c             	add    $0xc,%esp
c002627f:	56                   	push   %esi
c0026280:	8d 83 92 a8 fe ff    	lea    -0x1576e(%ebx),%eax
c0026286:	50                   	push   %eax
c0026287:	0f b6 83 32 1a 00 00 	movzbl 0x1a32(%ebx),%eax
c002628e:	50                   	push   %eax
c002628f:	e8 57 bc ff ff       	call   c0021eeb <intr_register_ext>
    for (dev_no = 0; dev_no < 2; dev_no++) {
c0026294:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c0026298:	8d 6c 24 2e          	lea    0x2e(%esp),%ebp
c002629c:	8d 44 24 30          	lea    0x30(%esp),%eax
c00262a0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00262a4:	83 c4 10             	add    $0x10,%esp
c00262a7:	e9 cd 00 00 00       	jmp    c0026379 <ide_init+0x3be>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00262ac:	89 ca                	mov    %ecx,%edx
c00262ae:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c00262af:	3c aa                	cmp    $0xaa,%al
c00262b1:	0f 94 c2             	sete   %dl
c00262b4:	0f b6 d2             	movzbl %dl,%edx
c00262b7:	e9 1a fe ff ff       	jmp    c00260d6 <ide_init+0x11b>
c00262bc:	89 f2                	mov    %esi,%edx
c00262be:	ec                   	in     (%dx),%al
c00262bf:	3c aa                	cmp    $0xaa,%al
c00262c1:	0f 94 c2             	sete   %dl
c00262c4:	0f b6 d2             	movzbl %dl,%edx
c00262c7:	e9 64 fe ff ff       	jmp    c0026130 <ide_init+0x175>
        select_device(&c->devices[0]);
c00262cc:	8d 83 00 1a 00 00    	lea    0x1a00(%ebx),%eax
c00262d2:	e8 de f7 ff ff       	call   c0025ab5 <select_device>
        wait_while_busy(&c->devices[0]);
c00262d7:	8d 83 00 1a 00 00    	lea    0x1a00(%ebx),%eax
c00262dd:	e8 3c f9 ff ff       	call   c0025c1e <wait_while_busy>
c00262e2:	e9 b8 fe ff ff       	jmp    c002619f <ide_init+0x1e4>
        select_device(&c->devices[1]);
c00262e7:	8d 83 14 1a 00 00    	lea    0x1a14(%ebx),%eax
c00262ed:	e8 c3 f7 ff ff       	call   c0025ab5 <select_device>
c00262f2:	be b8 0b 00 00       	mov    $0xbb8,%esi
c00262f7:	eb 14                	jmp    c002630d <ide_init+0x352>
            timer_msleep(10);
c00262f9:	83 ec 08             	sub    $0x8,%esp
c00262fc:	6a 00                	push   $0x0
c00262fe:	6a 0a                	push   $0xa
c0026300:	e8 e0 e3 ff ff       	call   c00246e5 <timer_msleep>
        for (i = 0; i < 3000; i++) {
c0026305:	83 c4 10             	add    $0x10,%esp
c0026308:	83 ee 01             	sub    $0x1,%esi
c002630b:	74 17                	je     c0026324 <ide_init+0x369>
            if (inb(reg_nsect (c)) == 1 && inb(reg_lbal (c)) == 1)
c002630d:	0f b7 8b c0 19 00 00 	movzwl 0x19c0(%ebx),%ecx
c0026314:	8d 51 02             	lea    0x2(%ecx),%edx
c0026317:	ec                   	in     (%dx),%al
c0026318:	3c 01                	cmp    $0x1,%al
c002631a:	75 dd                	jne    c00262f9 <ide_init+0x33e>
c002631c:	8d 51 03             	lea    0x3(%ecx),%edx
c002631f:	ec                   	in     (%dx),%al
c0026320:	3c 01                	cmp    $0x1,%al
c0026322:	75 d5                	jne    c00262f9 <ide_init+0x33e>
        wait_while_busy(&c->devices[1]);
c0026324:	8d 83 14 1a 00 00    	lea    0x1a14(%ebx),%eax
c002632a:	e8 ef f8 ff ff       	call   c0025c1e <wait_while_busy>
c002632f:	e9 75 fe ff ff       	jmp    c00261a9 <ide_init+0x1ee>
            check_device_type(&c->devices[1]);
c0026334:	8d 83 14 1a 00 00    	lea    0x1a14(%ebx),%eax
c002633a:	e8 b9 f7 ff ff       	call   c0025af8 <check_device_type>
c002633f:	e9 78 fe ff ff       	jmp    c00261bc <ide_init+0x201>
                identify_ata_device(&c->devices[dev_no]);
c0026344:	8d 83 00 1a 00 00    	lea    0x1a00(%ebx),%eax
c002634a:	e8 77 fa ff ff       	call   c0025dc6 <identify_ata_device>
c002634f:	e9 75 fe ff ff       	jmp    c00261c9 <ide_init+0x20e>
c0026354:	8d 83 14 1a 00 00    	lea    0x1a14(%ebx),%eax
c002635a:	e8 67 fa ff ff       	call   c0025dc6 <identify_ata_device>
c002635f:	e9 72 fe ff ff       	jmp    c00261d6 <ide_init+0x21b>
                           && inb(reg_lbal (c)) == 0xaa);
c0026364:	88 55 00             	mov    %dl,0x0(%ebp)
c0026367:	80 65 00 01          	andb   $0x1,0x0(%ebp)
c002636b:	83 44 24 08 14       	addl   $0x14,0x8(%esp)
c0026370:	83 c5 01             	add    $0x1,%ebp
    for (dev_no = 0; dev_no < 2; dev_no++) {
c0026373:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c0026377:	74 55                	je     c00263ce <ide_init+0x413>
        select_device(d);
c0026379:	8b 44 24 08          	mov    0x8(%esp),%eax
c002637d:	e8 33 f7 ff ff       	call   c0025ab5 <select_device>
        outb(reg_nsect (c), 0x55);
c0026382:	0f b7 bb 30 1a 00 00 	movzwl 0x1a30(%ebx),%edi
c0026389:	8d 4f 02             	lea    0x2(%edi),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002638c:	b8 55 00 00 00       	mov    $0x55,%eax
c0026391:	89 ca                	mov    %ecx,%edx
c0026393:	ee                   	out    %al,(%dx)
        outb(reg_lbal (c), 0xaa);
c0026394:	8d 77 03             	lea    0x3(%edi),%esi
c0026397:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c002639c:	89 f2                	mov    %esi,%edx
c002639e:	ee                   	out    %al,(%dx)
c002639f:	89 ca                	mov    %ecx,%edx
c00263a1:	ee                   	out    %al,(%dx)
c00263a2:	b8 55 00 00 00       	mov    $0x55,%eax
c00263a7:	89 f2                	mov    %esi,%edx
c00263a9:	ee                   	out    %al,(%dx)
c00263aa:	89 ca                	mov    %ecx,%edx
c00263ac:	ee                   	out    %al,(%dx)
c00263ad:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c00263b2:	89 f2                	mov    %esi,%edx
c00263b4:	ee                   	out    %al,(%dx)
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00263b5:	89 ca                	mov    %ecx,%edx
c00263b7:	ec                   	in     (%dx),%al
                           && inb(reg_lbal (c)) == 0xaa);
c00263b8:	ba 00 00 00 00       	mov    $0x0,%edx
c00263bd:	3c 55                	cmp    $0x55,%al
c00263bf:	75 a3                	jne    c0026364 <ide_init+0x3a9>
c00263c1:	89 f2                	mov    %esi,%edx
c00263c3:	ec                   	in     (%dx),%al
c00263c4:	3c aa                	cmp    $0xaa,%al
c00263c6:	0f 94 c2             	sete   %dl
c00263c9:	0f b6 d2             	movzbl %dl,%edx
c00263cc:	eb 96                	jmp    c0026364 <ide_init+0x3a9>
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00263ce:	be 00 00 00 00       	mov    $0x0,%esi
    outb(reg_ctl (c), 0);
c00263d3:	8d 97 06 02 00 00    	lea    0x206(%edi),%edx
c00263d9:	89 f0                	mov    %esi,%eax
c00263db:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c00263dc:	83 ec 08             	sub    $0x8,%esp
c00263df:	6a 00                	push   $0x0
c00263e1:	6a 0a                	push   $0xa
c00263e3:	e8 16 e3 ff ff       	call   c00246fe <timer_usleep>
    outb(reg_ctl (c), CTL_SRST);
c00263e8:	0f b7 93 30 1a 00 00 	movzwl 0x1a30(%ebx),%edx
c00263ef:	66 81 c2 06 02       	add    $0x206,%dx
c00263f4:	b8 04 00 00 00       	mov    $0x4,%eax
c00263f9:	ee                   	out    %al,(%dx)
    timer_usleep(10);
c00263fa:	83 c4 08             	add    $0x8,%esp
c00263fd:	6a 00                	push   $0x0
c00263ff:	6a 0a                	push   $0xa
c0026401:	e8 f8 e2 ff ff       	call   c00246fe <timer_usleep>
    outb(reg_ctl (c), 0);
c0026406:	0f b7 93 30 1a 00 00 	movzwl 0x1a30(%ebx),%edx
c002640d:	66 81 c2 06 02       	add    $0x206,%dx
c0026412:	89 f0                	mov    %esi,%eax
c0026414:	ee                   	out    %al,(%dx)
    timer_msleep(150);
c0026415:	83 c4 08             	add    $0x8,%esp
c0026418:	6a 00                	push   $0x0
c002641a:	68 96 00 00 00       	push   $0x96
c002641f:	e8 c1 e2 ff ff       	call   c00246e5 <timer_msleep>
    if (present[0]) {
c0026424:	83 c4 10             	add    $0x10,%esp
c0026427:	80 7c 24 1e 00       	cmpb   $0x0,0x1e(%esp)
c002642c:	75 38                	jne    c0026466 <ide_init+0x4ab>
    if (present[1]) {
c002642e:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0026433:	75 49                	jne    c002647e <ide_init+0x4c3>
        if (check_device_type(&c->devices[0]))
c0026435:	8d 83 70 1a 00 00    	lea    0x1a70(%ebx),%eax
c002643b:	e8 b8 f6 ff ff       	call   c0025af8 <check_device_type>
c0026440:	84 c0                	test   %al,%al
c0026442:	0f 85 83 00 00 00    	jne    c00264cb <ide_init+0x510>
            if (c->devices[dev_no].is_ata)
c0026448:	80 bb 80 1a 00 00 00 	cmpb   $0x0,0x1a80(%ebx)
c002644f:	0f 85 96 00 00 00    	jne    c00264eb <ide_init+0x530>
c0026455:	80 bb 94 1a 00 00 00 	cmpb   $0x0,0x1a94(%ebx)
c002645c:	75 7d                	jne    c00264db <ide_init+0x520>
}
c002645e:	83 c4 2c             	add    $0x2c,%esp
c0026461:	5b                   	pop    %ebx
c0026462:	5e                   	pop    %esi
c0026463:	5f                   	pop    %edi
c0026464:	5d                   	pop    %ebp
c0026465:	c3                   	ret    
        select_device(&c->devices[0]);
c0026466:	8d 83 70 1a 00 00    	lea    0x1a70(%ebx),%eax
c002646c:	e8 44 f6 ff ff       	call   c0025ab5 <select_device>
        wait_while_busy(&c->devices[0]);
c0026471:	8d 83 70 1a 00 00    	lea    0x1a70(%ebx),%eax
c0026477:	e8 a2 f7 ff ff       	call   c0025c1e <wait_while_busy>
c002647c:	eb b0                	jmp    c002642e <ide_init+0x473>
        select_device(&c->devices[1]);
c002647e:	8d 83 84 1a 00 00    	lea    0x1a84(%ebx),%eax
c0026484:	e8 2c f6 ff ff       	call   c0025ab5 <select_device>
c0026489:	be b8 0b 00 00       	mov    $0xbb8,%esi
c002648e:	eb 14                	jmp    c00264a4 <ide_init+0x4e9>
            timer_msleep(10);
c0026490:	83 ec 08             	sub    $0x8,%esp
c0026493:	6a 00                	push   $0x0
c0026495:	6a 0a                	push   $0xa
c0026497:	e8 49 e2 ff ff       	call   c00246e5 <timer_msleep>
        for (i = 0; i < 3000; i++) {
c002649c:	83 c4 10             	add    $0x10,%esp
c002649f:	83 ee 01             	sub    $0x1,%esi
c00264a2:	74 17                	je     c00264bb <ide_init+0x500>
            if (inb(reg_nsect (c)) == 1 && inb(reg_lbal (c)) == 1)
c00264a4:	0f b7 8b 30 1a 00 00 	movzwl 0x1a30(%ebx),%ecx
c00264ab:	8d 51 02             	lea    0x2(%ecx),%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00264ae:	ec                   	in     (%dx),%al
c00264af:	3c 01                	cmp    $0x1,%al
c00264b1:	75 dd                	jne    c0026490 <ide_init+0x4d5>
c00264b3:	8d 51 03             	lea    0x3(%ecx),%edx
c00264b6:	ec                   	in     (%dx),%al
c00264b7:	3c 01                	cmp    $0x1,%al
c00264b9:	75 d5                	jne    c0026490 <ide_init+0x4d5>
        wait_while_busy(&c->devices[1]);
c00264bb:	8d 83 84 1a 00 00    	lea    0x1a84(%ebx),%eax
c00264c1:	e8 58 f7 ff ff       	call   c0025c1e <wait_while_busy>
c00264c6:	e9 6a ff ff ff       	jmp    c0026435 <ide_init+0x47a>
            check_device_type(&c->devices[1]);
c00264cb:	8d 83 84 1a 00 00    	lea    0x1a84(%ebx),%eax
c00264d1:	e8 22 f6 ff ff       	call   c0025af8 <check_device_type>
c00264d6:	e9 6d ff ff ff       	jmp    c0026448 <ide_init+0x48d>
                identify_ata_device(&c->devices[dev_no]);
c00264db:	8d 83 84 1a 00 00    	lea    0x1a84(%ebx),%eax
c00264e1:	e8 e0 f8 ff ff       	call   c0025dc6 <identify_ata_device>
}
c00264e6:	e9 73 ff ff ff       	jmp    c002645e <ide_init+0x4a3>
                identify_ata_device(&c->devices[dev_no]);
c00264eb:	8d 83 70 1a 00 00    	lea    0x1a70(%ebx),%eax
c00264f1:	e8 d0 f8 ff ff       	call   c0025dc6 <identify_ata_device>
c00264f6:	e9 5a ff ff ff       	jmp    c0026455 <ide_init+0x49a>

c00264fb <input_init>:
/* Stores keys from the keyboard and serial port. */
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init(void) {
c00264fb:	53                   	push   %ebx
c00264fc:	83 ec 14             	sub    $0x14,%esp
c00264ff:	e8 f4 89 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026504:	81 c3 24 4c 01 00    	add    $0x14c24,%ebx
    intq_init(&buffer);
c002650a:	8d 83 98 1a 00 00    	lea    0x1a98(%ebx),%eax
c0026510:	50                   	push   %eax
c0026511:	e8 32 01 00 00       	call   c0026648 <intq_init>
}
c0026516:	83 c4 18             	add    $0x18,%esp
c0026519:	5b                   	pop    %ebx
c002651a:	c3                   	ret    

c002651b <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc(uint8_t key) {
c002651b:	56                   	push   %esi
c002651c:	53                   	push   %ebx
c002651d:	83 ec 04             	sub    $0x4,%esp
c0026520:	e8 d3 89 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026525:	81 c3 03 4c 01 00    	add    $0x14c03,%ebx
c002652b:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c002652f:	e8 89 b7 ff ff       	call   c0021cbd <intr_get_level>
c0026534:	85 c0                	test   %eax,%eax
c0026536:	75 36                	jne    c002656e <input_putc+0x53>
    ASSERT (!intq_full(&buffer));
c0026538:	83 ec 0c             	sub    $0xc,%esp
c002653b:	8d 83 98 1a 00 00    	lea    0x1a98(%ebx),%eax
c0026541:	50                   	push   %eax
c0026542:	e8 8f 01 00 00       	call   c00266d6 <intq_full>
c0026547:	83 c4 10             	add    $0x10,%esp
c002654a:	84 c0                	test   %al,%al
c002654c:	75 46                	jne    c0026594 <input_putc+0x79>

    intq_putc(&buffer, key);
c002654e:	83 ec 08             	sub    $0x8,%esp
c0026551:	89 f0                	mov    %esi,%eax
c0026553:	0f b6 f0             	movzbl %al,%esi
c0026556:	56                   	push   %esi
c0026557:	8d 83 98 1a 00 00    	lea    0x1a98(%ebx),%eax
c002655d:	50                   	push   %eax
c002655e:	e8 2e 04 00 00       	call   c0026991 <intq_putc>
    serial_notify();
c0026563:	e8 90 ea ff ff       	call   c0024ff8 <serial_notify>
}
c0026568:	83 c4 14             	add    $0x14,%esp
c002656b:	5b                   	pop    %ebx
c002656c:	5e                   	pop    %esi
c002656d:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c002656e:	83 ec 0c             	sub    $0xc,%esp
c0026571:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0026577:	50                   	push   %eax
c0026578:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002657e:	50                   	push   %eax
c002657f:	8d 83 bc 42 ff ff    	lea    -0xbd44(%ebx),%eax
c0026585:	50                   	push   %eax
c0026586:	6a 13                	push   $0x13
c0026588:	8d 83 90 67 ff ff    	lea    -0x9870(%ebx),%eax
c002658e:	50                   	push   %eax
c002658f:	e8 46 2b 00 00       	call   c00290da <debug_panic>
    ASSERT (!intq_full(&buffer));
c0026594:	83 ec 0c             	sub    $0xc,%esp
c0026597:	8d 83 a6 67 ff ff    	lea    -0x985a(%ebx),%eax
c002659d:	50                   	push   %eax
c002659e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00265a4:	50                   	push   %eax
c00265a5:	8d 83 bc 42 ff ff    	lea    -0xbd44(%ebx),%eax
c00265ab:	50                   	push   %eax
c00265ac:	6a 14                	push   $0x14
c00265ae:	8d 83 90 67 ff ff    	lea    -0x9870(%ebx),%eax
c00265b4:	50                   	push   %eax
c00265b5:	e8 20 2b 00 00       	call   c00290da <debug_panic>

c00265ba <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc(void) {
c00265ba:	57                   	push   %edi
c00265bb:	56                   	push   %esi
c00265bc:	53                   	push   %ebx
c00265bd:	e8 36 89 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00265c2:	81 c3 66 4b 01 00    	add    $0x14b66,%ebx
    enum intr_level old_level;
    uint8_t key;

    old_level = intr_disable();
c00265c8:	e8 42 b7 ff ff       	call   c0021d0f <intr_disable>
c00265cd:	89 c7                	mov    %eax,%edi
    key = intq_getc(&buffer);
c00265cf:	83 ec 0c             	sub    $0xc,%esp
c00265d2:	8d 83 98 1a 00 00    	lea    0x1a98(%ebx),%eax
c00265d8:	50                   	push   %eax
c00265d9:	e8 e8 02 00 00       	call   c00268c6 <intq_getc>
c00265de:	89 c6                	mov    %eax,%esi
    serial_notify();
c00265e0:	e8 13 ea ff ff       	call   c0024ff8 <serial_notify>
    intr_set_level(old_level);
c00265e5:	89 3c 24             	mov    %edi,(%esp)
c00265e8:	e8 29 b7 ff ff       	call   c0021d16 <intr_set_level>

    return key;
c00265ed:	83 c4 10             	add    $0x10,%esp
}
c00265f0:	89 f0                	mov    %esi,%eax
c00265f2:	5b                   	pop    %ebx
c00265f3:	5e                   	pop    %esi
c00265f4:	5f                   	pop    %edi
c00265f5:	c3                   	ret    

c00265f6 <input_full>:

/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full(void) {
c00265f6:	53                   	push   %ebx
c00265f7:	83 ec 08             	sub    $0x8,%esp
c00265fa:	e8 f9 88 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00265ff:	81 c3 29 4b 01 00    	add    $0x14b29,%ebx
    ASSERT (intr_get_level() == INTR_OFF);
c0026605:	e8 b3 b6 ff ff       	call   c0021cbd <intr_get_level>
c002660a:	85 c0                	test   %eax,%eax
c002660c:	75 14                	jne    c0026622 <input_full+0x2c>
    return intq_full(&buffer);
c002660e:	83 ec 0c             	sub    $0xc,%esp
c0026611:	8d 83 98 1a 00 00    	lea    0x1a98(%ebx),%eax
c0026617:	50                   	push   %eax
c0026618:	e8 b9 00 00 00       	call   c00266d6 <intq_full>
}
c002661d:	83 c4 18             	add    $0x18,%esp
c0026620:	5b                   	pop    %ebx
c0026621:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026622:	83 ec 0c             	sub    $0xc,%esp
c0026625:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c002662b:	50                   	push   %eax
c002662c:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0026632:	50                   	push   %eax
c0026633:	8d 83 b0 42 ff ff    	lea    -0xbd50(%ebx),%eax
c0026639:	50                   	push   %eax
c002663a:	6a 2e                	push   $0x2e
c002663c:	8d 83 90 67 ff ff    	lea    -0x9870(%ebx),%eax
c0026642:	50                   	push   %eax
c0026643:	e8 92 2a 00 00       	call   c00290da <debug_panic>

c0026648 <intq_init>:

static void signal(struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init(struct intq *q) {
c0026648:	56                   	push   %esi
c0026649:	53                   	push   %ebx
c002664a:	83 ec 10             	sub    $0x10,%esp
c002664d:	e8 a6 88 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026652:	81 c3 d6 4a 01 00    	add    $0x14ad6,%ebx
c0026658:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    lock_init(&q->lock);
c002665c:	56                   	push   %esi
c002665d:	e8 fb ca ff ff       	call   c002315d <lock_init>
    q->not_full = q->not_empty = NULL;
c0026662:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c0026669:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
    q->head = q->tail = 0;
c0026670:	c7 46 70 00 00 00 00 	movl   $0x0,0x70(%esi)
c0026677:	c7 46 6c 00 00 00 00 	movl   $0x0,0x6c(%esi)
}
c002667e:	83 c4 14             	add    $0x14,%esp
c0026681:	5b                   	pop    %ebx
c0026682:	5e                   	pop    %esi
c0026683:	c3                   	ret    

c0026684 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty(const struct intq *q) {
c0026684:	56                   	push   %esi
c0026685:	53                   	push   %ebx
c0026686:	83 ec 04             	sub    $0x4,%esp
c0026689:	e8 6a 88 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002668e:	81 c3 9a 4a 01 00    	add    $0x14a9a,%ebx
c0026694:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0026698:	e8 20 b6 ff ff       	call   c0021cbd <intr_get_level>
c002669d:	85 c0                	test   %eax,%eax
c002669f:	75 0f                	jne    c00266b0 <intq_empty+0x2c>
    return q->head == q->tail;
c00266a1:	8b 46 70             	mov    0x70(%esi),%eax
c00266a4:	39 46 6c             	cmp    %eax,0x6c(%esi)
c00266a7:	0f 94 c0             	sete   %al
}
c00266aa:	83 c4 04             	add    $0x4,%esp
c00266ad:	5b                   	pop    %ebx
c00266ae:	5e                   	pop    %esi
c00266af:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c00266b0:	83 ec 0c             	sub    $0xc,%esp
c00266b3:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c00266b9:	50                   	push   %eax
c00266ba:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00266c0:	50                   	push   %eax
c00266c1:	8d 83 fc 42 ff ff    	lea    -0xbd04(%ebx),%eax
c00266c7:	50                   	push   %eax
c00266c8:	6a 16                	push   $0x16
c00266ca:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c00266d0:	50                   	push   %eax
c00266d1:	e8 04 2a 00 00       	call   c00290da <debug_panic>

c00266d6 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full(const struct intq *q) {
c00266d6:	56                   	push   %esi
c00266d7:	53                   	push   %ebx
c00266d8:	83 ec 04             	sub    $0x4,%esp
c00266db:	e8 18 88 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00266e0:	81 c3 48 4a 01 00    	add    $0x14a48,%ebx
c00266e6:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c00266ea:	e8 ce b5 ff ff       	call   c0021cbd <intr_get_level>
c00266ef:	85 c0                	test   %eax,%eax
c00266f1:	75 1d                	jne    c0026710 <intq_full+0x3a>
}

/* Returns the position after POS within an intq. */
static int
next(int pos) {
    return (pos + 1) % INTQ_BUFSIZE;
c00266f3:	8b 46 6c             	mov    0x6c(%esi),%eax
c00266f6:	83 c0 01             	add    $0x1,%eax
c00266f9:	99                   	cltd   
c00266fa:	c1 ea 1a             	shr    $0x1a,%edx
c00266fd:	01 d0                	add    %edx,%eax
c00266ff:	83 e0 3f             	and    $0x3f,%eax
c0026702:	29 d0                	sub    %edx,%eax
    return next(q->head) == q->tail;
c0026704:	3b 46 70             	cmp    0x70(%esi),%eax
c0026707:	0f 94 c0             	sete   %al
}
c002670a:	83 c4 04             	add    $0x4,%esp
c002670d:	5b                   	pop    %ebx
c002670e:	5e                   	pop    %esi
c002670f:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026710:	83 ec 0c             	sub    $0xc,%esp
c0026713:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0026719:	50                   	push   %eax
c002671a:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0026720:	50                   	push   %eax
c0026721:	8d 83 f0 42 ff ff    	lea    -0xbd10(%ebx),%eax
c0026727:	50                   	push   %eax
c0026728:	6a 1d                	push   $0x1d
c002672a:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c0026730:	50                   	push   %eax
c0026731:	e8 a4 29 00 00       	call   c00290da <debug_panic>

c0026736 <wait>:
}

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait(struct intq *q UNUSED, struct thread **waiter) {
c0026736:	57                   	push   %edi
c0026737:	56                   	push   %esi
c0026738:	53                   	push   %ebx
c0026739:	e8 ba 87 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002673e:	81 c3 ea 49 01 00    	add    $0x149ea,%ebx
c0026744:	89 c6                	mov    %eax,%esi
c0026746:	89 d7                	mov    %edx,%edi
    ASSERT (!intr_context());
c0026748:	e8 68 b8 ff ff       	call   c0021fb5 <intr_context>
c002674d:	84 c0                	test   %al,%al
c002674f:	75 3b                	jne    c002678c <wait+0x56>
    ASSERT (intr_get_level() == INTR_OFF);
c0026751:	e8 67 b5 ff ff       	call   c0021cbd <intr_get_level>
c0026756:	85 c0                	test   %eax,%eax
c0026758:	75 58                	jne    c00267b2 <wait+0x7c>
    ASSERT ((waiter == &q->not_empty && intq_empty(q))
c002675a:	8d 46 28             	lea    0x28(%esi),%eax
c002675d:	39 c7                	cmp    %eax,%edi
c002675f:	74 77                	je     c00267d8 <wait+0xa2>
c0026761:	8d 46 24             	lea    0x24(%esi),%eax
c0026764:	39 c7                	cmp    %eax,%edi
c0026766:	0f 85 81 00 00 00    	jne    c00267ed <wait+0xb7>
c002676c:	83 ec 0c             	sub    $0xc,%esp
c002676f:	56                   	push   %esi
c0026770:	e8 61 ff ff ff       	call   c00266d6 <intq_full>
c0026775:	83 c4 10             	add    $0x10,%esp
c0026778:	84 c0                	test   %al,%al
c002677a:	74 71                	je     c00267ed <wait+0xb7>
            || (waiter == &q->not_full && intq_full(q)));

    *waiter = thread_current();
c002677c:	e8 f5 a7 ff ff       	call   c0020f76 <thread_current>
c0026781:	89 07                	mov    %eax,(%edi)
    thread_block();
c0026783:	e8 8d ad ff ff       	call   c0021515 <thread_block>
}
c0026788:	5b                   	pop    %ebx
c0026789:	5e                   	pop    %esi
c002678a:	5f                   	pop    %edi
c002678b:	c3                   	ret    
    ASSERT (!intr_context());
c002678c:	83 ec 0c             	sub    $0xc,%esp
c002678f:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c0026795:	50                   	push   %eax
c0026796:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002679c:	50                   	push   %eax
c002679d:	8d 83 dc 42 ff ff    	lea    -0xbd24(%ebx),%eax
c00267a3:	50                   	push   %eax
c00267a4:	6a 52                	push   $0x52
c00267a6:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c00267ac:	50                   	push   %eax
c00267ad:	e8 28 29 00 00       	call   c00290da <debug_panic>
    ASSERT (intr_get_level() == INTR_OFF);
c00267b2:	83 ec 0c             	sub    $0xc,%esp
c00267b5:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c00267bb:	50                   	push   %eax
c00267bc:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00267c2:	50                   	push   %eax
c00267c3:	8d 83 dc 42 ff ff    	lea    -0xbd24(%ebx),%eax
c00267c9:	50                   	push   %eax
c00267ca:	6a 53                	push   $0x53
c00267cc:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c00267d2:	50                   	push   %eax
c00267d3:	e8 02 29 00 00       	call   c00290da <debug_panic>
    ASSERT ((waiter == &q->not_empty && intq_empty(q))
c00267d8:	83 ec 0c             	sub    $0xc,%esp
c00267db:	56                   	push   %esi
c00267dc:	e8 a3 fe ff ff       	call   c0026684 <intq_empty>
c00267e1:	83 c4 10             	add    $0x10,%esp
c00267e4:	84 c0                	test   %al,%al
c00267e6:	75 94                	jne    c002677c <wait+0x46>
c00267e8:	e9 74 ff ff ff       	jmp    c0026761 <wait+0x2b>
c00267ed:	83 ec 0c             	sub    $0xc,%esp
c00267f0:	8d 83 d0 67 ff ff    	lea    -0x9830(%ebx),%eax
c00267f6:	50                   	push   %eax
c00267f7:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00267fd:	50                   	push   %eax
c00267fe:	8d 83 dc 42 ff ff    	lea    -0xbd24(%ebx),%eax
c0026804:	50                   	push   %eax
c0026805:	6a 55                	push   $0x55
c0026807:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c002680d:	50                   	push   %eax
c002680e:	e8 c7 28 00 00       	call   c00290da <debug_panic>

c0026813 <signal>:
/* WAITER must be the address of Q's not_empty or not_full
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal(struct intq *q UNUSED, struct thread **waiter) {
c0026813:	57                   	push   %edi
c0026814:	56                   	push   %esi
c0026815:	53                   	push   %ebx
c0026816:	e8 dd 86 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002681b:	81 c3 0d 49 01 00    	add    $0x1490d,%ebx
c0026821:	89 c7                	mov    %eax,%edi
c0026823:	89 d6                	mov    %edx,%esi
    ASSERT (intr_get_level() == INTR_OFF);
c0026825:	e8 93 b4 ff ff       	call   c0021cbd <intr_get_level>
c002682a:	85 c0                	test   %eax,%eax
c002682c:	75 3a                	jne    c0026868 <signal+0x55>
    ASSERT ((waiter == &q->not_empty && !intq_empty(q))
c002682e:	8d 47 28             	lea    0x28(%edi),%eax
c0026831:	39 c6                	cmp    %eax,%esi
c0026833:	74 59                	je     c002688e <signal+0x7b>
c0026835:	8d 47 24             	lea    0x24(%edi),%eax
c0026838:	39 c6                	cmp    %eax,%esi
c002683a:	75 64                	jne    c00268a0 <signal+0x8d>
c002683c:	83 ec 0c             	sub    $0xc,%esp
c002683f:	57                   	push   %edi
c0026840:	e8 91 fe ff ff       	call   c00266d6 <intq_full>
c0026845:	83 c4 10             	add    $0x10,%esp
c0026848:	84 c0                	test   %al,%al
c002684a:	75 54                	jne    c00268a0 <signal+0x8d>
            || (waiter == &q->not_full && !intq_full(q)));

    if (*waiter != NULL) {
c002684c:	8b 06                	mov    (%esi),%eax
c002684e:	85 c0                	test   %eax,%eax
c0026850:	74 12                	je     c0026864 <signal+0x51>
        thread_unblock(*waiter);
c0026852:	83 ec 0c             	sub    $0xc,%esp
c0026855:	50                   	push   %eax
c0026856:	e8 68 a6 ff ff       	call   c0020ec3 <thread_unblock>
        *waiter = NULL;
c002685b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0026861:	83 c4 10             	add    $0x10,%esp
    }
}
c0026864:	5b                   	pop    %ebx
c0026865:	5e                   	pop    %esi
c0026866:	5f                   	pop    %edi
c0026867:	c3                   	ret    
    ASSERT (intr_get_level() == INTR_OFF);
c0026868:	83 ec 0c             	sub    $0xc,%esp
c002686b:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0026871:	50                   	push   %eax
c0026872:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0026878:	50                   	push   %eax
c0026879:	8d 83 d4 42 ff ff    	lea    -0xbd2c(%ebx),%eax
c002687f:	50                   	push   %eax
c0026880:	6a 61                	push   $0x61
c0026882:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c0026888:	50                   	push   %eax
c0026889:	e8 4c 28 00 00       	call   c00290da <debug_panic>
    ASSERT ((waiter == &q->not_empty && !intq_empty(q))
c002688e:	83 ec 0c             	sub    $0xc,%esp
c0026891:	57                   	push   %edi
c0026892:	e8 ed fd ff ff       	call   c0026684 <intq_empty>
c0026897:	83 c4 10             	add    $0x10,%esp
c002689a:	84 c0                	test   %al,%al
c002689c:	74 ae                	je     c002684c <signal+0x39>
c002689e:	eb 95                	jmp    c0026835 <signal+0x22>
c00268a0:	83 ec 0c             	sub    $0xc,%esp
c00268a3:	8d 83 28 68 ff ff    	lea    -0x97d8(%ebx),%eax
c00268a9:	50                   	push   %eax
c00268aa:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00268b0:	50                   	push   %eax
c00268b1:	8d 83 d4 42 ff ff    	lea    -0xbd2c(%ebx),%eax
c00268b7:	50                   	push   %eax
c00268b8:	6a 63                	push   $0x63
c00268ba:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c00268c0:	50                   	push   %eax
c00268c1:	e8 14 28 00 00       	call   c00290da <debug_panic>

c00268c6 <intq_getc>:
intq_getc(struct intq *q) {
c00268c6:	57                   	push   %edi
c00268c7:	56                   	push   %esi
c00268c8:	53                   	push   %ebx
c00268c9:	e8 2a 86 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00268ce:	81 c3 5a 48 01 00    	add    $0x1485a,%ebx
c00268d4:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT (intr_get_level() == INTR_OFF);
c00268d8:	e8 e0 b3 ff ff       	call   c0021cbd <intr_get_level>
c00268dd:	85 c0                	test   %eax,%eax
c00268df:	75 3b                	jne    c002691c <intq_getc+0x56>
        wait(q, &q->not_empty);
c00268e1:	8d 7e 28             	lea    0x28(%esi),%edi
    while (intq_empty(q)) {
c00268e4:	83 ec 0c             	sub    $0xc,%esp
c00268e7:	56                   	push   %esi
c00268e8:	e8 97 fd ff ff       	call   c0026684 <intq_empty>
c00268ed:	83 c4 10             	add    $0x10,%esp
c00268f0:	84 c0                	test   %al,%al
c00268f2:	74 74                	je     c0026968 <intq_getc+0xa2>
        ASSERT (!intr_context());
c00268f4:	e8 bc b6 ff ff       	call   c0021fb5 <intr_context>
c00268f9:	84 c0                	test   %al,%al
c00268fb:	75 45                	jne    c0026942 <intq_getc+0x7c>
        lock_acquire(&q->lock);
c00268fd:	83 ec 0c             	sub    $0xc,%esp
c0026900:	56                   	push   %esi
c0026901:	e8 03 c9 ff ff       	call   c0023209 <lock_acquire>
        wait(q, &q->not_empty);
c0026906:	89 fa                	mov    %edi,%edx
c0026908:	89 f0                	mov    %esi,%eax
c002690a:	e8 27 fe ff ff       	call   c0026736 <wait>
        lock_release(&q->lock);
c002690f:	89 34 24             	mov    %esi,(%esp)
c0026912:	e8 f3 ca ff ff       	call   c002340a <lock_release>
c0026917:	83 c4 10             	add    $0x10,%esp
c002691a:	eb c8                	jmp    c00268e4 <intq_getc+0x1e>
    ASSERT (intr_get_level() == INTR_OFF);
c002691c:	83 ec 0c             	sub    $0xc,%esp
c002691f:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c0026925:	50                   	push   %eax
c0026926:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002692c:	50                   	push   %eax
c002692d:	8d 83 e4 42 ff ff    	lea    -0xbd1c(%ebx),%eax
c0026933:	50                   	push   %eax
c0026934:	6a 28                	push   $0x28
c0026936:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c002693c:	50                   	push   %eax
c002693d:	e8 98 27 00 00       	call   c00290da <debug_panic>
        ASSERT (!intr_context());
c0026942:	83 ec 0c             	sub    $0xc,%esp
c0026945:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c002694b:	50                   	push   %eax
c002694c:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0026952:	50                   	push   %eax
c0026953:	8d 83 e4 42 ff ff    	lea    -0xbd1c(%ebx),%eax
c0026959:	50                   	push   %eax
c002695a:	6a 2a                	push   $0x2a
c002695c:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c0026962:	50                   	push   %eax
c0026963:	e8 72 27 00 00       	call   c00290da <debug_panic>
    byte = q->buf[q->tail];
c0026968:	8b 46 70             	mov    0x70(%esi),%eax
c002696b:	0f b6 5c 06 2c       	movzbl 0x2c(%esi,%eax,1),%ebx
    return (pos + 1) % INTQ_BUFSIZE;
c0026970:	83 c0 01             	add    $0x1,%eax
c0026973:	99                   	cltd   
c0026974:	c1 ea 1a             	shr    $0x1a,%edx
c0026977:	01 d0                	add    %edx,%eax
c0026979:	83 e0 3f             	and    $0x3f,%eax
c002697c:	29 d0                	sub    %edx,%eax
    q->tail = next(q->tail);
c002697e:	89 46 70             	mov    %eax,0x70(%esi)
    signal(q, &q->not_full);
c0026981:	8d 56 24             	lea    0x24(%esi),%edx
c0026984:	89 f0                	mov    %esi,%eax
c0026986:	e8 88 fe ff ff       	call   c0026813 <signal>
}
c002698b:	89 d8                	mov    %ebx,%eax
c002698d:	5b                   	pop    %ebx
c002698e:	5e                   	pop    %esi
c002698f:	5f                   	pop    %edi
c0026990:	c3                   	ret    

c0026991 <intq_putc>:
intq_putc(struct intq *q, uint8_t byte) {
c0026991:	55                   	push   %ebp
c0026992:	57                   	push   %edi
c0026993:	56                   	push   %esi
c0026994:	53                   	push   %ebx
c0026995:	83 ec 0c             	sub    $0xc,%esp
c0026998:	e8 5b 85 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002699d:	81 c3 8b 47 01 00    	add    $0x1478b,%ebx
c00269a3:	8b 74 24 20          	mov    0x20(%esp),%esi
c00269a7:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    ASSERT (intr_get_level() == INTR_OFF);
c00269ab:	e8 0d b3 ff ff       	call   c0021cbd <intr_get_level>
c00269b0:	85 c0                	test   %eax,%eax
c00269b2:	75 3b                	jne    c00269ef <intq_putc+0x5e>
        wait(q, &q->not_full);
c00269b4:	8d 7e 24             	lea    0x24(%esi),%edi
    while (intq_full(q)) {
c00269b7:	83 ec 0c             	sub    $0xc,%esp
c00269ba:	56                   	push   %esi
c00269bb:	e8 16 fd ff ff       	call   c00266d6 <intq_full>
c00269c0:	83 c4 10             	add    $0x10,%esp
c00269c3:	84 c0                	test   %al,%al
c00269c5:	74 74                	je     c0026a3b <intq_putc+0xaa>
        ASSERT (!intr_context());
c00269c7:	e8 e9 b5 ff ff       	call   c0021fb5 <intr_context>
c00269cc:	84 c0                	test   %al,%al
c00269ce:	75 45                	jne    c0026a15 <intq_putc+0x84>
        lock_acquire(&q->lock);
c00269d0:	83 ec 0c             	sub    $0xc,%esp
c00269d3:	56                   	push   %esi
c00269d4:	e8 30 c8 ff ff       	call   c0023209 <lock_acquire>
        wait(q, &q->not_full);
c00269d9:	89 fa                	mov    %edi,%edx
c00269db:	89 f0                	mov    %esi,%eax
c00269dd:	e8 54 fd ff ff       	call   c0026736 <wait>
        lock_release(&q->lock);
c00269e2:	89 34 24             	mov    %esi,(%esp)
c00269e5:	e8 20 ca ff ff       	call   c002340a <lock_release>
c00269ea:	83 c4 10             	add    $0x10,%esp
c00269ed:	eb c8                	jmp    c00269b7 <intq_putc+0x26>
    ASSERT (intr_get_level() == INTR_OFF);
c00269ef:	83 ec 0c             	sub    $0xc,%esp
c00269f2:	8d 83 91 56 ff ff    	lea    -0xa96f(%ebx),%eax
c00269f8:	50                   	push   %eax
c00269f9:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00269ff:	50                   	push   %eax
c0026a00:	8d 83 c8 42 ff ff    	lea    -0xbd38(%ebx),%eax
c0026a06:	50                   	push   %eax
c0026a07:	6a 3b                	push   $0x3b
c0026a09:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c0026a0f:	50                   	push   %eax
c0026a10:	e8 c5 26 00 00       	call   c00290da <debug_panic>
        ASSERT (!intr_context());
c0026a15:	83 ec 0c             	sub    $0xc,%esp
c0026a18:	8d 83 25 57 ff ff    	lea    -0xa8db(%ebx),%eax
c0026a1e:	50                   	push   %eax
c0026a1f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0026a25:	50                   	push   %eax
c0026a26:	8d 83 c8 42 ff ff    	lea    -0xbd38(%ebx),%eax
c0026a2c:	50                   	push   %eax
c0026a2d:	6a 3d                	push   $0x3d
c0026a2f:	8d 83 ba 67 ff ff    	lea    -0x9846(%ebx),%eax
c0026a35:	50                   	push   %eax
c0026a36:	e8 9f 26 00 00       	call   c00290da <debug_panic>
    q->buf[q->head] = byte;
c0026a3b:	8b 46 6c             	mov    0x6c(%esi),%eax
c0026a3e:	89 e9                	mov    %ebp,%ecx
c0026a40:	88 4c 06 2c          	mov    %cl,0x2c(%esi,%eax,1)
    return (pos + 1) % INTQ_BUFSIZE;
c0026a44:	83 c0 01             	add    $0x1,%eax
c0026a47:	99                   	cltd   
c0026a48:	c1 ea 1a             	shr    $0x1a,%edx
c0026a4b:	01 d0                	add    %edx,%eax
c0026a4d:	83 e0 3f             	and    $0x3f,%eax
c0026a50:	29 d0                	sub    %edx,%eax
    q->head = next(q->head);
c0026a52:	89 46 6c             	mov    %eax,0x6c(%esi)
    signal(q, &q->not_empty);
c0026a55:	8d 56 28             	lea    0x28(%esi),%edx
c0026a58:	89 f0                	mov    %esi,%eax
c0026a5a:	e8 b4 fd ff ff       	call   c0026813 <signal>
}
c0026a5f:	83 c4 0c             	add    $0xc,%esp
c0026a62:	5b                   	pop    %ebx
c0026a63:	5e                   	pop    %esi
c0026a64:	5f                   	pop    %edi
c0026a65:	5d                   	pop    %ebp
c0026a66:	c3                   	ret    

c0026a67 <rtc_get_time>:
static uint8_t cmos_read(uint8_t index);

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time(void) {
c0026a67:	55                   	push   %ebp
c0026a68:	57                   	push   %edi
c0026a69:	56                   	push   %esi
c0026a6a:	53                   	push   %ebx
c0026a6b:	83 ec 10             	sub    $0x10,%esp
c0026a6e:	e8 89 84 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0026a73:	05 b5 46 01 00       	add    $0x146b5,%eax
c0026a78:	89 44 24 0c          	mov    %eax,0xc(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026a7c:	be 00 00 00 00       	mov    $0x0,%esi
c0026a81:	bf 02 00 00 00       	mov    $0x2,%edi
c0026a86:	89 f0                	mov    %esi,%eax
c0026a88:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026a8a:	e4 71                	in     $0x71,%al
}

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin(uint8_t x) {
    return (x & 0x0f) + ((x >> 4) * 10);
c0026a8c:	89 c2                	mov    %eax,%edx
c0026a8e:	c0 ea 04             	shr    $0x4,%dl
c0026a91:	0f b6 d2             	movzbl %dl,%edx
c0026a94:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026a97:	83 e0 0f             	and    $0xf,%eax
c0026a9a:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026a9d:	89 f8                	mov    %edi,%eax
c0026a9f:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026aa1:	e4 71                	in     $0x71,%al
c0026aa3:	88 44 24 08          	mov    %al,0x8(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026aa7:	b8 04 00 00 00       	mov    $0x4,%eax
c0026aac:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026aae:	e4 71                	in     $0x71,%al
c0026ab0:	88 44 24 04          	mov    %al,0x4(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ab4:	b8 07 00 00 00       	mov    $0x7,%eax
c0026ab9:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026abb:	e4 71                	in     $0x71,%al
c0026abd:	88 04 24             	mov    %al,(%esp)
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ac0:	b8 08 00 00 00       	mov    $0x8,%eax
c0026ac5:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026ac7:	e4 71                	in     $0x71,%al
c0026ac9:	89 c5                	mov    %eax,%ebp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026acb:	b8 09 00 00 00       	mov    $0x9,%eax
c0026ad0:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026ad2:	e4 71                	in     $0x71,%al
c0026ad4:	89 c1                	mov    %eax,%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ad6:	89 f0                	mov    %esi,%eax
c0026ad8:	e6 70                	out    %al,$0x70
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026ada:	e4 71                	in     $0x71,%al
c0026adc:	89 c2                	mov    %eax,%edx
c0026ade:	c0 ea 04             	shr    $0x4,%dl
c0026ae1:	0f b6 d2             	movzbl %dl,%edx
c0026ae4:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026ae7:	83 e0 0f             	and    $0xf,%eax
c0026aea:	8d 04 50             	lea    (%eax,%edx,2),%eax
    } while (sec != bcd_to_bin(cmos_read(RTC_REG_SEC)));
c0026aed:	39 d8                	cmp    %ebx,%eax
c0026aef:	75 95                	jne    c0026a86 <rtc_get_time+0x1f>
    return (x & 0x0f) + ((x >> 4) * 10);
c0026af1:	89 c8                	mov    %ecx,%eax
c0026af3:	c0 e8 04             	shr    $0x4,%al
c0026af6:	0f b6 c0             	movzbl %al,%eax
c0026af9:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0026afc:	83 e1 0f             	and    $0xf,%ecx
c0026aff:	8d 04 41             	lea    (%ecx,%eax,2),%eax
        year += 100;
c0026b02:	8d 48 64             	lea    0x64(%eax),%ecx
c0026b05:	83 f8 46             	cmp    $0x46,%eax
c0026b08:	0f 4c c1             	cmovl  %ecx,%eax
    return (x & 0x0f) + ((x >> 4) * 10);
c0026b0b:	89 ea                	mov    %ebp,%edx
c0026b0d:	89 e9                	mov    %ebp,%ecx
c0026b0f:	c0 e9 04             	shr    $0x4,%cl
c0026b12:	0f b6 c9             	movzbl %cl,%ecx
c0026b15:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026b18:	83 e2 0f             	and    $0xf,%edx
c0026b1b:	8d 2c 4a             	lea    (%edx,%ecx,2),%ebp
    year -= 70;
c0026b1e:	8d 78 ba             	lea    -0x46(%eax),%edi
    time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026b21:	8d 50 bc             	lea    -0x44(%eax),%edx
c0026b24:	83 e8 47             	sub    $0x47,%eax
c0026b27:	0f 48 c2             	cmovs  %edx,%eax
c0026b2a:	c1 f8 02             	sar    $0x2,%eax
c0026b2d:	69 d7 6d 01 00 00    	imul   $0x16d,%edi,%edx
c0026b33:	01 d0                	add    %edx,%eax
c0026b35:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    for (i = 1; i <= mon; i++)
c0026b3b:	85 ed                	test   %ebp,%ebp
c0026b3d:	7e 1c                	jle    c0026b5b <rtc_get_time+0xf4>
c0026b3f:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0026b43:	8d 96 18 43 ff ff    	lea    -0xbce8(%esi),%edx
c0026b49:	8d 34 aa             	lea    (%edx,%ebp,4),%esi
        time += days_per_month[i - 1] * 24 * 60 * 60;
c0026b4c:	69 0a 80 51 01 00    	imul   $0x15180,(%edx),%ecx
c0026b52:	01 c8                	add    %ecx,%eax
c0026b54:	83 c2 04             	add    $0x4,%edx
    for (i = 1; i <= mon; i++)
c0026b57:	39 f2                	cmp    %esi,%edx
c0026b59:	75 f1                	jne    c0026b4c <rtc_get_time+0xe5>
    if (mon > 2 && year % 4 == 0)
c0026b5b:	83 fd 02             	cmp    $0x2,%ebp
c0026b5e:	7e 0e                	jle    c0026b6e <rtc_get_time+0x107>
c0026b60:	83 e7 03             	and    $0x3,%edi
        time += 24 * 60 * 60;
c0026b63:	8d 90 80 51 01 00    	lea    0x15180(%eax),%edx
c0026b69:	85 ff                	test   %edi,%edi
c0026b6b:	0f 44 c2             	cmove  %edx,%eax
    return (x & 0x0f) + ((x >> 4) * 10);
c0026b6e:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c0026b73:	c0 ea 04             	shr    $0x4,%dl
c0026b76:	0f b6 d2             	movzbl %dl,%edx
c0026b79:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026b7c:	8b 54 24 04          	mov    0x4(%esp),%edx
c0026b80:	83 e2 0f             	and    $0xf,%edx
c0026b83:	8d 0c 4a             	lea    (%edx,%ecx,2),%ecx
    time += hour * 60 * 60;
c0026b86:	69 c9 10 0e 00 00    	imul   $0xe10,%ecx,%ecx
    return (x & 0x0f) + ((x >> 4) * 10);
c0026b8c:	0f b6 54 24 08       	movzbl 0x8(%esp),%edx
c0026b91:	c0 ea 04             	shr    $0x4,%dl
c0026b94:	0f b6 d2             	movzbl %dl,%edx
c0026b97:	8d 34 92             	lea    (%edx,%edx,4),%esi
c0026b9a:	8b 54 24 08          	mov    0x8(%esp),%edx
c0026b9e:	83 e2 0f             	and    $0xf,%edx
c0026ba1:	8d 14 72             	lea    (%edx,%esi,2),%edx
    time += min * 60;
c0026ba4:	6b d2 3c             	imul   $0x3c,%edx,%edx
    time += sec;
c0026ba7:	01 d1                	add    %edx,%ecx
c0026ba9:	01 cb                	add    %ecx,%ebx
    return (x & 0x0f) + ((x >> 4) * 10);
c0026bab:	0f b6 14 24          	movzbl (%esp),%edx
c0026baf:	c0 ea 04             	shr    $0x4,%dl
c0026bb2:	0f b6 d2             	movzbl %dl,%edx
c0026bb5:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026bb8:	8b 14 24             	mov    (%esp),%edx
c0026bbb:	83 e2 0f             	and    $0xf,%edx
    time += (mday - 1) * 24 * 60 * 60;
c0026bbe:	8d 54 4a ff          	lea    -0x1(%edx,%ecx,2),%edx
c0026bc2:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
    time += sec;
c0026bc8:	01 d3                	add    %edx,%ebx
c0026bca:	01 d8                	add    %ebx,%eax
}
c0026bcc:	83 c4 10             	add    $0x10,%esp
c0026bcf:	5b                   	pop    %ebx
c0026bd0:	5e                   	pop    %esi
c0026bd1:	5f                   	pop    %edi
c0026bd2:	5d                   	pop    %ebp
c0026bd3:	c3                   	ret    

c0026bd4 <shutdown_configure>:
}

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure(enum shutdown_type type) {
c0026bd4:	e8 23 83 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0026bd9:	05 4f 45 01 00       	add    $0x1454f,%eax
    how = type;
c0026bde:	8b 54 24 04          	mov    0x4(%esp),%edx
c0026be2:	89 90 0c 1b 00 00    	mov    %edx,0x1b0c(%eax)
}
c0026be8:	c3                   	ret    

c0026be9 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot(void) {
c0026be9:	57                   	push   %edi
c0026bea:	56                   	push   %esi
c0026beb:	53                   	push   %ebx
c0026bec:	e8 07 83 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026bf1:	81 c3 37 45 01 00    	add    $0x14537,%ebx
    printf("Rebooting...\n");
c0026bf7:	83 ec 0c             	sub    $0xc,%esp
c0026bfa:	8d 83 81 68 ff ff    	lea    -0x977f(%ebx),%eax
c0026c00:	50                   	push   %eax
c0026c01:	e8 aa 44 00 00       	call   c002b0b0 <puts>
c0026c06:	83 c4 10             	add    $0x10,%esp
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026c09:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
c0026c0e:	eb 1f                	jmp    c0026c2f <shutdown_reboot+0x46>
            if ((inb(CONTROL_REG) & 0x02) == 0)
                break;
            timer_udelay(2);
        }

        timer_udelay(50);
c0026c10:	83 ec 08             	sub    $0x8,%esp
c0026c13:	6a 00                	push   $0x0
c0026c15:	6a 32                	push   $0x32
c0026c17:	e8 2d db ff ff       	call   c0024749 <timer_udelay>
c0026c1c:	89 f8                	mov    %edi,%eax
c0026c1e:	e6 64                	out    %al,$0x64

        /* Pulse bit 0 of the output port P2 of the keyboard controller.
         * This will reset the CPU. */
        outb(CONTROL_REG, 0xfe);
        timer_udelay(50);
c0026c20:	83 c4 08             	add    $0x8,%esp
c0026c23:	6a 00                	push   $0x0
c0026c25:	6a 32                	push   $0x32
c0026c27:	e8 1d db ff ff       	call   c0024749 <timer_udelay>
    for (;;) {
c0026c2c:	83 c4 10             	add    $0x10,%esp
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026c2f:	e4 64                	in     $0x64,%al
            if ((inb(CONTROL_REG) & 0x02) == 0)
c0026c31:	a8 02                	test   $0x2,%al
c0026c33:	74 db                	je     c0026c10 <shutdown_reboot+0x27>
            timer_udelay(2);
c0026c35:	83 ec 08             	sub    $0x8,%esp
c0026c38:	6a 00                	push   $0x0
c0026c3a:	6a 02                	push   $0x2
c0026c3c:	e8 08 db ff ff       	call   c0024749 <timer_udelay>
c0026c41:	83 c4 10             	add    $0x10,%esp
c0026c44:	be ff ff 00 00       	mov    $0xffff,%esi
c0026c49:	e4 64                	in     $0x64,%al
            if ((inb(CONTROL_REG) & 0x02) == 0)
c0026c4b:	a8 02                	test   $0x2,%al
c0026c4d:	74 c1                	je     c0026c10 <shutdown_reboot+0x27>
            timer_udelay(2);
c0026c4f:	83 ec 08             	sub    $0x8,%esp
c0026c52:	6a 00                	push   $0x0
c0026c54:	6a 02                	push   $0x2
c0026c56:	e8 ee da ff ff       	call   c0024749 <timer_udelay>
        for (i = 0; i < 0x10000; i++) {
c0026c5b:	83 c4 10             	add    $0x10,%esp
c0026c5e:	83 ee 01             	sub    $0x1,%esi
c0026c61:	75 e6                	jne    c0026c49 <shutdown_reboot+0x60>
c0026c63:	eb ab                	jmp    c0026c10 <shutdown_reboot+0x27>

c0026c65 <shutdown_power_off>:
}

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off(void) {
c0026c65:	53                   	push   %ebx
c0026c66:	83 ec 18             	sub    $0x18,%esp
c0026c69:	e8 8a 82 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026c6e:	81 c3 ba 44 01 00    	add    $0x144ba,%ebx
    const char s[] = "Shutdown";
c0026c74:	c7 44 24 07 53 68 75 	movl   $0x74756853,0x7(%esp)
c0026c7b:	74 
c0026c7c:	c7 44 24 0b 64 6f 77 	movl   $0x6e776f64,0xb(%esp)
c0026c83:	6e 
c0026c84:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
    const char *p;

#ifdef FILESYS
    filesys_done ();
c0026c89:	e8 d4 67 00 00       	call   c002d462 <filesys_done>
}

/* Print statistics about Pintos execution. */
static void
print_stats(void) {
    timer_print_stats();
c0026c8e:	e8 e8 da ff ff       	call   c002477b <timer_print_stats>
    thread_print_stats();
c0026c93:	e8 d6 a1 ff ff       	call   c0020e6e <thread_print_stats>
#ifdef FILESYS
    block_print_stats ();
c0026c98:	e8 74 e6 ff ff       	call   c0025311 <block_print_stats>
#endif
    console_print_stats();
c0026c9d:	e8 9f 43 00 00       	call   c002b041 <console_print_stats>
    kbd_print_stats();
c0026ca2:	e8 52 dd ff ff       	call   c00249f9 <kbd_print_stats>
#ifdef USERPROG
    exception_print_stats ();
c0026ca7:	e8 7c 5a 00 00       	call   c002c728 <exception_print_stats>
    printf("Powering off...\n");
c0026cac:	83 ec 0c             	sub    $0xc,%esp
c0026caf:	8d 83 8e 68 ff ff    	lea    -0x9772(%ebx),%eax
c0026cb5:	50                   	push   %eax
c0026cb6:	e8 f5 43 00 00       	call   c002b0b0 <puts>
    serial_flush();
c0026cbb:	e8 e7 e2 ff ff       	call   c0024fa7 <serial_flush>
    asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026cc0:	b8 00 20 00 00       	mov    $0x2000,%eax
c0026cc5:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c0026cca:	66 ef                	out    %ax,(%dx)
    for (p = s; *p != '\0'; p++)
c0026ccc:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
c0026cd1:	83 c4 10             	add    $0x10,%esp
c0026cd4:	84 c0                	test   %al,%al
c0026cd6:	74 14                	je     c0026cec <shutdown_power_off+0x87>
c0026cd8:	8d 4c 24 07          	lea    0x7(%esp),%ecx
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026cdc:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c0026ce1:	ee                   	out    %al,(%dx)
c0026ce2:	83 c1 01             	add    $0x1,%ecx
c0026ce5:	0f b6 01             	movzbl (%ecx),%eax
c0026ce8:	84 c0                	test   %al,%al
c0026cea:	75 f5                	jne    c0026ce1 <shutdown_power_off+0x7c>
c0026cec:	b8 31 00 00 00       	mov    $0x31,%eax
c0026cf1:	ba 01 05 00 00       	mov    $0x501,%edx
c0026cf6:	ee                   	out    %al,(%dx)
    asm volatile ("cli; hlt" : : : "memory");
c0026cf7:	fa                   	cli    
c0026cf8:	f4                   	hlt    
    printf("still running...\n");
c0026cf9:	83 ec 0c             	sub    $0xc,%esp
c0026cfc:	8d 83 9e 68 ff ff    	lea    -0x9762(%ebx),%eax
c0026d02:	50                   	push   %eax
c0026d03:	e8 a8 43 00 00       	call   c002b0b0 <puts>
c0026d08:	83 c4 10             	add    $0x10,%esp
    for (;;);
c0026d0b:	eb fe                	jmp    c0026d0b <shutdown_power_off+0xa6>

c0026d0d <shutdown>:
shutdown(void) {
c0026d0d:	83 ec 0c             	sub    $0xc,%esp
c0026d10:	e8 e7 81 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0026d15:	05 13 44 01 00       	add    $0x14413,%eax
    switch (how) {
c0026d1a:	8b 80 0c 1b 00 00    	mov    0x1b0c(%eax),%eax
c0026d20:	83 f8 01             	cmp    $0x1,%eax
c0026d23:	74 09                	je     c0026d2e <shutdown+0x21>
c0026d25:	83 f8 02             	cmp    $0x2,%eax
c0026d28:	74 09                	je     c0026d33 <shutdown+0x26>
}
c0026d2a:	83 c4 0c             	add    $0xc,%esp
c0026d2d:	c3                   	ret    
            shutdown_power_off();
c0026d2e:	e8 32 ff ff ff       	call   c0026c65 <shutdown_power_off>
            shutdown_reboot();
c0026d33:	e8 b1 fe ff ff       	call   c0026be9 <shutdown_reboot>

c0026d38 <speaker_off>:
}

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off(void) {
c0026d38:	53                   	push   %ebx
c0026d39:	83 ec 08             	sub    $0x8,%esp
c0026d3c:	e8 b7 81 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026d41:	81 c3 e7 43 01 00    	add    $0x143e7,%ebx
    enum intr_level old_level = intr_disable();
c0026d47:	e8 c3 af ff ff       	call   c0021d0f <intr_disable>
c0026d4c:	89 c2                	mov    %eax,%edx
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026d4e:	e4 61                	in     $0x61,%al
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026d50:	83 e0 fc             	and    $0xfffffffc,%eax
c0026d53:	e6 61                	out    %al,$0x61
    outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
    intr_set_level(old_level);
c0026d55:	83 ec 0c             	sub    $0xc,%esp
c0026d58:	52                   	push   %edx
c0026d59:	e8 b8 af ff ff       	call   c0021d16 <intr_set_level>
}
c0026d5e:	83 c4 18             	add    $0x18,%esp
c0026d61:	5b                   	pop    %ebx
c0026d62:	c3                   	ret    

c0026d63 <speaker_on>:
speaker_on(int frequency) {
c0026d63:	57                   	push   %edi
c0026d64:	56                   	push   %esi
c0026d65:	53                   	push   %ebx
c0026d66:	e8 8d 81 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026d6b:	81 c3 bd 43 01 00    	add    $0x143bd,%ebx
c0026d71:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (frequency >= 20 && frequency <= 20000) {
c0026d75:	8d 46 ec             	lea    -0x14(%esi),%eax
c0026d78:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c0026d7d:	77 2a                	ja     c0026da9 <speaker_on+0x46>
        enum intr_level old_level = intr_disable();
c0026d7f:	e8 8b af ff ff       	call   c0021d0f <intr_disable>
c0026d84:	89 c7                	mov    %eax,%edi
        pit_configure_channel(2, 3, frequency);
c0026d86:	83 ec 04             	sub    $0x4,%esp
c0026d89:	56                   	push   %esi
c0026d8a:	6a 03                	push   $0x3
c0026d8c:	6a 02                	push   $0x2
c0026d8e:	e8 9a d3 ff ff       	call   c002412d <pit_configure_channel>
    asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026d93:	e4 61                	in     $0x61,%al
        outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026d95:	83 c8 03             	or     $0x3,%eax
    asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026d98:	e6 61                	out    %al,$0x61
        intr_set_level(old_level);
c0026d9a:	89 3c 24             	mov    %edi,(%esp)
c0026d9d:	e8 74 af ff ff       	call   c0021d16 <intr_set_level>
c0026da2:	83 c4 10             	add    $0x10,%esp
}
c0026da5:	5b                   	pop    %ebx
c0026da6:	5e                   	pop    %esi
c0026da7:	5f                   	pop    %edi
c0026da8:	c3                   	ret    
        speaker_off();
c0026da9:	e8 8a ff ff ff       	call   c0026d38 <speaker_off>
}
c0026dae:	eb f5                	jmp    c0026da5 <speaker_on+0x42>

c0026db0 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep(void) {
c0026db0:	53                   	push   %ebx
c0026db1:	83 ec 08             	sub    $0x8,%esp
c0026db4:	e8 3f 81 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026db9:	81 c3 6f 43 01 00    	add    $0x1436f,%ebx

       We can't just enable interrupts while we sleep.  For one
       thing, we get called (indirectly) from printf, which should
       always work, even during boot before we're ready to enable
       interrupts. */
    if (intr_get_level() == INTR_ON) {
c0026dbf:	e8 f9 ae ff ff       	call   c0021cbd <intr_get_level>
c0026dc4:	83 f8 01             	cmp    $0x1,%eax
c0026dc7:	74 05                	je     c0026dce <speaker_beep+0x1e>
        speaker_on(440);
        timer_msleep(250);
        speaker_off();
    }
}
c0026dc9:	83 c4 08             	add    $0x8,%esp
c0026dcc:	5b                   	pop    %ebx
c0026dcd:	c3                   	ret    
        speaker_on(440);
c0026dce:	83 ec 0c             	sub    $0xc,%esp
c0026dd1:	68 b8 01 00 00       	push   $0x1b8
c0026dd6:	e8 88 ff ff ff       	call   c0026d63 <speaker_on>
        timer_msleep(250);
c0026ddb:	83 c4 08             	add    $0x8,%esp
c0026dde:	6a 00                	push   $0x0
c0026de0:	68 fa 00 00 00       	push   $0xfa
c0026de5:	e8 fb d8 ff ff       	call   c00246e5 <timer_msleep>
        speaker_off();
c0026dea:	e8 49 ff ff ff       	call   c0026d38 <speaker_off>
c0026def:	83 c4 10             	add    $0x10,%esp
}
c0026df2:	eb d5                	jmp    c0026dc9 <speaker_beep+0x19>

c0026df4 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026df4:	55                   	push   %ebp
c0026df5:	89 e5                	mov    %esp,%ebp
c0026df7:	57                   	push   %edi
c0026df8:	56                   	push   %esi
c0026df9:	53                   	push   %ebx
c0026dfa:	83 ec 14             	sub    $0x14,%esp
c0026dfd:	e8 f6 80 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0026e02:	81 c3 26 43 01 00    	add    $0x14326,%ebx
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026e08:	ff 75 04             	pushl  0x4(%ebp)
c0026e0b:	8d 83 af 68 ff ff    	lea    -0x9751(%ebx),%eax
c0026e11:	50                   	push   %eax
c0026e12:	e8 67 06 00 00       	call   c002747e <printf>
  for (frame = __builtin_frame_address (1);
c0026e17:	8b 75 00             	mov    0x0(%ebp),%esi
c0026e1a:	83 c4 10             	add    $0x10,%esp
c0026e1d:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026e23:	76 29                	jbe    c0026e4e <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026e25:	83 3e 00             	cmpl   $0x0,(%esi)
c0026e28:	74 24                	je     c0026e4e <debug_backtrace+0x5a>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026e2a:	8d bb ba 68 ff ff    	lea    -0x9746(%ebx),%edi
c0026e30:	83 ec 08             	sub    $0x8,%esp
c0026e33:	ff 76 04             	pushl  0x4(%esi)
c0026e36:	57                   	push   %edi
c0026e37:	e8 42 06 00 00       	call   c002747e <printf>
       frame = frame[0]) 
c0026e3c:	8b 36                	mov    (%esi),%esi
  for (frame = __builtin_frame_address (1);
c0026e3e:	83 c4 10             	add    $0x10,%esp
c0026e41:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026e47:	76 05                	jbe    c0026e4e <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026e49:	83 3e 00             	cmpl   $0x0,(%esi)
c0026e4c:	75 e2                	jne    c0026e30 <debug_backtrace+0x3c>
  printf (".\n");
c0026e4e:	83 ec 0c             	sub    $0xc,%esp
c0026e51:	8d 83 57 64 ff ff    	lea    -0x9ba9(%ebx),%eax
c0026e57:	50                   	push   %eax
c0026e58:	e8 53 42 00 00       	call   c002b0b0 <puts>

  if (!explained) 
c0026e5d:	83 c4 10             	add    $0x10,%esp
c0026e60:	80 bb 10 1b 00 00 00 	cmpb   $0x0,0x1b10(%ebx)
c0026e67:	74 08                	je     c0026e71 <debug_backtrace+0x7d>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026e69:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0026e6c:	5b                   	pop    %ebx
c0026e6d:	5e                   	pop    %esi
c0026e6e:	5f                   	pop    %edi
c0026e6f:	5d                   	pop    %ebp
c0026e70:	c3                   	ret    
      explained = true;
c0026e71:	c6 83 10 1b 00 00 01 	movb   $0x1,0x1b10(%ebx)
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026e78:	83 ec 0c             	sub    $0xc,%esp
c0026e7b:	8d 83 c0 68 ff ff    	lea    -0x9740(%ebx),%eax
c0026e81:	50                   	push   %eax
c0026e82:	e8 29 42 00 00       	call   c002b0b0 <puts>
c0026e87:	83 c4 10             	add    $0x10,%esp
}
c0026e8a:	eb dd                	jmp    c0026e69 <debug_backtrace+0x75>

c0026e8c <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026e8c:	55                   	push   %ebp
c0026e8d:	57                   	push   %edi
c0026e8e:	56                   	push   %esi
c0026e8f:	53                   	push   %ebx
c0026e90:	83 ec 04             	sub    $0x4,%esp
c0026e93:	e8 6c 80 00 00       	call   c002ef04 <__x86.get_pc_thunk.di>
c0026e98:	81 c7 90 42 01 00    	add    $0x14290,%edi
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026e9e:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c0026ea3:	88 84 38 38 1b 00 00 	mov    %al,0x1b38(%eax,%edi,1)
  for (i = 0; i < 256; i++) 
c0026eaa:	83 c0 01             	add    $0x1,%eax
c0026ead:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026eb2:	75 ef                	jne    c0026ea3 <random_init+0x17>
c0026eb4:	8d 8f 38 1b 00 00    	lea    0x1b38(%edi),%ecx
  for (i = j = 0; i < 256; i++) 
c0026eba:	bb 00 00 00 00       	mov    $0x0,%ebx
c0026ebf:	ba 00 00 00 00       	mov    $0x0,%edx
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
c0026ec4:	89 cd                	mov    %ecx,%ebp
c0026ec6:	88 5c 24 03          	mov    %bl,0x3(%esp)
      j += s[i] + seedp[i % sizeof seed];
c0026eca:	89 d0                	mov    %edx,%eax
c0026ecc:	83 e0 03             	and    $0x3,%eax
c0026ecf:	0f b6 31             	movzbl (%ecx),%esi
c0026ed2:	89 f3                	mov    %esi,%ebx
c0026ed4:	02 5c 04 18          	add    0x18(%esp,%eax,1),%bl
c0026ed8:	00 5c 24 03          	add    %bl,0x3(%esp)
c0026edc:	0f b6 44 24 03       	movzbl 0x3(%esp),%eax
      swap_byte (s + i, s + j);
c0026ee1:	0f b6 c0             	movzbl %al,%eax
c0026ee4:	01 e8                	add    %ebp,%eax
  *a = *b;
c0026ee6:	0f b6 18             	movzbl (%eax),%ebx
c0026ee9:	88 19                	mov    %bl,(%ecx)
  *b = t;
c0026eeb:	89 f3                	mov    %esi,%ebx
c0026eed:	88 18                	mov    %bl,(%eax)
  for (i = j = 0; i < 256; i++) 
c0026eef:	83 c2 01             	add    $0x1,%edx
c0026ef2:	83 c1 01             	add    $0x1,%ecx
c0026ef5:	81 fa 00 01 00 00    	cmp    $0x100,%edx
c0026efb:	75 cd                	jne    c0026eca <random_init+0x3e>
    }

  s_i = s_j = 0;
c0026efd:	c6 87 19 1b 00 00 00 	movb   $0x0,0x1b19(%edi)
c0026f04:	c6 87 1a 1b 00 00 00 	movb   $0x0,0x1b1a(%edi)
  inited = true;
c0026f0b:	c6 87 18 1b 00 00 01 	movb   $0x1,0x1b18(%edi)
}
c0026f12:	83 c4 04             	add    $0x4,%esp
c0026f15:	5b                   	pop    %ebx
c0026f16:	5e                   	pop    %esi
c0026f17:	5f                   	pop    %edi
c0026f18:	5d                   	pop    %ebp
c0026f19:	c3                   	ret    

c0026f1a <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026f1a:	55                   	push   %ebp
c0026f1b:	57                   	push   %edi
c0026f1c:	56                   	push   %esi
c0026f1d:	53                   	push   %ebx
c0026f1e:	83 ec 14             	sub    $0x14,%esp
c0026f21:	e8 d6 7f 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0026f26:	05 02 42 01 00       	add    $0x14202,%eax
c0026f2b:	89 44 24 08          	mov    %eax,0x8(%esp)
c0026f2f:	8b 74 24 28          	mov    0x28(%esp),%esi
c0026f33:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  uint8_t *buf;

  if (!inited)
c0026f37:	80 b8 18 1b 00 00 00 	cmpb   $0x0,0x1b18(%eax)
c0026f3e:	0f 84 ac 00 00 00    	je     c0026ff0 <random_bytes+0xd6>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c0026f44:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0026f47:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0026f4b:	85 db                	test   %ebx,%ebx
c0026f4d:	0f 84 95 00 00 00    	je     c0026fe8 <random_bytes+0xce>
c0026f53:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0026f57:	0f b6 87 19 1b 00 00 	movzbl 0x1b19(%edi),%eax
c0026f5e:	88 44 24 11          	mov    %al,0x11(%esp)
c0026f62:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c0026f65:	89 44 24 04          	mov    %eax,0x4(%esp)
c0026f69:	89 f3                	mov    %esi,%ebx
c0026f6b:	0f b6 87 1a 1b 00 00 	movzbl 0x1b1a(%edi),%eax
c0026f72:	83 c0 01             	add    $0x1,%eax
c0026f75:	88 44 24 13          	mov    %al,0x13(%esp)
c0026f79:	89 f2                	mov    %esi,%edx
c0026f7b:	29 d0                	sub    %edx,%eax
c0026f7d:	88 44 24 12          	mov    %al,0x12(%esp)
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c0026f81:	8d 87 38 1b 00 00    	lea    0x1b38(%edi),%eax
      s_i++;
c0026f87:	0f b6 7c 24 12       	movzbl 0x12(%esp),%edi
c0026f8c:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
      s_j += s[s_i];
c0026f8f:	0f b6 d2             	movzbl %dl,%edx
c0026f92:	0f b6 4c 24 11       	movzbl 0x11(%esp),%ecx
c0026f97:	02 0c 10             	add    (%eax,%edx,1),%cl
c0026f9a:	88 4c 24 11          	mov    %cl,0x11(%esp)
      swap_byte (s + s_i, s + s_j);
c0026f9e:	0f b6 f1             	movzbl %cl,%esi
c0026fa1:	89 34 24             	mov    %esi,(%esp)
c0026fa4:	01 c6                	add    %eax,%esi
c0026fa6:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  uint8_t t = *a;
c0026fa9:	0f b6 2f             	movzbl (%edi),%ebp
  *a = *b;
c0026fac:	0f b6 0e             	movzbl (%esi),%ecx
c0026faf:	88 0f                	mov    %cl,(%edi)
  *b = t;
c0026fb1:	89 e9                	mov    %ebp,%ecx
c0026fb3:	88 0e                	mov    %cl,(%esi)

      s_k = s[s_i] + s[s_j];
c0026fb5:	02 0c 10             	add    (%eax,%edx,1),%cl
      *buf = s[s_k];
c0026fb8:	0f b6 d1             	movzbl %cl,%edx
c0026fbb:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
c0026fbf:	88 13                	mov    %dl,(%ebx)
  for (buf = buf_; size-- > 0; buf++)
c0026fc1:	83 c3 01             	add    $0x1,%ebx
c0026fc4:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
c0026fc8:	75 bd                	jne    c0026f87 <random_bytes+0x6d>
c0026fca:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
c0026fcf:	02 44 24 0c          	add    0xc(%esp),%al
c0026fd3:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026fd7:	88 83 1a 1b 00 00    	mov    %al,0x1b1a(%ebx)
c0026fdd:	0f b6 44 24 11       	movzbl 0x11(%esp),%eax
c0026fe2:	88 83 19 1b 00 00    	mov    %al,0x1b19(%ebx)
    }
}
c0026fe8:	83 c4 14             	add    $0x14,%esp
c0026feb:	5b                   	pop    %ebx
c0026fec:	5e                   	pop    %esi
c0026fed:	5f                   	pop    %edi
c0026fee:	5d                   	pop    %ebp
c0026fef:	c3                   	ret    
    random_init (0);
c0026ff0:	6a 00                	push   $0x0
c0026ff2:	e8 95 fe ff ff       	call   c0026e8c <random_init>
c0026ff7:	83 c4 04             	add    $0x4,%esp
c0026ffa:	e9 45 ff ff ff       	jmp    c0026f44 <random_bytes+0x2a>

c0026fff <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0026fff:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0027002:	6a 04                	push   $0x4
c0027004:	8d 44 24 10          	lea    0x10(%esp),%eax
c0027008:	50                   	push   %eax
c0027009:	e8 0c ff ff ff       	call   c0026f1a <random_bytes>
  return ul;
}
c002700e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027012:	83 c4 18             	add    $0x18,%esp
c0027015:	c3                   	ret    

c0027016 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027016:	53                   	push   %ebx
c0027017:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c002701b:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c002701f:	8b 50 04             	mov    0x4(%eax),%edx
c0027022:	8d 4a 01             	lea    0x1(%edx),%ecx
c0027025:	89 48 04             	mov    %ecx,0x4(%eax)
c0027028:	3b 50 08             	cmp    0x8(%eax),%edx
c002702b:	7d 09                	jge    c0027036 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c002702d:	8b 10                	mov    (%eax),%edx
c002702f:	8d 4a 01             	lea    0x1(%edx),%ecx
c0027032:	89 08                	mov    %ecx,(%eax)
c0027034:	88 1a                	mov    %bl,(%edx)
}
c0027036:	5b                   	pop    %ebx
c0027037:	c3                   	ret    

c0027038 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0027038:	55                   	push   %ebp
c0027039:	57                   	push   %edi
c002703a:	56                   	push   %esi
c002703b:	53                   	push   %ebx
c002703c:	83 ec 0c             	sub    $0xc,%esp
c002703f:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c0027043:	85 d2                	test   %edx,%edx
c0027045:	74 1a                	je     c0027061 <output_dup+0x29>
c0027047:	8d 5a ff             	lea    -0x1(%edx),%ebx
c002704a:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c002704c:	0f be f0             	movsbl %al,%esi
c002704f:	83 ec 08             	sub    $0x8,%esp
c0027052:	57                   	push   %edi
c0027053:	56                   	push   %esi
c0027054:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c0027056:	83 eb 01             	sub    $0x1,%ebx
c0027059:	83 c4 10             	add    $0x10,%esp
c002705c:	83 fb ff             	cmp    $0xffffffff,%ebx
c002705f:	75 ee                	jne    c002704f <output_dup+0x17>
}
c0027061:	83 c4 0c             	add    $0xc,%esp
c0027064:	5b                   	pop    %ebx
c0027065:	5e                   	pop    %esi
c0027066:	5f                   	pop    %edi
c0027067:	5d                   	pop    %ebp
c0027068:	c3                   	ret    

c0027069 <format_integer>:
{
c0027069:	55                   	push   %ebp
c002706a:	57                   	push   %edi
c002706b:	56                   	push   %esi
c002706c:	53                   	push   %ebx
c002706d:	83 ec 7c             	sub    $0x7c,%esp
c0027070:	e8 83 7e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0027075:	81 c3 b3 40 01 00    	add    $0x140b3,%ebx
c002707b:	89 c6                	mov    %eax,%esi
c002707d:	89 d7                	mov    %edx,%edi
c002707f:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  sign = 0;
c0027086:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c002708d:	00 
  if (is_signed) 
c002708e:	84 c9                	test   %cl,%cl
c0027090:	74 20                	je     c00270b2 <format_integer+0x49>
      if (c->flags & PLUS)
c0027092:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0027099:	8b 11                	mov    (%ecx),%edx
c002709b:	f6 c2 02             	test   $0x2,%dl
c002709e:	0f 84 88 00 00 00    	je     c002712c <format_integer+0xc3>
        sign = negative ? '-' : '+';
c00270a4:	3c 01                	cmp    $0x1,%al
c00270a6:	19 c0                	sbb    %eax,%eax
c00270a8:	83 e0 fe             	and    $0xfffffffe,%eax
c00270ab:	83 c0 2d             	add    $0x2d,%eax
c00270ae:	89 44 24 20          	mov    %eax,0x20(%esp)
  x = (c->flags & POUND) && value ? b->x : 0;
c00270b2:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00270b9:	8b 00                	mov    (%eax),%eax
c00270bb:	89 44 24 28          	mov    %eax,0x28(%esp)
c00270bf:	83 e0 08             	and    $0x8,%eax
c00270c2:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c00270c6:	89 f1                	mov    %esi,%ecx
c00270c8:	09 f9                	or     %edi,%ecx
c00270ca:	74 08                	je     c00270d4 <format_integer+0x6b>
c00270cc:	85 c0                	test   %eax,%eax
c00270ce:	0f 85 82 00 00 00    	jne    c0027156 <format_integer+0xed>
  while (value > 0) 
c00270d4:	89 fa                	mov    %edi,%edx
c00270d6:	09 f2                	or     %esi,%edx
c00270d8:	0f 84 e2 02 00 00    	je     c00273c0 <format_integer+0x357>
  x = (c->flags & POUND) && value ? b->x : 0;
c00270de:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00270e5:	00 
      *cp++ = b->digits[value % b->base];
c00270e6:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c00270ed:	8b 40 04             	mov    0x4(%eax),%eax
c00270f0:	89 44 24 18          	mov    %eax,0x18(%esp)
c00270f4:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c00270fb:	8b 00                	mov    (%eax),%eax
c00270fd:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027101:	89 c1                	mov    %eax,%ecx
c0027103:	c1 f9 1f             	sar    $0x1f,%ecx
c0027106:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c002710a:	b9 00 00 00 00       	mov    $0x0,%ecx
c002710f:	8d 6c 24 30          	lea    0x30(%esp),%ebp
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027113:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027117:	c1 e8 05             	shr    $0x5,%eax
c002711a:	83 e0 01             	and    $0x1,%eax
c002711d:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0027121:	89 6c 24 14          	mov    %ebp,0x14(%esp)
c0027125:	89 cd                	mov    %ecx,%ebp
c0027127:	e9 90 00 00 00       	jmp    c00271bc <format_integer+0x153>
      else if (c->flags & SPACE)
c002712c:	f6 c2 04             	test   $0x4,%dl
c002712f:	74 13                	je     c0027144 <format_integer+0xdb>
        sign = negative ? '-' : ' ';
c0027131:	3c 01                	cmp    $0x1,%al
c0027133:	19 c0                	sbb    %eax,%eax
c0027135:	83 e0 f3             	and    $0xfffffff3,%eax
c0027138:	83 c0 2d             	add    $0x2d,%eax
c002713b:	89 44 24 20          	mov    %eax,0x20(%esp)
c002713f:	e9 6e ff ff ff       	jmp    c00270b2 <format_integer+0x49>
        sign = '-';
c0027144:	3c 01                	cmp    $0x1,%al
c0027146:	19 c0                	sbb    %eax,%eax
c0027148:	f7 d0                	not    %eax
c002714a:	83 e0 2d             	and    $0x2d,%eax
c002714d:	89 44 24 20          	mov    %eax,0x20(%esp)
c0027151:	e9 5c ff ff ff       	jmp    c00270b2 <format_integer+0x49>
  x = (c->flags & POUND) && value ? b->x : 0;
c0027156:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c002715d:	8b 40 08             	mov    0x8(%eax),%eax
c0027160:	89 44 24 24          	mov    %eax,0x24(%esp)
  while (value > 0) 
c0027164:	eb 80                	jmp    c00270e6 <format_integer+0x7d>
c0027166:	8b 44 24 14          	mov    0x14(%esp),%eax
c002716a:	89 44 24 10          	mov    %eax,0x10(%esp)
      *cp++ = b->digits[value % b->base];
c002716e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027172:	8d 50 01             	lea    0x1(%eax),%edx
c0027175:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027179:	ff 74 24 0c          	pushl  0xc(%esp)
c002717d:	ff 74 24 0c          	pushl  0xc(%esp)
c0027181:	57                   	push   %edi
c0027182:	56                   	push   %esi
c0027183:	e8 7f 19 00 00       	call   c0028b07 <__umoddi3>
c0027188:	83 c4 10             	add    $0x10,%esp
c002718b:	8b 54 24 18          	mov    0x18(%esp),%edx
c002718f:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
c0027193:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0027197:	88 01                	mov    %al,(%ecx)
      value /= b->base;
c0027199:	ff 74 24 0c          	pushl  0xc(%esp)
c002719d:	ff 74 24 0c          	pushl  0xc(%esp)
c00271a1:	57                   	push   %edi
c00271a2:	56                   	push   %esi
c00271a3:	e8 43 19 00 00       	call   c0028aeb <__udivdi3>
c00271a8:	83 c4 10             	add    $0x10,%esp
      digit_cnt++;
c00271ab:	83 c5 01             	add    $0x1,%ebp
  while (value > 0) 
c00271ae:	3b 74 24 08          	cmp    0x8(%esp),%esi
c00271b2:	1b 7c 24 0c          	sbb    0xc(%esp),%edi
c00271b6:	72 34                	jb     c00271ec <format_integer+0x183>
      value /= b->base;
c00271b8:	89 c6                	mov    %eax,%esi
c00271ba:	89 d7                	mov    %edx,%edi
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c00271bc:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c00271c1:	74 a3                	je     c0027166 <format_integer+0xfd>
c00271c3:	85 ed                	test   %ebp,%ebp
c00271c5:	7e 9f                	jle    c0027166 <format_integer+0xfd>
c00271c7:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c00271ce:	89 e8                	mov    %ebp,%eax
c00271d0:	99                   	cltd   
c00271d1:	f7 79 0c             	idivl  0xc(%ecx)
c00271d4:	8b 44 24 14          	mov    0x14(%esp),%eax
c00271d8:	89 44 24 10          	mov    %eax,0x10(%esp)
c00271dc:	85 d2                	test   %edx,%edx
c00271de:	75 8e                	jne    c002716e <format_integer+0x105>
        *cp++ = ',';
c00271e0:	8d 48 01             	lea    0x1(%eax),%ecx
c00271e3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00271e7:	c6 00 2c             	movb   $0x2c,(%eax)
c00271ea:	eb 82                	jmp    c002716e <format_integer+0x105>
c00271ec:	8b 6c 24 14          	mov    0x14(%esp),%ebp
  precision = c->precision < 0 ? 1 : c->precision;
c00271f0:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00271f7:	8b 50 08             	mov    0x8(%eax),%edx
c00271fa:	85 d2                	test   %edx,%edx
c00271fc:	b8 01 00 00 00       	mov    $0x1,%eax
c0027201:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027204:	8d 44 24 30          	lea    0x30(%esp),%eax
c0027208:	89 ef                	mov    %ebp,%edi
c002720a:	29 c7                	sub    %eax,%edi
c002720c:	39 fa                	cmp    %edi,%edx
c002720e:	7e 21                	jle    c0027231 <format_integer+0x1c8>
c0027210:	8d 44 24 6f          	lea    0x6f(%esp),%eax
c0027214:	39 c5                	cmp    %eax,%ebp
c0027216:	73 19                	jae    c0027231 <format_integer+0x1c8>
c0027218:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c002721c:	89 c3                	mov    %eax,%ebx
    *cp++ = '0';
c002721e:	83 c5 01             	add    $0x1,%ebp
c0027221:	c6 45 ff 30          	movb   $0x30,-0x1(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027225:	89 e8                	mov    %ebp,%eax
c0027227:	29 c8                	sub    %ecx,%eax
c0027229:	39 d0                	cmp    %edx,%eax
c002722b:	7d 04                	jge    c0027231 <format_integer+0x1c8>
c002722d:	39 dd                	cmp    %ebx,%ebp
c002722f:	72 ed                	jb     c002721e <format_integer+0x1b5>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027231:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0027236:	74 10                	je     c0027248 <format_integer+0x1df>
c0027238:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c002723f:	83 38 08             	cmpl   $0x8,(%eax)
c0027242:	0f 84 eb 00 00 00    	je     c0027333 <format_integer+0x2ca>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0027248:	8d 74 24 30          	lea    0x30(%esp),%esi
c002724c:	29 ee                	sub    %ebp,%esi
c002724e:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027255:	03 70 04             	add    0x4(%eax),%esi
c0027258:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002725c:	85 ff                	test   %edi,%edi
c002725e:	b8 02 00 00 00       	mov    $0x2,%eax
c0027263:	0f 44 c7             	cmove  %edi,%eax
c0027266:	29 c6                	sub    %eax,%esi
c0027268:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002726d:	0f 95 c0             	setne  %al
c0027270:	0f b6 c0             	movzbl %al,%eax
  if (pad_cnt < 0)
c0027273:	29 c6                	sub    %eax,%esi
c0027275:	b8 00 00 00 00       	mov    $0x0,%eax
c002727a:	0f 48 f0             	cmovs  %eax,%esi
  if ((c->flags & (MINUS | ZERO)) == 0)
c002727d:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c0027282:	0f 84 c9 00 00 00    	je     c0027351 <format_integer+0x2e8>
  if (sign)
c0027288:	8b 44 24 20          	mov    0x20(%esp),%eax
c002728c:	85 c0                	test   %eax,%eax
c002728e:	74 15                	je     c00272a5 <format_integer+0x23c>
    output (sign, aux);
c0027290:	83 ec 08             	sub    $0x8,%esp
c0027293:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002729a:	50                   	push   %eax
c002729b:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c00272a2:	83 c4 10             	add    $0x10,%esp
  if (x) 
c00272a5:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00272a9:	85 ff                	test   %edi,%edi
c00272ab:	74 2d                	je     c00272da <format_integer+0x271>
      output ('0', aux);
c00272ad:	83 ec 08             	sub    $0x8,%esp
c00272b0:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c00272b7:	6a 30                	push   $0x30
c00272b9:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c00272c0:	83 c4 08             	add    $0x8,%esp
c00272c3:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c00272ca:	89 f8                	mov    %edi,%eax
c00272cc:	0f be c0             	movsbl %al,%eax
c00272cf:	50                   	push   %eax
c00272d0:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c00272d7:	83 c4 10             	add    $0x10,%esp
  if (c->flags & ZERO)
c00272da:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00272e1:	f6 00 10             	testb  $0x10,(%eax)
c00272e4:	0f 85 8c 00 00 00    	jne    c0027376 <format_integer+0x30d>
  while (cp > buf)
c00272ea:	8d 44 24 30          	lea    0x30(%esp),%eax
c00272ee:	89 c7                	mov    %eax,%edi
c00272f0:	39 c5                	cmp    %eax,%ebp
c00272f2:	76 2b                	jbe    c002731f <format_integer+0x2b6>
c00272f4:	89 74 24 08          	mov    %esi,0x8(%esp)
c00272f8:	8b 9c 24 9c 00 00 00 	mov    0x9c(%esp),%ebx
c00272ff:	8b b4 24 a0 00 00 00 	mov    0xa0(%esp),%esi
    output (*--cp, aux);
c0027306:	83 ed 01             	sub    $0x1,%ebp
c0027309:	83 ec 08             	sub    $0x8,%esp
c002730c:	56                   	push   %esi
c002730d:	0f be 45 00          	movsbl 0x0(%ebp),%eax
c0027311:	50                   	push   %eax
c0027312:	ff d3                	call   *%ebx
  while (cp > buf)
c0027314:	83 c4 10             	add    $0x10,%esp
c0027317:	39 fd                	cmp    %edi,%ebp
c0027319:	75 eb                	jne    c0027306 <format_integer+0x29d>
c002731b:	8b 74 24 08          	mov    0x8(%esp),%esi
  if (c->flags & MINUS)
c002731f:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027326:	f6 00 01             	testb  $0x1,(%eax)
c0027329:	75 70                	jne    c002739b <format_integer+0x332>
}
c002732b:	83 c4 7c             	add    $0x7c,%esp
c002732e:	5b                   	pop    %ebx
c002732f:	5e                   	pop    %esi
c0027330:	5f                   	pop    %edi
c0027331:	5d                   	pop    %ebp
c0027332:	c3                   	ret    
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027333:	8d 44 24 30          	lea    0x30(%esp),%eax
c0027337:	39 c5                	cmp    %eax,%ebp
c0027339:	74 0a                	je     c0027345 <format_integer+0x2dc>
c002733b:	80 7d ff 30          	cmpb   $0x30,-0x1(%ebp)
c002733f:	0f 84 03 ff ff ff    	je     c0027248 <format_integer+0x1df>
    *cp++ = '0';
c0027345:	c6 45 00 30          	movb   $0x30,0x0(%ebp)
c0027349:	8d 6d 01             	lea    0x1(%ebp),%ebp
c002734c:	e9 f7 fe ff ff       	jmp    c0027248 <format_integer+0x1df>
    output_dup (' ', pad_cnt, output, aux);
c0027351:	83 ec 0c             	sub    $0xc,%esp
c0027354:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c002735b:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027362:	89 f2                	mov    %esi,%edx
c0027364:	b8 20 00 00 00       	mov    $0x20,%eax
c0027369:	e8 ca fc ff ff       	call   c0027038 <output_dup>
c002736e:	83 c4 10             	add    $0x10,%esp
c0027371:	e9 12 ff ff ff       	jmp    c0027288 <format_integer+0x21f>
    output_dup ('0', pad_cnt, output, aux);
c0027376:	83 ec 0c             	sub    $0xc,%esp
c0027379:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027380:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027387:	89 f2                	mov    %esi,%edx
c0027389:	b8 30 00 00 00       	mov    $0x30,%eax
c002738e:	e8 a5 fc ff ff       	call   c0027038 <output_dup>
c0027393:	83 c4 10             	add    $0x10,%esp
c0027396:	e9 4f ff ff ff       	jmp    c00272ea <format_integer+0x281>
    output_dup (' ', pad_cnt, output, aux);
c002739b:	83 ec 0c             	sub    $0xc,%esp
c002739e:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c00273a5:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c00273ac:	89 f2                	mov    %esi,%edx
c00273ae:	b8 20 00 00 00       	mov    $0x20,%eax
c00273b3:	e8 80 fc ff ff       	call   c0027038 <output_dup>
c00273b8:	83 c4 10             	add    $0x10,%esp
}
c00273bb:	e9 6b ff ff ff       	jmp    c002732b <format_integer+0x2c2>
  precision = c->precision < 0 ? 1 : c->precision;
c00273c0:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00273c7:	8b 50 08             	mov    0x8(%eax),%edx
  cp = buf;
c00273ca:	8d 6c 24 30          	lea    0x30(%esp),%ebp
  x = (c->flags & POUND) && value ? b->x : 0;
c00273ce:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00273d5:	00 
  precision = c->precision < 0 ? 1 : c->precision;
c00273d6:	85 d2                	test   %edx,%edx
c00273d8:	0f 89 26 fe ff ff    	jns    c0027204 <format_integer+0x19b>
    *cp++ = '0';
c00273de:	8d 6c 24 31          	lea    0x31(%esp),%ebp
c00273e2:	c6 44 24 30 30       	movb   $0x30,0x30(%esp)
c00273e7:	e9 45 fe ff ff       	jmp    c0027231 <format_integer+0x1c8>

c00273ec <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c00273ec:	55                   	push   %ebp
c00273ed:	57                   	push   %edi
c00273ee:	56                   	push   %esi
c00273ef:	53                   	push   %ebx
c00273f0:	83 ec 1c             	sub    $0x1c,%esp
c00273f3:	89 c5                	mov    %eax,%ebp
c00273f5:	89 d6                	mov    %edx,%esi
c00273f7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c00273fb:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c00273ff:	8b 51 04             	mov    0x4(%ecx),%edx
c0027402:	39 f2                	cmp    %esi,%edx
c0027404:	7e 3f                	jle    c0027445 <format_string+0x59>
c0027406:	f6 01 01             	testb  $0x1,(%ecx)
c0027409:	74 1d                	je     c0027428 <format_string+0x3c>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c002740b:	85 f6                	test   %esi,%esi
c002740d:	7f 3a                	jg     c0027449 <format_string+0x5d>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c002740f:	29 f2                	sub    %esi,%edx
c0027411:	83 ec 0c             	sub    $0xc,%esp
c0027414:	57                   	push   %edi
c0027415:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0027419:	b8 20 00 00 00       	mov    $0x20,%eax
c002741e:	e8 15 fc ff ff       	call   c0027038 <output_dup>
c0027423:	83 c4 10             	add    $0x10,%esp
}
c0027426:	eb 4e                	jmp    c0027476 <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
c0027428:	29 f2                	sub    %esi,%edx
c002742a:	83 ec 0c             	sub    $0xc,%esp
c002742d:	57                   	push   %edi
c002742e:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0027432:	b8 20 00 00 00       	mov    $0x20,%eax
c0027437:	e8 fc fb ff ff       	call   c0027038 <output_dup>
  for (i = 0; i < length; i++)
c002743c:	83 c4 10             	add    $0x10,%esp
c002743f:	85 f6                	test   %esi,%esi
c0027441:	7f 06                	jg     c0027449 <format_string+0x5d>
c0027443:	eb 21                	jmp    c0027466 <format_string+0x7a>
c0027445:	85 f6                	test   %esi,%esi
c0027447:	7e 2d                	jle    c0027476 <format_string+0x8a>
{
c0027449:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c002744e:	83 ec 08             	sub    $0x8,%esp
c0027451:	57                   	push   %edi
c0027452:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c0027457:	50                   	push   %eax
c0027458:	ff 54 24 40          	call   *0x40(%esp)
  for (i = 0; i < length; i++)
c002745c:	83 c3 01             	add    $0x1,%ebx
c002745f:	83 c4 10             	add    $0x10,%esp
c0027462:	39 de                	cmp    %ebx,%esi
c0027464:	7f e8                	jg     c002744e <format_string+0x62>
  if (c->width > length && (c->flags & MINUS) != 0)
c0027466:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002746a:	8b 50 04             	mov    0x4(%eax),%edx
c002746d:	39 f2                	cmp    %esi,%edx
c002746f:	7e 05                	jle    c0027476 <format_string+0x8a>
c0027471:	f6 00 01             	testb  $0x1,(%eax)
c0027474:	75 99                	jne    c002740f <format_string+0x23>
}
c0027476:	83 c4 1c             	add    $0x1c,%esp
c0027479:	5b                   	pop    %ebx
c002747a:	5e                   	pop    %esi
c002747b:	5f                   	pop    %edi
c002747c:	5d                   	pop    %ebp
c002747d:	c3                   	ret    

c002747e <printf>:
{
c002747e:	53                   	push   %ebx
c002747f:	83 ec 08             	sub    $0x8,%esp
c0027482:	e8 71 7a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0027487:	81 c3 a1 3c 01 00    	add    $0x13ca1,%ebx
  va_start (args, format);
c002748d:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c0027491:	83 ec 08             	sub    $0x8,%esp
c0027494:	50                   	push   %eax
c0027495:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027499:	e8 cf 3b 00 00       	call   c002b06d <vprintf>
}
c002749e:	83 c4 18             	add    $0x18,%esp
c00274a1:	5b                   	pop    %ebx
c00274a2:	c3                   	ret    

c00274a3 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c00274a3:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c00274a6:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c00274aa:	ff 74 24 18          	pushl  0x18(%esp)
c00274ae:	ff 74 24 18          	pushl  0x18(%esp)
c00274b2:	50                   	push   %eax
c00274b3:	ff 74 24 1c          	pushl  0x1c(%esp)
c00274b7:	e8 04 00 00 00       	call   c00274c0 <__vprintf>
  va_end (args);
}
c00274bc:	83 c4 1c             	add    $0x1c,%esp
c00274bf:	c3                   	ret    

c00274c0 <__vprintf>:
{
c00274c0:	55                   	push   %ebp
c00274c1:	57                   	push   %edi
c00274c2:	56                   	push   %esi
c00274c3:	53                   	push   %ebx
c00274c4:	83 ec 4c             	sub    $0x4c,%esp
c00274c7:	e8 34 7a 00 00       	call   c002ef00 <__x86.get_pc_thunk.bp>
c00274cc:	81 c5 5c 3c 01 00    	add    $0x13c5c,%ebp
c00274d2:	8b 74 24 60          	mov    0x60(%esp),%esi
c00274d6:	8b 7c 24 64          	mov    0x64(%esp),%edi
  for (; *format != '\0'; format++)
c00274da:	0f b6 06             	movzbl (%esi),%eax
c00274dd:	84 c0                	test   %al,%al
c00274df:	75 27                	jne    c0027508 <__vprintf+0x48>
}
c00274e1:	83 c4 4c             	add    $0x4c,%esp
c00274e4:	5b                   	pop    %ebx
c00274e5:	5e                   	pop    %esi
c00274e6:	5f                   	pop    %edi
c00274e7:	5d                   	pop    %ebp
c00274e8:	c3                   	ret    
          output (*format, aux);
c00274e9:	83 ec 08             	sub    $0x8,%esp
c00274ec:	ff 74 24 74          	pushl  0x74(%esp)
c00274f0:	0f be c0             	movsbl %al,%eax
c00274f3:	50                   	push   %eax
c00274f4:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c00274f8:	83 c4 10             	add    $0x10,%esp
c00274fb:	89 f3                	mov    %esi,%ebx
  for (; *format != '\0'; format++)
c00274fd:	8d 73 01             	lea    0x1(%ebx),%esi
c0027500:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027504:	84 c0                	test   %al,%al
c0027506:	74 d9                	je     c00274e1 <__vprintf+0x21>
      if (*format != '%') 
c0027508:	3c 25                	cmp    $0x25,%al
c002750a:	75 dd                	jne    c00274e9 <__vprintf+0x29>
      format++;
c002750c:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c002750f:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c0027513:	74 17                	je     c002752c <__vprintf+0x6c>
  c->flags = 0;
c0027515:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c002751c:	00 
c002751d:	c6 04 24 00          	movb   $0x0,(%esp)
c0027521:	ba 00 00 00 00       	mov    $0x0,%edx
c0027526:	89 7c 24 64          	mov    %edi,0x64(%esp)
c002752a:	eb 1b                	jmp    c0027547 <.L80+0x9>
          output ('%', aux);
c002752c:	83 ec 08             	sub    $0x8,%esp
c002752f:	ff 74 24 74          	pushl  0x74(%esp)
c0027533:	6a 25                	push   $0x25
c0027535:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c0027539:	83 c4 10             	add    $0x10,%esp
c002753c:	eb bf                	jmp    c00274fd <__vprintf+0x3d>

c002753e <.L80>:
          c->flags |= MINUS;
c002753e:	83 ca 01             	or     $0x1,%edx
          break;
c0027541:	c6 04 24 01          	movb   $0x1,(%esp)
      switch (*format++) 
c0027545:	89 f3                	mov    %esi,%ebx
c0027547:	8d 73 01             	lea    0x1(%ebx),%esi
c002754a:	0f b6 46 ff          	movzbl -0x1(%esi),%eax
c002754e:	8d 48 e0             	lea    -0x20(%eax),%ecx
c0027551:	80 f9 10             	cmp    $0x10,%cl
c0027554:	77 27                	ja     c002757d <.L77>
c0027556:	0f b6 c9             	movzbl %cl,%ecx
c0027559:	89 ef                	mov    %ebp,%edi
c002755b:	03 bc 8d 48 43 ff ff 	add    -0xbcb8(%ebp,%ecx,4),%edi
c0027562:	ff e7                	jmp    *%edi

c0027564 <.L81>:
          c->flags |= PLUS;
c0027564:	83 ca 02             	or     $0x2,%edx
          break;
c0027567:	eb d8                	jmp    c0027541 <.L80+0x3>

c0027569 <.L84>:
          c->flags |= SPACE;
c0027569:	83 ca 04             	or     $0x4,%edx
          break;
c002756c:	eb d3                	jmp    c0027541 <.L80+0x3>

c002756e <.L83>:
          c->flags |= POUND;
c002756e:	83 ca 08             	or     $0x8,%edx
          break;
c0027571:	eb ce                	jmp    c0027541 <.L80+0x3>

c0027573 <.L78>:
          c->flags |= ZERO;
c0027573:	83 ca 10             	or     $0x10,%edx
          break;
c0027576:	eb c9                	jmp    c0027541 <.L80+0x3>

c0027578 <.L82>:
          c->flags |= GROUP;
c0027578:	83 ca 20             	or     $0x20,%edx
          break;
c002757b:	eb c4                	jmp    c0027541 <.L80+0x3>

c002757d <.L77>:
c002757d:	8b 7c 24 64          	mov    0x64(%esp),%edi
c0027581:	80 3c 24 00          	cmpb   $0x0,(%esp)
c0027585:	74 0f                	je     c0027596 <.L77+0x19>
    c->flags &= ~ZERO;
c0027587:	89 d1                	mov    %edx,%ecx
c0027589:	83 e1 ef             	and    $0xffffffef,%ecx
c002758c:	f6 c2 01             	test   $0x1,%dl
c002758f:	0f 45 d1             	cmovne %ecx,%edx
c0027592:	89 54 24 30          	mov    %edx,0x30(%esp)
  if (c->flags & PLUS)
c0027596:	8b 54 24 30          	mov    0x30(%esp),%edx
c002759a:	f6 c2 02             	test   $0x2,%dl
c002759d:	74 07                	je     c00275a6 <.L77+0x29>
    c->flags &= ~SPACE;
c002759f:	83 e2 fb             	and    $0xfffffffb,%edx
c00275a2:	89 54 24 30          	mov    %edx,0x30(%esp)
  c->width = 0;
c00275a6:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
c00275ad:	00 
  if (*format == '*')
c00275ae:	3c 2a                	cmp    $0x2a,%al
c00275b0:	74 47                	je     c00275f9 <.L77+0x7c>
      for (; isdigit (*format); format++)
c00275b2:	0f be c0             	movsbl %al,%eax
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00275b5:	8d 48 d0             	lea    -0x30(%eax),%ecx
c00275b8:	ba 00 00 00 00       	mov    $0x0,%edx
c00275bd:	83 f9 09             	cmp    $0x9,%ecx
c00275c0:	77 21                	ja     c00275e3 <.L77+0x66>
        c->width = c->width * 10 + *format - '0';
c00275c2:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00275c5:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
      for (; isdigit (*format); format++)
c00275c9:	83 c3 01             	add    $0x1,%ebx
c00275cc:	0f be 03             	movsbl (%ebx),%eax
c00275cf:	8d 48 d0             	lea    -0x30(%eax),%ecx
c00275d2:	83 f9 09             	cmp    $0x9,%ecx
c00275d5:	76 eb                	jbe    c00275c2 <.L77+0x45>
c00275d7:	89 54 24 34          	mov    %edx,0x34(%esp)
  if (c->width < 0) 
c00275db:	8b 44 24 34          	mov    0x34(%esp),%eax
c00275df:	85 c0                	test   %eax,%eax
c00275e1:	78 23                	js     c0027606 <.L77+0x89>
  c->precision = -1;
c00275e3:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c00275ea:	ff 
  if (*format == '.') 
c00275eb:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c00275ee:	74 23                	je     c0027613 <.L77+0x96>
  if (c->precision >= 0)
c00275f0:	8b 44 24 38          	mov    0x38(%esp),%eax
c00275f4:	89 04 24             	mov    %eax,(%esp)
c00275f7:	eb 69                	jmp    c0027662 <.L77+0xe5>
      c->width = va_arg (*args, int);
c00275f9:	8b 07                	mov    (%edi),%eax
c00275fb:	89 44 24 34          	mov    %eax,0x34(%esp)
c00275ff:	8d 7f 04             	lea    0x4(%edi),%edi
      switch (*format++) 
c0027602:	89 f3                	mov    %esi,%ebx
c0027604:	eb d5                	jmp    c00275db <.L77+0x5e>
      c->width = -c->width;
c0027606:	f7 d8                	neg    %eax
c0027608:	89 44 24 34          	mov    %eax,0x34(%esp)
      c->flags |= MINUS;
c002760c:	83 4c 24 30 01       	orl    $0x1,0x30(%esp)
c0027611:	eb d0                	jmp    c00275e3 <.L77+0x66>
      if (*format == '*') 
c0027613:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027617:	3c 2a                	cmp    $0x2a,%al
c0027619:	74 6f                	je     c002768a <.L77+0x10d>
      format++;
c002761b:	83 c3 01             	add    $0x1,%ebx
          c->precision = 0;
c002761e:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
c0027625:	00 
          for (; isdigit (*format); format++)
c0027626:	0f be c0             	movsbl %al,%eax
c0027629:	8d 50 d0             	lea    -0x30(%eax),%edx
c002762c:	83 fa 09             	cmp    $0x9,%edx
c002762f:	77 25                	ja     c0027656 <.L77+0xd9>
c0027631:	ba 00 00 00 00       	mov    $0x0,%edx
            c->precision = c->precision * 10 + *format - '0';
c0027636:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0027639:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
          for (; isdigit (*format); format++)
c002763d:	83 c3 01             	add    $0x1,%ebx
c0027640:	0f be 03             	movsbl (%ebx),%eax
c0027643:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0027646:	83 f9 09             	cmp    $0x9,%ecx
c0027649:	76 eb                	jbe    c0027636 <.L77+0xb9>
c002764b:	89 54 24 38          	mov    %edx,0x38(%esp)
      if (c->precision < 0) 
c002764f:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0027654:	78 42                	js     c0027698 <.L77+0x11b>
  if (c->precision >= 0)
c0027656:	8b 44 24 38          	mov    0x38(%esp),%eax
c002765a:	89 04 24             	mov    %eax,(%esp)
    c->flags &= ~ZERO;
c002765d:	83 64 24 30 ef       	andl   $0xffffffef,0x30(%esp)
  c->type = INT;
c0027662:	c7 44 24 3c 03 00 00 	movl   $0x3,0x3c(%esp)
c0027669:	00 
  switch (*format++) 
c002766a:	8d 73 01             	lea    0x1(%ebx),%esi
c002766d:	0f b6 03             	movzbl (%ebx),%eax
c0027670:	8d 50 98             	lea    -0x68(%eax),%edx
c0027673:	80 fa 12             	cmp    $0x12,%dl
c0027676:	0f 87 56 01 00 00    	ja     c00277d2 <.L97>
c002767c:	0f b6 d2             	movzbl %dl,%edx
c002767f:	89 e9                	mov    %ebp,%ecx
c0027681:	03 8c 95 8c 43 ff ff 	add    -0xbc74(%ebp,%edx,4),%ecx
c0027688:	ff e1                	jmp    *%ecx
          format++;
c002768a:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c002768d:	8b 07                	mov    (%edi),%eax
c002768f:	89 44 24 38          	mov    %eax,0x38(%esp)
c0027693:	8d 7f 04             	lea    0x4(%edi),%edi
c0027696:	eb b7                	jmp    c002764f <.L77+0xd2>
        c->precision = -1;
c0027698:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c002769f:	ff 
c00276a0:	e9 4b ff ff ff       	jmp    c00275f0 <.L77+0x73>

c00276a5 <.L103>:
      if (*format == 'h') 
c00276a5:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00276a9:	3c 68                	cmp    $0x68,%al
c00276ab:	74 25                	je     c00276d2 <.L103+0x2d>
        c->type = SHORT;
c00276ad:	c7 44 24 3c 02 00 00 	movl   $0x2,0x3c(%esp)
c00276b4:	00 
      switch (*format) 
c00276b5:	0f be d0             	movsbl %al,%edx
c00276b8:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00276bb:	80 fb 33             	cmp    $0x33,%bl
c00276be:	0f 87 ae 04 00 00    	ja     c0027b72 <.L105>
c00276c4:	0f b6 db             	movzbl %bl,%ebx
c00276c7:	89 e9                	mov    %ebp,%ecx
c00276c9:	03 8c 9d d8 43 ff ff 	add    -0xbc28(%ebp,%ebx,4),%ecx
c00276d0:	ff e1                	jmp    *%ecx
          format++;
c00276d2:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = CHAR;
c00276d5:	c7 44 24 3c 01 00 00 	movl   $0x1,0x3c(%esp)
c00276dc:	00 
      switch (*format) 
c00276dd:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c00276e1:	0f be d0             	movsbl %al,%edx
c00276e4:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00276e7:	80 fb 33             	cmp    $0x33,%bl
c00276ea:	0f 87 82 04 00 00    	ja     c0027b72 <.L105>
c00276f0:	0f b6 db             	movzbl %bl,%ebx
c00276f3:	89 e9                	mov    %ebp,%ecx
c00276f5:	03 8c 9d a8 44 ff ff 	add    -0xbb58(%ebp,%ebx,4),%ecx
c00276fc:	ff e1                	jmp    *%ecx

c00276fe <.L102>:
      c->type = INTMAX;
c00276fe:	c7 44 24 3c 04 00 00 	movl   $0x4,0x3c(%esp)
c0027705:	00 
      switch (*format) 
c0027706:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002770a:	0f be d0             	movsbl %al,%edx
c002770d:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0027710:	80 fb 33             	cmp    $0x33,%bl
c0027713:	0f 87 59 04 00 00    	ja     c0027b72 <.L105>
c0027719:	0f b6 db             	movzbl %bl,%ebx
c002771c:	89 e9                	mov    %ebp,%ecx
c002771e:	03 8c 9d 78 45 ff ff 	add    -0xba88(%ebp,%ebx,4),%ecx
c0027725:	ff e1                	jmp    *%ecx

c0027727 <.L101>:
      if (*format == 'l')
c0027727:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002772b:	3c 6c                	cmp    $0x6c,%al
c002772d:	74 25                	je     c0027754 <.L101+0x2d>
        c->type = LONG;
c002772f:	c7 44 24 3c 05 00 00 	movl   $0x5,0x3c(%esp)
c0027736:	00 
      switch (*format) 
c0027737:	0f be d0             	movsbl %al,%edx
c002773a:	8d 58 bb             	lea    -0x45(%eax),%ebx
c002773d:	80 fb 33             	cmp    $0x33,%bl
c0027740:	0f 87 2c 04 00 00    	ja     c0027b72 <.L105>
c0027746:	0f b6 db             	movzbl %bl,%ebx
c0027749:	89 e9                	mov    %ebp,%ecx
c002774b:	03 8c 9d 48 46 ff ff 	add    -0xb9b8(%ebp,%ebx,4),%ecx
c0027752:	ff e1                	jmp    *%ecx
          format++;
c0027754:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = LONGLONG;
c0027757:	c7 44 24 3c 06 00 00 	movl   $0x6,0x3c(%esp)
c002775e:	00 
      switch (*format) 
c002775f:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c0027763:	0f be d0             	movsbl %al,%edx
c0027766:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0027769:	80 fb 33             	cmp    $0x33,%bl
c002776c:	0f 87 00 04 00 00    	ja     c0027b72 <.L105>
c0027772:	0f b6 db             	movzbl %bl,%ebx
c0027775:	89 e9                	mov    %ebp,%ecx
c0027777:	03 8c 9d 18 47 ff ff 	add    -0xb8e8(%ebp,%ebx,4),%ecx
c002777e:	ff e1                	jmp    *%ecx

c0027780 <.L100>:
      c->type = PTRDIFFT;
c0027780:	c7 44 24 3c 07 00 00 	movl   $0x7,0x3c(%esp)
c0027787:	00 
      switch (*format) 
c0027788:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002778c:	0f be d0             	movsbl %al,%edx
c002778f:	8d 58 bb             	lea    -0x45(%eax),%ebx
c0027792:	80 fb 33             	cmp    $0x33,%bl
c0027795:	0f 87 d7 03 00 00    	ja     c0027b72 <.L105>
c002779b:	0f b6 db             	movzbl %bl,%ebx
c002779e:	89 e9                	mov    %ebp,%ecx
c00277a0:	03 8c 9d e8 47 ff ff 	add    -0xb818(%ebp,%ebx,4),%ecx
c00277a7:	ff e1                	jmp    *%ecx

c00277a9 <.L98>:
      c->type = SIZET;
c00277a9:	c7 44 24 3c 08 00 00 	movl   $0x8,0x3c(%esp)
c00277b0:	00 
      switch (*format) 
c00277b1:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00277b5:	0f be d0             	movsbl %al,%edx
c00277b8:	8d 58 bb             	lea    -0x45(%eax),%ebx
c00277bb:	80 fb 33             	cmp    $0x33,%bl
c00277be:	0f 87 ae 03 00 00    	ja     c0027b72 <.L105>
c00277c4:	0f b6 db             	movzbl %bl,%ebx
c00277c7:	89 e9                	mov    %ebp,%ecx
c00277c9:	03 8c 9d b8 48 ff ff 	add    -0xb748(%ebp,%ebx,4),%ecx
c00277d0:	ff e1                	jmp    *%ecx

c00277d2 <.L97>:
c00277d2:	0f be d0             	movsbl %al,%edx
c00277d5:	8d 70 bb             	lea    -0x45(%eax),%esi
c00277d8:	89 f1                	mov    %esi,%ecx
c00277da:	80 f9 33             	cmp    $0x33,%cl
c00277dd:	0f 87 8d 03 00 00    	ja     c0027b70 <.L149>
c00277e3:	0f b6 f1             	movzbl %cl,%esi
c00277e6:	89 e9                	mov    %ebp,%ecx
c00277e8:	03 8c b5 88 49 ff ff 	add    -0xb678(%ebp,%esi,4),%ecx
c00277ef:	ff e1                	jmp    *%ecx

c00277f1 <.L152>:
c00277f1:	89 de                	mov    %ebx,%esi

c00277f3 <.L111>:
            switch (c.type) 
c00277f3:	83 7c 24 3c 08       	cmpl   $0x8,0x3c(%esp)
c00277f8:	0f 87 20 01 00 00    	ja     c002791e <.L128>
c00277fe:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0027802:	89 eb                	mov    %ebp,%ebx
c0027804:	03 9c 85 58 4a ff ff 	add    -0xb5a8(%ebp,%eax,4),%ebx
c002780b:	ff e3                	jmp    *%ebx

c002780d <.L137>:
                value = (signed char) va_arg (args, int);
c002780d:	0f be 0f             	movsbl (%edi),%ecx
c0027810:	89 c8                	mov    %ecx,%eax
c0027812:	99                   	cltd   
c0027813:	89 0c 24             	mov    %ecx,(%esp)
c0027816:	89 54 24 04          	mov    %edx,0x4(%esp)
c002781a:	8d 7f 04             	lea    0x4(%edi),%edi
            format_integer (value < 0 ? -value : value,
c002781d:	8b 54 24 04          	mov    0x4(%esp),%edx
c0027821:	c1 fa 1f             	sar    $0x1f,%edx
c0027824:	89 d3                	mov    %edx,%ebx
c0027826:	33 1c 24             	xor    (%esp),%ebx
c0027829:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c002782d:	89 d3                	mov    %edx,%ebx
c002782f:	33 5c 24 04          	xor    0x4(%esp),%ebx
c0027833:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0027837:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002783b:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002783f:	29 d1                	sub    %edx,%ecx
c0027841:	19 d3                	sbb    %edx,%ebx
c0027843:	89 c8                	mov    %ecx,%eax
c0027845:	89 da                	mov    %ebx,%edx
c0027847:	83 ec 0c             	sub    $0xc,%esp
c002784a:	ff 74 24 78          	pushl  0x78(%esp)
c002784e:	ff 74 24 78          	pushl  0x78(%esp)
c0027852:	8d 4c 24 44          	lea    0x44(%esp),%ecx
c0027856:	51                   	push   %ecx
c0027857:	8d 8d c8 7c ff ff    	lea    -0x8338(%ebp),%ecx
c002785d:	51                   	push   %ecx
c002785e:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c0027862:	c1 e9 1f             	shr    $0x1f,%ecx
c0027865:	51                   	push   %ecx
c0027866:	b9 01 00 00 00       	mov    $0x1,%ecx
c002786b:	e8 f9 f7 ff ff       	call   c0027069 <format_integer>
          break;
c0027870:	83 c4 20             	add    $0x20,%esp
c0027873:	89 f3                	mov    %esi,%ebx
c0027875:	e9 83 fc ff ff       	jmp    c00274fd <__vprintf+0x3d>

c002787a <.L136>:
                value = (short) va_arg (args, int);
c002787a:	0f bf 0f             	movswl (%edi),%ecx
c002787d:	89 c8                	mov    %ecx,%eax
c002787f:	99                   	cltd   
c0027880:	89 0c 24             	mov    %ecx,(%esp)
c0027883:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027887:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c002788a:	eb 91                	jmp    c002781d <.L137+0x10>

c002788c <.L135>:
                value = va_arg (args, int);
c002788c:	8b 0f                	mov    (%edi),%ecx
c002788e:	89 c8                	mov    %ecx,%eax
c0027890:	99                   	cltd   
c0027891:	89 0c 24             	mov    %ecx,(%esp)
c0027894:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027898:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c002789b:	eb 80                	jmp    c002781d <.L137+0x10>

c002789d <.L134>:
                value = va_arg (args, intmax_t);
c002789d:	8b 07                	mov    (%edi),%eax
c002789f:	8b 57 04             	mov    0x4(%edi),%edx
c00278a2:	89 04 24             	mov    %eax,(%esp)
c00278a5:	89 54 24 04          	mov    %edx,0x4(%esp)
c00278a9:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00278ac:	e9 6c ff ff ff       	jmp    c002781d <.L137+0x10>

c00278b1 <.L133>:
                value = va_arg (args, long);
c00278b1:	8b 0f                	mov    (%edi),%ecx
c00278b3:	89 c8                	mov    %ecx,%eax
c00278b5:	99                   	cltd   
c00278b6:	89 0c 24             	mov    %ecx,(%esp)
c00278b9:	89 54 24 04          	mov    %edx,0x4(%esp)
c00278bd:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00278c0:	e9 58 ff ff ff       	jmp    c002781d <.L137+0x10>

c00278c5 <.L132>:
                value = va_arg (args, long long);
c00278c5:	8b 07                	mov    (%edi),%eax
c00278c7:	8b 57 04             	mov    0x4(%edi),%edx
c00278ca:	89 04 24             	mov    %eax,(%esp)
c00278cd:	89 54 24 04          	mov    %edx,0x4(%esp)
c00278d1:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00278d4:	e9 44 ff ff ff       	jmp    c002781d <.L137+0x10>

c00278d9 <.L131>:
                value = va_arg (args, ptrdiff_t);
c00278d9:	8b 0f                	mov    (%edi),%ecx
c00278db:	89 c8                	mov    %ecx,%eax
c00278dd:	99                   	cltd   
c00278de:	89 0c 24             	mov    %ecx,(%esp)
c00278e1:	89 54 24 04          	mov    %edx,0x4(%esp)
c00278e5:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00278e8:	e9 30 ff ff ff       	jmp    c002781d <.L137+0x10>

c00278ed <.L129>:
                value = va_arg (args, size_t);
c00278ed:	8d 47 04             	lea    0x4(%edi),%eax
c00278f0:	8b 0f                	mov    (%edi),%ecx
c00278f2:	bb 00 00 00 00       	mov    $0x0,%ebx
c00278f7:	89 0c 24             	mov    %ecx,(%esp)
c00278fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
                if (value > SIZE_MAX / 2)
c00278fe:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
c0027903:	39 ca                	cmp    %ecx,%edx
c0027905:	ba 00 00 00 00       	mov    $0x0,%edx
c002790a:	19 da                	sbb    %ebx,%edx
                value = va_arg (args, size_t);
c002790c:	89 c7                	mov    %eax,%edi
                if (value > SIZE_MAX / 2)
c002790e:	0f 8d 09 ff ff ff    	jge    c002781d <.L137+0x10>
                  value = value - SIZE_MAX - 1;
c0027914:	83 6c 24 04 01       	subl   $0x1,0x4(%esp)
c0027919:	e9 ff fe ff ff       	jmp    c002781d <.L137+0x10>

c002791e <.L128>:
                NOT_REACHED ();
c002791e:	8d 85 d0 55 ff ff    	lea    -0xaa30(%ebp),%eax
c0027924:	50                   	push   %eax
c0027925:	8d 85 7c 4a ff ff    	lea    -0xb584(%ebp),%eax
c002792b:	50                   	push   %eax
c002792c:	68 dc 00 00 00       	push   $0xdc
c0027931:	8d 85 61 69 ff ff    	lea    -0x969f(%ebp),%eax
c0027937:	50                   	push   %eax
c0027938:	89 eb                	mov    %ebp,%ebx
c002793a:	e8 9b 17 00 00       	call   c00290da <debug_panic>

c002793f <.L126>:
                value = va_arg (args, unsigned);
c002793f:	8b 17                	mov    (%edi),%edx
c0027941:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027946:	89 54 24 10          	mov    %edx,0x10(%esp)
c002794a:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002794e:	8d 7f 04             	lea    0x4(%edi),%edi
            switch (*format) 
c0027951:	3c 6f                	cmp    $0x6f,%al
c0027953:	0f 84 1c 01 00 00    	je     c0027a75 <.L124+0x71>
c0027959:	3c 6f                	cmp    $0x6f,%al
c002795b:	0f 8e bc 00 00 00    	jle    c0027a1d <.L124+0x19>
c0027961:	3c 75                	cmp    $0x75,%al
c0027963:	0f 84 14 01 00 00    	je     c0027a7d <.L124+0x79>
c0027969:	3c 78                	cmp    $0x78,%al
c002796b:	0f 85 e3 00 00 00    	jne    c0027a54 <.L124+0x50>
              case 'x': b = &base_x; break;
c0027971:	8d 85 a8 7c ff ff    	lea    -0x8358(%ebp),%eax
c0027977:	e9 ab 00 00 00       	jmp    c0027a27 <.L124+0x23>

c002797c <.L106>:
                value = (unsigned char) va_arg (args, unsigned);
c002797c:	0f b6 17             	movzbl (%edi),%edx
c002797f:	89 54 24 10          	mov    %edx,0x10(%esp)
c0027983:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c002798a:	00 
                break;
c002798b:	89 f3                	mov    %esi,%ebx
                value = (unsigned char) va_arg (args, unsigned);
c002798d:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027990:	eb bf                	jmp    c0027951 <.L126+0x12>

c0027992 <.L113>:
                value = (unsigned short) va_arg (args, unsigned);
c0027992:	0f b7 17             	movzwl (%edi),%edx
c0027995:	89 54 24 10          	mov    %edx,0x10(%esp)
c0027999:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c00279a0:	00 
                break;
c00279a1:	89 f3                	mov    %esi,%ebx
                value = (unsigned short) va_arg (args, unsigned);
c00279a3:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00279a6:	eb a9                	jmp    c0027951 <.L126+0x12>

c00279a8 <.L115>:
                value = va_arg (args, uintmax_t);
c00279a8:	8b 0f                	mov    (%edi),%ecx
c00279aa:	8b 5f 04             	mov    0x4(%edi),%ebx
c00279ad:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00279b1:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c00279b5:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, uintmax_t);
c00279b7:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00279ba:	eb 95                	jmp    c0027951 <.L126+0x12>

c00279bc <.L120>:
                value = va_arg (args, unsigned long);
c00279bc:	8b 0f                	mov    (%edi),%ecx
c00279be:	bb 00 00 00 00       	mov    $0x0,%ebx
c00279c3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00279c7:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c00279cb:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, unsigned long);
c00279cd:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00279d0:	e9 7c ff ff ff       	jmp    c0027951 <.L126+0x12>

c00279d5 <.L118>:
                value = va_arg (args, unsigned long long);
c00279d5:	8b 0f                	mov    (%edi),%ecx
c00279d7:	8b 5f 04             	mov    0x4(%edi),%ebx
c00279da:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00279de:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c00279e2:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, unsigned long long);
c00279e4:	8d 7f 08             	lea    0x8(%edi),%edi
                break;
c00279e7:	e9 65 ff ff ff       	jmp    c0027951 <.L126+0x12>

c00279ec <.L122>:
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c00279ec:	8b 1f                	mov    (%edi),%ebx
c00279ee:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c00279f2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c00279f9:	00 
                break;
c00279fa:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, ptrdiff_t);
c00279fc:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c00279ff:	e9 4d ff ff ff       	jmp    c0027951 <.L126+0x12>

c0027a04 <.L124>:
                value = va_arg (args, size_t);
c0027a04:	8b 0f                	mov    (%edi),%ecx
c0027a06:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027a0b:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a0f:	89 5c 24 14          	mov    %ebx,0x14(%esp)
                break;
c0027a13:	89 f3                	mov    %esi,%ebx
                value = va_arg (args, size_t);
c0027a15:	8d 7f 04             	lea    0x4(%edi),%edi
                break;
c0027a18:	e9 34 ff ff ff       	jmp    c0027951 <.L126+0x12>
c0027a1d:	3c 58                	cmp    $0x58,%al
c0027a1f:	75 33                	jne    c0027a54 <.L124+0x50>
              case 'X': b = &base_X; break;
c0027a21:	8d 85 98 7c ff ff    	lea    -0x8368(%ebp),%eax
            format_integer (value, false, false, b, &c, output, aux);
c0027a27:	83 ec 0c             	sub    $0xc,%esp
c0027a2a:	ff 74 24 78          	pushl  0x78(%esp)
c0027a2e:	ff 74 24 78          	pushl  0x78(%esp)
c0027a32:	8d 54 24 44          	lea    0x44(%esp),%edx
c0027a36:	52                   	push   %edx
c0027a37:	50                   	push   %eax
c0027a38:	6a 00                	push   $0x0
c0027a3a:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027a3f:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027a43:	8b 54 24 34          	mov    0x34(%esp),%edx
c0027a47:	e8 1d f6 ff ff       	call   c0027069 <format_integer>
          break;
c0027a4c:	83 c4 20             	add    $0x20,%esp
c0027a4f:	e9 a9 fa ff ff       	jmp    c00274fd <__vprintf+0x3d>
              default: NOT_REACHED ();
c0027a54:	8d 85 d0 55 ff ff    	lea    -0xaa30(%ebp),%eax
c0027a5a:	50                   	push   %eax
c0027a5b:	8d 85 7c 4a ff ff    	lea    -0xb584(%ebp),%eax
c0027a61:	50                   	push   %eax
c0027a62:	68 14 01 00 00       	push   $0x114
c0027a67:	8d 85 61 69 ff ff    	lea    -0x969f(%ebp),%eax
c0027a6d:	50                   	push   %eax
c0027a6e:	89 eb                	mov    %ebp,%ebx
c0027a70:	e8 65 16 00 00       	call   c00290da <debug_panic>
              case 'o': b = &base_o; break;
c0027a75:	8d 85 b8 7c ff ff    	lea    -0x8348(%ebp),%eax
c0027a7b:	eb aa                	jmp    c0027a27 <.L124+0x23>
              case 'u': b = &base_d; break;
c0027a7d:	8d 85 c8 7c ff ff    	lea    -0x8338(%ebp),%eax
c0027a83:	eb a2                	jmp    c0027a27 <.L124+0x23>

c0027a85 <.L151>:
      switch (*format) 
c0027a85:	89 de                	mov    %ebx,%esi

c0027a87 <.L112>:
            char ch = va_arg (args, int);
c0027a87:	8d 47 04             	lea    0x4(%edi),%eax
c0027a8a:	89 04 24             	mov    %eax,(%esp)
c0027a8d:	8b 07                	mov    (%edi),%eax
c0027a8f:	88 44 24 2f          	mov    %al,0x2f(%esp)
            format_string (&ch, 1, &c, output, aux);
c0027a93:	8d 4c 24 30          	lea    0x30(%esp),%ecx
c0027a97:	8d 44 24 2f          	lea    0x2f(%esp),%eax
c0027a9b:	83 ec 08             	sub    $0x8,%esp
c0027a9e:	ff 74 24 74          	pushl  0x74(%esp)
c0027aa2:	ff 74 24 74          	pushl  0x74(%esp)
c0027aa6:	ba 01 00 00 00       	mov    $0x1,%edx
c0027aab:	e8 3c f9 ff ff       	call   c00273ec <format_string>
          break;
c0027ab0:	83 c4 10             	add    $0x10,%esp
c0027ab3:	89 f3                	mov    %esi,%ebx
            char ch = va_arg (args, int);
c0027ab5:	8b 3c 24             	mov    (%esp),%edi
          break;
c0027ab8:	e9 40 fa ff ff       	jmp    c00274fd <__vprintf+0x3d>

c0027abd <.L154>:
      switch (*format) 
c0027abd:	89 de                	mov    %ebx,%esi

c0027abf <.L108>:
            const char *s = va_arg (args, char *);
c0027abf:	8d 47 04             	lea    0x4(%edi),%eax
c0027ac2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0027ac6:	8b 3f                	mov    (%edi),%edi
              s = "(null)";
c0027ac8:	85 ff                	test   %edi,%edi
c0027aca:	8d 85 5a 69 ff ff    	lea    -0x96a6(%ebp),%eax
c0027ad0:	0f 44 f8             	cmove  %eax,%edi
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027ad3:	83 ec 08             	sub    $0x8,%esp
c0027ad6:	ff 74 24 08          	pushl  0x8(%esp)
c0027ada:	57                   	push   %edi
c0027adb:	89 eb                	mov    %ebp,%ebx
c0027add:	e8 0e 0c 00 00       	call   c00286f0 <strnlen>
c0027ae2:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c0027ae6:	83 c4 08             	add    $0x8,%esp
c0027ae9:	ff 74 24 74          	pushl  0x74(%esp)
c0027aed:	ff 74 24 74          	pushl  0x74(%esp)
c0027af1:	89 c2                	mov    %eax,%edx
c0027af3:	89 f8                	mov    %edi,%eax
c0027af5:	e8 f2 f8 ff ff       	call   c00273ec <format_string>
          break;
c0027afa:	83 c4 10             	add    $0x10,%esp
c0027afd:	89 f3                	mov    %esi,%ebx
            const char *s = va_arg (args, char *);
c0027aff:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
          break;
c0027b03:	e9 f5 f9 ff ff       	jmp    c00274fd <__vprintf+0x3d>

c0027b08 <.L153>:
      switch (*format) 
c0027b08:	89 de                	mov    %ebx,%esi

c0027b0a <.L109>:
            void *p = va_arg (args, void *);
c0027b0a:	8d 47 04             	lea    0x4(%edi),%eax
c0027b0d:	89 04 24             	mov    %eax,(%esp)
c0027b10:	8b 07                	mov    (%edi),%eax
            c.flags = POUND;
c0027b12:	c7 44 24 30 08 00 00 	movl   $0x8,0x30(%esp)
c0027b19:	00 
            format_integer ((uintptr_t) p, false, false,
c0027b1a:	ba 00 00 00 00       	mov    $0x0,%edx
c0027b1f:	83 ec 0c             	sub    $0xc,%esp
c0027b22:	ff 74 24 78          	pushl  0x78(%esp)
c0027b26:	ff 74 24 78          	pushl  0x78(%esp)
c0027b2a:	8d 4c 24 44          	lea    0x44(%esp),%ecx
c0027b2e:	51                   	push   %ecx
c0027b2f:	8d 8d a8 7c ff ff    	lea    -0x8358(%ebp),%ecx
c0027b35:	51                   	push   %ecx
c0027b36:	6a 00                	push   $0x0
c0027b38:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027b3d:	e8 27 f5 ff ff       	call   c0027069 <format_integer>
          break;
c0027b42:	83 c4 20             	add    $0x20,%esp
c0027b45:	89 f3                	mov    %esi,%ebx
            void *p = va_arg (args, void *);
c0027b47:	8b 3c 24             	mov    (%esp),%edi
          break;
c0027b4a:	e9 ae f9 ff ff       	jmp    c00274fd <__vprintf+0x3d>

c0027b4f <.L150>:
      switch (*format) 
c0027b4f:	89 de                	mov    %ebx,%esi

c0027b51 <.L110>:
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027b51:	52                   	push   %edx
c0027b52:	ff 74 24 70          	pushl  0x70(%esp)
c0027b56:	ff 74 24 70          	pushl  0x70(%esp)
c0027b5a:	8d 85 73 69 ff ff    	lea    -0x968d(%ebp),%eax
c0027b60:	50                   	push   %eax
c0027b61:	e8 3d f9 ff ff       	call   c00274a3 <__printf>
          break;
c0027b66:	83 c4 10             	add    $0x10,%esp
c0027b69:	89 f3                	mov    %esi,%ebx
c0027b6b:	e9 8d f9 ff ff       	jmp    c00274fd <__vprintf+0x3d>

c0027b70 <.L149>:
      switch (*format) 
c0027b70:	89 de                	mov    %ebx,%esi

c0027b72 <.L105>:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027b72:	52                   	push   %edx
c0027b73:	ff 74 24 70          	pushl  0x70(%esp)
c0027b77:	ff 74 24 70          	pushl  0x70(%esp)
c0027b7b:	8d 85 89 69 ff ff    	lea    -0x9677(%ebp),%eax
c0027b81:	50                   	push   %eax
c0027b82:	e8 1c f9 ff ff       	call   c00274a3 <__printf>
          break;
c0027b87:	83 c4 10             	add    $0x10,%esp
c0027b8a:	89 f3                	mov    %esi,%ebx
c0027b8c:	e9 6c f9 ff ff       	jmp    c00274fd <__vprintf+0x3d>

c0027b91 <vsnprintf>:
{
c0027b91:	56                   	push   %esi
c0027b92:	53                   	push   %ebx
c0027b93:	83 ec 14             	sub    $0x14,%esp
c0027b96:	e8 5d 73 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0027b9b:	81 c3 8d 35 01 00    	add    $0x1358d,%ebx
c0027ba1:	8b 44 24 24          	mov    0x24(%esp),%eax
c0027ba5:	8b 54 24 28          	mov    0x28(%esp),%edx
c0027ba9:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c0027bad:	8b 74 24 20          	mov    0x20(%esp),%esi
c0027bb1:	89 74 24 04          	mov    %esi,0x4(%esp)
  aux.length = 0;
c0027bb5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0027bbc:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027bbd:	85 c0                	test   %eax,%eax
c0027bbf:	74 26                	je     c0027be7 <vsnprintf+0x56>
c0027bc1:	83 e8 01             	sub    $0x1,%eax
c0027bc4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027bc8:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027bcc:	50                   	push   %eax
c0027bcd:	8d 83 ee be fe ff    	lea    -0x14112(%ebx),%eax
c0027bd3:	50                   	push   %eax
c0027bd4:	51                   	push   %ecx
c0027bd5:	52                   	push   %edx
c0027bd6:	e8 e5 f8 ff ff       	call   c00274c0 <__vprintf>
    *aux.p = '\0';
c0027bdb:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027bdf:	c6 00 00             	movb   $0x0,(%eax)
c0027be2:	83 c4 10             	add    $0x10,%esp
c0027be5:	eb 1e                	jmp    c0027c05 <vsnprintf+0x74>
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027be7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027bee:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027bef:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027bf3:	50                   	push   %eax
c0027bf4:	8d 83 ee be fe ff    	lea    -0x14112(%ebx),%eax
c0027bfa:	50                   	push   %eax
c0027bfb:	51                   	push   %ecx
c0027bfc:	52                   	push   %edx
c0027bfd:	e8 be f8 ff ff       	call   c00274c0 <__vprintf>
c0027c02:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c0027c05:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c0027c09:	83 c4 14             	add    $0x14,%esp
c0027c0c:	5b                   	pop    %ebx
c0027c0d:	5e                   	pop    %esi
c0027c0e:	c3                   	ret    

c0027c0f <snprintf>:
{
c0027c0f:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0027c12:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0027c16:	50                   	push   %eax
c0027c17:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027c1b:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027c1f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027c23:	e8 69 ff ff ff       	call   c0027b91 <vsnprintf>
}
c0027c28:	83 c4 1c             	add    $0x1c,%esp
c0027c2b:	c3                   	ret    

c0027c2c <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027c2c:	55                   	push   %ebp
c0027c2d:	57                   	push   %edi
c0027c2e:	56                   	push   %esi
c0027c2f:	53                   	push   %ebx
c0027c30:	83 ec 2c             	sub    $0x2c,%esp
c0027c33:	e8 cc 72 00 00       	call   c002ef04 <__x86.get_pc_thunk.di>
c0027c38:	81 c7 f0 34 01 00    	add    $0x134f0,%edi
c0027c3e:	0f b6 44 24 4c       	movzbl 0x4c(%esp),%eax
c0027c43:	88 44 24 17          	mov    %al,0x17(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027c47:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c0027c4c:	0f 84 ea 01 00 00    	je     c0027e3c <hex_dump+0x210>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027c52:	8d 87 a0 69 ff ff    	lea    -0x9660(%edi),%eax
c0027c58:	89 44 24 18          	mov    %eax,0x18(%esp)
c0027c5c:	eb 5a                	jmp    c0027cb8 <hex_dump+0x8c>
      for (i = 0; i < start; i++)
c0027c5e:	89 eb                	mov    %ebp,%ebx
c0027c60:	e9 c2 00 00 00       	jmp    c0027d27 <hex_dump+0xfb>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0027c65:	89 ee                	mov    %ebp,%esi
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
            printf (" ");
c0027c67:	83 ec 0c             	sub    $0xc,%esp
c0027c6a:	6a 20                	push   $0x20
c0027c6c:	89 fb                	mov    %edi,%ebx
c0027c6e:	e8 af 34 00 00       	call   c002b122 <putchar>
          for (; i < per_line; i++)
c0027c73:	83 c6 01             	add    $0x1,%esi
c0027c76:	83 c4 10             	add    $0x10,%esp
c0027c79:	83 fe 0f             	cmp    $0xf,%esi
c0027c7c:	76 e9                	jbe    c0027c67 <hex_dump+0x3b>
          printf ("|");
c0027c7e:	83 ec 0c             	sub    $0xc,%esp
c0027c81:	6a 7c                	push   $0x7c
c0027c83:	89 fb                	mov    %edi,%ebx
c0027c85:	e8 98 34 00 00       	call   c002b122 <putchar>
c0027c8a:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027c8d:	83 ec 0c             	sub    $0xc,%esp
c0027c90:	6a 0a                	push   $0xa
c0027c92:	89 fb                	mov    %edi,%ebx
c0027c94:	e8 89 34 00 00       	call   c002b122 <putchar>

      ofs += n;
c0027c99:	8b 44 24 20          	mov    0x20(%esp),%eax
c0027c9d:	01 44 24 50          	add    %eax,0x50(%esp)
      buf += n;
c0027ca1:	01 44 24 54          	add    %eax,0x54(%esp)
      size -= n;
c0027ca5:	89 e8                	mov    %ebp,%eax
c0027ca7:	2b 44 24 1c          	sub    0x1c(%esp),%eax
  while (size > 0)
c0027cab:	83 c4 10             	add    $0x10,%esp
c0027cae:	01 44 24 48          	add    %eax,0x48(%esp)
c0027cb2:	0f 84 84 01 00 00    	je     c0027e3c <hex_dump+0x210>
      start = ofs % per_line;
c0027cb8:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c0027cbc:	83 e5 0f             	and    $0xf,%ebp
      if (end - start > size)
c0027cbf:	ba 10 00 00 00       	mov    $0x10,%edx
c0027cc4:	29 ea                	sub    %ebp,%edx
        end = start + size;
c0027cc6:	89 e8                	mov    %ebp,%eax
c0027cc8:	03 44 24 48          	add    0x48(%esp),%eax
c0027ccc:	3b 54 24 48          	cmp    0x48(%esp),%edx
c0027cd0:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027cd5:	0f 46 c1             	cmovbe %ecx,%eax
c0027cd8:	89 44 24 0c          	mov    %eax,0xc(%esp)
      n = end - start;
c0027cdc:	29 e8                	sub    %ebp,%eax
c0027cde:	89 44 24 10          	mov    %eax,0x10(%esp)
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027ce2:	83 ec 04             	sub    $0x4,%esp
c0027ce5:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027ce9:	83 e0 f0             	and    $0xfffffff0,%eax
c0027cec:	ba 00 00 00 00       	mov    $0x0,%edx
c0027cf1:	52                   	push   %edx
c0027cf2:	50                   	push   %eax
c0027cf3:	ff 74 24 24          	pushl  0x24(%esp)
c0027cf7:	e8 82 f7 ff ff       	call   c002747e <printf>
      for (i = 0; i < start; i++)
c0027cfc:	83 c4 10             	add    $0x10,%esp
c0027cff:	85 ed                	test   %ebp,%ebp
c0027d01:	0f 84 57 ff ff ff    	je     c0027c5e <hex_dump+0x32>
c0027d07:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c0027d0c:	8d b7 a8 69 ff ff    	lea    -0x9658(%edi),%esi
c0027d12:	83 ec 0c             	sub    $0xc,%esp
c0027d15:	56                   	push   %esi
c0027d16:	e8 63 f7 ff ff       	call   c002747e <printf>
      for (i = 0; i < start; i++)
c0027d1b:	83 c3 01             	add    $0x1,%ebx
c0027d1e:	83 c4 10             	add    $0x10,%esp
c0027d21:	39 dd                	cmp    %ebx,%ebp
c0027d23:	75 ed                	jne    c0027d12 <hex_dump+0xe6>
c0027d25:	89 eb                	mov    %ebp,%ebx
      for (; i < end; i++) 
c0027d27:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0027d2b:	0f 86 fb 00 00 00    	jbe    c0027e2c <hex_dump+0x200>
        printf ("%02hhx%c",
c0027d31:	be 20 00 00 00       	mov    $0x20,%esi
c0027d36:	83 fb 07             	cmp    $0x7,%ebx
c0027d39:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027d3e:	0f 45 c6             	cmovne %esi,%eax
c0027d41:	83 ec 04             	sub    $0x4,%esp
c0027d44:	50                   	push   %eax
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027d45:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0027d49:	29 e8                	sub    %ebp,%eax
        printf ("%02hhx%c",
c0027d4b:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
c0027d4f:	50                   	push   %eax
c0027d50:	8d 87 ac 69 ff ff    	lea    -0x9654(%edi),%eax
c0027d56:	50                   	push   %eax
c0027d57:	e8 22 f7 ff ff       	call   c002747e <printf>
      for (; i < end; i++) 
c0027d5c:	83 c3 01             	add    $0x1,%ebx
c0027d5f:	83 c4 10             	add    $0x10,%esp
c0027d62:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0027d66:	75 ce                	jne    c0027d36 <hex_dump+0x10a>
      if (ascii) 
c0027d68:	80 7c 24 17 00       	cmpb   $0x0,0x17(%esp)
c0027d6d:	0f 84 1a ff ff ff    	je     c0027c8d <hex_dump+0x61>
          for (; i < per_line; i++)
c0027d73:	83 fb 0f             	cmp    $0xf,%ebx
c0027d76:	77 1a                	ja     c0027d92 <hex_dump+0x166>
            printf ("   ");
c0027d78:	8d b7 a8 69 ff ff    	lea    -0x9658(%edi),%esi
c0027d7e:	83 ec 0c             	sub    $0xc,%esp
c0027d81:	56                   	push   %esi
c0027d82:	e8 f7 f6 ff ff       	call   c002747e <printf>
          for (; i < per_line; i++)
c0027d87:	83 c3 01             	add    $0x1,%ebx
c0027d8a:	83 c4 10             	add    $0x10,%esp
c0027d8d:	83 fb 10             	cmp    $0x10,%ebx
c0027d90:	75 ec                	jne    c0027d7e <hex_dump+0x152>
          printf ("|");
c0027d92:	83 ec 0c             	sub    $0xc,%esp
c0027d95:	6a 7c                	push   $0x7c
c0027d97:	89 fb                	mov    %edi,%ebx
c0027d99:	e8 84 33 00 00       	call   c002b122 <putchar>
          for (i = 0; i < start; i++)
c0027d9e:	83 c4 10             	add    $0x10,%esp
c0027da1:	85 ed                	test   %ebp,%ebp
c0027da3:	74 75                	je     c0027e1a <hex_dump+0x1ee>
c0027da5:	be 00 00 00 00       	mov    $0x0,%esi
            printf (" ");
c0027daa:	83 ec 0c             	sub    $0xc,%esp
c0027dad:	6a 20                	push   $0x20
c0027daf:	89 fb                	mov    %edi,%ebx
c0027db1:	e8 6c 33 00 00       	call   c002b122 <putchar>
          for (i = 0; i < start; i++)
c0027db6:	83 c6 01             	add    $0x1,%esi
c0027db9:	83 c4 10             	add    $0x10,%esp
c0027dbc:	39 f5                	cmp    %esi,%ebp
c0027dbe:	75 ea                	jne    c0027daa <hex_dump+0x17e>
          for (; i < end; i++)
c0027dc0:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c0027dc4:	0f 86 9b fe ff ff    	jbe    c0027c65 <hex_dump+0x39>
          for (i = 0; i < start; i++)
c0027dca:	89 ee                	mov    %ebp,%esi
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027dcc:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027dd0:	29 e8                	sub    %ebp,%eax
c0027dd2:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c0027dd6:	89 c5                	mov    %eax,%ebp
c0027dd8:	0f b6 44 35 00       	movzbl 0x0(%ebp,%esi,1),%eax
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027ddd:	0f b6 d0             	movzbl %al,%edx
c0027de0:	83 ea 20             	sub    $0x20,%edx
c0027de3:	83 fa 5f             	cmp    $0x5f,%edx
c0027de6:	b9 2e 00 00 00       	mov    $0x2e,%ecx
c0027deb:	0f 43 c1             	cmovae %ecx,%eax
            printf ("%c",
c0027dee:	83 ec 0c             	sub    $0xc,%esp
c0027df1:	0f b6 c0             	movzbl %al,%eax
c0027df4:	50                   	push   %eax
c0027df5:	89 fb                	mov    %edi,%ebx
c0027df7:	e8 26 33 00 00       	call   c002b122 <putchar>
          for (; i < end; i++)
c0027dfc:	83 c6 01             	add    $0x1,%esi
c0027dff:	83 c4 10             	add    $0x10,%esp
c0027e02:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c0027e06:	77 d0                	ja     c0027dd8 <hex_dump+0x1ac>
c0027e08:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
          for (; i < per_line; i++)
c0027e0c:	83 fe 0f             	cmp    $0xf,%esi
c0027e0f:	0f 86 52 fe ff ff    	jbe    c0027c67 <hex_dump+0x3b>
c0027e15:	e9 64 fe ff ff       	jmp    c0027c7e <hex_dump+0x52>
          for (i = 0; i < start; i++)
c0027e1a:	89 ee                	mov    %ebp,%esi
          for (; i < end; i++)
c0027e1c:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0027e21:	75 a9                	jne    c0027dcc <hex_dump+0x1a0>
          for (i = 0; i < start; i++)
c0027e23:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027e27:	e9 3b fe ff ff       	jmp    c0027c67 <hex_dump+0x3b>
      if (ascii) 
c0027e2c:	80 7c 24 17 00       	cmpb   $0x0,0x17(%esp)
c0027e31:	0f 84 56 fe ff ff    	je     c0027c8d <hex_dump+0x61>
c0027e37:	e9 3c ff ff ff       	jmp    c0027d78 <hex_dump+0x14c>
    }
}
c0027e3c:	83 c4 2c             	add    $0x2c,%esp
c0027e3f:	5b                   	pop    %ebx
c0027e40:	5e                   	pop    %esi
c0027e41:	5f                   	pop    %edi
c0027e42:	5d                   	pop    %ebp
c0027e43:	c3                   	ret    

c0027e44 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027e44:	55                   	push   %ebp
c0027e45:	57                   	push   %edi
c0027e46:	56                   	push   %esi
c0027e47:	53                   	push   %ebx
c0027e48:	83 ec 1c             	sub    $0x1c,%esp
c0027e4b:	e8 b4 70 00 00       	call   c002ef04 <__x86.get_pc_thunk.di>
c0027e50:	81 c7 d8 32 01 00    	add    $0x132d8,%edi
c0027e56:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0027e5a:	8b 44 24 30          	mov    0x30(%esp),%eax
c0027e5e:	8b 54 24 34          	mov    0x34(%esp),%edx
  if (size == 1)
c0027e62:	89 c1                	mov    %eax,%ecx
c0027e64:	83 f1 01             	xor    $0x1,%ecx
c0027e67:	89 d3                	mov    %edx,%ebx
c0027e69:	09 cb                	or     %ecx,%ebx
c0027e6b:	74 6e                	je     c0027edb <print_human_readable_size+0x97>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027e6d:	b9 ff 03 00 00       	mov    $0x3ff,%ecx
c0027e72:	39 c1                	cmp    %eax,%ecx
c0027e74:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027e79:	19 d1                	sbb    %edx,%ecx
c0027e7b:	73 76                	jae    c0027ef3 <print_human_readable_size+0xaf>
c0027e7d:	8d 8f e4 ff ff ff    	lea    -0x1c(%edi),%ecx
c0027e83:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027e88:	83 bf e8 ff ff ff 00 	cmpl   $0x0,-0x18(%edi)
c0027e8f:	74 44                	je     c0027ed5 <print_human_readable_size+0x91>
        size /= 1024;
c0027e91:	89 c6                	mov    %eax,%esi
c0027e93:	89 d7                	mov    %edx,%edi
c0027e95:	0f ac d6 0a          	shrd   $0xa,%edx,%esi
c0027e99:	c1 ef 0a             	shr    $0xa,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027e9c:	83 c1 04             	add    $0x4,%ecx
c0027e9f:	bd ff ff 0f 00       	mov    $0xfffff,%ebp
c0027ea4:	39 c5                	cmp    %eax,%ebp
c0027ea6:	89 dd                	mov    %ebx,%ebp
c0027ea8:	19 d5                	sbb    %edx,%ebp
c0027eaa:	73 0a                	jae    c0027eb6 <print_human_readable_size+0x72>
        size /= 1024;
c0027eac:	89 f0                	mov    %esi,%eax
c0027eae:	89 fa                	mov    %edi,%edx
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027eb0:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
c0027eb4:	75 db                	jne    c0027e91 <print_human_readable_size+0x4d>
      printf ("%"PRIu64" %s", size, *fp);
c0027eb6:	ff 31                	pushl  (%ecx)
c0027eb8:	57                   	push   %edi
c0027eb9:	56                   	push   %esi
c0027eba:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027ebe:	8d 80 bc 69 ff ff    	lea    -0x9644(%eax),%eax
c0027ec4:	50                   	push   %eax
c0027ec5:	e8 b4 f5 ff ff       	call   c002747e <printf>
c0027eca:	83 c4 10             	add    $0x10,%esp
    }
}
c0027ecd:	83 c4 1c             	add    $0x1c,%esp
c0027ed0:	5b                   	pop    %ebx
c0027ed1:	5e                   	pop    %esi
c0027ed2:	5f                   	pop    %edi
c0027ed3:	5d                   	pop    %ebp
c0027ed4:	c3                   	ret    
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027ed5:	89 c6                	mov    %eax,%esi
c0027ed7:	89 d7                	mov    %edx,%edi
c0027ed9:	eb db                	jmp    c0027eb6 <print_human_readable_size+0x72>
    printf ("1 byte");
c0027edb:	83 ec 0c             	sub    $0xc,%esp
c0027ede:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027ee2:	8d 80 b5 69 ff ff    	lea    -0x964b(%eax),%eax
c0027ee8:	50                   	push   %eax
c0027ee9:	e8 90 f5 ff ff       	call   c002747e <printf>
c0027eee:	83 c4 10             	add    $0x10,%esp
c0027ef1:	eb da                	jmp    c0027ecd <print_human_readable_size+0x89>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027ef3:	89 c6                	mov    %eax,%esi
c0027ef5:	89 d7                	mov    %edx,%edi
c0027ef7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027efb:	8d 88 e4 ff ff ff    	lea    -0x1c(%eax),%ecx
c0027f01:	eb b3                	jmp    c0027eb6 <print_human_readable_size+0x72>

c0027f03 <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0027f03:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c0027f06:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027f0a:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027f0e:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027f12:	ff 10                	call   *(%eax)
}
c0027f14:	83 c4 1c             	add    $0x1c,%esp
c0027f17:	c3                   	ret    

c0027f18 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0027f18:	55                   	push   %ebp
c0027f19:	57                   	push   %edi
c0027f1a:	56                   	push   %esi
c0027f1b:	53                   	push   %ebx
c0027f1c:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c0027f20:	8d 72 ff             	lea    -0x1(%edx),%esi
c0027f23:	0f af f7             	imul   %edi,%esi
  unsigned char *b = array + (b_idx - 1) * size;
c0027f26:	83 e9 01             	sub    $0x1,%ecx
c0027f29:	0f af cf             	imul   %edi,%ecx
  size_t i;

  for (i = 0; i < size; i++)
c0027f2c:	85 ff                	test   %edi,%edi
c0027f2e:	74 21                	je     c0027f51 <do_swap+0x39>
c0027f30:	8d 14 30             	lea    (%eax,%esi,1),%edx
c0027f33:	01 f8                	add    %edi,%eax
c0027f35:	8d 3c 30             	lea    (%eax,%esi,1),%edi
    {
      unsigned char t = a[i];
c0027f38:	0f b6 2a             	movzbl (%edx),%ebp
      a[i] = b[i];
c0027f3b:	89 d0                	mov    %edx,%eax
c0027f3d:	29 f0                	sub    %esi,%eax
c0027f3f:	0f b6 1c 08          	movzbl (%eax,%ecx,1),%ebx
c0027f43:	88 1a                	mov    %bl,(%edx)
      b[i] = t;
c0027f45:	89 eb                	mov    %ebp,%ebx
c0027f47:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
c0027f4a:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < size; i++)
c0027f4d:	39 fa                	cmp    %edi,%edx
c0027f4f:	75 e7                	jne    c0027f38 <do_swap+0x20>
    }
}
c0027f51:	5b                   	pop    %ebx
c0027f52:	5e                   	pop    %esi
c0027f53:	5f                   	pop    %edi
c0027f54:	5d                   	pop    %ebp
c0027f55:	c3                   	ret    

c0027f56 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0027f56:	55                   	push   %ebp
c0027f57:	57                   	push   %edi
c0027f58:	56                   	push   %esi
c0027f59:	53                   	push   %ebx
c0027f5a:	83 ec 1c             	sub    $0x1c,%esp
c0027f5d:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027f61:	89 d7                	mov    %edx,%edi
c0027f63:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027f67:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0027f6b:	eb 4a                	jmp    c0027fb7 <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027f6d:	83 ec 04             	sub    $0x4,%esp
c0027f70:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027f74:	8d 47 ff             	lea    -0x1(%edi),%eax
c0027f77:	0f af c5             	imul   %ebp,%eax
c0027f7a:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027f7e:	01 d0                	add    %edx,%eax
c0027f80:	50                   	push   %eax
c0027f81:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027f84:	0f af c5             	imul   %ebp,%eax
c0027f87:	01 d0                	add    %edx,%eax
c0027f89:	50                   	push   %eax
c0027f8a:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027f8e:	83 c4 10             	add    $0x10,%esp
c0027f91:	85 c0                	test   %eax,%eax
c0027f93:	7e 2e                	jle    c0027fc3 <heapify+0x6d>
        max = left;
      if (right <= cnt
c0027f95:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027f99:	76 5b                	jbe    c0027ff6 <heapify+0xa0>
        max = left;
c0027f9b:	89 de                	mov    %ebx,%esi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0027f9d:	39 f7                	cmp    %esi,%edi
c0027f9f:	74 4d                	je     c0027fee <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0027fa1:	83 ec 0c             	sub    $0xc,%esp
c0027fa4:	55                   	push   %ebp
c0027fa5:	89 f1                	mov    %esi,%ecx
c0027fa7:	89 fa                	mov    %edi,%edx
c0027fa9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0027fad:	e8 66 ff ff ff       	call   c0027f18 <do_swap>
      i = max;
c0027fb2:	89 f7                	mov    %esi,%edi
    {
c0027fb4:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c0027fb7:	8d 1c 3f             	lea    (%edi,%edi,1),%ebx
      size_t right = 2 * i + 1;
c0027fba:	8d 73 01             	lea    0x1(%ebx),%esi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027fbd:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0027fc1:	76 aa                	jbe    c0027f6d <heapify+0x17>
      if (right <= cnt
c0027fc3:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027fc7:	77 25                	ja     c0027fee <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027fc9:	83 ec 04             	sub    $0x4,%esp
c0027fcc:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027fd0:	8d 47 ff             	lea    -0x1(%edi),%eax
c0027fd3:	0f af c5             	imul   %ebp,%eax
c0027fd6:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0027fda:	01 c8                	add    %ecx,%eax
c0027fdc:	50                   	push   %eax
c0027fdd:	0f af dd             	imul   %ebp,%ebx
c0027fe0:	01 cb                	add    %ecx,%ebx
c0027fe2:	53                   	push   %ebx
c0027fe3:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0027fe7:	83 c4 10             	add    $0x10,%esp
c0027fea:	85 c0                	test   %eax,%eax
c0027fec:	7f af                	jg     c0027f9d <heapify+0x47>
    }
}
c0027fee:	83 c4 1c             	add    $0x1c,%esp
c0027ff1:	5b                   	pop    %ebx
c0027ff2:	5e                   	pop    %esi
c0027ff3:	5f                   	pop    %edi
c0027ff4:	5d                   	pop    %ebp
c0027ff5:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027ff6:	83 ec 04             	sub    $0x4,%esp
c0027ff9:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027ffd:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0028000:	0f af c5             	imul   %ebp,%eax
c0028003:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028007:	01 d0                	add    %edx,%eax
c0028009:	50                   	push   %eax
c002800a:	89 d8                	mov    %ebx,%eax
c002800c:	0f af c5             	imul   %ebp,%eax
c002800f:	01 d0                	add    %edx,%eax
c0028011:	50                   	push   %eax
c0028012:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028016:	83 c4 10             	add    $0x10,%esp
c0028019:	85 c0                	test   %eax,%eax
        max = left;
c002801b:	0f 4e f3             	cmovle %ebx,%esi
c002801e:	e9 7a ff ff ff       	jmp    c0027f9d <heapify+0x47>

c0028023 <atoi>:
{
c0028023:	56                   	push   %esi
c0028024:	53                   	push   %ebx
c0028025:	83 ec 04             	sub    $0x4,%esp
c0028028:	e8 cb 6e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002802d:	81 c3 fb 30 01 00    	add    $0x130fb,%ebx
c0028033:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c0028037:	85 d2                	test   %edx,%edx
c0028039:	75 29                	jne    c0028064 <atoi+0x41>
c002803b:	83 ec 0c             	sub    $0xc,%esp
c002803e:	8d 83 5b 6a ff ff    	lea    -0x95a5(%ebx),%eax
c0028044:	50                   	push   %eax
c0028045:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002804b:	50                   	push   %eax
c002804c:	8d 83 90 4a ff ff    	lea    -0xb570(%ebx),%eax
c0028052:	50                   	push   %eax
c0028053:	6a 0f                	push   $0xf
c0028055:	8d 83 0c 6a ff ff    	lea    -0x95f4(%ebx),%eax
c002805b:	50                   	push   %eax
c002805c:	e8 79 10 00 00       	call   c00290da <debug_panic>
    s++;
c0028061:	83 c2 01             	add    $0x1,%edx
  while (isspace ((unsigned char) *s))
c0028064:	0f b6 02             	movzbl (%edx),%eax
          || c == '\r' || c == '\t' || c == '\v');
c0028067:	3c 20                	cmp    $0x20,%al
c0028069:	74 f6                	je     c0028061 <atoi+0x3e>
c002806b:	8d 48 f7             	lea    -0x9(%eax),%ecx
c002806e:	80 f9 04             	cmp    $0x4,%cl
c0028071:	76 ee                	jbe    c0028061 <atoi+0x3e>
  if (*s == '+')
c0028073:	3c 2b                	cmp    $0x2b,%al
c0028075:	74 40                	je     c00280b7 <atoi+0x94>
  negative = false;
c0028077:	bb 00 00 00 00       	mov    $0x0,%ebx
  else if (*s == '-')
c002807c:	3c 2d                	cmp    $0x2d,%al
c002807e:	74 41                	je     c00280c1 <atoi+0x9e>
  for (value = 0; isdigit (*s); s++)
c0028080:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0028083:	8d 41 d0             	lea    -0x30(%ecx),%eax
c0028086:	83 f8 09             	cmp    $0x9,%eax
c0028089:	77 40                	ja     c00280cb <atoi+0xa8>
c002808b:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c0028090:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0028093:	01 c0                	add    %eax,%eax
c0028095:	83 e9 30             	sub    $0x30,%ecx
c0028098:	29 c8                	sub    %ecx,%eax
  for (value = 0; isdigit (*s); s++)
c002809a:	83 c2 01             	add    $0x1,%edx
c002809d:	0f be 0a             	movsbl (%edx),%ecx
c00280a0:	8d 71 d0             	lea    -0x30(%ecx),%esi
c00280a3:	83 fe 09             	cmp    $0x9,%esi
c00280a6:	76 e8                	jbe    c0028090 <atoi+0x6d>
    value = -value;
c00280a8:	89 c2                	mov    %eax,%edx
c00280aa:	f7 da                	neg    %edx
c00280ac:	84 db                	test   %bl,%bl
c00280ae:	0f 44 c2             	cmove  %edx,%eax
}
c00280b1:	83 c4 04             	add    $0x4,%esp
c00280b4:	5b                   	pop    %ebx
c00280b5:	5e                   	pop    %esi
c00280b6:	c3                   	ret    
    s++;
c00280b7:	83 c2 01             	add    $0x1,%edx
  negative = false;
c00280ba:	bb 00 00 00 00       	mov    $0x0,%ebx
c00280bf:	eb bf                	jmp    c0028080 <atoi+0x5d>
      s++;
c00280c1:	83 c2 01             	add    $0x1,%edx
      negative = true;
c00280c4:	bb 01 00 00 00       	mov    $0x1,%ebx
c00280c9:	eb b5                	jmp    c0028080 <atoi+0x5d>
  for (value = 0; isdigit (*s); s++)
c00280cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00280d0:	eb d6                	jmp    c00280a8 <atoi+0x85>

c00280d2 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c00280d2:	55                   	push   %ebp
c00280d3:	57                   	push   %edi
c00280d4:	56                   	push   %esi
c00280d5:	53                   	push   %ebx
c00280d6:	83 ec 0c             	sub    $0xc,%esp
c00280d9:	e8 1a 6e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00280de:	81 c3 4a 30 01 00    	add    $0x1304a,%ebx
c00280e4:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00280e8:	8b 74 24 24          	mov    0x24(%esp),%esi
c00280ec:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c00280f0:	85 ff                	test   %edi,%edi
c00280f2:	75 08                	jne    c00280fc <sort+0x2a>
c00280f4:	85 f6                	test   %esi,%esi
c00280f6:	0f 85 89 00 00 00    	jne    c0028185 <sort+0xb3>
  ASSERT (compare != NULL);
c00280fc:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0028101:	0f 84 a7 00 00 00    	je     c00281ae <sort+0xdc>
  ASSERT (size > 0);
c0028107:	85 ed                	test   %ebp,%ebp
c0028109:	0f 84 c8 00 00 00    	je     c00281d7 <sort+0x105>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c002810f:	89 f3                	mov    %esi,%ebx
c0028111:	d1 eb                	shr    %ebx
c0028113:	83 fe 01             	cmp    $0x1,%esi
c0028116:	76 65                	jbe    c002817d <sort+0xab>
c0028118:	89 74 24 24          	mov    %esi,0x24(%esp)
c002811c:	89 fe                	mov    %edi,%esi
c002811e:	8b 7c 24 24          	mov    0x24(%esp),%edi
    heapify (array, i, cnt, size, compare, aux);
c0028122:	83 ec 04             	sub    $0x4,%esp
c0028125:	ff 74 24 34          	pushl  0x34(%esp)
c0028129:	ff 74 24 34          	pushl  0x34(%esp)
c002812d:	55                   	push   %ebp
c002812e:	89 f9                	mov    %edi,%ecx
c0028130:	89 da                	mov    %ebx,%edx
c0028132:	89 f0                	mov    %esi,%eax
c0028134:	e8 1d fe ff ff       	call   c0027f56 <heapify>
  for (i = cnt / 2; i > 0; i--)
c0028139:	83 c4 10             	add    $0x10,%esp
c002813c:	83 eb 01             	sub    $0x1,%ebx
c002813f:	75 e1                	jne    c0028122 <sort+0x50>
c0028141:	89 f3                	mov    %esi,%ebx
c0028143:	89 fe                	mov    %edi,%esi
c0028145:	8b 7c 24 30          	mov    0x30(%esp),%edi

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
    {
      do_swap (array, 1, i, size);
c0028149:	83 ec 0c             	sub    $0xc,%esp
c002814c:	55                   	push   %ebp
c002814d:	89 f1                	mov    %esi,%ecx
c002814f:	ba 01 00 00 00       	mov    $0x1,%edx
c0028154:	89 d8                	mov    %ebx,%eax
c0028156:	e8 bd fd ff ff       	call   c0027f18 <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c002815b:	83 ee 01             	sub    $0x1,%esi
c002815e:	83 c4 0c             	add    $0xc,%esp
c0028161:	57                   	push   %edi
c0028162:	ff 74 24 34          	pushl  0x34(%esp)
c0028166:	55                   	push   %ebp
c0028167:	89 f1                	mov    %esi,%ecx
c0028169:	ba 01 00 00 00       	mov    $0x1,%edx
c002816e:	89 d8                	mov    %ebx,%eax
c0028170:	e8 e1 fd ff ff       	call   c0027f56 <heapify>
  for (i = cnt; i > 1; i--) 
c0028175:	83 c4 10             	add    $0x10,%esp
c0028178:	83 fe 01             	cmp    $0x1,%esi
c002817b:	75 cc                	jne    c0028149 <sort+0x77>
    }
}
c002817d:	83 c4 0c             	add    $0xc,%esp
c0028180:	5b                   	pop    %ebx
c0028181:	5e                   	pop    %esi
c0028182:	5f                   	pop    %edi
c0028183:	5d                   	pop    %ebp
c0028184:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c0028185:	83 ec 0c             	sub    $0xc,%esp
c0028188:	8d 83 1f 6a ff ff    	lea    -0x95e1(%ebx),%eax
c002818e:	50                   	push   %eax
c002818f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0028195:	50                   	push   %eax
c0028196:	8d 83 88 4a ff ff    	lea    -0xb578(%ebx),%eax
c002819c:	50                   	push   %eax
c002819d:	68 8a 00 00 00       	push   $0x8a
c00281a2:	8d 83 0c 6a ff ff    	lea    -0x95f4(%ebx),%eax
c00281a8:	50                   	push   %eax
c00281a9:	e8 2c 0f 00 00       	call   c00290da <debug_panic>
  ASSERT (compare != NULL);
c00281ae:	83 ec 0c             	sub    $0xc,%esp
c00281b1:	8d 83 39 6a ff ff    	lea    -0x95c7(%ebx),%eax
c00281b7:	50                   	push   %eax
c00281b8:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00281be:	50                   	push   %eax
c00281bf:	8d 83 88 4a ff ff    	lea    -0xb578(%ebx),%eax
c00281c5:	50                   	push   %eax
c00281c6:	68 8b 00 00 00       	push   $0x8b
c00281cb:	8d 83 0c 6a ff ff    	lea    -0x95f4(%ebx),%eax
c00281d1:	50                   	push   %eax
c00281d2:	e8 03 0f 00 00       	call   c00290da <debug_panic>
  ASSERT (size > 0);
c00281d7:	83 ec 0c             	sub    $0xc,%esp
c00281da:	8d 83 49 6a ff ff    	lea    -0x95b7(%ebx),%eax
c00281e0:	50                   	push   %eax
c00281e1:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00281e7:	50                   	push   %eax
c00281e8:	8d 83 88 4a ff ff    	lea    -0xb578(%ebx),%eax
c00281ee:	50                   	push   %eax
c00281ef:	68 8c 00 00 00       	push   $0x8c
c00281f4:	8d 83 0c 6a ff ff    	lea    -0x95f4(%ebx),%eax
c00281fa:	50                   	push   %eax
c00281fb:	e8 da 0e 00 00       	call   c00290da <debug_panic>

c0028200 <qsort>:
{
c0028200:	83 ec 18             	sub    $0x18,%esp
c0028203:	e8 f4 6c 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c0028208:	05 20 2f 01 00       	add    $0x12f20,%eax
  sort (array, cnt, size, compare_thunk, &compare);
c002820d:	8d 54 24 28          	lea    0x28(%esp),%edx
c0028211:	52                   	push   %edx
c0028212:	8d 80 db cd fe ff    	lea    -0x13225(%eax),%eax
c0028218:	50                   	push   %eax
c0028219:	ff 74 24 2c          	pushl  0x2c(%esp)
c002821d:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028221:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028225:	e8 a8 fe ff ff       	call   c00280d2 <sort>
}
c002822a:	83 c4 2c             	add    $0x2c,%esp
c002822d:	c3                   	ret    

c002822e <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c002822e:	55                   	push   %ebp
c002822f:	57                   	push   %edi
c0028230:	56                   	push   %esi
c0028231:	53                   	push   %ebx
c0028232:	83 ec 0c             	sub    $0xc,%esp
c0028235:	8b 74 24 24          	mov    0x24(%esp),%esi
c0028239:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c002823d:	89 fd                	mov    %edi,%ebp
c002823f:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c0028244:	01 f5                	add    %esi,%ebp

  while (first < last) 
c0028246:	39 ee                	cmp    %ebp,%esi
c0028248:	72 0d                	jb     c0028257 <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c002824a:	bb 00 00 00 00       	mov    $0x0,%ebx
c002824f:	eb 3c                	jmp    c002828d <binary_search+0x5f>
      const unsigned char *middle = first + (range / 2) * size;
c0028251:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c0028253:	39 ee                	cmp    %ebp,%esi
c0028255:	73 31                	jae    c0028288 <binary_search+0x5a>
      size_t range = (last - first) / size;
c0028257:	89 e8                	mov    %ebp,%eax
c0028259:	29 f0                	sub    %esi,%eax
c002825b:	ba 00 00 00 00       	mov    $0x0,%edx
c0028260:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c0028262:	d1 e8                	shr    %eax
c0028264:	0f af c7             	imul   %edi,%eax
c0028267:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c002826a:	83 ec 04             	sub    $0x4,%esp
c002826d:	ff 74 24 38          	pushl  0x38(%esp)
c0028271:	53                   	push   %ebx
c0028272:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028276:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c002827a:	83 c4 10             	add    $0x10,%esp
c002827d:	85 c0                	test   %eax,%eax
c002827f:	78 d0                	js     c0028251 <binary_search+0x23>
      else if (cmp > 0) 
c0028281:	7e 0a                	jle    c002828d <binary_search+0x5f>
        first = middle + size;
c0028283:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c0028286:	eb cb                	jmp    c0028253 <binary_search+0x25>
  return NULL;
c0028288:	bb 00 00 00 00       	mov    $0x0,%ebx
}
c002828d:	89 d8                	mov    %ebx,%eax
c002828f:	83 c4 0c             	add    $0xc,%esp
c0028292:	5b                   	pop    %ebx
c0028293:	5e                   	pop    %esi
c0028294:	5f                   	pop    %edi
c0028295:	5d                   	pop    %ebp
c0028296:	c3                   	ret    

c0028297 <bsearch>:
{
c0028297:	83 ec 14             	sub    $0x14,%esp
c002829a:	e8 5d 6c 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c002829f:	05 89 2e 01 00       	add    $0x12e89,%eax
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00282a4:	8d 54 24 28          	lea    0x28(%esp),%edx
c00282a8:	52                   	push   %edx
c00282a9:	8d 80 db cd fe ff    	lea    -0x13225(%eax),%eax
c00282af:	50                   	push   %eax
c00282b0:	ff 74 24 2c          	pushl  0x2c(%esp)
c00282b4:	ff 74 24 2c          	pushl  0x2c(%esp)
c00282b8:	ff 74 24 2c          	pushl  0x2c(%esp)
c00282bc:	ff 74 24 2c          	pushl  0x2c(%esp)
c00282c0:	e8 69 ff ff ff       	call   c002822e <binary_search>
}
c00282c5:	83 c4 2c             	add    $0x2c,%esp
c00282c8:	c3                   	ret    

c00282c9 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c00282c9:	56                   	push   %esi
c00282ca:	53                   	push   %ebx
c00282cb:	8b 74 24 0c          	mov    0xc(%esp),%esi
c00282cf:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00282d3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c00282d7:	85 db                	test   %ebx,%ebx
c00282d9:	74 15                	je     c00282f0 <memcpy+0x27>
c00282db:	01 f3                	add    %esi,%ebx
  unsigned char *dst = dst_;
c00282dd:	89 f2                	mov    %esi,%edx
    *dst++ = *src++;
c00282df:	83 c1 01             	add    $0x1,%ecx
c00282e2:	83 c2 01             	add    $0x1,%edx
c00282e5:	0f b6 41 ff          	movzbl -0x1(%ecx),%eax
c00282e9:	88 42 ff             	mov    %al,-0x1(%edx)
  while (size-- > 0)
c00282ec:	39 d3                	cmp    %edx,%ebx
c00282ee:	75 ef                	jne    c00282df <memcpy+0x16>

  return dst_;
}
c00282f0:	89 f0                	mov    %esi,%eax
c00282f2:	5b                   	pop    %ebx
c00282f3:	5e                   	pop    %esi
c00282f4:	c3                   	ret    

c00282f5 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00282f5:	56                   	push   %esi
c00282f6:	53                   	push   %ebx
c00282f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00282fb:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00282ff:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c0028303:	39 c8                	cmp    %ecx,%eax
c0028305:	73 1d                	jae    c0028324 <memmove+0x2f>
    {
      while (size-- > 0)
c0028307:	85 db                	test   %ebx,%ebx
c0028309:	74 16                	je     c0028321 <memmove+0x2c>
c002830b:	8d 14 18             	lea    (%eax,%ebx,1),%edx
        *dst++ = *src++;
c002830e:	83 c1 01             	add    $0x1,%ecx
c0028311:	83 c0 01             	add    $0x1,%eax
c0028314:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
c0028318:	88 58 ff             	mov    %bl,-0x1(%eax)
      while (size-- > 0)
c002831b:	39 d0                	cmp    %edx,%eax
c002831d:	75 ef                	jne    c002830e <memmove+0x19>
        *dst++ = *src++;
c002831f:	89 d0                	mov    %edx,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c0028321:	5b                   	pop    %ebx
c0028322:	5e                   	pop    %esi
c0028323:	c3                   	ret    
      dst += size;
c0028324:	8d 34 18             	lea    (%eax,%ebx,1),%esi
      while (size-- > 0)
c0028327:	8d 53 ff             	lea    -0x1(%ebx),%edx
c002832a:	85 db                	test   %ebx,%ebx
c002832c:	74 11                	je     c002833f <memmove+0x4a>
        *--dst = *--src;
c002832e:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c0028332:	88 1c 10             	mov    %bl,(%eax,%edx,1)
      while (size-- > 0)
c0028335:	83 ea 01             	sub    $0x1,%edx
c0028338:	83 fa ff             	cmp    $0xffffffff,%edx
c002833b:	75 f1                	jne    c002832e <memmove+0x39>
c002833d:	eb e2                	jmp    c0028321 <memmove+0x2c>
      dst += size;
c002833f:	89 f0                	mov    %esi,%eax
c0028341:	eb de                	jmp    c0028321 <memmove+0x2c>

c0028343 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028343:	56                   	push   %esi
c0028344:	53                   	push   %ebx
c0028345:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028349:	8b 54 24 10          	mov    0x10(%esp),%edx
c002834d:	8b 74 24 14          	mov    0x14(%esp),%esi
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0028351:	85 f6                	test   %esi,%esi
c0028353:	74 34                	je     c0028389 <memcmp+0x46>
    if (*a != *b)
c0028355:	0f b6 08             	movzbl (%eax),%ecx
c0028358:	0f b6 1a             	movzbl (%edx),%ebx
c002835b:	01 c6                	add    %eax,%esi
c002835d:	38 d9                	cmp    %bl,%cl
c002835f:	75 14                	jne    c0028375 <memcmp+0x32>
  for (; size-- > 0; a++, b++)
c0028361:	83 c0 01             	add    $0x1,%eax
c0028364:	83 c2 01             	add    $0x1,%edx
c0028367:	39 c6                	cmp    %eax,%esi
c0028369:	74 17                	je     c0028382 <memcmp+0x3f>
    if (*a != *b)
c002836b:	0f b6 08             	movzbl (%eax),%ecx
c002836e:	0f b6 1a             	movzbl (%edx),%ebx
c0028371:	38 d9                	cmp    %bl,%cl
c0028373:	74 ec                	je     c0028361 <memcmp+0x1e>
      return *a > *b ? +1 : -1;
c0028375:	38 cb                	cmp    %cl,%bl
c0028377:	19 c0                	sbb    %eax,%eax
c0028379:	83 e0 02             	and    $0x2,%eax
c002837c:	83 e8 01             	sub    $0x1,%eax
  return 0;
}
c002837f:	5b                   	pop    %ebx
c0028380:	5e                   	pop    %esi
c0028381:	c3                   	ret    
  return 0;
c0028382:	b8 00 00 00 00       	mov    $0x0,%eax
c0028387:	eb f6                	jmp    c002837f <memcmp+0x3c>
c0028389:	b8 00 00 00 00       	mov    $0x0,%eax
c002838e:	eb ef                	jmp    c002837f <memcmp+0x3c>

c0028390 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0028390:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028394:	8b 44 24 08          	mov    0x8(%esp),%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c0028398:	0f b6 11             	movzbl (%ecx),%edx
c002839b:	84 d2                	test   %dl,%dl
c002839d:	74 15                	je     c00283b4 <strcmp+0x24>
c002839f:	3a 10                	cmp    (%eax),%dl
c00283a1:	75 11                	jne    c00283b4 <strcmp+0x24>
    {
      a++;
c00283a3:	83 c1 01             	add    $0x1,%ecx
      b++;
c00283a6:	83 c0 01             	add    $0x1,%eax
  while (*a != '\0' && *a == *b) 
c00283a9:	0f b6 11             	movzbl (%ecx),%edx
c00283ac:	84 d2                	test   %dl,%dl
c00283ae:	74 04                	je     c00283b4 <strcmp+0x24>
c00283b0:	3a 10                	cmp    (%eax),%dl
c00283b2:	74 ef                	je     c00283a3 <strcmp+0x13>
    }

  return *a < *b ? -1 : *a > *b;
c00283b4:	0f b6 08             	movzbl (%eax),%ecx
c00283b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00283bc:	38 d1                	cmp    %dl,%cl
c00283be:	77 06                	ja     c00283c6 <strcmp+0x36>
c00283c0:	0f 92 c0             	setb   %al
c00283c3:	0f b6 c0             	movzbl %al,%eax
}
c00283c6:	c3                   	ret    

c00283c7 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c00283c7:	53                   	push   %ebx
c00283c8:	8b 44 24 08          	mov    0x8(%esp),%eax
c00283cc:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00283d0:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c00283d4:	85 d2                	test   %edx,%edx
c00283d6:	74 1c                	je     c00283f4 <memchr+0x2d>
c00283d8:	89 d9                	mov    %ebx,%ecx
    if (*block == ch)
c00283da:	3a 18                	cmp    (%eax),%bl
c00283dc:	74 14                	je     c00283f2 <memchr+0x2b>
c00283de:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c00283e0:	83 c0 01             	add    $0x1,%eax
c00283e3:	39 c2                	cmp    %eax,%edx
c00283e5:	74 06                	je     c00283ed <memchr+0x26>
    if (*block == ch)
c00283e7:	38 08                	cmp    %cl,(%eax)
c00283e9:	75 f5                	jne    c00283e0 <memchr+0x19>
c00283eb:	eb 05                	jmp    c00283f2 <memchr+0x2b>
      return (void *) block;

  return NULL;
c00283ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00283f2:	5b                   	pop    %ebx
c00283f3:	c3                   	ret    
  return NULL;
c00283f4:	b8 00 00 00 00       	mov    $0x0,%eax
c00283f9:	eb f7                	jmp    c00283f2 <memchr+0x2b>

c00283fb <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c00283fb:	53                   	push   %ebx
c00283fc:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028400:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c0028404:	0f b6 18             	movzbl (%eax),%ebx
c0028407:	38 da                	cmp    %bl,%dl
c0028409:	74 19                	je     c0028424 <strchr+0x29>
c002840b:	89 d1                	mov    %edx,%ecx
      return (char *) string;
    else if (*string == '\0')
c002840d:	84 db                	test   %bl,%bl
c002840f:	74 15                	je     c0028426 <strchr+0x2b>
      return NULL;
    else
      string++;
c0028411:	83 c0 01             	add    $0x1,%eax
    if (*string == c)
c0028414:	0f b6 10             	movzbl (%eax),%edx
c0028417:	38 ca                	cmp    %cl,%dl
c0028419:	74 09                	je     c0028424 <strchr+0x29>
    else if (*string == '\0')
c002841b:	84 d2                	test   %dl,%dl
c002841d:	75 f2                	jne    c0028411 <strchr+0x16>
      return NULL;
c002841f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028424:	5b                   	pop    %ebx
c0028425:	c3                   	ret    
      return NULL;
c0028426:	b8 00 00 00 00       	mov    $0x0,%eax
c002842b:	eb f7                	jmp    c0028424 <strchr+0x29>

c002842d <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c002842d:	57                   	push   %edi
c002842e:	56                   	push   %esi
c002842f:	53                   	push   %ebx
c0028430:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028434:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028438:	0f b6 06             	movzbl (%esi),%eax
c002843b:	84 c0                	test   %al,%al
c002843d:	74 27                	je     c0028466 <strcspn+0x39>
c002843f:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c0028444:	0f be c0             	movsbl %al,%eax
c0028447:	50                   	push   %eax
c0028448:	57                   	push   %edi
c0028449:	e8 ad ff ff ff       	call   c00283fb <strchr>
c002844e:	83 c4 08             	add    $0x8,%esp
c0028451:	85 c0                	test   %eax,%eax
c0028453:	75 0b                	jne    c0028460 <strcspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c0028455:	83 c3 01             	add    $0x1,%ebx
c0028458:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c002845c:	84 c0                	test   %al,%al
c002845e:	75 e4                	jne    c0028444 <strcspn+0x17>
      break;
  return length;
}
c0028460:	89 d8                	mov    %ebx,%eax
c0028462:	5b                   	pop    %ebx
c0028463:	5e                   	pop    %esi
c0028464:	5f                   	pop    %edi
c0028465:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0028466:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c002846b:	eb f3                	jmp    c0028460 <strcspn+0x33>

c002846d <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c002846d:	56                   	push   %esi
c002846e:	53                   	push   %ebx
c002846f:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028473:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c0028477:	0f b6 13             	movzbl (%ebx),%edx
c002847a:	84 d2                	test   %dl,%dl
c002847c:	74 1d                	je     c002849b <strpbrk+0x2e>
    if (strchr (stop, *string) != NULL)
c002847e:	0f be d2             	movsbl %dl,%edx
c0028481:	52                   	push   %edx
c0028482:	56                   	push   %esi
c0028483:	e8 73 ff ff ff       	call   c00283fb <strchr>
c0028488:	83 c4 08             	add    $0x8,%esp
c002848b:	85 c0                	test   %eax,%eax
c002848d:	75 13                	jne    c00284a2 <strpbrk+0x35>
  for (; *string != '\0'; string++)
c002848f:	83 c3 01             	add    $0x1,%ebx
c0028492:	0f b6 13             	movzbl (%ebx),%edx
c0028495:	84 d2                	test   %dl,%dl
c0028497:	75 e5                	jne    c002847e <strpbrk+0x11>
c0028499:	eb 09                	jmp    c00284a4 <strpbrk+0x37>
      return (char *) string;
  return NULL;
c002849b:	b8 00 00 00 00       	mov    $0x0,%eax
c00284a0:	eb 02                	jmp    c00284a4 <strpbrk+0x37>
c00284a2:	89 d8                	mov    %ebx,%eax
}
c00284a4:	5b                   	pop    %ebx
c00284a5:	5e                   	pop    %esi
c00284a6:	c3                   	ret    

c00284a7 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c00284a7:	53                   	push   %ebx
c00284a8:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c00284ac:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
c00284b1:	0f b6 0a             	movzbl (%edx),%ecx
c00284b4:	84 c9                	test   %cl,%cl
c00284b6:	74 16                	je     c00284ce <strrchr+0x27>
  const char *p = NULL;
c00284b8:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
c00284bd:	38 cb                	cmp    %cl,%bl
c00284bf:	0f 44 c2             	cmove  %edx,%eax
  for (; *string != '\0'; string++)
c00284c2:	83 c2 01             	add    $0x1,%edx
c00284c5:	0f b6 0a             	movzbl (%edx),%ecx
c00284c8:	84 c9                	test   %cl,%cl
c00284ca:	75 f1                	jne    c00284bd <strrchr+0x16>
      p = string;
  return (char *) p;
}
c00284cc:	5b                   	pop    %ebx
c00284cd:	c3                   	ret    
  const char *p = NULL;
c00284ce:	b8 00 00 00 00       	mov    $0x0,%eax
  return (char *) p;
c00284d3:	eb f7                	jmp    c00284cc <strrchr+0x25>

c00284d5 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c00284d5:	57                   	push   %edi
c00284d6:	56                   	push   %esi
c00284d7:	53                   	push   %ebx
c00284d8:	8b 74 24 10          	mov    0x10(%esp),%esi
c00284dc:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c00284e0:	0f b6 06             	movzbl (%esi),%eax
c00284e3:	84 c0                	test   %al,%al
c00284e5:	74 27                	je     c002850e <strspn+0x39>
c00284e7:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c00284ec:	0f be c0             	movsbl %al,%eax
c00284ef:	50                   	push   %eax
c00284f0:	57                   	push   %edi
c00284f1:	e8 05 ff ff ff       	call   c00283fb <strchr>
c00284f6:	83 c4 08             	add    $0x8,%esp
c00284f9:	85 c0                	test   %eax,%eax
c00284fb:	74 0b                	je     c0028508 <strspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c00284fd:	83 c3 01             	add    $0x1,%ebx
c0028500:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0028504:	84 c0                	test   %al,%al
c0028506:	75 e4                	jne    c00284ec <strspn+0x17>
      break;
  return length;
}
c0028508:	89 d8                	mov    %ebx,%eax
c002850a:	5b                   	pop    %ebx
c002850b:	5e                   	pop    %esi
c002850c:	5f                   	pop    %edi
c002850d:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c002850e:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0028513:	eb f3                	jmp    c0028508 <strspn+0x33>

c0028515 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028515:	55                   	push   %ebp
c0028516:	57                   	push   %edi
c0028517:	56                   	push   %esi
c0028518:	53                   	push   %ebx
c0028519:	83 ec 1c             	sub    $0x1c,%esp
c002851c:	e8 d7 69 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0028521:	81 c3 07 2c 01 00    	add    $0x12c07,%ebx
c0028527:	8b 74 24 30          	mov    0x30(%esp),%esi
c002852b:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c002852f:	85 ff                	test   %edi,%edi
c0028531:	74 33                	je     c0028566 <strtok_r+0x51>
  ASSERT (save_ptr != NULL);
c0028533:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0028538:	74 55                	je     c002858f <strtok_r+0x7a>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c002853a:	85 f6                	test   %esi,%esi
c002853c:	74 7a                	je     c00285b8 <strtok_r+0xa3>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c002853e:	0f b6 1e             	movzbl (%esi),%ebx
c0028541:	83 ec 08             	sub    $0x8,%esp
c0028544:	0f be c3             	movsbl %bl,%eax
c0028547:	50                   	push   %eax
c0028548:	57                   	push   %edi
c0028549:	e8 ad fe ff ff       	call   c00283fb <strchr>
c002854e:	83 c4 10             	add    $0x10,%esp
c0028551:	85 c0                	test   %eax,%eax
c0028553:	0f 84 a9 00 00 00    	je     c0028602 <strtok_r+0xed>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0028559:	84 db                	test   %bl,%bl
c002855b:	0f 84 8e 00 00 00    	je     c00285ef <strtok_r+0xda>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c0028561:	83 c6 01             	add    $0x1,%esi
c0028564:	eb d8                	jmp    c002853e <strtok_r+0x29>
  ASSERT (delimiters != NULL);
c0028566:	83 ec 0c             	sub    $0xc,%esp
c0028569:	8d 83 52 6a ff ff    	lea    -0x95ae(%ebx),%eax
c002856f:	50                   	push   %eax
c0028570:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0028576:	50                   	push   %eax
c0028577:	8d 83 a8 4a ff ff    	lea    -0xb558(%ebx),%eax
c002857d:	50                   	push   %eax
c002857e:	68 ef 00 00 00       	push   $0xef
c0028583:	8d 83 65 6a ff ff    	lea    -0x959b(%ebx),%eax
c0028589:	50                   	push   %eax
c002858a:	e8 4b 0b 00 00       	call   c00290da <debug_panic>
  ASSERT (save_ptr != NULL);
c002858f:	83 ec 0c             	sub    $0xc,%esp
c0028592:	8d 83 78 6a ff ff    	lea    -0x9588(%ebx),%eax
c0028598:	50                   	push   %eax
c0028599:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002859f:	50                   	push   %eax
c00285a0:	8d 83 a8 4a ff ff    	lea    -0xb558(%ebx),%eax
c00285a6:	50                   	push   %eax
c00285a7:	68 f0 00 00 00       	push   $0xf0
c00285ac:	8d 83 65 6a ff ff    	lea    -0x959b(%ebx),%eax
c00285b2:	50                   	push   %eax
c00285b3:	e8 22 0b 00 00       	call   c00290da <debug_panic>
    s = *save_ptr;
c00285b8:	8b 44 24 38          	mov    0x38(%esp),%eax
c00285bc:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c00285be:	85 f6                	test   %esi,%esi
c00285c0:	0f 85 78 ff ff ff    	jne    c002853e <strtok_r+0x29>
c00285c6:	83 ec 0c             	sub    $0xc,%esp
c00285c9:	8d 83 5b 6a ff ff    	lea    -0x95a5(%ebx),%eax
c00285cf:	50                   	push   %eax
c00285d0:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00285d6:	50                   	push   %eax
c00285d7:	8d 83 a8 4a ff ff    	lea    -0xb558(%ebx),%eax
c00285dd:	50                   	push   %eax
c00285de:	68 f6 00 00 00       	push   $0xf6
c00285e3:	8d 83 65 6a ff ff    	lea    -0x959b(%ebx),%eax
c00285e9:	50                   	push   %eax
c00285ea:	e8 eb 0a 00 00       	call   c00290da <debug_panic>
          *save_ptr = s;
c00285ef:	8b 44 24 38          	mov    0x38(%esp),%eax
c00285f3:	89 30                	mov    %esi,(%eax)
          return NULL;
c00285f5:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c00285fa:	83 c4 1c             	add    $0x1c,%esp
c00285fd:	5b                   	pop    %ebx
c00285fe:	5e                   	pop    %esi
c00285ff:	5f                   	pop    %edi
c0028600:	5d                   	pop    %ebp
c0028601:	c3                   	ret    
c0028602:	89 f3                	mov    %esi,%ebx
c0028604:	eb 02                	jmp    c0028608 <strtok_r+0xf3>
    s++;
c0028606:	89 eb                	mov    %ebp,%ebx
c0028608:	8d 6b 01             	lea    0x1(%ebx),%ebp
  while (strchr (delimiters, *s) == NULL)
c002860b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002860f:	88 44 24 0f          	mov    %al,0xf(%esp)
c0028613:	83 ec 08             	sub    $0x8,%esp
c0028616:	0f be c0             	movsbl %al,%eax
c0028619:	50                   	push   %eax
c002861a:	57                   	push   %edi
c002861b:	e8 db fd ff ff       	call   c00283fb <strchr>
c0028620:	83 c4 10             	add    $0x10,%esp
c0028623:	85 c0                	test   %eax,%eax
c0028625:	74 df                	je     c0028606 <strtok_r+0xf1>
  if (*s != '\0') 
c0028627:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c002862c:	74 11                	je     c002863f <strtok_r+0x12a>
      *s = '\0';
c002862e:	c6 45 00 00          	movb   $0x0,0x0(%ebp)
      *save_ptr = s + 1;
c0028632:	83 c3 02             	add    $0x2,%ebx
c0028635:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028639:	89 18                	mov    %ebx,(%eax)
c002863b:	89 f0                	mov    %esi,%eax
c002863d:	eb bb                	jmp    c00285fa <strtok_r+0xe5>
    *save_ptr = s;
c002863f:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028643:	89 28                	mov    %ebp,(%eax)
c0028645:	89 f0                	mov    %esi,%eax
c0028647:	eb b1                	jmp    c00285fa <strtok_r+0xe5>

c0028649 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028649:	53                   	push   %ebx
c002864a:	8b 44 24 08          	mov    0x8(%esp),%eax
c002864e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028652:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0028656:	85 c9                	test   %ecx,%ecx
c0028658:	74 0e                	je     c0028668 <memset+0x1f>
c002865a:	01 c1                	add    %eax,%ecx
  unsigned char *dst = dst_;
c002865c:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c002865e:	83 c2 01             	add    $0x1,%edx
c0028661:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c0028664:	39 d1                	cmp    %edx,%ecx
c0028666:	75 f6                	jne    c002865e <memset+0x15>

  return dst_;
}
c0028668:	5b                   	pop    %ebx
c0028669:	c3                   	ret    

c002866a <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c002866a:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c002866e:	89 d0                	mov    %edx,%eax
c0028670:	80 3a 00             	cmpb   $0x0,(%edx)
c0028673:	75 03                	jne    c0028678 <strlen+0xe>
    continue;
  return p - string;
c0028675:	29 d0                	sub    %edx,%eax
}
c0028677:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c0028678:	83 c0 01             	add    $0x1,%eax
c002867b:	80 38 00             	cmpb   $0x0,(%eax)
c002867e:	74 f5                	je     c0028675 <strlen+0xb>
c0028680:	eb f6                	jmp    c0028678 <strlen+0xe>

c0028682 <strstr>:
{
c0028682:	55                   	push   %ebp
c0028683:	57                   	push   %edi
c0028684:	56                   	push   %esi
c0028685:	53                   	push   %ebx
c0028686:	83 ec 04             	sub    $0x4,%esp
c0028689:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c002868d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0028692:	b8 00 00 00 00       	mov    $0x0,%eax
c0028697:	89 d9                	mov    %ebx,%ecx
c0028699:	8b 7c 24 18          	mov    0x18(%esp),%edi
c002869d:	f2 ae                	repnz scas %es:(%edi),%al
c002869f:	f7 d1                	not    %ecx
c00286a1:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c00286a4:	89 d9                	mov    %ebx,%ecx
c00286a6:	89 ef                	mov    %ebp,%edi
c00286a8:	f2 ae                	repnz scas %es:(%edi),%al
c00286aa:	89 c8                	mov    %ecx,%eax
c00286ac:	f7 d0                	not    %eax
c00286ae:	8d 70 ff             	lea    -0x1(%eax),%esi
  return NULL;
c00286b1:	bf 00 00 00 00       	mov    $0x0,%edi
  if (haystack_len >= needle_len) 
c00286b6:	39 f2                	cmp    %esi,%edx
c00286b8:	72 2c                	jb     c00286e6 <strstr+0x64>
      for (i = 0; i <= haystack_len - needle_len; i++)
c00286ba:	29 f2                	sub    %esi,%edx
c00286bc:	89 14 24             	mov    %edx,(%esp)
c00286bf:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (!memcmp (haystack + i, needle, needle_len))
c00286c4:	89 df                	mov    %ebx,%edi
c00286c6:	03 7c 24 18          	add    0x18(%esp),%edi
c00286ca:	56                   	push   %esi
c00286cb:	55                   	push   %ebp
c00286cc:	57                   	push   %edi
c00286cd:	e8 71 fc ff ff       	call   c0028343 <memcmp>
c00286d2:	83 c4 0c             	add    $0xc,%esp
c00286d5:	85 c0                	test   %eax,%eax
c00286d7:	74 0d                	je     c00286e6 <strstr+0x64>
      for (i = 0; i <= haystack_len - needle_len; i++)
c00286d9:	83 c3 01             	add    $0x1,%ebx
c00286dc:	3b 1c 24             	cmp    (%esp),%ebx
c00286df:	76 e3                	jbe    c00286c4 <strstr+0x42>
  return NULL;
c00286e1:	bf 00 00 00 00       	mov    $0x0,%edi
}
c00286e6:	89 f8                	mov    %edi,%eax
c00286e8:	83 c4 04             	add    $0x4,%esp
c00286eb:	5b                   	pop    %ebx
c00286ec:	5e                   	pop    %esi
c00286ed:	5f                   	pop    %edi
c00286ee:	5d                   	pop    %ebp
c00286ef:	c3                   	ret    

c00286f0 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00286f0:	8b 54 24 04          	mov    0x4(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00286f4:	80 3a 00             	cmpb   $0x0,(%edx)
c00286f7:	74 07                	je     c0028700 <strnlen+0x10>
c00286f9:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c00286fe:	75 06                	jne    c0028706 <strnlen+0x16>
c0028700:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
c0028705:	c3                   	ret    
  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028706:	b8 00 00 00 00       	mov    $0x0,%eax
c002870b:	83 c0 01             	add    $0x1,%eax
c002870e:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c0028712:	74 f1                	je     c0028705 <strnlen+0x15>
c0028714:	39 44 24 08          	cmp    %eax,0x8(%esp)
c0028718:	76 eb                	jbe    c0028705 <strnlen+0x15>
c002871a:	eb ef                	jmp    c002870b <strnlen+0x1b>

c002871c <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c002871c:	55                   	push   %ebp
c002871d:	57                   	push   %edi
c002871e:	56                   	push   %esi
c002871f:	53                   	push   %ebx
c0028720:	83 ec 0c             	sub    $0xc,%esp
c0028723:	e8 d0 67 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0028728:	81 c3 00 2a 01 00    	add    $0x12a00,%ebx
c002872e:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0028732:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c0028736:	85 ed                	test   %ebp,%ebp
c0028738:	74 49                	je     c0028783 <strlcpy+0x67>
  ASSERT (src != NULL);
c002873a:	85 d2                	test   %edx,%edx
c002873c:	74 6e                	je     c00287ac <strlcpy+0x90>

  src_len = strlen (src);
c002873e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028743:	b8 00 00 00 00       	mov    $0x0,%eax
c0028748:	89 d7                	mov    %edx,%edi
c002874a:	f2 ae                	repnz scas %es:(%edi),%al
c002874c:	89 ce                	mov    %ecx,%esi
c002874e:	f7 d6                	not    %esi
c0028750:	8d 76 ff             	lea    -0x1(%esi),%esi
  if (size > 0) 
c0028753:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0028758:	74 1f                	je     c0028779 <strlcpy+0x5d>
    {
      size_t dst_len = size - 1;
c002875a:	8b 44 24 28          	mov    0x28(%esp),%eax
c002875e:	8d 78 ff             	lea    -0x1(%eax),%edi
      if (src_len < dst_len)
c0028761:	39 fe                	cmp    %edi,%esi
c0028763:	0f 46 fe             	cmovbe %esi,%edi
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c0028766:	83 ec 04             	sub    $0x4,%esp
c0028769:	57                   	push   %edi
c002876a:	52                   	push   %edx
c002876b:	55                   	push   %ebp
c002876c:	e8 58 fb ff ff       	call   c00282c9 <memcpy>
      dst[dst_len] = '\0';
c0028771:	c6 44 3d 00 00       	movb   $0x0,0x0(%ebp,%edi,1)
c0028776:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
c0028779:	89 f0                	mov    %esi,%eax
c002877b:	83 c4 0c             	add    $0xc,%esp
c002877e:	5b                   	pop    %ebx
c002877f:	5e                   	pop    %esi
c0028780:	5f                   	pop    %edi
c0028781:	5d                   	pop    %ebp
c0028782:	c3                   	ret    
  ASSERT (dst != NULL);
c0028783:	83 ec 0c             	sub    $0xc,%esp
c0028786:	8d 83 89 6a ff ff    	lea    -0x9577(%ebx),%eax
c002878c:	50                   	push   %eax
c002878d:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0028793:	50                   	push   %eax
c0028794:	8d 83 a0 4a ff ff    	lea    -0xb560(%ebx),%eax
c002879a:	50                   	push   %eax
c002879b:	68 4a 01 00 00       	push   $0x14a
c00287a0:	8d 83 65 6a ff ff    	lea    -0x959b(%ebx),%eax
c00287a6:	50                   	push   %eax
c00287a7:	e8 2e 09 00 00       	call   c00290da <debug_panic>
  ASSERT (src != NULL);
c00287ac:	83 ec 0c             	sub    $0xc,%esp
c00287af:	8d 83 95 6a ff ff    	lea    -0x956b(%ebx),%eax
c00287b5:	50                   	push   %eax
c00287b6:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00287bc:	50                   	push   %eax
c00287bd:	8d 83 a0 4a ff ff    	lea    -0xb560(%ebx),%eax
c00287c3:	50                   	push   %eax
c00287c4:	68 4b 01 00 00       	push   $0x14b
c00287c9:	8d 83 65 6a ff ff    	lea    -0x959b(%ebx),%eax
c00287cf:	50                   	push   %eax
c00287d0:	e8 05 09 00 00       	call   c00290da <debug_panic>

c00287d5 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c00287d5:	55                   	push   %ebp
c00287d6:	57                   	push   %edi
c00287d7:	56                   	push   %esi
c00287d8:	53                   	push   %ebx
c00287d9:	83 ec 1c             	sub    $0x1c,%esp
c00287dc:	e8 17 67 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00287e1:	81 c3 47 29 01 00    	add    $0x12947,%ebx
c00287e7:	8b 54 24 34          	mov    0x34(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c00287eb:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c00287f0:	74 75                	je     c0028867 <strlcat+0x92>
  ASSERT (src != NULL);
c00287f2:	85 d2                	test   %edx,%edx
c00287f4:	0f 84 96 00 00 00    	je     c0028890 <strlcat+0xbb>

  src_len = strlen (src);
c00287fa:	be ff ff ff ff       	mov    $0xffffffff,%esi
c00287ff:	b8 00 00 00 00       	mov    $0x0,%eax
c0028804:	89 f1                	mov    %esi,%ecx
c0028806:	89 d7                	mov    %edx,%edi
c0028808:	f2 ae                	repnz scas %es:(%edi),%al
c002880a:	f7 d1                	not    %ecx
c002880c:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
c002880f:	89 f1                	mov    %esi,%ecx
c0028811:	8b 7c 24 30          	mov    0x30(%esp),%edi
c0028815:	f2 ae                	repnz scas %es:(%edi),%al
c0028817:	89 ce                	mov    %ecx,%esi
c0028819:	f7 d6                	not    %esi
c002881b:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size) 
c002881e:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0028823:	74 36                	je     c002885b <strlcat+0x86>
c0028825:	3b 74 24 38          	cmp    0x38(%esp),%esi
c0028829:	73 30                	jae    c002885b <strlcat+0x86>
    {
      size_t copy_cnt = size - dst_len - 1;
c002882b:	8b 44 24 38          	mov    0x38(%esp),%eax
c002882f:	83 e8 01             	sub    $0x1,%eax
c0028832:	29 f0                	sub    %esi,%eax
      if (src_len < copy_cnt)
c0028834:	39 c5                	cmp    %eax,%ebp
c0028836:	0f 46 c5             	cmovbe %ebp,%eax
c0028839:	89 c7                	mov    %eax,%edi
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c002883b:	89 f0                	mov    %esi,%eax
c002883d:	03 44 24 30          	add    0x30(%esp),%eax
c0028841:	83 ec 04             	sub    $0x4,%esp
c0028844:	57                   	push   %edi
c0028845:	52                   	push   %edx
c0028846:	89 44 24 18          	mov    %eax,0x18(%esp)
c002884a:	50                   	push   %eax
c002884b:	e8 79 fa ff ff       	call   c00282c9 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
c0028850:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0028854:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
c0028858:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
c002885b:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
}
c002885f:	83 c4 1c             	add    $0x1c,%esp
c0028862:	5b                   	pop    %ebx
c0028863:	5e                   	pop    %esi
c0028864:	5f                   	pop    %edi
c0028865:	5d                   	pop    %ebp
c0028866:	c3                   	ret    
  ASSERT (dst != NULL);
c0028867:	83 ec 0c             	sub    $0xc,%esp
c002886a:	8d 83 89 6a ff ff    	lea    -0x9577(%ebx),%eax
c0028870:	50                   	push   %eax
c0028871:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0028877:	50                   	push   %eax
c0028878:	8d 83 98 4a ff ff    	lea    -0xb568(%ebx),%eax
c002887e:	50                   	push   %eax
c002887f:	68 68 01 00 00       	push   $0x168
c0028884:	8d 83 65 6a ff ff    	lea    -0x959b(%ebx),%eax
c002888a:	50                   	push   %eax
c002888b:	e8 4a 08 00 00       	call   c00290da <debug_panic>
  ASSERT (src != NULL);
c0028890:	83 ec 0c             	sub    $0xc,%esp
c0028893:	8d 83 95 6a ff ff    	lea    -0x956b(%ebx),%eax
c0028899:	50                   	push   %eax
c002889a:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00288a0:	50                   	push   %eax
c00288a1:	8d 83 98 4a ff ff    	lea    -0xb568(%ebx),%eax
c00288a7:	50                   	push   %eax
c00288a8:	68 69 01 00 00       	push   $0x169
c00288ad:	8d 83 65 6a ff ff    	lea    -0x959b(%ebx),%eax
c00288b3:	50                   	push   %eax
c00288b4:	e8 21 08 00 00       	call   c00290da <debug_panic>

c00288b9 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c00288b9:	55                   	push   %ebp
c00288ba:	57                   	push   %edi
c00288bb:	56                   	push   %esi
c00288bc:	53                   	push   %ebx
c00288bd:	83 ec 1c             	sub    $0x1c,%esp
c00288c0:	89 44 24 08          	mov    %eax,0x8(%esp)
c00288c4:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00288c8:	8b 44 24 30          	mov    0x30(%esp),%eax
c00288cc:	8b 54 24 34          	mov    0x34(%esp),%edx
c00288d0:	89 04 24             	mov    %eax,(%esp)
c00288d3:	89 54 24 04          	mov    %edx,0x4(%esp)
  if ((d >> 32) == 0) 
c00288d7:	85 d2                	test   %edx,%edx
c00288d9:	0f 84 08 01 00 00    	je     c00289e7 <udiv64+0x12e>
c00288df:	89 d0                	mov    %edx,%eax
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c00288e1:	8b 7c 24 08          	mov    0x8(%esp),%edi
c00288e5:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00288e9:	8b 1c 24             	mov    (%esp),%ebx
c00288ec:	8b 74 24 04          	mov    0x4(%esp),%esi
c00288f0:	39 df                	cmp    %ebx,%edi
c00288f2:	89 ef                	mov    %ebp,%edi
c00288f4:	19 f7                	sbb    %esi,%edi
        return 0;
c00288f6:	b9 00 00 00 00       	mov    $0x0,%ecx
c00288fb:	bb 00 00 00 00       	mov    $0x0,%ebx
      if (n < d)
c0028900:	0f 82 33 01 00 00    	jb     c0028a39 <udiv64+0x180>
  if (x <= 0x0000FFFF)
c0028906:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
c002890c:	77 0a                	ja     c0028918 <udiv64+0x5f>
      x <<= 16; 
c002890e:	c1 e0 10             	shl    $0x10,%eax
c0028911:	89 c2                	mov    %eax,%edx
      n += 16;
c0028913:	b9 10 00 00 00       	mov    $0x10,%ecx
  if (x <= 0x00FFFFFF)
c0028918:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
c002891e:	77 06                	ja     c0028926 <udiv64+0x6d>
      n += 8;
c0028920:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c0028923:	c1 e2 08             	shl    $0x8,%edx
  if (x <= 0x0FFFFFFF)
c0028926:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c002892c:	77 06                	ja     c0028934 <udiv64+0x7b>
      n += 4;
c002892e:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c0028931:	c1 e2 04             	shl    $0x4,%edx
  if (x <= 0x3FFFFFFF)
c0028934:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
c002893a:	77 06                	ja     c0028942 <udiv64+0x89>
      n += 2;
c002893c:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c002893f:	c1 e2 02             	shl    $0x2,%edx
    n++;
c0028942:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
c0028948:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c002894b:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002894f:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c0028953:	89 ea                	mov    %ebp,%edx
c0028955:	d1 ea                	shr    %edx
c0028957:	89 d3                	mov    %edx,%ebx
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028959:	89 f8                	mov    %edi,%eax
c002895b:	89 ea                	mov    %ebp,%edx
c002895d:	0f ac e8 01          	shrd   $0x1,%ebp,%eax
c0028961:	d1 ea                	shr    %edx
c0028963:	89 44 24 10          	mov    %eax,0x10(%esp)
c0028967:	89 54 24 14          	mov    %edx,0x14(%esp)
c002896b:	8b 34 24             	mov    (%esp),%esi
c002896e:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0028972:	0f a5 f7             	shld   %cl,%esi,%edi
c0028975:	d3 e6                	shl    %cl,%esi
c0028977:	f6 c1 20             	test   $0x20,%cl
c002897a:	74 02                	je     c002897e <udiv64+0xc5>
c002897c:	89 f7                	mov    %esi,%edi
  asm ("divl %4"
c002897e:	89 da                	mov    %ebx,%edx
c0028980:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028984:	f7 f7                	div    %edi
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028986:	ba 1f 00 00 00       	mov    $0x1f,%edx
c002898b:	29 ca                	sub    %ecx,%edx
c002898d:	89 d1                	mov    %edx,%ecx
c002898f:	d3 e8                	shr    %cl,%eax
c0028991:	89 c1                	mov    %eax,%ecx
c0028993:	bb 00 00 00 00       	mov    $0x0,%ebx
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028998:	89 44 24 10          	mov    %eax,0x10(%esp)
c002899c:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c00289a0:	83 c1 ff             	add    $0xffffffff,%ecx
c00289a3:	83 d3 ff             	adc    $0xffffffff,%ebx
c00289a6:	89 dd                	mov    %ebx,%ebp
c00289a8:	8b 34 24             	mov    (%esp),%esi
c00289ab:	8b 7c 24 04          	mov    0x4(%esp),%edi
c00289af:	0f af ee             	imul   %esi,%ebp
c00289b2:	89 f8                	mov    %edi,%eax
c00289b4:	0f af c1             	imul   %ecx,%eax
c00289b7:	01 c5                	add    %eax,%ebp
c00289b9:	89 c8                	mov    %ecx,%eax
c00289bb:	f7 24 24             	mull   (%esp)
c00289be:	01 ea                	add    %ebp,%edx
c00289c0:	8b 7c 24 08          	mov    0x8(%esp),%edi
c00289c4:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00289c8:	29 c7                	sub    %eax,%edi
c00289ca:	19 d5                	sbb    %edx,%ebp
c00289cc:	89 f8                	mov    %edi,%eax
c00289ce:	8b 34 24             	mov    (%esp),%esi
c00289d1:	8b 7c 24 04          	mov    0x4(%esp),%edi
c00289d5:	39 f0                	cmp    %esi,%eax
c00289d7:	89 e8                	mov    %ebp,%eax
c00289d9:	19 f8                	sbb    %edi,%eax
c00289db:	72 5c                	jb     c0028a39 <udiv64+0x180>
c00289dd:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00289e1:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c00289e5:	eb 52                	jmp    c0028a39 <udiv64+0x180>
      uint32_t n1 = n >> 32;
c00289e7:	8b 7c 24 08          	mov    0x8(%esp),%edi
c00289eb:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
c00289ef:	89 e8                	mov    %ebp,%eax
      uint32_t d0 = d;
c00289f1:	8b 0c 24             	mov    (%esp),%ecx
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c00289f4:	ba 00 00 00 00       	mov    $0x0,%edx
c00289f9:	f7 f1                	div    %ecx
c00289fb:	89 c1                	mov    %eax,%ecx
c00289fd:	89 d3                	mov    %edx,%ebx
c00289ff:	89 da                	mov    %ebx,%edx
c0028a01:	b8 00 00 00 00       	mov    $0x0,%eax
c0028a06:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0028a0a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028a11:	00 
c0028a12:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0028a16:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0028a1a:	01 c3                	add    %eax,%ebx
c0028a1c:	11 d6                	adc    %edx,%esi
  asm ("divl %4"
c0028a1e:	89 f2                	mov    %esi,%edx
c0028a20:	89 d8                	mov    %ebx,%eax
c0028a22:	f7 34 24             	divl   (%esp)
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028a25:	89 cd                	mov    %ecx,%ebp
c0028a27:	bf 00 00 00 00       	mov    $0x0,%edi
c0028a2c:	89 f9                	mov    %edi,%ecx
c0028a2e:	89 eb                	mov    %ebp,%ebx
c0028a30:	ba 00 00 00 00       	mov    $0x0,%edx
c0028a35:	01 c1                	add    %eax,%ecx
c0028a37:	11 d3                	adc    %edx,%ebx
        }
    }
}
c0028a39:	89 c8                	mov    %ecx,%eax
c0028a3b:	89 da                	mov    %ebx,%edx
c0028a3d:	83 c4 1c             	add    $0x1c,%esp
c0028a40:	5b                   	pop    %ebx
c0028a41:	5e                   	pop    %esi
c0028a42:	5f                   	pop    %edi
c0028a43:	5d                   	pop    %ebp
c0028a44:	c3                   	ret    

c0028a45 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0028a45:	57                   	push   %edi
c0028a46:	56                   	push   %esi
c0028a47:	53                   	push   %ebx
c0028a48:	83 ec 08             	sub    $0x8,%esp
c0028a4b:	89 04 24             	mov    %eax,(%esp)
c0028a4e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0028a52:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028a56:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028a5a:	85 d2                	test   %edx,%edx
c0028a5c:	78 2b                	js     c0028a89 <sdiv64+0x44>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028a5e:	89 f1                	mov    %esi,%ecx
c0028a60:	89 fb                	mov    %edi,%ebx
c0028a62:	85 ff                	test   %edi,%edi
c0028a64:	78 2c                	js     c0028a92 <sdiv64+0x4d>
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028a66:	53                   	push   %ebx
c0028a67:	51                   	push   %ecx
c0028a68:	e8 4c fe ff ff       	call   c00288b9 <udiv64>
c0028a6d:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028a70:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028a74:	f7 d1                	not    %ecx
c0028a76:	c1 e9 1f             	shr    $0x1f,%ecx
c0028a79:	89 fb                	mov    %edi,%ebx
c0028a7b:	c1 eb 1f             	shr    $0x1f,%ebx
c0028a7e:	38 d9                	cmp    %bl,%cl
c0028a80:	74 19                	je     c0028a9b <sdiv64+0x56>
}
c0028a82:	83 c4 08             	add    $0x8,%esp
c0028a85:	5b                   	pop    %ebx
c0028a86:	5e                   	pop    %esi
c0028a87:	5f                   	pop    %edi
c0028a88:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028a89:	f7 d8                	neg    %eax
c0028a8b:	83 d2 00             	adc    $0x0,%edx
c0028a8e:	f7 da                	neg    %edx
c0028a90:	eb cc                	jmp    c0028a5e <sdiv64+0x19>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028a92:	f7 d9                	neg    %ecx
c0028a94:	83 d3 00             	adc    $0x0,%ebx
c0028a97:	f7 db                	neg    %ebx
c0028a99:	eb cb                	jmp    c0028a66 <sdiv64+0x21>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028a9b:	f7 d8                	neg    %eax
c0028a9d:	83 d2 00             	adc    $0x0,%edx
c0028aa0:	f7 da                	neg    %edx
c0028aa2:	eb de                	jmp    c0028a82 <sdiv64+0x3d>

c0028aa4 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028aa4:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c0028aa7:	ff 74 24 14          	pushl  0x14(%esp)
c0028aab:	ff 74 24 14          	pushl  0x14(%esp)
c0028aaf:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028ab3:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028ab7:	e8 89 ff ff ff       	call   c0028a45 <sdiv64>
}
c0028abc:	83 c4 0c             	add    $0xc,%esp
c0028abf:	c3                   	ret    

c0028ac0 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0028ac0:	57                   	push   %edi
c0028ac1:	56                   	push   %esi
c0028ac2:	53                   	push   %ebx
c0028ac3:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028ac7:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028acb:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c0028acf:	57                   	push   %edi
c0028ad0:	56                   	push   %esi
c0028ad1:	89 d8                	mov    %ebx,%eax
c0028ad3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028ad7:	e8 69 ff ff ff       	call   c0028a45 <sdiv64>
c0028adc:	83 c4 08             	add    $0x8,%esp
c0028adf:	0f af c6             	imul   %esi,%eax
c0028ae2:	29 c3                	sub    %eax,%ebx
  return smod64 (n, d);
c0028ae4:	89 d8                	mov    %ebx,%eax
c0028ae6:	99                   	cltd   
}
c0028ae7:	5b                   	pop    %ebx
c0028ae8:	5e                   	pop    %esi
c0028ae9:	5f                   	pop    %edi
c0028aea:	c3                   	ret    

c0028aeb <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0028aeb:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c0028aee:	ff 74 24 14          	pushl  0x14(%esp)
c0028af2:	ff 74 24 14          	pushl  0x14(%esp)
c0028af6:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028afa:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028afe:	e8 b6 fd ff ff       	call   c00288b9 <udiv64>
}
c0028b03:	83 c4 0c             	add    $0xc,%esp
c0028b06:	c3                   	ret    

c0028b07 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0028b07:	57                   	push   %edi
c0028b08:	56                   	push   %esi
c0028b09:	53                   	push   %ebx
c0028b0a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028b0e:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028b12:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c0028b16:	57                   	push   %edi
c0028b17:	56                   	push   %esi
c0028b18:	89 d8                	mov    %ebx,%eax
c0028b1a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028b1e:	e8 96 fd ff ff       	call   c00288b9 <udiv64>
c0028b23:	83 c4 08             	add    $0x8,%esp
c0028b26:	0f af c6             	imul   %esi,%eax
c0028b29:	29 c3                	sub    %eax,%ebx
  return umod64 (n, d);
c0028b2b:	89 d8                	mov    %ebx,%eax
c0028b2d:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0028b32:	5b                   	pop    %ebx
c0028b33:	5e                   	pop    %esi
c0028b34:	5f                   	pop    %edi
c0028b35:	c3                   	ret    

c0028b36 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0028b36:	55                   	push   %ebp
c0028b37:	57                   	push   %edi
c0028b38:	56                   	push   %esi
c0028b39:	53                   	push   %ebx
c0028b3a:	83 ec 04             	sub    $0x4,%esp
c0028b3d:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
c0028b40:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0028b46:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ofs = 0; ofs < size; ofs++)
c0028b4b:	85 d2                	test   %edx,%edx
c0028b4d:	74 4d                	je     c0028b9c <parse_octal_field+0x66>
      char c = s[ofs];
c0028b4f:	8b 04 24             	mov    (%esp),%eax
c0028b52:	0f b6 18             	movzbl (%eax),%ebx
      if (c >= '0' && c <= '7')
c0028b55:	8d 6b d0             	lea    -0x30(%ebx),%ebp
  for (ofs = 0; ofs < size; ofs++)
c0028b58:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
c0028b5d:	bf 00 00 00 00       	mov    $0x0,%edi
      if (c >= '0' && c <= '7')
c0028b62:	89 e8                	mov    %ebp,%eax
c0028b64:	3c 07                	cmp    $0x7,%al
c0028b66:	77 3c                	ja     c0028ba4 <parse_octal_field+0x6e>
          *value = c - '0' + *value * 8;
c0028b68:	0f be db             	movsbl %bl,%ebx
c0028b6b:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0028b6f:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0028b71:	83 c6 01             	add    $0x1,%esi
c0028b74:	39 f2                	cmp    %esi,%edx
c0028b76:	74 1f                	je     c0028b97 <parse_octal_field+0x61>
      char c = s[ofs];
c0028b78:	8b 04 24             	mov    (%esp),%eax
c0028b7b:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
      if (c >= '0' && c <= '7')
c0028b7f:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c0028b82:	89 e8                	mov    %ebp,%eax
c0028b84:	3c 07                	cmp    $0x7,%al
c0028b86:	77 1c                	ja     c0028ba4 <parse_octal_field+0x6e>
          if (*value > ULONG_MAX / 8)
c0028b88:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0028b8e:	76 d8                	jbe    c0028b68 <parse_octal_field+0x32>
              return false;
c0028b90:	b8 00 00 00 00       	mov    $0x0,%eax
c0028b95:	eb 05                	jmp    c0028b9c <parse_octal_field+0x66>
  return false;
c0028b97:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028b9c:	83 c4 04             	add    $0x4,%esp
c0028b9f:	5b                   	pop    %ebx
c0028ba0:	5e                   	pop    %esi
c0028ba1:	5f                   	pop    %edi
c0028ba2:	5d                   	pop    %ebp
c0028ba3:	c3                   	ret    
          return false;
c0028ba4:	b8 00 00 00 00       	mov    $0x0,%eax
      else if (c == ' ' || c == '\0')
c0028ba9:	f6 c3 df             	test   $0xdf,%bl
c0028bac:	75 ee                	jne    c0028b9c <parse_octal_field+0x66>
          return ofs > 0;
c0028bae:	85 f6                	test   %esi,%esi
c0028bb0:	0f 95 c0             	setne  %al
c0028bb3:	eb e7                	jmp    c0028b9c <parse_octal_field+0x66>

c0028bb5 <strip_antisocial_prefixes>:
{
c0028bb5:	55                   	push   %ebp
c0028bb6:	57                   	push   %edi
c0028bb7:	56                   	push   %esi
c0028bb8:	53                   	push   %ebx
c0028bb9:	83 ec 1c             	sub    $0x1c,%esp
c0028bbc:	e8 37 63 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0028bc1:	81 c3 67 25 01 00    	add    $0x12567,%ebx
c0028bc7:	89 c5                	mov    %eax,%ebp
         || !memcmp (file_name, "./", 2)
c0028bc9:	8d bb d8 5e ff ff    	lea    -0xa128(%ebx),%edi
         || !memcmp (file_name, "../", 3))
c0028bcf:	8d 83 a1 6a ff ff    	lea    -0x955f(%ebx),%eax
c0028bd5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (*file_name == '/'
c0028bd9:	eb 11                	jmp    c0028bec <strip_antisocial_prefixes+0x37>
    file_name = strchr (file_name, '/') + 1;
c0028bdb:	83 ec 08             	sub    $0x8,%esp
c0028bde:	6a 2f                	push   $0x2f
c0028be0:	55                   	push   %ebp
c0028be1:	e8 15 f8 ff ff       	call   c00283fb <strchr>
c0028be6:	83 c4 10             	add    $0x10,%esp
c0028be9:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c0028bec:	0f b6 75 00          	movzbl 0x0(%ebp),%esi
c0028bf0:	89 f0                	mov    %esi,%eax
c0028bf2:	3c 2f                	cmp    $0x2f,%al
c0028bf4:	74 e5                	je     c0028bdb <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "./", 2)
c0028bf6:	83 ec 04             	sub    $0x4,%esp
c0028bf9:	6a 02                	push   $0x2
c0028bfb:	57                   	push   %edi
c0028bfc:	55                   	push   %ebp
c0028bfd:	e8 41 f7 ff ff       	call   c0028343 <memcmp>
c0028c02:	83 c4 10             	add    $0x10,%esp
c0028c05:	85 c0                	test   %eax,%eax
c0028c07:	74 d2                	je     c0028bdb <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "../", 3))
c0028c09:	83 ec 04             	sub    $0x4,%esp
c0028c0c:	6a 03                	push   $0x3
c0028c0e:	ff 74 24 14          	pushl  0x14(%esp)
c0028c12:	55                   	push   %ebp
c0028c13:	e8 2b f7 ff ff       	call   c0028343 <memcmp>
c0028c18:	83 c4 10             	add    $0x10,%esp
c0028c1b:	85 c0                	test   %eax,%eax
c0028c1d:	74 bc                	je     c0028bdb <strip_antisocial_prefixes+0x26>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0028c1f:	8d 83 57 64 ff ff    	lea    -0x9ba9(%ebx),%eax
c0028c25:	89 f2                	mov    %esi,%edx
c0028c27:	84 d2                	test   %dl,%dl
c0028c29:	74 22                	je     c0028c4d <strip_antisocial_prefixes+0x98>
c0028c2b:	b9 03 00 00 00       	mov    $0x3,%ecx
c0028c30:	8d bb 56 64 ff ff    	lea    -0x9baa(%ebx),%edi
c0028c36:	89 ee                	mov    %ebp,%esi
c0028c38:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0028c3a:	0f 97 c0             	seta   %al
c0028c3d:	1c 00                	sbb    $0x0,%al
c0028c3f:	0f be c0             	movsbl %al,%eax
c0028c42:	85 c0                	test   %eax,%eax
c0028c44:	8d 83 57 64 ff ff    	lea    -0x9ba9(%ebx),%eax
c0028c4a:	0f 45 c5             	cmovne %ebp,%eax
}
c0028c4d:	83 c4 1c             	add    $0x1c,%esp
c0028c50:	5b                   	pop    %ebx
c0028c51:	5e                   	pop    %esi
c0028c52:	5f                   	pop    %edi
c0028c53:	5d                   	pop    %ebp
c0028c54:	c3                   	ret    

c0028c55 <ustar_make_header>:
{
c0028c55:	55                   	push   %ebp
c0028c56:	57                   	push   %edi
c0028c57:	56                   	push   %esi
c0028c58:	53                   	push   %ebx
c0028c59:	83 ec 1c             	sub    $0x1c,%esp
c0028c5c:	e8 97 62 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0028c61:	81 c3 c7 24 01 00    	add    $0x124c7,%ebx
c0028c67:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028c6b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028c6f:	83 fd 30             	cmp    $0x30,%ebp
c0028c72:	0f 94 c2             	sete   %dl
c0028c75:	83 fd 35             	cmp    $0x35,%ebp
c0028c78:	0f 94 c0             	sete   %al
c0028c7b:	08 c2                	or     %al,%dl
c0028c7d:	88 54 24 0f          	mov    %dl,0xf(%esp)
c0028c81:	0f 84 77 01 00 00    	je     c0028dfe <ustar_make_header+0x1a9>
  file_name = strip_antisocial_prefixes (file_name);
c0028c87:	8b 44 24 30          	mov    0x30(%esp),%eax
c0028c8b:	e8 25 ff ff ff       	call   c0028bb5 <strip_antisocial_prefixes>
c0028c90:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0028c92:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028c97:	b8 00 00 00 00       	mov    $0x0,%eax
c0028c9c:	89 d7                	mov    %edx,%edi
c0028c9e:	f2 ae                	repnz scas %es:(%edi),%al
c0028ca0:	f7 d1                	not    %ecx
c0028ca2:	83 e9 01             	sub    $0x1,%ecx
c0028ca5:	83 f9 63             	cmp    $0x63,%ecx
c0028ca8:	0f 87 76 01 00 00    	ja     c0028e24 <ustar_make_header+0x1cf>
  memset (h, 0, sizeof *h);
c0028cae:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0028cb4:	c7 86 fc 01 00 00 00 	movl   $0x0,0x1fc(%esi)
c0028cbb:	00 00 00 
c0028cbe:	8d 7e 04             	lea    0x4(%esi),%edi
c0028cc1:	83 e7 fc             	and    $0xfffffffc,%edi
c0028cc4:	89 f1                	mov    %esi,%ecx
c0028cc6:	29 f9                	sub    %edi,%ecx
c0028cc8:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0028cce:	c1 e9 02             	shr    $0x2,%ecx
c0028cd1:	b8 00 00 00 00       	mov    $0x0,%eax
c0028cd6:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028cd8:	83 ec 04             	sub    $0x4,%esp
c0028cdb:	6a 64                	push   $0x64
c0028cdd:	52                   	push   %edx
c0028cde:	56                   	push   %esi
c0028cdf:	e8 38 fa ff ff       	call   c002871c <strlcpy>
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028ce4:	83 c4 10             	add    $0x10,%esp
c0028ce7:	83 fd 30             	cmp    $0x30,%ebp
c0028cea:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0028cef:	ba ed 01 00 00       	mov    $0x1ed,%edx
c0028cf4:	0f 45 c2             	cmovne %edx,%eax
c0028cf7:	50                   	push   %eax
c0028cf8:	8d 83 cf 6a ff ff    	lea    -0x9531(%ebx),%eax
c0028cfe:	50                   	push   %eax
c0028cff:	6a 08                	push   $0x8
c0028d01:	8d 46 64             	lea    0x64(%esi),%eax
c0028d04:	50                   	push   %eax
c0028d05:	e8 05 ef ff ff       	call   c0027c0f <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0028d0a:	83 c4 0c             	add    $0xc,%esp
c0028d0d:	6a 08                	push   $0x8
c0028d0f:	8d bb d4 6a ff ff    	lea    -0x952c(%ebx),%edi
c0028d15:	57                   	push   %edi
c0028d16:	8d 46 6c             	lea    0x6c(%esi),%eax
c0028d19:	50                   	push   %eax
c0028d1a:	e8 fd f9 ff ff       	call   c002871c <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0028d1f:	83 c4 0c             	add    $0xc,%esp
c0028d22:	6a 08                	push   $0x8
c0028d24:	57                   	push   %edi
c0028d25:	8d 46 74             	lea    0x74(%esi),%eax
c0028d28:	50                   	push   %eax
c0028d29:	e8 ee f9 ff ff       	call   c002871c <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c0028d2e:	ff 74 24 48          	pushl  0x48(%esp)
c0028d32:	8d bb dc 6a ff ff    	lea    -0x9524(%ebx),%edi
c0028d38:	57                   	push   %edi
c0028d39:	6a 0c                	push   $0xc
c0028d3b:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028d3e:	50                   	push   %eax
c0028d3f:	e8 cb ee ff ff       	call   c0027c0f <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0028d44:	83 c4 20             	add    $0x20,%esp
c0028d47:	68 00 8c b7 43       	push   $0x43b78c00
c0028d4c:	57                   	push   %edi
c0028d4d:	6a 0c                	push   $0xc
c0028d4f:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0028d55:	50                   	push   %eax
c0028d56:	e8 b4 ee ff ff       	call   c0027c0f <snprintf>
  h->typeflag = type;
c0028d5b:	89 e8                	mov    %ebp,%eax
c0028d5d:	88 86 9c 00 00 00    	mov    %al,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0028d63:	83 c4 0c             	add    $0xc,%esp
c0028d66:	6a 06                	push   $0x6
c0028d68:	8d 83 e2 6a ff ff    	lea    -0x951e(%ebx),%eax
c0028d6e:	50                   	push   %eax
c0028d6f:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028d75:	50                   	push   %eax
c0028d76:	e8 a1 f9 ff ff       	call   c002871c <strlcpy>
  h->version[0] = h->version[1] = '0';
c0028d7b:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0028d82:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c0028d89:	83 c4 0c             	add    $0xc,%esp
c0028d8c:	6a 20                	push   $0x20
c0028d8e:	8d bb 88 60 ff ff    	lea    -0x9f78(%ebx),%edi
c0028d94:	57                   	push   %edi
c0028d95:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c0028d9b:	50                   	push   %eax
c0028d9c:	e8 7b f9 ff ff       	call   c002871c <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0028da1:	83 c4 0c             	add    $0xc,%esp
c0028da4:	6a 20                	push   $0x20
c0028da6:	57                   	push   %edi
c0028da7:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0028dad:	50                   	push   %eax
c0028dae:	e8 69 f9 ff ff       	call   c002871c <strlcpy>
c0028db3:	83 c4 10             	add    $0x10,%esp
c0028db6:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028dbb:	ba 00 00 00 00       	mov    $0x0,%edx
      chksum += in_chksum_field ? ' ' : header[i];
c0028dc0:	bf 20 00 00 00       	mov    $0x20,%edi
c0028dc5:	83 f8 07             	cmp    $0x7,%eax
c0028dc8:	77 74                	ja     c0028e3e <ustar_make_header+0x1e9>
c0028dca:	89 f9                	mov    %edi,%ecx
c0028dcc:	01 ca                	add    %ecx,%edx
c0028dce:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028dd1:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028dd6:	75 ed                	jne    c0028dc5 <ustar_make_header+0x170>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0028dd8:	52                   	push   %edx
c0028dd9:	8d 83 cf 6a ff ff    	lea    -0x9531(%ebx),%eax
c0028ddf:	50                   	push   %eax
c0028de0:	6a 08                	push   $0x8
c0028de2:	81 c6 94 00 00 00    	add    $0x94,%esi
c0028de8:	56                   	push   %esi
c0028de9:	e8 21 ee ff ff       	call   c0027c0f <snprintf>
  return true;
c0028dee:	83 c4 10             	add    $0x10,%esp
}
c0028df1:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c0028df6:	83 c4 1c             	add    $0x1c,%esp
c0028df9:	5b                   	pop    %ebx
c0028dfa:	5e                   	pop    %esi
c0028dfb:	5f                   	pop    %edi
c0028dfc:	5d                   	pop    %ebp
c0028dfd:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028dfe:	83 ec 0c             	sub    $0xc,%esp
c0028e01:	8d 83 8c 6b ff ff    	lea    -0x9474(%ebx),%eax
c0028e07:	50                   	push   %eax
c0028e08:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0028e0e:	50                   	push   %eax
c0028e0f:	8d 83 b4 4a ff ff    	lea    -0xb54c(%ebx),%eax
c0028e15:	50                   	push   %eax
c0028e16:	6a 59                	push   $0x59
c0028e18:	8d 83 a5 6a ff ff    	lea    -0x955b(%ebx),%eax
c0028e1e:	50                   	push   %eax
c0028e1f:	e8 b6 02 00 00       	call   c00290da <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028e24:	83 ec 08             	sub    $0x8,%esp
c0028e27:	52                   	push   %edx
c0028e28:	8d 83 b7 6a ff ff    	lea    -0x9549(%ebx),%eax
c0028e2e:	50                   	push   %eax
c0028e2f:	e8 4a e6 ff ff       	call   c002747e <printf>
      return false;
c0028e34:	83 c4 10             	add    $0x10,%esp
c0028e37:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
c0028e3c:	eb b3                	jmp    c0028df1 <ustar_make_header+0x19c>
      chksum += in_chksum_field ? ' ' : header[i];
c0028e3e:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c0028e45:	00 
c0028e46:	eb 84                	jmp    c0028dcc <ustar_make_header+0x177>

c0028e48 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0028e48:	57                   	push   %edi
c0028e49:	56                   	push   %esi
c0028e4a:	53                   	push   %ebx
c0028e4b:	83 ec 10             	sub    $0x10,%esp
c0028e4e:	e8 a5 60 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0028e53:	81 c3 d5 22 01 00    	add    $0x122d5,%ebx
c0028e59:	8b 74 24 20          	mov    0x20(%esp),%esi
  while (cnt-- > 0)
c0028e5d:	8d 96 00 02 00 00    	lea    0x200(%esi),%edx
{
c0028e63:	89 f0                	mov    %esi,%eax
    if (*block++ != 0)
c0028e65:	83 c0 01             	add    $0x1,%eax
c0028e68:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c0028e6c:	0f 85 28 01 00 00    	jne    c0028f9a <ustar_parse_header+0x152>
  while (cnt-- > 0)
c0028e72:	39 c2                	cmp    %eax,%edx
c0028e74:	75 ef                	jne    c0028e65 <ustar_parse_header+0x1d>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c0028e76:	8b 44 24 24          	mov    0x24(%esp),%eax
c0028e7a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0028e80:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028e84:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0028e8a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0028e8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0028e94:	ba 00 00 00 00       	mov    $0x0,%edx
c0028e99:	e9 3d 01 00 00       	jmp    c0028fdb <ustar_parse_header+0x193>
  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028e9e:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c0028ea2:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c0028ea8:	ba 08 00 00 00       	mov    $0x8,%edx
c0028ead:	e8 84 fc ff ff       	call   c0028b36 <parse_octal_field>
    return "corrupt chksum field";
c0028eb2:	8d 93 62 6b ff ff    	lea    -0x949e(%ebx),%edx
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028eb8:	84 c0                	test   %al,%al
c0028eba:	0f 84 1b 01 00 00    	je     c0028fdb <ustar_parse_header+0x193>
c0028ec0:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028ec5:	b9 00 00 00 00       	mov    $0x0,%ecx
      chksum += in_chksum_field ? ' ' : header[i];
c0028eca:	bf 20 00 00 00       	mov    $0x20,%edi
c0028ecf:	83 f8 07             	cmp    $0x7,%eax
c0028ed2:	0f 87 8b 00 00 00    	ja     c0028f63 <ustar_parse_header+0x11b>
c0028ed8:	89 fa                	mov    %edi,%edx
c0028eda:	01 d1                	add    %edx,%ecx
c0028edc:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028edf:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028ee4:	75 e9                	jne    c0028ecf <ustar_parse_header+0x87>
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
c0028ee6:	8d 93 25 6b ff ff    	lea    -0x94db(%ebx),%edx
  else if (chksum != calculate_chksum (h))
c0028eec:	39 4c 24 0c          	cmp    %ecx,0xc(%esp)
c0028ef0:	0f 85 e5 00 00 00    	jne    c0028fdb <ustar_parse_header+0x193>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
    return "file name too long";
c0028ef6:	8d 93 37 6b ff ff    	lea    -0x94c9(%ebx),%edx
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0028efc:	80 7e 63 00          	cmpb   $0x0,0x63(%esi)
c0028f00:	0f 85 d5 00 00 00    	jne    c0028fdb <ustar_parse_header+0x193>
c0028f06:	80 be 59 01 00 00 00 	cmpb   $0x0,0x159(%esi)
c0028f0d:	0f 85 c8 00 00 00    	jne    c0028fdb <ustar_parse_header+0x193>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028f13:	0f b6 86 9c 00 00 00 	movzbl 0x9c(%esi),%eax
c0028f1a:	3c 30                	cmp    $0x30,%al
c0028f1c:	74 0e                	je     c0028f2c <ustar_parse_header+0xe4>
    return "unimplemented file type";
c0028f1e:	8d 93 4a 6b ff ff    	lea    -0x94b6(%ebx),%edx
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028f24:	3c 35                	cmp    $0x35,%al
c0028f26:	0f 85 af 00 00 00    	jne    c0028fdb <ustar_parse_header+0x193>
  if (h->typeflag == USTAR_REGULAR)
c0028f2c:	3c 30                	cmp    $0x30,%al
c0028f2e:	74 40                	je     c0028f70 <ustar_parse_header+0x128>
        return "corrupt file size field";
      else if (size_ul > INT_MAX)
        return "file too large";
    }
  else
    size_ul = 0;
c0028f30:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0028f37:	00 

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0028f38:	89 f0                	mov    %esi,%eax
c0028f3a:	e8 76 fc ff ff       	call   c0028bb5 <strip_antisocial_prefixes>
c0028f3f:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028f43:	89 07                	mov    %eax,(%edi)
  *type = h->typeflag;
c0028f45:	0f be 86 9c 00 00 00 	movsbl 0x9c(%esi),%eax
c0028f4c:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0028f50:	89 07                	mov    %eax,(%edi)
  *size = size_ul;
c0028f52:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028f56:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0028f5a:	89 07                	mov    %eax,(%edi)
  return NULL;
c0028f5c:	ba 00 00 00 00       	mov    $0x0,%edx
c0028f61:	eb 78                	jmp    c0028fdb <ustar_parse_header+0x193>
      chksum += in_chksum_field ? ' ' : header[i];
c0028f63:	0f b6 94 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%edx
c0028f6a:	00 
c0028f6b:	e9 6a ff ff ff       	jmp    c0028eda <ustar_parse_header+0x92>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028f70:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0028f74:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028f77:	ba 0c 00 00 00       	mov    $0xc,%edx
c0028f7c:	e8 b5 fb ff ff       	call   c0028b36 <parse_octal_field>
        return "corrupt file size field";
c0028f81:	8d 93 e8 6a ff ff    	lea    -0x9518(%ebx),%edx
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028f87:	84 c0                	test   %al,%al
c0028f89:	74 50                	je     c0028fdb <ustar_parse_header+0x193>
        return "file too large";
c0028f8b:	8d 93 00 6b ff ff    	lea    -0x9500(%ebx),%edx
      else if (size_ul > INT_MAX)
c0028f91:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028f96:	79 a0                	jns    c0028f38 <ustar_parse_header+0xf0>
c0028f98:	eb 41                	jmp    c0028fdb <ustar_parse_header+0x193>
  if (memcmp (h->magic, "ustar", 6))
c0028f9a:	83 ec 04             	sub    $0x4,%esp
c0028f9d:	6a 06                	push   $0x6
c0028f9f:	8d 83 e2 6a ff ff    	lea    -0x951e(%ebx),%eax
c0028fa5:	50                   	push   %eax
c0028fa6:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028fac:	50                   	push   %eax
c0028fad:	e8 91 f3 ff ff       	call   c0028343 <memcmp>
c0028fb2:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
c0028fb5:	8d 93 77 6b ff ff    	lea    -0x9489(%ebx),%edx
  if (memcmp (h->magic, "ustar", 6))
c0028fbb:	85 c0                	test   %eax,%eax
c0028fbd:	75 1c                	jne    c0028fdb <ustar_parse_header+0x193>
    return "invalid ustar version";
c0028fbf:	8d 93 0f 6b ff ff    	lea    -0x94f1(%ebx),%edx
  else if (h->version[0] != '0' || h->version[1] != '0')
c0028fc5:	80 be 07 01 00 00 30 	cmpb   $0x30,0x107(%esi)
c0028fcc:	75 0d                	jne    c0028fdb <ustar_parse_header+0x193>
c0028fce:	80 be 08 01 00 00 30 	cmpb   $0x30,0x108(%esi)
c0028fd5:	0f 84 c3 fe ff ff    	je     c0028e9e <ustar_parse_header+0x56>
}
c0028fdb:	89 d0                	mov    %edx,%eax
c0028fdd:	83 c4 10             	add    $0x10,%esp
c0028fe0:	5b                   	pop    %ebx
c0028fe1:	5e                   	pop    %esi
c0028fe2:	5f                   	pop    %edi
c0028fe3:	c3                   	ret    

c0028fe4 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0028fe4:	55                   	push   %ebp
c0028fe5:	89 e5                	mov    %esp,%ebp
c0028fe7:	57                   	push   %edi
c0028fe8:	56                   	push   %esi
c0028fe9:	53                   	push   %ebx
c0028fea:	83 ec 0c             	sub    $0xc,%esp
c0028fed:	e8 06 5f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0028ff2:	81 c3 36 21 01 00    	add    $0x12136,%ebx
c0028ff8:	8b 75 08             	mov    0x8(%ebp),%esi
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0028ffb:	8b 56 04             	mov    0x4(%esi),%edx
    case THREAD_RUNNING:  
      status = "RUNNING";
      break;

    case THREAD_READY:  
      status = "READY";
c0028ffe:	8d 83 c5 6b ff ff    	lea    -0x943b(%ebx),%eax
  switch (t->status) {
c0029004:	83 fa 01             	cmp    $0x1,%edx
c0029007:	74 1c                	je     c0029025 <print_stacktrace+0x41>
      status = "RUNNING";
c0029009:	8d 83 0d 57 ff ff    	lea    -0xa8f3(%ebx),%eax
  switch (t->status) {
c002900f:	85 d2                	test   %edx,%edx
c0029011:	74 12                	je     c0029025 <print_stacktrace+0x41>
  const char *status = "UNKNOWN";
c0029013:	83 fa 02             	cmp    $0x2,%edx
c0029016:	8d 83 c7 56 ff ff    	lea    -0xa939(%ebx),%eax
c002901c:	8d 93 bd 6b ff ff    	lea    -0x9443(%ebx),%edx
c0029022:	0f 45 c2             	cmovne %edx,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029025:	83 ec 04             	sub    $0x4,%esp
c0029028:	50                   	push   %eax
c0029029:	8d 46 08             	lea    0x8(%esi),%eax
c002902c:	50                   	push   %eax
c002902d:	8d 83 e8 6b ff ff    	lea    -0x9418(%ebx),%eax
c0029033:	50                   	push   %eax
c0029034:	e8 45 e4 ff ff       	call   c002747e <printf>

  if (t == thread_current()) 
c0029039:	e8 38 7f ff ff       	call   c0020f76 <thread_current>
c002903e:	83 c4 10             	add    $0x10,%esp
c0029041:	39 f0                	cmp    %esi,%eax
c0029043:	74 79                	je     c00290be <print_stacktrace+0xda>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0029045:	8b 56 18             	mov    0x18(%esi),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0029048:	81 c6 00 10 00 00    	add    $0x1000,%esi
c002904e:	39 f2                	cmp    %esi,%edx
c0029050:	74 74                	je     c00290c6 <print_stacktrace+0xe2>
c0029052:	8b 42 10             	mov    0x10(%edx),%eax
c0029055:	81 f8 59 1b 02 c0    	cmp    $0xc0021b59,%eax
c002905b:	74 69                	je     c00290c6 <print_stacktrace+0xe2>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c002905d:	8b 72 08             	mov    0x8(%edx),%esi
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c0029060:	83 ec 08             	sub    $0x8,%esp
c0029063:	50                   	push   %eax
c0029064:	8d 83 ba 68 ff ff    	lea    -0x9746(%ebx),%eax
c002906a:	50                   	push   %eax
c002906b:	e8 0e e4 ff ff       	call   c002747e <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029070:	83 c4 10             	add    $0x10,%esp
c0029073:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0029079:	76 29                	jbe    c00290a4 <print_stacktrace+0xc0>
c002907b:	83 3e 00             	cmpl   $0x0,(%esi)
c002907e:	74 24                	je     c00290a4 <print_stacktrace+0xc0>
    printf (" %p", frame[1]);
c0029080:	8d bb ba 68 ff ff    	lea    -0x9746(%ebx),%edi
c0029086:	83 ec 08             	sub    $0x8,%esp
c0029089:	ff 76 04             	pushl  0x4(%esi)
c002908c:	57                   	push   %edi
c002908d:	e8 ec e3 ff ff       	call   c002747e <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029092:	8b 36                	mov    (%esi),%esi
c0029094:	83 c4 10             	add    $0x10,%esp
c0029097:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c002909d:	76 05                	jbe    c00290a4 <print_stacktrace+0xc0>
c002909f:	83 3e 00             	cmpl   $0x0,(%esi)
c00290a2:	75 e2                	jne    c0029086 <print_stacktrace+0xa2>
  printf (".\n");
c00290a4:	83 ec 0c             	sub    $0xc,%esp
c00290a7:	8d 83 57 64 ff ff    	lea    -0x9ba9(%ebx),%eax
c00290ad:	50                   	push   %eax
c00290ae:	e8 fd 1f 00 00       	call   c002b0b0 <puts>
c00290b3:	83 c4 10             	add    $0x10,%esp
}
c00290b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00290b9:	5b                   	pop    %ebx
c00290ba:	5e                   	pop    %esi
c00290bb:	5f                   	pop    %edi
c00290bc:	5d                   	pop    %ebp
c00290bd:	c3                   	ret    
      frame = __builtin_frame_address (1);
c00290be:	8b 75 00             	mov    0x0(%ebp),%esi
      retaddr = __builtin_return_address (0);
c00290c1:	8b 45 04             	mov    0x4(%ebp),%eax
c00290c4:	eb 9a                	jmp    c0029060 <print_stacktrace+0x7c>
          printf (" thread was never scheduled.\n");
c00290c6:	83 ec 0c             	sub    $0xc,%esp
c00290c9:	8d 83 cb 6b ff ff    	lea    -0x9435(%ebx),%eax
c00290cf:	50                   	push   %eax
c00290d0:	e8 db 1f 00 00       	call   c002b0b0 <puts>
          return;
c00290d5:	83 c4 10             	add    $0x10,%esp
c00290d8:	eb dc                	jmp    c00290b6 <print_stacktrace+0xd2>

c00290da <debug_panic>:
{
c00290da:	55                   	push   %ebp
c00290db:	57                   	push   %edi
c00290dc:	56                   	push   %esi
c00290dd:	53                   	push   %ebx
c00290de:	83 ec 0c             	sub    $0xc,%esp
c00290e1:	e8 12 5e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00290e6:	81 c3 42 20 01 00    	add    $0x12042,%ebx
c00290ec:	8b 74 24 20          	mov    0x20(%esp),%esi
c00290f0:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00290f4:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  intr_disable ();
c00290f8:	e8 12 8c ff ff       	call   c0021d0f <intr_disable>
  console_panic ();
c00290fd:	e8 2d 1f 00 00       	call   c002b02f <console_panic>
  level++;
c0029102:	8b 83 38 1c 00 00    	mov    0x1c38(%ebx),%eax
c0029108:	83 c0 01             	add    $0x1,%eax
c002910b:	89 83 38 1c 00 00    	mov    %eax,0x1c38(%ebx)
  if (level == 1) 
c0029111:	83 f8 01             	cmp    $0x1,%eax
c0029114:	74 11                	je     c0029127 <debug_panic+0x4d>
  else if (level == 2)
c0029116:	83 f8 02             	cmp    $0x2,%eax
c0029119:	74 42                	je     c002915d <debug_panic+0x83>
  serial_flush ();
c002911b:	e8 87 be ff ff       	call   c0024fa7 <serial_flush>
  shutdown ();
c0029120:	e8 e8 db ff ff       	call   c0026d0d <shutdown>
  for (;;);
c0029125:	eb fe                	jmp    c0029125 <debug_panic+0x4b>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0029127:	55                   	push   %ebp
c0029128:	57                   	push   %edi
c0029129:	56                   	push   %esi
c002912a:	8d 83 10 6c ff ff    	lea    -0x93f0(%ebx),%eax
c0029130:	50                   	push   %eax
c0029131:	e8 48 e3 ff ff       	call   c002747e <printf>
      va_start (args, message);
c0029136:	8d 44 24 40          	lea    0x40(%esp),%eax
      vprintf (message, args);
c002913a:	83 c4 08             	add    $0x8,%esp
c002913d:	50                   	push   %eax
c002913e:	ff 74 24 38          	pushl  0x38(%esp)
c0029142:	e8 26 1f 00 00       	call   c002b06d <vprintf>
      printf ("\n");
c0029147:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c002914e:	e8 cf 1f 00 00       	call   c002b122 <putchar>
      debug_backtrace ();
c0029153:	e8 9c dc ff ff       	call   c0026df4 <debug_backtrace>
c0029158:	83 c4 10             	add    $0x10,%esp
c002915b:	eb be                	jmp    c002911b <debug_panic+0x41>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c002915d:	55                   	push   %ebp
c002915e:	57                   	push   %edi
c002915f:	56                   	push   %esi
c0029160:	8d 83 30 6c ff ff    	lea    -0x93d0(%ebx),%eax
c0029166:	50                   	push   %eax
c0029167:	e8 12 e3 ff ff       	call   c002747e <printf>
c002916c:	83 c4 10             	add    $0x10,%esp
c002916f:	eb aa                	jmp    c002911b <debug_panic+0x41>

c0029171 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0029171:	56                   	push   %esi
c0029172:	53                   	push   %ebx
c0029173:	83 ec 04             	sub    $0x4,%esp
c0029176:	e8 7d 5d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002917b:	81 c3 ad 1f 01 00    	add    $0x11fad,%ebx
  enum intr_level oldlevel = intr_disable ();
c0029181:	e8 89 8b ff ff       	call   c0021d0f <intr_disable>
c0029186:	89 c6                	mov    %eax,%esi

  thread_foreach (print_stacktrace, 0);
c0029188:	83 ec 08             	sub    $0x8,%esp
c002918b:	6a 00                	push   $0x0
c002918d:	8d 83 bc de fe ff    	lea    -0x12144(%ebx),%eax
c0029193:	50                   	push   %eax
c0029194:	e8 ee 7e ff ff       	call   c0021087 <thread_foreach>
  intr_set_level (oldlevel);
c0029199:	89 34 24             	mov    %esi,(%esp)
c002919c:	e8 75 8b ff ff       	call   c0021d16 <intr_set_level>
}
c00291a1:	83 c4 14             	add    $0x14,%esp
c00291a4:	5b                   	pop    %ebx
c00291a5:	5e                   	pop    %esi
c00291a6:	c3                   	ret    

c00291a7 <list_init>:
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
}

/* Initializes LIST as an empty list. */
void
list_init(struct list *list) {
c00291a7:	53                   	push   %ebx
c00291a8:	83 ec 08             	sub    $0x8,%esp
c00291ab:	e8 48 5d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00291b0:	81 c3 78 1f 01 00    	add    $0x11f78,%ebx
c00291b6:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c00291ba:	85 c0                	test   %eax,%eax
c00291bc:	74 1b                	je     c00291d9 <list_init+0x32>
    list->head.prev = NULL;
c00291be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list->head.next = &list->tail;
c00291c4:	8d 50 08             	lea    0x8(%eax),%edx
c00291c7:	89 50 04             	mov    %edx,0x4(%eax)
    list->tail.prev = &list->head;
c00291ca:	89 40 08             	mov    %eax,0x8(%eax)
    list->tail.next = NULL;
c00291cd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c00291d4:	83 c4 08             	add    $0x8,%esp
c00291d7:	5b                   	pop    %ebx
c00291d8:	c3                   	ret    
    ASSERT (list != NULL);
c00291d9:	83 ec 0c             	sub    $0xc,%esp
c00291dc:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c00291e2:	50                   	push   %eax
c00291e3:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00291e9:	50                   	push   %eax
c00291ea:	8d 83 b0 4b ff ff    	lea    -0xb450(%ebx),%eax
c00291f0:	50                   	push   %eax
c00291f1:	6a 3b                	push   $0x3b
c00291f3:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c00291f9:	50                   	push   %eax
c00291fa:	e8 db fe ff ff       	call   c00290da <debug_panic>

c00291ff <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin(struct list *list) {
c00291ff:	53                   	push   %ebx
c0029200:	83 ec 08             	sub    $0x8,%esp
c0029203:	e8 f0 5c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029208:	81 c3 20 1f 01 00    	add    $0x11f20,%ebx
c002920e:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029212:	85 c0                	test   %eax,%eax
c0029214:	74 08                	je     c002921e <list_begin+0x1f>
    return list->head.next;
c0029216:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029219:	83 c4 08             	add    $0x8,%esp
c002921c:	5b                   	pop    %ebx
c002921d:	c3                   	ret    
    ASSERT (list != NULL);
c002921e:	83 ec 0c             	sub    $0xc,%esp
c0029221:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c0029227:	50                   	push   %eax
c0029228:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002922e:	50                   	push   %eax
c002922f:	8d 83 a4 4b ff ff    	lea    -0xb45c(%ebx),%eax
c0029235:	50                   	push   %eax
c0029236:	6a 45                	push   $0x45
c0029238:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c002923e:	50                   	push   %eax
c002923f:	e8 96 fe ff ff       	call   c00290da <debug_panic>

c0029244 <list_next>:

/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next(struct list_elem *elem) {
c0029244:	53                   	push   %ebx
c0029245:	83 ec 08             	sub    $0x8,%esp
c0029248:	e8 ab 5c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002924d:	81 c3 db 1e 01 00    	add    $0x11edb,%ebx
c0029253:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029257:	85 c0                	test   %eax,%eax
c0029259:	74 20                	je     c002927b <list_next+0x37>
c002925b:	83 38 00             	cmpl   $0x0,(%eax)
c002925e:	74 13                	je     c0029273 <list_next+0x2f>
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029260:	83 38 00             	cmpl   $0x0,(%eax)
c0029263:	74 16                	je     c002927b <list_next+0x37>
c0029265:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029269:	74 10                	je     c002927b <list_next+0x37>
    ASSERT (is_head(elem) || is_interior(elem));
    return elem->next;
c002926b:	8b 40 04             	mov    0x4(%eax),%eax
}
c002926e:	83 c4 08             	add    $0x8,%esp
c0029271:	5b                   	pop    %ebx
c0029272:	c3                   	ret    
    return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029273:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029277:	75 f2                	jne    c002926b <list_next+0x27>
c0029279:	eb e5                	jmp    c0029260 <list_next+0x1c>
    ASSERT (is_head(elem) || is_interior(elem));
c002927b:	83 ec 0c             	sub    $0xc,%esp
c002927e:	8d 83 18 6d ff ff    	lea    -0x92e8(%ebx),%eax
c0029284:	50                   	push   %eax
c0029285:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002928b:	50                   	push   %eax
c002928c:	8d 83 98 4b ff ff    	lea    -0xb468(%ebx),%eax
c0029292:	50                   	push   %eax
c0029293:	6a 4e                	push   $0x4e
c0029295:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c002929b:	50                   	push   %eax
c002929c:	e8 39 fe ff ff       	call   c00290da <debug_panic>

c00292a1 <list_end>:

   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end(struct list *list) {
c00292a1:	53                   	push   %ebx
c00292a2:	83 ec 08             	sub    $0x8,%esp
c00292a5:	e8 4e 5c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00292aa:	81 c3 7e 1e 01 00    	add    $0x11e7e,%ebx
c00292b0:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c00292b4:	85 c0                	test   %eax,%eax
c00292b6:	74 08                	je     c00292c0 <list_end+0x1f>
    return &list->tail;
c00292b8:	83 c0 08             	add    $0x8,%eax
}
c00292bb:	83 c4 08             	add    $0x8,%esp
c00292be:	5b                   	pop    %ebx
c00292bf:	c3                   	ret    
    ASSERT (list != NULL);
c00292c0:	83 ec 0c             	sub    $0xc,%esp
c00292c3:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c00292c9:	50                   	push   %eax
c00292ca:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00292d0:	50                   	push   %eax
c00292d1:	8d 83 8c 4b ff ff    	lea    -0xb474(%ebx),%eax
c00292d7:	50                   	push   %eax
c00292d8:	6a 59                	push   $0x59
c00292da:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c00292e0:	50                   	push   %eax
c00292e1:	e8 f4 fd ff ff       	call   c00290da <debug_panic>

c00292e6 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin(struct list *list) {
c00292e6:	53                   	push   %ebx
c00292e7:	83 ec 08             	sub    $0x8,%esp
c00292ea:	e8 09 5c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00292ef:	81 c3 39 1e 01 00    	add    $0x11e39,%ebx
c00292f5:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c00292f9:	85 c0                	test   %eax,%eax
c00292fb:	74 08                	je     c0029305 <list_rbegin+0x1f>
    return list->tail.prev;
c00292fd:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029300:	83 c4 08             	add    $0x8,%esp
c0029303:	5b                   	pop    %ebx
c0029304:	c3                   	ret    
    ASSERT (list != NULL);
c0029305:	83 ec 0c             	sub    $0xc,%esp
c0029308:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c002930e:	50                   	push   %eax
c002930f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029315:	50                   	push   %eax
c0029316:	8d 83 80 4b ff ff    	lea    -0xb480(%ebx),%eax
c002931c:	50                   	push   %eax
c002931d:	6a 61                	push   $0x61
c002931f:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029325:	50                   	push   %eax
c0029326:	e8 af fd ff ff       	call   c00290da <debug_panic>

c002932b <list_prev>:

/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev(struct list_elem *elem) {
c002932b:	53                   	push   %ebx
c002932c:	83 ec 08             	sub    $0x8,%esp
c002932f:	e8 c4 5b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029334:	81 c3 f4 1d 01 00    	add    $0x11df4,%ebx
c002933a:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002933e:	85 c0                	test   %eax,%eax
c0029340:	74 1d                	je     c002935f <list_prev+0x34>
c0029342:	83 38 00             	cmpl   $0x0,(%eax)
c0029345:	74 0d                	je     c0029354 <list_prev+0x29>
c0029347:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002934b:	74 07                	je     c0029354 <list_prev+0x29>
    ASSERT (is_interior(elem) || is_tail(elem));
    return elem->prev;
c002934d:	8b 00                	mov    (%eax),%eax
}
c002934f:	83 c4 08             	add    $0x8,%esp
c0029352:	5b                   	pop    %ebx
c0029353:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029354:	83 38 00             	cmpl   $0x0,(%eax)
c0029357:	74 06                	je     c002935f <list_prev+0x34>
c0029359:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002935d:	74 ee                	je     c002934d <list_prev+0x22>
    ASSERT (is_interior(elem) || is_tail(elem));
c002935f:	83 ec 0c             	sub    $0xc,%esp
c0029362:	8d 83 3c 6d ff ff    	lea    -0x92c4(%ebx),%eax
c0029368:	50                   	push   %eax
c0029369:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002936f:	50                   	push   %eax
c0029370:	8d 83 74 4b ff ff    	lea    -0xb48c(%ebx),%eax
c0029376:	50                   	push   %eax
c0029377:	6a 6a                	push   $0x6a
c0029379:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c002937f:	50                   	push   %eax
c0029380:	e8 55 fd ff ff       	call   c00290da <debug_panic>

c0029385 <find_end_of_run>:
   given auxiliary data AUX.  Returns the (exclusive) end of the
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run(struct list_elem *a, struct list_elem *b,
                list_less_func *less, void *aux) {
c0029385:	55                   	push   %ebp
c0029386:	57                   	push   %edi
c0029387:	56                   	push   %esi
c0029388:	53                   	push   %ebx
c0029389:	83 ec 1c             	sub    $0x1c,%esp
c002938c:	e8 73 5b 00 00       	call   c002ef04 <__x86.get_pc_thunk.di>
c0029391:	81 c7 97 1d 01 00    	add    $0x11d97,%edi
c0029397:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c002939b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    ASSERT (a != NULL);
c002939f:	85 c0                	test   %eax,%eax
c00293a1:	74 4e                	je     c00293f1 <find_end_of_run+0x6c>
c00293a3:	89 c3                	mov    %eax,%ebx
c00293a5:	89 d6                	mov    %edx,%esi
c00293a7:	89 cf                	mov    %ecx,%edi
    ASSERT (b != NULL);
c00293a9:	85 d2                	test   %edx,%edx
c00293ab:	74 71                	je     c002941e <find_end_of_run+0x99>
    ASSERT (less != NULL);
c00293ad:	85 c9                	test   %ecx,%ecx
c00293af:	0f 84 96 00 00 00    	je     c002944b <find_end_of_run+0xc6>
    ASSERT (a != b);
c00293b5:	39 d0                	cmp    %edx,%eax
c00293b7:	0f 84 bb 00 00 00    	je     c0029478 <find_end_of_run+0xf3>

    do {
        a = list_next(a);
c00293bd:	83 ec 0c             	sub    $0xc,%esp
c00293c0:	53                   	push   %ebx
c00293c1:	e8 7e fe ff ff       	call   c0029244 <list_next>
c00293c6:	83 c4 10             	add    $0x10,%esp
c00293c9:	89 c3                	mov    %eax,%ebx
    } while (a != b && !less(a, list_prev(a), aux));
c00293cb:	39 c6                	cmp    %eax,%esi
c00293cd:	74 18                	je     c00293e7 <find_end_of_run+0x62>
c00293cf:	83 ec 0c             	sub    $0xc,%esp
c00293d2:	50                   	push   %eax
c00293d3:	e8 53 ff ff ff       	call   c002932b <list_prev>
c00293d8:	83 c4 0c             	add    $0xc,%esp
c00293db:	55                   	push   %ebp
c00293dc:	50                   	push   %eax
c00293dd:	53                   	push   %ebx
c00293de:	ff d7                	call   *%edi
c00293e0:	83 c4 10             	add    $0x10,%esp
c00293e3:	84 c0                	test   %al,%al
c00293e5:	74 d6                	je     c00293bd <find_end_of_run+0x38>
    return a;
}
c00293e7:	89 d8                	mov    %ebx,%eax
c00293e9:	83 c4 1c             	add    $0x1c,%esp
c00293ec:	5b                   	pop    %ebx
c00293ed:	5e                   	pop    %esi
c00293ee:	5f                   	pop    %edi
c00293ef:	5d                   	pop    %ebp
c00293f0:	c3                   	ret    
    ASSERT (a != NULL);
c00293f1:	83 ec 0c             	sub    $0xc,%esp
c00293f4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00293f8:	8d 83 f5 5a ff ff    	lea    -0xa50b(%ebx),%eax
c00293fe:	50                   	push   %eax
c00293ff:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029405:	50                   	push   %eax
c0029406:	8d 83 f8 4a ff ff    	lea    -0xb508(%ebx),%eax
c002940c:	50                   	push   %eax
c002940d:	68 4d 01 00 00       	push   $0x14d
c0029412:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029418:	50                   	push   %eax
c0029419:	e8 bc fc ff ff       	call   c00290da <debug_panic>
    ASSERT (b != NULL);
c002941e:	83 ec 0c             	sub    $0xc,%esp
c0029421:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029425:	8d 83 7f 6c ff ff    	lea    -0x9381(%ebx),%eax
c002942b:	50                   	push   %eax
c002942c:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029432:	50                   	push   %eax
c0029433:	8d 83 f8 4a ff ff    	lea    -0xb508(%ebx),%eax
c0029439:	50                   	push   %eax
c002943a:	68 4e 01 00 00       	push   $0x14e
c002943f:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029445:	50                   	push   %eax
c0029446:	e8 8f fc ff ff       	call   c00290da <debug_panic>
    ASSERT (less != NULL);
c002944b:	83 ec 0c             	sub    $0xc,%esp
c002944e:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029452:	8d 83 89 6c ff ff    	lea    -0x9377(%ebx),%eax
c0029458:	50                   	push   %eax
c0029459:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002945f:	50                   	push   %eax
c0029460:	8d 83 f8 4a ff ff    	lea    -0xb508(%ebx),%eax
c0029466:	50                   	push   %eax
c0029467:	68 4f 01 00 00       	push   $0x14f
c002946c:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029472:	50                   	push   %eax
c0029473:	e8 62 fc ff ff       	call   c00290da <debug_panic>
    ASSERT (a != b);
c0029478:	83 ec 0c             	sub    $0xc,%esp
c002947b:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002947f:	8d 83 96 6c ff ff    	lea    -0x936a(%ebx),%eax
c0029485:	50                   	push   %eax
c0029486:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002948c:	50                   	push   %eax
c002948d:	8d 83 f8 4a ff ff    	lea    -0xb508(%ebx),%eax
c0029493:	50                   	push   %eax
c0029494:	68 50 01 00 00       	push   $0x150
c0029499:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c002949f:	50                   	push   %eax
c00294a0:	e8 35 fc ff ff       	call   c00290da <debug_panic>

c00294a5 <is_sorted>:
          list_less_func *less, void *aux) {
c00294a5:	55                   	push   %ebp
c00294a6:	57                   	push   %edi
c00294a7:	56                   	push   %esi
c00294a8:	53                   	push   %ebx
c00294a9:	83 ec 0c             	sub    $0xc,%esp
c00294ac:	89 c3                	mov    %eax,%ebx
c00294ae:	89 d6                	mov    %edx,%esi
c00294b0:	89 cd                	mov    %ecx,%ebp
c00294b2:	8b 7c 24 20          	mov    0x20(%esp),%edi
    if (a != b)
c00294b6:	39 d0                	cmp    %edx,%eax
c00294b8:	74 31                	je     c00294eb <is_sorted+0x46>
        while ((a = list_next(a)) != b)
c00294ba:	83 ec 0c             	sub    $0xc,%esp
c00294bd:	53                   	push   %ebx
c00294be:	e8 81 fd ff ff       	call   c0029244 <list_next>
c00294c3:	83 c4 10             	add    $0x10,%esp
c00294c6:	89 c3                	mov    %eax,%ebx
c00294c8:	39 c6                	cmp    %eax,%esi
c00294ca:	74 26                	je     c00294f2 <is_sorted+0x4d>
            if (less(a, list_prev(a), aux))
c00294cc:	83 ec 0c             	sub    $0xc,%esp
c00294cf:	53                   	push   %ebx
c00294d0:	e8 56 fe ff ff       	call   c002932b <list_prev>
c00294d5:	83 c4 0c             	add    $0xc,%esp
c00294d8:	57                   	push   %edi
c00294d9:	50                   	push   %eax
c00294da:	53                   	push   %ebx
c00294db:	ff d5                	call   *%ebp
c00294dd:	83 c4 10             	add    $0x10,%esp
c00294e0:	84 c0                	test   %al,%al
c00294e2:	74 d6                	je     c00294ba <is_sorted+0x15>
                return false;
c00294e4:	b8 00 00 00 00       	mov    $0x0,%eax
c00294e9:	eb 0c                	jmp    c00294f7 <is_sorted+0x52>
    return true;
c00294eb:	b8 01 00 00 00       	mov    $0x1,%eax
c00294f0:	eb 05                	jmp    c00294f7 <is_sorted+0x52>
c00294f2:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00294f7:	83 c4 0c             	add    $0xc,%esp
c00294fa:	5b                   	pop    %ebx
c00294fb:	5e                   	pop    %esi
c00294fc:	5f                   	pop    %edi
c00294fd:	5d                   	pop    %ebp
c00294fe:	c3                   	ret    

c00294ff <list_rend>:
list_rend(struct list *list) {
c00294ff:	53                   	push   %ebx
c0029500:	83 ec 08             	sub    $0x8,%esp
c0029503:	e8 f0 59 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029508:	81 c3 20 1c 01 00    	add    $0x11c20,%ebx
c002950e:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029512:	85 c0                	test   %eax,%eax
c0029514:	74 05                	je     c002951b <list_rend+0x1c>
}
c0029516:	83 c4 08             	add    $0x8,%esp
c0029519:	5b                   	pop    %ebx
c002951a:	c3                   	ret    
    ASSERT (list != NULL);
c002951b:	83 ec 0c             	sub    $0xc,%esp
c002951e:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c0029524:	50                   	push   %eax
c0029525:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002952b:	50                   	push   %eax
c002952c:	8d 83 68 4b ff ff    	lea    -0xb498(%ebx),%eax
c0029532:	50                   	push   %eax
c0029533:	6a 7d                	push   $0x7d
c0029535:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c002953b:	50                   	push   %eax
c002953c:	e8 99 fb ff ff       	call   c00290da <debug_panic>

c0029541 <list_head>:
list_head(struct list *list) {
c0029541:	53                   	push   %ebx
c0029542:	83 ec 08             	sub    $0x8,%esp
c0029545:	e8 ae 59 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002954a:	81 c3 de 1b 01 00    	add    $0x11bde,%ebx
c0029550:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029554:	85 c0                	test   %eax,%eax
c0029556:	74 05                	je     c002955d <list_head+0x1c>
}
c0029558:	83 c4 08             	add    $0x8,%esp
c002955b:	5b                   	pop    %ebx
c002955c:	c3                   	ret    
    ASSERT (list != NULL);
c002955d:	83 ec 0c             	sub    $0xc,%esp
c0029560:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c0029566:	50                   	push   %eax
c0029567:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002956d:	50                   	push   %eax
c002956e:	8d 83 5c 4b ff ff    	lea    -0xb4a4(%ebx),%eax
c0029574:	50                   	push   %eax
c0029575:	68 8e 00 00 00       	push   $0x8e
c002957a:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029580:	50                   	push   %eax
c0029581:	e8 54 fb ff ff       	call   c00290da <debug_panic>

c0029586 <list_tail>:
list_tail(struct list *list) {
c0029586:	53                   	push   %ebx
c0029587:	83 ec 08             	sub    $0x8,%esp
c002958a:	e8 69 59 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002958f:	81 c3 99 1b 01 00    	add    $0x11b99,%ebx
c0029595:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (list != NULL);
c0029599:	85 c0                	test   %eax,%eax
c002959b:	74 08                	je     c00295a5 <list_tail+0x1f>
    return &list->tail;
c002959d:	83 c0 08             	add    $0x8,%eax
}
c00295a0:	83 c4 08             	add    $0x8,%esp
c00295a3:	5b                   	pop    %ebx
c00295a4:	c3                   	ret    
    ASSERT (list != NULL);
c00295a5:	83 ec 0c             	sub    $0xc,%esp
c00295a8:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c00295ae:	50                   	push   %eax
c00295af:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00295b5:	50                   	push   %eax
c00295b6:	8d 83 50 4b ff ff    	lea    -0xb4b0(%ebx),%eax
c00295bc:	50                   	push   %eax
c00295bd:	68 95 00 00 00       	push   $0x95
c00295c2:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c00295c8:	50                   	push   %eax
c00295c9:	e8 0c fb ff ff       	call   c00290da <debug_panic>

c00295ce <list_insert>:
list_insert(struct list_elem *before, struct list_elem *elem) {
c00295ce:	53                   	push   %ebx
c00295cf:	83 ec 08             	sub    $0x8,%esp
c00295d2:	e8 21 59 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00295d7:	81 c3 51 1b 01 00    	add    $0x11b51,%ebx
c00295dd:	8b 44 24 10          	mov    0x10(%esp),%eax
c00295e1:	8b 54 24 14          	mov    0x14(%esp),%edx
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00295e5:	85 c0                	test   %eax,%eax
c00295e7:	74 2d                	je     c0029616 <list_insert+0x48>
c00295e9:	83 38 00             	cmpl   $0x0,(%eax)
c00295ec:	74 1d                	je     c002960b <list_insert+0x3d>
c00295ee:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00295f2:	74 17                	je     c002960b <list_insert+0x3d>
    ASSERT (elem != NULL);
c00295f4:	85 d2                	test   %edx,%edx
c00295f6:	74 47                	je     c002963f <list_insert+0x71>
    elem->prev = before->prev;
c00295f8:	8b 08                	mov    (%eax),%ecx
c00295fa:	89 0a                	mov    %ecx,(%edx)
    elem->next = before;
c00295fc:	89 42 04             	mov    %eax,0x4(%edx)
    before->prev->next = elem;
c00295ff:	8b 08                	mov    (%eax),%ecx
c0029601:	89 51 04             	mov    %edx,0x4(%ecx)
    before->prev = elem;
c0029604:	89 10                	mov    %edx,(%eax)
}
c0029606:	83 c4 08             	add    $0x8,%esp
c0029609:	5b                   	pop    %ebx
c002960a:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002960b:	83 38 00             	cmpl   $0x0,(%eax)
c002960e:	74 06                	je     c0029616 <list_insert+0x48>
c0029610:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029614:	74 de                	je     c00295f4 <list_insert+0x26>
    ASSERT (is_interior(before) || is_tail(before));
c0029616:	83 ec 0c             	sub    $0xc,%esp
c0029619:	8d 83 60 6d ff ff    	lea    -0x92a0(%ebx),%eax
c002961f:	50                   	push   %eax
c0029620:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029626:	50                   	push   %eax
c0029627:	8d 83 44 4b ff ff    	lea    -0xb4bc(%ebx),%eax
c002962d:	50                   	push   %eax
c002962e:	68 9e 00 00 00       	push   $0x9e
c0029633:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029639:	50                   	push   %eax
c002963a:	e8 9b fa ff ff       	call   c00290da <debug_panic>
    ASSERT (elem != NULL);
c002963f:	83 ec 0c             	sub    $0xc,%esp
c0029642:	8d 83 9d 6c ff ff    	lea    -0x9363(%ebx),%eax
c0029648:	50                   	push   %eax
c0029649:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002964f:	50                   	push   %eax
c0029650:	8d 83 44 4b ff ff    	lea    -0xb4bc(%ebx),%eax
c0029656:	50                   	push   %eax
c0029657:	68 9f 00 00 00       	push   $0x9f
c002965c:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029662:	50                   	push   %eax
c0029663:	e8 72 fa ff ff       	call   c00290da <debug_panic>

c0029668 <list_splice>:
            struct list_elem *first, struct list_elem *last) {
c0029668:	57                   	push   %edi
c0029669:	56                   	push   %esi
c002966a:	53                   	push   %ebx
c002966b:	e8 88 58 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029670:	81 c3 b8 1a 01 00    	add    $0x11ab8,%ebx
c0029676:	8b 74 24 10          	mov    0x10(%esp),%esi
c002967a:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002967e:	8b 44 24 18          	mov    0x18(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029682:	85 f6                	test   %esi,%esi
c0029684:	74 6e                	je     c00296f4 <list_splice+0x8c>
c0029686:	83 3e 00             	cmpl   $0x0,(%esi)
c0029689:	74 5e                	je     c00296e9 <list_splice+0x81>
c002968b:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c002968f:	74 58                	je     c00296e9 <list_splice+0x81>
    if (first == last)
c0029691:	39 c7                	cmp    %eax,%edi
c0029693:	74 50                	je     c00296e5 <list_splice+0x7d>
    last = list_prev(last);
c0029695:	83 ec 0c             	sub    $0xc,%esp
c0029698:	50                   	push   %eax
c0029699:	e8 8d fc ff ff       	call   c002932b <list_prev>
c002969e:	83 c4 10             	add    $0x10,%esp
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00296a1:	85 ff                	test   %edi,%edi
c00296a3:	0f 84 9d 00 00 00    	je     c0029746 <list_splice+0xde>
c00296a9:	8b 17                	mov    (%edi),%edx
c00296ab:	85 d2                	test   %edx,%edx
c00296ad:	0f 84 93 00 00 00    	je     c0029746 <list_splice+0xde>
c00296b3:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c00296b7:	0f 84 89 00 00 00    	je     c0029746 <list_splice+0xde>
c00296bd:	85 c0                	test   %eax,%eax
c00296bf:	74 5c                	je     c002971d <list_splice+0xb5>
c00296c1:	83 38 00             	cmpl   $0x0,(%eax)
c00296c4:	74 57                	je     c002971d <list_splice+0xb5>
c00296c6:	8b 48 04             	mov    0x4(%eax),%ecx
c00296c9:	85 c9                	test   %ecx,%ecx
c00296cb:	74 50                	je     c002971d <list_splice+0xb5>
    first->prev->next = last->next;
c00296cd:	89 4a 04             	mov    %ecx,0x4(%edx)
    last->next->prev = first->prev;
c00296d0:	8b 50 04             	mov    0x4(%eax),%edx
c00296d3:	8b 0f                	mov    (%edi),%ecx
c00296d5:	89 0a                	mov    %ecx,(%edx)
    first->prev = before->prev;
c00296d7:	8b 16                	mov    (%esi),%edx
c00296d9:	89 17                	mov    %edx,(%edi)
    last->next = before;
c00296db:	89 70 04             	mov    %esi,0x4(%eax)
    before->prev->next = first;
c00296de:	8b 16                	mov    (%esi),%edx
c00296e0:	89 7a 04             	mov    %edi,0x4(%edx)
    before->prev = last;
c00296e3:	89 06                	mov    %eax,(%esi)
}
c00296e5:	5b                   	pop    %ebx
c00296e6:	5e                   	pop    %esi
c00296e7:	5f                   	pop    %edi
c00296e8:	c3                   	ret    
    return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00296e9:	83 3e 00             	cmpl   $0x0,(%esi)
c00296ec:	74 06                	je     c00296f4 <list_splice+0x8c>
c00296ee:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c00296f2:	74 9d                	je     c0029691 <list_splice+0x29>
    ASSERT (is_interior(before) || is_tail(before));
c00296f4:	83 ec 0c             	sub    $0xc,%esp
c00296f7:	8d 83 60 6d ff ff    	lea    -0x92a0(%ebx),%eax
c00296fd:	50                   	push   %eax
c00296fe:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029704:	50                   	push   %eax
c0029705:	8d 83 38 4b ff ff    	lea    -0xb4c8(%ebx),%eax
c002970b:	50                   	push   %eax
c002970c:	68 ad 00 00 00       	push   $0xad
c0029711:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029717:	50                   	push   %eax
c0029718:	e8 bd f9 ff ff       	call   c00290da <debug_panic>
    ASSERT (is_interior(last));
c002971d:	83 ec 0c             	sub    $0xc,%esp
c0029720:	8d 83 aa 6c ff ff    	lea    -0x9356(%ebx),%eax
c0029726:	50                   	push   %eax
c0029727:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002972d:	50                   	push   %eax
c002972e:	8d 83 38 4b ff ff    	lea    -0xb4c8(%ebx),%eax
c0029734:	50                   	push   %eax
c0029735:	68 b3 00 00 00       	push   $0xb3
c002973a:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029740:	50                   	push   %eax
c0029741:	e8 94 f9 ff ff       	call   c00290da <debug_panic>
    ASSERT (is_interior(first));
c0029746:	83 ec 0c             	sub    $0xc,%esp
c0029749:	8d 83 bc 6c ff ff    	lea    -0x9344(%ebx),%eax
c002974f:	50                   	push   %eax
c0029750:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029756:	50                   	push   %eax
c0029757:	8d 83 38 4b ff ff    	lea    -0xb4c8(%ebx),%eax
c002975d:	50                   	push   %eax
c002975e:	68 b2 00 00 00       	push   $0xb2
c0029763:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029769:	50                   	push   %eax
c002976a:	e8 6b f9 ff ff       	call   c00290da <debug_panic>

c002976f <list_push_front>:
list_push_front(struct list *list, struct list_elem *elem) {
c002976f:	83 ec 18             	sub    $0x18,%esp
    list_insert(list_begin(list), elem);
c0029772:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029776:	e8 84 fa ff ff       	call   c00291ff <list_begin>
c002977b:	83 c4 08             	add    $0x8,%esp
c002977e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029782:	50                   	push   %eax
c0029783:	e8 46 fe ff ff       	call   c00295ce <list_insert>
}
c0029788:	83 c4 1c             	add    $0x1c,%esp
c002978b:	c3                   	ret    

c002978c <list_push_back>:
list_push_back(struct list *list, struct list_elem *elem) {
c002978c:	83 ec 18             	sub    $0x18,%esp
    list_insert(list_end(list), elem);
c002978f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029793:	e8 09 fb ff ff       	call   c00292a1 <list_end>
c0029798:	83 c4 08             	add    $0x8,%esp
c002979b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002979f:	50                   	push   %eax
c00297a0:	e8 29 fe ff ff       	call   c00295ce <list_insert>
}
c00297a5:	83 c4 1c             	add    $0x1c,%esp
c00297a8:	c3                   	ret    

c00297a9 <list_remove>:
list_remove(struct list_elem *elem) {
c00297a9:	53                   	push   %ebx
c00297aa:	83 ec 08             	sub    $0x8,%esp
c00297ad:	e8 46 57 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00297b2:	81 c3 76 19 01 00    	add    $0x11976,%ebx
c00297b8:	8b 44 24 10          	mov    0x10(%esp),%eax
    return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00297bc:	85 c0                	test   %eax,%eax
c00297be:	74 1f                	je     c00297df <list_remove+0x36>
c00297c0:	8b 10                	mov    (%eax),%edx
c00297c2:	85 d2                	test   %edx,%edx
c00297c4:	74 19                	je     c00297df <list_remove+0x36>
c00297c6:	8b 48 04             	mov    0x4(%eax),%ecx
c00297c9:	85 c9                	test   %ecx,%ecx
c00297cb:	74 12                	je     c00297df <list_remove+0x36>
    elem->prev->next = elem->next;
c00297cd:	89 4a 04             	mov    %ecx,0x4(%edx)
    elem->next->prev = elem->prev;
c00297d0:	8b 50 04             	mov    0x4(%eax),%edx
c00297d3:	8b 08                	mov    (%eax),%ecx
c00297d5:	89 0a                	mov    %ecx,(%edx)
    return elem->next;
c00297d7:	8b 40 04             	mov    0x4(%eax),%eax
}
c00297da:	83 c4 08             	add    $0x8,%esp
c00297dd:	5b                   	pop    %ebx
c00297de:	c3                   	ret    
    ASSERT (is_interior(elem));
c00297df:	83 ec 0c             	sub    $0xc,%esp
c00297e2:	8d 83 cf 6c ff ff    	lea    -0x9331(%ebx),%eax
c00297e8:	50                   	push   %eax
c00297e9:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00297ef:	50                   	push   %eax
c00297f0:	8d 83 2c 4b ff ff    	lea    -0xb4d4(%ebx),%eax
c00297f6:	50                   	push   %eax
c00297f7:	68 ea 00 00 00       	push   $0xea
c00297fc:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029802:	50                   	push   %eax
c0029803:	e8 d2 f8 ff ff       	call   c00290da <debug_panic>

c0029808 <list_size>:
list_size(struct list *list) {
c0029808:	57                   	push   %edi
c0029809:	56                   	push   %esi
c002980a:	53                   	push   %ebx
c002980b:	8b 7c 24 10          	mov    0x10(%esp),%edi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c002980f:	83 ec 0c             	sub    $0xc,%esp
c0029812:	57                   	push   %edi
c0029813:	e8 e7 f9 ff ff       	call   c00291ff <list_begin>
c0029818:	83 c4 10             	add    $0x10,%esp
c002981b:	89 c3                	mov    %eax,%ebx
    size_t cnt = 0;
c002981d:	be 00 00 00 00       	mov    $0x0,%esi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029822:	83 ec 0c             	sub    $0xc,%esp
c0029825:	57                   	push   %edi
c0029826:	e8 76 fa ff ff       	call   c00292a1 <list_end>
c002982b:	83 c4 10             	add    $0x10,%esp
c002982e:	39 d8                	cmp    %ebx,%eax
c0029830:	74 13                	je     c0029845 <list_size+0x3d>
        cnt++;
c0029832:	83 c6 01             	add    $0x1,%esi
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029835:	83 ec 0c             	sub    $0xc,%esp
c0029838:	53                   	push   %ebx
c0029839:	e8 06 fa ff ff       	call   c0029244 <list_next>
c002983e:	83 c4 10             	add    $0x10,%esp
c0029841:	89 c3                	mov    %eax,%ebx
c0029843:	eb dd                	jmp    c0029822 <list_size+0x1a>
}
c0029845:	89 f0                	mov    %esi,%eax
c0029847:	5b                   	pop    %ebx
c0029848:	5e                   	pop    %esi
c0029849:	5f                   	pop    %edi
c002984a:	c3                   	ret    

c002984b <list_empty>:
list_empty(struct list *list) {
c002984b:	56                   	push   %esi
c002984c:	53                   	push   %ebx
c002984d:	83 ec 10             	sub    $0x10,%esp
c0029850:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    return list_begin(list) == list_end(list);
c0029854:	53                   	push   %ebx
c0029855:	e8 a5 f9 ff ff       	call   c00291ff <list_begin>
c002985a:	89 c6                	mov    %eax,%esi
c002985c:	89 1c 24             	mov    %ebx,(%esp)
c002985f:	e8 3d fa ff ff       	call   c00292a1 <list_end>
c0029864:	39 c6                	cmp    %eax,%esi
c0029866:	0f 94 c0             	sete   %al
}
c0029869:	83 c4 14             	add    $0x14,%esp
c002986c:	5b                   	pop    %ebx
c002986d:	5e                   	pop    %esi
c002986e:	c3                   	ret    

c002986f <list_front>:
list_front(struct list *list) {
c002986f:	56                   	push   %esi
c0029870:	53                   	push   %ebx
c0029871:	83 ec 10             	sub    $0x10,%esp
c0029874:	e8 7f 56 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029879:	81 c3 af 18 01 00    	add    $0x118af,%ebx
c002987f:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    ASSERT (!list_empty(list));
c0029883:	56                   	push   %esi
c0029884:	e8 c2 ff ff ff       	call   c002984b <list_empty>
c0029889:	83 c4 10             	add    $0x10,%esp
c002988c:	84 c0                	test   %al,%al
c002988e:	75 09                	jne    c0029899 <list_front+0x2a>
    return list->head.next;
c0029890:	8b 46 04             	mov    0x4(%esi),%eax
}
c0029893:	83 c4 04             	add    $0x4,%esp
c0029896:	5b                   	pop    %ebx
c0029897:	5e                   	pop    %esi
c0029898:	c3                   	ret    
    ASSERT (!list_empty(list));
c0029899:	83 ec 0c             	sub    $0xc,%esp
c002989c:	8d 83 e1 6c ff ff    	lea    -0x931f(%ebx),%eax
c00298a2:	50                   	push   %eax
c00298a3:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00298a9:	50                   	push   %eax
c00298aa:	8d 83 20 4b ff ff    	lea    -0xb4e0(%ebx),%eax
c00298b0:	50                   	push   %eax
c00298b1:	68 06 01 00 00       	push   $0x106
c00298b6:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c00298bc:	50                   	push   %eax
c00298bd:	e8 18 f8 ff ff       	call   c00290da <debug_panic>

c00298c2 <list_pop_front>:
list_pop_front(struct list *list) {
c00298c2:	53                   	push   %ebx
c00298c3:	83 ec 14             	sub    $0x14,%esp
    struct list_elem *front = list_front(list);
c00298c6:	ff 74 24 1c          	pushl  0x1c(%esp)
c00298ca:	e8 a0 ff ff ff       	call   c002986f <list_front>
c00298cf:	89 c3                	mov    %eax,%ebx
    list_remove(front);
c00298d1:	89 04 24             	mov    %eax,(%esp)
c00298d4:	e8 d0 fe ff ff       	call   c00297a9 <list_remove>
}
c00298d9:	89 d8                	mov    %ebx,%eax
c00298db:	83 c4 18             	add    $0x18,%esp
c00298de:	5b                   	pop    %ebx
c00298df:	c3                   	ret    

c00298e0 <list_back>:
list_back(struct list *list) {
c00298e0:	56                   	push   %esi
c00298e1:	53                   	push   %ebx
c00298e2:	83 ec 10             	sub    $0x10,%esp
c00298e5:	e8 0e 56 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c00298ea:	81 c3 3e 18 01 00    	add    $0x1183e,%ebx
c00298f0:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    ASSERT (!list_empty(list));
c00298f4:	56                   	push   %esi
c00298f5:	e8 51 ff ff ff       	call   c002984b <list_empty>
c00298fa:	83 c4 10             	add    $0x10,%esp
c00298fd:	84 c0                	test   %al,%al
c00298ff:	75 09                	jne    c002990a <list_back+0x2a>
    return list->tail.prev;
c0029901:	8b 46 08             	mov    0x8(%esi),%eax
}
c0029904:	83 c4 04             	add    $0x4,%esp
c0029907:	5b                   	pop    %ebx
c0029908:	5e                   	pop    %esi
c0029909:	c3                   	ret    
    ASSERT (!list_empty(list));
c002990a:	83 ec 0c             	sub    $0xc,%esp
c002990d:	8d 83 e1 6c ff ff    	lea    -0x931f(%ebx),%eax
c0029913:	50                   	push   %eax
c0029914:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002991a:	50                   	push   %eax
c002991b:	8d 83 14 4b ff ff    	lea    -0xb4ec(%ebx),%eax
c0029921:	50                   	push   %eax
c0029922:	68 0e 01 00 00       	push   $0x10e
c0029927:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c002992d:	50                   	push   %eax
c002992e:	e8 a7 f7 ff ff       	call   c00290da <debug_panic>

c0029933 <list_pop_back>:
list_pop_back(struct list *list) {
c0029933:	53                   	push   %ebx
c0029934:	83 ec 14             	sub    $0x14,%esp
    struct list_elem *back = list_back(list);
c0029937:	ff 74 24 1c          	pushl  0x1c(%esp)
c002993b:	e8 a0 ff ff ff       	call   c00298e0 <list_back>
c0029940:	89 c3                	mov    %eax,%ebx
    list_remove(back);
c0029942:	89 04 24             	mov    %eax,(%esp)
c0029945:	e8 5f fe ff ff       	call   c00297a9 <list_remove>
}
c002994a:	89 d8                	mov    %ebx,%eax
c002994c:	83 c4 18             	add    $0x18,%esp
c002994f:	5b                   	pop    %ebx
c0029950:	c3                   	ret    

c0029951 <list_reverse>:
list_reverse(struct list *list) {
c0029951:	56                   	push   %esi
c0029952:	53                   	push   %ebx
c0029953:	83 ec 10             	sub    $0x10,%esp
c0029956:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    if (!list_empty(list)) {
c002995a:	56                   	push   %esi
c002995b:	e8 eb fe ff ff       	call   c002984b <list_empty>
c0029960:	83 c4 10             	add    $0x10,%esp
c0029963:	84 c0                	test   %al,%al
c0029965:	74 06                	je     c002996d <list_reverse+0x1c>
}
c0029967:	83 c4 04             	add    $0x4,%esp
c002996a:	5b                   	pop    %ebx
c002996b:	5e                   	pop    %esi
c002996c:	c3                   	ret    
        for (e = list_begin(list); e != list_end(list); e = e->prev)
c002996d:	83 ec 0c             	sub    $0xc,%esp
c0029970:	56                   	push   %esi
c0029971:	e8 89 f8 ff ff       	call   c00291ff <list_begin>
c0029976:	83 c4 10             	add    $0x10,%esp
c0029979:	89 c3                	mov    %eax,%ebx
c002997b:	83 ec 0c             	sub    $0xc,%esp
c002997e:	56                   	push   %esi
c002997f:	e8 1d f9 ff ff       	call   c00292a1 <list_end>
c0029984:	83 c4 10             	add    $0x10,%esp
c0029987:	39 d8                	cmp    %ebx,%eax
c0029989:	74 0e                	je     c0029999 <list_reverse+0x48>
    struct list_elem *t = *a;
c002998b:	8b 13                	mov    (%ebx),%edx
    *a = *b;
c002998d:	8b 43 04             	mov    0x4(%ebx),%eax
c0029990:	89 03                	mov    %eax,(%ebx)
    *b = t;
c0029992:	89 53 04             	mov    %edx,0x4(%ebx)
        for (e = list_begin(list); e != list_end(list); e = e->prev)
c0029995:	89 c3                	mov    %eax,%ebx
c0029997:	eb e2                	jmp    c002997b <list_reverse+0x2a>
    struct list_elem *t = *a;
c0029999:	8b 46 04             	mov    0x4(%esi),%eax
    *a = *b;
c002999c:	8b 56 08             	mov    0x8(%esi),%edx
c002999f:	89 56 04             	mov    %edx,0x4(%esi)
    *b = t;
c00299a2:	89 46 08             	mov    %eax,0x8(%esi)
    struct list_elem *t = *a;
c00299a5:	8b 0a                	mov    (%edx),%ecx
    *a = *b;
c00299a7:	8b 58 04             	mov    0x4(%eax),%ebx
c00299aa:	89 1a                	mov    %ebx,(%edx)
    *b = t;
c00299ac:	89 48 04             	mov    %ecx,0x4(%eax)
}
c00299af:	eb b6                	jmp    c0029967 <list_reverse+0x16>

c00299b1 <list_sort>:

/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort(struct list *list, list_less_func *less, void *aux) {
c00299b1:	55                   	push   %ebp
c00299b2:	57                   	push   %edi
c00299b3:	56                   	push   %esi
c00299b4:	53                   	push   %ebx
c00299b5:	83 ec 1c             	sub    $0x1c,%esp
c00299b8:	e8 3f 55 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c00299bd:	05 6b 17 01 00       	add    $0x1176b,%eax
c00299c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
c00299c6:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c00299ca:	8b 7c 24 38          	mov    0x38(%esp),%edi
    size_t output_run_cnt;        /* Number of runs output in current pass. */

    ASSERT (list != NULL);
c00299ce:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c00299d3:	74 35                	je     c0029a0a <list_sort+0x59>
    ASSERT (less != NULL);
c00299d5:	85 ed                	test   %ebp,%ebp
c00299d7:	0f 85 41 02 00 00    	jne    c0029c1e <list_sort+0x26d>
c00299dd:	83 ec 0c             	sub    $0xc,%esp
c00299e0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00299e4:	8d 83 89 6c ff ff    	lea    -0x9377(%ebx),%eax
c00299ea:	50                   	push   %eax
c00299eb:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c00299f1:	50                   	push   %eax
c00299f2:	8d 83 08 4b ff ff    	lea    -0xb4f8(%ebx),%eax
c00299f8:	50                   	push   %eax
c00299f9:	68 79 01 00 00       	push   $0x179
c00299fe:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029a04:	50                   	push   %eax
c0029a05:	e8 d0 f6 ff ff       	call   c00290da <debug_panic>
    ASSERT (list != NULL);
c0029a0a:	83 ec 0c             	sub    $0xc,%esp
c0029a0d:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a11:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c0029a17:	50                   	push   %eax
c0029a18:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029a1e:	50                   	push   %eax
c0029a1f:	8d 83 08 4b ff ff    	lea    -0xb4f8(%ebx),%eax
c0029a25:	50                   	push   %eax
c0029a26:	68 78 01 00 00       	push   $0x178
c0029a2b:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029a31:	50                   	push   %eax
c0029a32:	e8 a3 f6 ff ff       	call   c00290da <debug_panic>
    ASSERT (a0 != NULL);
c0029a37:	83 ec 0c             	sub    $0xc,%esp
c0029a3a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a3e:	8d 83 f3 6c ff ff    	lea    -0x930d(%ebx),%eax
c0029a44:	50                   	push   %eax
c0029a45:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029a4b:	50                   	push   %eax
c0029a4c:	8d 83 e8 4a ff ff    	lea    -0xb518(%ebx),%eax
c0029a52:	50                   	push   %eax
c0029a53:	68 61 01 00 00       	push   $0x161
c0029a58:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029a5e:	50                   	push   %eax
c0029a5f:	e8 76 f6 ff ff       	call   c00290da <debug_panic>
    ASSERT (a1b0 != NULL);
c0029a64:	83 ec 0c             	sub    $0xc,%esp
c0029a67:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a6b:	8d 83 fe 6c ff ff    	lea    -0x9302(%ebx),%eax
c0029a71:	50                   	push   %eax
c0029a72:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029a78:	50                   	push   %eax
c0029a79:	8d 83 e8 4a ff ff    	lea    -0xb518(%ebx),%eax
c0029a7f:	50                   	push   %eax
c0029a80:	68 62 01 00 00       	push   $0x162
c0029a85:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029a8b:	50                   	push   %eax
c0029a8c:	e8 49 f6 ff ff       	call   c00290da <debug_panic>
    ASSERT (b1 != NULL);
c0029a91:	83 ec 0c             	sub    $0xc,%esp
c0029a94:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029a98:	8d 83 0b 6d ff ff    	lea    -0x92f5(%ebx),%eax
c0029a9e:	50                   	push   %eax
c0029a9f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029aa5:	50                   	push   %eax
c0029aa6:	8d 83 e8 4a ff ff    	lea    -0xb518(%ebx),%eax
c0029aac:	50                   	push   %eax
c0029aad:	68 63 01 00 00       	push   $0x163
c0029ab2:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029ab8:	50                   	push   %eax
c0029ab9:	e8 1c f6 ff ff       	call   c00290da <debug_panic>
    ASSERT (is_sorted(a0, a1b0, less, aux));
c0029abe:	83 ec 0c             	sub    $0xc,%esp
c0029ac1:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029ac5:	8d 83 88 6d ff ff    	lea    -0x9278(%ebx),%eax
c0029acb:	50                   	push   %eax
c0029acc:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029ad2:	50                   	push   %eax
c0029ad3:	8d 83 e8 4a ff ff    	lea    -0xb518(%ebx),%eax
c0029ad9:	50                   	push   %eax
c0029ada:	68 65 01 00 00       	push   $0x165
c0029adf:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029ae5:	50                   	push   %eax
c0029ae6:	e8 ef f5 ff ff       	call   c00290da <debug_panic>
            a1b0 = list_next(a1b0);
c0029aeb:	83 ec 0c             	sub    $0xc,%esp
c0029aee:	53                   	push   %ebx
c0029aef:	e8 50 f7 ff ff       	call   c0029244 <list_next>
c0029af4:	89 c3                	mov    %eax,%ebx
            list_splice(a0, list_prev(a1b0), a1b0);
c0029af6:	89 04 24             	mov    %eax,(%esp)
c0029af9:	e8 2d f8 ff ff       	call   c002932b <list_prev>
c0029afe:	83 c4 0c             	add    $0xc,%esp
c0029b01:	53                   	push   %ebx
c0029b02:	50                   	push   %eax
c0029b03:	56                   	push   %esi
c0029b04:	e8 5f fb ff ff       	call   c0029668 <list_splice>
c0029b09:	83 c4 10             	add    $0x10,%esp
    while (a0 != a1b0 && a1b0 != b1)
c0029b0c:	39 f3                	cmp    %esi,%ebx
c0029b0e:	0f 95 c2             	setne  %dl
c0029b11:	39 5c 24 04          	cmp    %ebx,0x4(%esp)
c0029b15:	0f 95 c0             	setne  %al
c0029b18:	84 c2                	test   %al,%dl
c0029b1a:	74 1f                	je     c0029b3b <list_sort+0x18a>
        if (!less(a1b0, a0, aux))
c0029b1c:	83 ec 04             	sub    $0x4,%esp
c0029b1f:	57                   	push   %edi
c0029b20:	56                   	push   %esi
c0029b21:	53                   	push   %ebx
c0029b22:	ff d5                	call   *%ebp
c0029b24:	83 c4 10             	add    $0x10,%esp
c0029b27:	84 c0                	test   %al,%al
c0029b29:	75 c0                	jne    c0029aeb <list_sort+0x13a>
            a0 = list_next(a0);
c0029b2b:	83 ec 0c             	sub    $0xc,%esp
c0029b2e:	56                   	push   %esi
c0029b2f:	e8 10 f7 ff ff       	call   c0029244 <list_next>
c0029b34:	83 c4 10             	add    $0x10,%esp
c0029b37:	89 c6                	mov    %eax,%esi
c0029b39:	eb d1                	jmp    c0029b0c <list_sort+0x15b>
        struct list_elem *a0;     /* Start of first run. */
        struct list_elem *a1b0;   /* End of first run, start of second. */
        struct list_elem *b1;     /* End of second run. */

        output_run_cnt = 0;
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029b3b:	8b 74 24 04          	mov    0x4(%esp),%esi
c0029b3f:	83 ec 0c             	sub    $0xc,%esp
c0029b42:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029b46:	e8 56 f7 ff ff       	call   c00292a1 <list_end>
c0029b4b:	83 c4 10             	add    $0x10,%esp
c0029b4e:	39 f0                	cmp    %esi,%eax
c0029b50:	0f 84 c1 00 00 00    	je     c0029c17 <list_sort+0x266>
            /* Each iteration produces one output run. */
            output_run_cnt++;
c0029b56:	83 44 24 08 01       	addl   $0x1,0x8(%esp)

            /* Locate two adjacent runs of nondecreasing elements
               A0...A1B0 and A1B0...B1. */
            a1b0 = find_end_of_run(a0, list_end(list), less, aux);
c0029b5b:	83 ec 0c             	sub    $0xc,%esp
c0029b5e:	57                   	push   %edi
c0029b5f:	89 e9                	mov    %ebp,%ecx
c0029b61:	89 c2                	mov    %eax,%edx
c0029b63:	89 f0                	mov    %esi,%eax
c0029b65:	e8 1b f8 ff ff       	call   c0029385 <find_end_of_run>
c0029b6a:	89 c3                	mov    %eax,%ebx
            if (a1b0 == list_end(list))
c0029b6c:	83 c4 04             	add    $0x4,%esp
c0029b6f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029b73:	e8 29 f7 ff ff       	call   c00292a1 <list_end>
c0029b78:	83 c4 10             	add    $0x10,%esp
c0029b7b:	39 d8                	cmp    %ebx,%eax
c0029b7d:	0f 84 94 00 00 00    	je     c0029c17 <list_sort+0x266>
                break;
            b1 = find_end_of_run(a1b0, list_end(list), less, aux);
c0029b83:	83 ec 0c             	sub    $0xc,%esp
c0029b86:	57                   	push   %edi
c0029b87:	89 e9                	mov    %ebp,%ecx
c0029b89:	89 c2                	mov    %eax,%edx
c0029b8b:	89 d8                	mov    %ebx,%eax
c0029b8d:	e8 f3 f7 ff ff       	call   c0029385 <find_end_of_run>
c0029b92:	89 44 24 14          	mov    %eax,0x14(%esp)
    ASSERT (a0 != NULL);
c0029b96:	83 c4 10             	add    $0x10,%esp
c0029b99:	85 f6                	test   %esi,%esi
c0029b9b:	0f 84 96 fe ff ff    	je     c0029a37 <list_sort+0x86>
    ASSERT (a1b0 != NULL);
c0029ba1:	85 db                	test   %ebx,%ebx
c0029ba3:	0f 84 bb fe ff ff    	je     c0029a64 <list_sort+0xb3>
    ASSERT (b1 != NULL);
c0029ba9:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0029bae:	0f 84 dd fe ff ff    	je     c0029a91 <list_sort+0xe0>
    ASSERT (is_sorted(a0, a1b0, less, aux));
c0029bb4:	83 ec 0c             	sub    $0xc,%esp
c0029bb7:	57                   	push   %edi
c0029bb8:	89 e9                	mov    %ebp,%ecx
c0029bba:	89 da                	mov    %ebx,%edx
c0029bbc:	89 f0                	mov    %esi,%eax
c0029bbe:	e8 e2 f8 ff ff       	call   c00294a5 <is_sorted>
c0029bc3:	83 c4 10             	add    $0x10,%esp
c0029bc6:	84 c0                	test   %al,%al
c0029bc8:	0f 84 f0 fe ff ff    	je     c0029abe <list_sort+0x10d>
    ASSERT (is_sorted(a1b0, b1, less, aux));
c0029bce:	83 ec 0c             	sub    $0xc,%esp
c0029bd1:	57                   	push   %edi
c0029bd2:	89 e9                	mov    %ebp,%ecx
c0029bd4:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029bd8:	89 d8                	mov    %ebx,%eax
c0029bda:	e8 c6 f8 ff ff       	call   c00294a5 <is_sorted>
c0029bdf:	83 c4 10             	add    $0x10,%esp
c0029be2:	84 c0                	test   %al,%al
c0029be4:	0f 85 22 ff ff ff    	jne    c0029b0c <list_sort+0x15b>
c0029bea:	83 ec 0c             	sub    $0xc,%esp
c0029bed:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029bf1:	8d 83 a8 6d ff ff    	lea    -0x9258(%ebx),%eax
c0029bf7:	50                   	push   %eax
c0029bf8:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029bfe:	50                   	push   %eax
c0029bff:	8d 83 e8 4a ff ff    	lea    -0xb518(%ebx),%eax
c0029c05:	50                   	push   %eax
c0029c06:	68 66 01 00 00       	push   $0x166
c0029c0b:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029c11:	50                   	push   %eax
c0029c12:	e8 c3 f4 ff ff       	call   c00290da <debug_panic>

            /* Merge the runs. */
            inplace_merge(a0, a1b0, b1, less, aux);
        }
    } while (output_run_cnt > 1);
c0029c17:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
c0029c1c:	76 1e                	jbe    c0029c3c <list_sort+0x28b>
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029c1e:	83 ec 0c             	sub    $0xc,%esp
c0029c21:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029c25:	e8 d5 f5 ff ff       	call   c00291ff <list_begin>
c0029c2a:	83 c4 10             	add    $0x10,%esp
c0029c2d:	89 c6                	mov    %eax,%esi
        output_run_cnt = 0;
c0029c2f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0029c36:	00 
        for (a0 = list_begin(list); a0 != list_end(list); a0 = b1) {
c0029c37:	e9 03 ff ff ff       	jmp    c0029b3f <list_sort+0x18e>

    ASSERT (is_sorted(list_begin(list), list_end(list), less, aux));
c0029c3c:	83 ec 0c             	sub    $0xc,%esp
c0029c3f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029c43:	e8 59 f6 ff ff       	call   c00292a1 <list_end>
c0029c48:	83 c4 04             	add    $0x4,%esp
c0029c4b:	89 c3                	mov    %eax,%ebx
c0029c4d:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029c51:	e8 a9 f5 ff ff       	call   c00291ff <list_begin>
c0029c56:	89 3c 24             	mov    %edi,(%esp)
c0029c59:	89 e9                	mov    %ebp,%ecx
c0029c5b:	89 da                	mov    %ebx,%edx
c0029c5d:	e8 43 f8 ff ff       	call   c00294a5 <is_sorted>
c0029c62:	83 c4 10             	add    $0x10,%esp
c0029c65:	84 c0                	test   %al,%al
c0029c67:	74 08                	je     c0029c71 <list_sort+0x2c0>
}
c0029c69:	83 c4 1c             	add    $0x1c,%esp
c0029c6c:	5b                   	pop    %ebx
c0029c6d:	5e                   	pop    %esi
c0029c6e:	5f                   	pop    %edi
c0029c6f:	5d                   	pop    %ebp
c0029c70:	c3                   	ret    
    ASSERT (is_sorted(list_begin(list), list_end(list), less, aux));
c0029c71:	83 ec 0c             	sub    $0xc,%esp
c0029c74:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029c78:	8d 83 c8 6d ff ff    	lea    -0x9238(%ebx),%eax
c0029c7e:	50                   	push   %eax
c0029c7f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029c85:	50                   	push   %eax
c0029c86:	8d 83 08 4b ff ff    	lea    -0xb4f8(%ebx),%eax
c0029c8c:	50                   	push   %eax
c0029c8d:	68 93 01 00 00       	push   $0x193
c0029c92:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029c98:	50                   	push   %eax
c0029c99:	e8 3c f4 ff ff       	call   c00290da <debug_panic>

c0029c9e <list_insert_ordered>:
/* Inserts ELEM in the proper position in LIST, which must be
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered(struct list *list, struct list_elem *elem,
                    list_less_func *less, void *aux) {
c0029c9e:	55                   	push   %ebp
c0029c9f:	57                   	push   %edi
c0029ca0:	56                   	push   %esi
c0029ca1:	53                   	push   %ebx
c0029ca2:	83 ec 0c             	sub    $0xc,%esp
c0029ca5:	e8 4e 52 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029caa:	81 c3 7e 14 01 00    	add    $0x1147e,%ebx
c0029cb0:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029cb4:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029cb8:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    struct list_elem *e;

    ASSERT (list != NULL);
c0029cbc:	85 f6                	test   %esi,%esi
c0029cbe:	74 54                	je     c0029d14 <list_insert_ordered+0x76>
    ASSERT (elem != NULL);
c0029cc0:	85 ff                	test   %edi,%edi
c0029cc2:	74 79                	je     c0029d3d <list_insert_ordered+0x9f>
    ASSERT (less != NULL);
c0029cc4:	85 ed                	test   %ebp,%ebp
c0029cc6:	0f 84 9a 00 00 00    	je     c0029d66 <list_insert_ordered+0xc8>

    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029ccc:	83 ec 0c             	sub    $0xc,%esp
c0029ccf:	56                   	push   %esi
c0029cd0:	e8 2a f5 ff ff       	call   c00291ff <list_begin>
c0029cd5:	83 c4 10             	add    $0x10,%esp
c0029cd8:	89 c3                	mov    %eax,%ebx
c0029cda:	83 ec 0c             	sub    $0xc,%esp
c0029cdd:	56                   	push   %esi
c0029cde:	e8 be f5 ff ff       	call   c00292a1 <list_end>
c0029ce3:	83 c4 10             	add    $0x10,%esp
c0029ce6:	39 d8                	cmp    %ebx,%eax
c0029ce8:	0f 84 a1 00 00 00    	je     c0029d8f <list_insert_ordered+0xf1>
        if (less(elem, e, aux))
c0029cee:	83 ec 04             	sub    $0x4,%esp
c0029cf1:	ff 74 24 30          	pushl  0x30(%esp)
c0029cf5:	53                   	push   %ebx
c0029cf6:	57                   	push   %edi
c0029cf7:	ff d5                	call   *%ebp
c0029cf9:	83 c4 10             	add    $0x10,%esp
c0029cfc:	84 c0                	test   %al,%al
c0029cfe:	0f 85 8b 00 00 00    	jne    c0029d8f <list_insert_ordered+0xf1>
    for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029d04:	83 ec 0c             	sub    $0xc,%esp
c0029d07:	53                   	push   %ebx
c0029d08:	e8 37 f5 ff ff       	call   c0029244 <list_next>
c0029d0d:	83 c4 10             	add    $0x10,%esp
c0029d10:	89 c3                	mov    %eax,%ebx
c0029d12:	eb c6                	jmp    c0029cda <list_insert_ordered+0x3c>
    ASSERT (list != NULL);
c0029d14:	83 ec 0c             	sub    $0xc,%esp
c0029d17:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c0029d1d:	50                   	push   %eax
c0029d1e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029d24:	50                   	push   %eax
c0029d25:	8d 83 d4 4a ff ff    	lea    -0xb52c(%ebx),%eax
c0029d2b:	50                   	push   %eax
c0029d2c:	68 9e 01 00 00       	push   $0x19e
c0029d31:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029d37:	50                   	push   %eax
c0029d38:	e8 9d f3 ff ff       	call   c00290da <debug_panic>
    ASSERT (elem != NULL);
c0029d3d:	83 ec 0c             	sub    $0xc,%esp
c0029d40:	8d 83 9d 6c ff ff    	lea    -0x9363(%ebx),%eax
c0029d46:	50                   	push   %eax
c0029d47:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029d4d:	50                   	push   %eax
c0029d4e:	8d 83 d4 4a ff ff    	lea    -0xb52c(%ebx),%eax
c0029d54:	50                   	push   %eax
c0029d55:	68 9f 01 00 00       	push   $0x19f
c0029d5a:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029d60:	50                   	push   %eax
c0029d61:	e8 74 f3 ff ff       	call   c00290da <debug_panic>
    ASSERT (less != NULL);
c0029d66:	83 ec 0c             	sub    $0xc,%esp
c0029d69:	8d 83 89 6c ff ff    	lea    -0x9377(%ebx),%eax
c0029d6f:	50                   	push   %eax
c0029d70:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029d76:	50                   	push   %eax
c0029d77:	8d 83 d4 4a ff ff    	lea    -0xb52c(%ebx),%eax
c0029d7d:	50                   	push   %eax
c0029d7e:	68 a0 01 00 00       	push   $0x1a0
c0029d83:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029d89:	50                   	push   %eax
c0029d8a:	e8 4b f3 ff ff       	call   c00290da <debug_panic>
            break;
    return list_insert(e, elem);
c0029d8f:	83 ec 08             	sub    $0x8,%esp
c0029d92:	57                   	push   %edi
c0029d93:	53                   	push   %ebx
c0029d94:	e8 35 f8 ff ff       	call   c00295ce <list_insert>
}
c0029d99:	83 c4 1c             	add    $0x1c,%esp
c0029d9c:	5b                   	pop    %ebx
c0029d9d:	5e                   	pop    %esi
c0029d9e:	5f                   	pop    %edi
c0029d9f:	5d                   	pop    %ebp
c0029da0:	c3                   	ret    

c0029da1 <list_unique>:
   set of adjacent elements that are equal according to LESS
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique(struct list *list, struct list *duplicates,
            list_less_func *less, void *aux) {
c0029da1:	55                   	push   %ebp
c0029da2:	57                   	push   %edi
c0029da3:	56                   	push   %esi
c0029da4:	53                   	push   %ebx
c0029da5:	83 ec 0c             	sub    $0xc,%esp
c0029da8:	e8 4b 51 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029dad:	81 c3 7b 13 01 00    	add    $0x1137b,%ebx
c0029db3:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0029db7:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    struct list_elem *elem, *next;

    ASSERT (list != NULL);
c0029dbb:	85 ff                	test   %edi,%edi
c0029dbd:	74 1c                	je     c0029ddb <list_unique+0x3a>
    ASSERT (less != NULL);
c0029dbf:	85 ed                	test   %ebp,%ebp
c0029dc1:	74 41                	je     c0029e04 <list_unique+0x63>
    if (list_empty(list))
c0029dc3:	83 ec 0c             	sub    $0xc,%esp
c0029dc6:	57                   	push   %edi
c0029dc7:	e8 7f fa ff ff       	call   c002984b <list_empty>
c0029dcc:	83 c4 10             	add    $0x10,%esp
c0029dcf:	84 c0                	test   %al,%al
c0029dd1:	74 5a                	je     c0029e2d <list_unique+0x8c>
            list_remove(next);
            if (duplicates != NULL)
                list_push_back(duplicates, next);
        } else
            elem = next;
}
c0029dd3:	83 c4 0c             	add    $0xc,%esp
c0029dd6:	5b                   	pop    %ebx
c0029dd7:	5e                   	pop    %esi
c0029dd8:	5f                   	pop    %edi
c0029dd9:	5d                   	pop    %ebp
c0029dda:	c3                   	ret    
    ASSERT (list != NULL);
c0029ddb:	83 ec 0c             	sub    $0xc,%esp
c0029dde:	8d 83 5a 6c ff ff    	lea    -0x93a6(%ebx),%eax
c0029de4:	50                   	push   %eax
c0029de5:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029deb:	50                   	push   %eax
c0029dec:	8d 83 c8 4a ff ff    	lea    -0xb538(%ebx),%eax
c0029df2:	50                   	push   %eax
c0029df3:	68 b1 01 00 00       	push   $0x1b1
c0029df8:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029dfe:	50                   	push   %eax
c0029dff:	e8 d6 f2 ff ff       	call   c00290da <debug_panic>
    ASSERT (less != NULL);
c0029e04:	83 ec 0c             	sub    $0xc,%esp
c0029e07:	8d 83 89 6c ff ff    	lea    -0x9377(%ebx),%eax
c0029e0d:	50                   	push   %eax
c0029e0e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c0029e14:	50                   	push   %eax
c0029e15:	8d 83 c8 4a ff ff    	lea    -0xb538(%ebx),%eax
c0029e1b:	50                   	push   %eax
c0029e1c:	68 b2 01 00 00       	push   $0x1b2
c0029e21:	8d 83 67 6c ff ff    	lea    -0x9399(%ebx),%eax
c0029e27:	50                   	push   %eax
c0029e28:	e8 ad f2 ff ff       	call   c00290da <debug_panic>
    elem = list_begin(list);
c0029e2d:	83 ec 0c             	sub    $0xc,%esp
c0029e30:	57                   	push   %edi
c0029e31:	e8 c9 f3 ff ff       	call   c00291ff <list_begin>
c0029e36:	83 c4 10             	add    $0x10,%esp
c0029e39:	89 c6                	mov    %eax,%esi
    while ((next = list_next(elem)) != list_end(list))
c0029e3b:	eb 04                	jmp    c0029e41 <list_unique+0xa0>
c0029e3d:	89 f3                	mov    %esi,%ebx
c0029e3f:	89 de                	mov    %ebx,%esi
c0029e41:	83 ec 0c             	sub    $0xc,%esp
c0029e44:	56                   	push   %esi
c0029e45:	e8 fa f3 ff ff       	call   c0029244 <list_next>
c0029e4a:	89 c3                	mov    %eax,%ebx
c0029e4c:	89 3c 24             	mov    %edi,(%esp)
c0029e4f:	e8 4d f4 ff ff       	call   c00292a1 <list_end>
c0029e54:	83 c4 10             	add    $0x10,%esp
c0029e57:	39 d8                	cmp    %ebx,%eax
c0029e59:	0f 84 74 ff ff ff    	je     c0029dd3 <list_unique+0x32>
        if (!less(elem, next, aux) && !less(next, elem, aux)) {
c0029e5f:	83 ec 04             	sub    $0x4,%esp
c0029e62:	ff 74 24 30          	pushl  0x30(%esp)
c0029e66:	53                   	push   %ebx
c0029e67:	56                   	push   %esi
c0029e68:	ff d5                	call   *%ebp
c0029e6a:	83 c4 10             	add    $0x10,%esp
c0029e6d:	84 c0                	test   %al,%al
c0029e6f:	75 ce                	jne    c0029e3f <list_unique+0x9e>
c0029e71:	83 ec 04             	sub    $0x4,%esp
c0029e74:	ff 74 24 30          	pushl  0x30(%esp)
c0029e78:	56                   	push   %esi
c0029e79:	53                   	push   %ebx
c0029e7a:	ff d5                	call   *%ebp
c0029e7c:	83 c4 10             	add    $0x10,%esp
c0029e7f:	84 c0                	test   %al,%al
c0029e81:	75 bc                	jne    c0029e3f <list_unique+0x9e>
            list_remove(next);
c0029e83:	83 ec 0c             	sub    $0xc,%esp
c0029e86:	53                   	push   %ebx
c0029e87:	e8 1d f9 ff ff       	call   c00297a9 <list_remove>
            if (duplicates != NULL)
c0029e8c:	83 c4 10             	add    $0x10,%esp
c0029e8f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0029e94:	74 a7                	je     c0029e3d <list_unique+0x9c>
                list_push_back(duplicates, next);
c0029e96:	83 ec 08             	sub    $0x8,%esp
c0029e99:	53                   	push   %ebx
c0029e9a:	ff 74 24 30          	pushl  0x30(%esp)
c0029e9e:	e8 e9 f8 ff ff       	call   c002978c <list_push_back>
c0029ea3:	83 c4 10             	add    $0x10,%esp
c0029ea6:	89 f3                	mov    %esi,%ebx
c0029ea8:	eb 95                	jmp    c0029e3f <list_unique+0x9e>

c0029eaa <list_max>:
/* Returns the element in LIST with the largest value according
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max(struct list *list, list_less_func *less, void *aux) {
c0029eaa:	55                   	push   %ebp
c0029eab:	57                   	push   %edi
c0029eac:	56                   	push   %esi
c0029ead:	53                   	push   %ebx
c0029eae:	83 ec 18             	sub    $0x18,%esp
c0029eb1:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029eb5:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    struct list_elem *max = list_begin(list);
c0029eb9:	57                   	push   %edi
c0029eba:	e8 40 f3 ff ff       	call   c00291ff <list_begin>
c0029ebf:	89 c6                	mov    %eax,%esi
    if (max != list_end(list)) {
c0029ec1:	89 3c 24             	mov    %edi,(%esp)
c0029ec4:	e8 d8 f3 ff ff       	call   c00292a1 <list_end>
c0029ec9:	83 c4 10             	add    $0x10,%esp
c0029ecc:	39 f0                	cmp    %esi,%eax
c0029ece:	74 3c                	je     c0029f0c <list_max+0x62>
        struct list_elem *e;

        for (e = list_next(max); e != list_end(list); e = list_next(e))
c0029ed0:	83 ec 0c             	sub    $0xc,%esp
c0029ed3:	56                   	push   %esi
c0029ed4:	e8 6b f3 ff ff       	call   c0029244 <list_next>
c0029ed9:	83 c4 10             	add    $0x10,%esp
c0029edc:	89 c3                	mov    %eax,%ebx
c0029ede:	83 ec 0c             	sub    $0xc,%esp
c0029ee1:	57                   	push   %edi
c0029ee2:	e8 ba f3 ff ff       	call   c00292a1 <list_end>
c0029ee7:	83 c4 10             	add    $0x10,%esp
c0029eea:	39 d8                	cmp    %ebx,%eax
c0029eec:	74 1e                	je     c0029f0c <list_max+0x62>
            if (less(max, e, aux))
c0029eee:	83 ec 04             	sub    $0x4,%esp
c0029ef1:	55                   	push   %ebp
c0029ef2:	53                   	push   %ebx
c0029ef3:	56                   	push   %esi
c0029ef4:	ff 54 24 34          	call   *0x34(%esp)
c0029ef8:	84 c0                	test   %al,%al
                max = e;
c0029efa:	0f 45 f3             	cmovne %ebx,%esi
        for (e = list_next(max); e != list_end(list); e = list_next(e))
c0029efd:	89 1c 24             	mov    %ebx,(%esp)
c0029f00:	e8 3f f3 ff ff       	call   c0029244 <list_next>
c0029f05:	83 c4 10             	add    $0x10,%esp
c0029f08:	89 c3                	mov    %eax,%ebx
c0029f0a:	eb d2                	jmp    c0029ede <list_max+0x34>
    }
    return max;
}
c0029f0c:	89 f0                	mov    %esi,%eax
c0029f0e:	83 c4 0c             	add    $0xc,%esp
c0029f11:	5b                   	pop    %ebx
c0029f12:	5e                   	pop    %esi
c0029f13:	5f                   	pop    %edi
c0029f14:	5d                   	pop    %ebp
c0029f15:	c3                   	ret    

c0029f16 <list_min>:
/* Returns the element in LIST with the smallest value according
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min(struct list *list, list_less_func *less, void *aux) {
c0029f16:	55                   	push   %ebp
c0029f17:	57                   	push   %edi
c0029f18:	56                   	push   %esi
c0029f19:	53                   	push   %ebx
c0029f1a:	83 ec 18             	sub    $0x18,%esp
c0029f1d:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029f21:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    struct list_elem *min = list_begin(list);
c0029f25:	57                   	push   %edi
c0029f26:	e8 d4 f2 ff ff       	call   c00291ff <list_begin>
c0029f2b:	89 c6                	mov    %eax,%esi
    if (min != list_end(list)) {
c0029f2d:	89 3c 24             	mov    %edi,(%esp)
c0029f30:	e8 6c f3 ff ff       	call   c00292a1 <list_end>
c0029f35:	83 c4 10             	add    $0x10,%esp
c0029f38:	39 f0                	cmp    %esi,%eax
c0029f3a:	74 3c                	je     c0029f78 <list_min+0x62>
        struct list_elem *e;

        for (e = list_next(min); e != list_end(list); e = list_next(e))
c0029f3c:	83 ec 0c             	sub    $0xc,%esp
c0029f3f:	56                   	push   %esi
c0029f40:	e8 ff f2 ff ff       	call   c0029244 <list_next>
c0029f45:	83 c4 10             	add    $0x10,%esp
c0029f48:	89 c3                	mov    %eax,%ebx
c0029f4a:	83 ec 0c             	sub    $0xc,%esp
c0029f4d:	57                   	push   %edi
c0029f4e:	e8 4e f3 ff ff       	call   c00292a1 <list_end>
c0029f53:	83 c4 10             	add    $0x10,%esp
c0029f56:	39 d8                	cmp    %ebx,%eax
c0029f58:	74 1e                	je     c0029f78 <list_min+0x62>
            if (less(e, min, aux))
c0029f5a:	83 ec 04             	sub    $0x4,%esp
c0029f5d:	55                   	push   %ebp
c0029f5e:	56                   	push   %esi
c0029f5f:	53                   	push   %ebx
c0029f60:	ff 54 24 34          	call   *0x34(%esp)
c0029f64:	84 c0                	test   %al,%al
                min = e;
c0029f66:	0f 45 f3             	cmovne %ebx,%esi
        for (e = list_next(min); e != list_end(list); e = list_next(e))
c0029f69:	89 1c 24             	mov    %ebx,(%esp)
c0029f6c:	e8 d3 f2 ff ff       	call   c0029244 <list_next>
c0029f71:	83 c4 10             	add    $0x10,%esp
c0029f74:	89 c3                	mov    %eax,%ebx
c0029f76:	eb d2                	jmp    c0029f4a <list_min+0x34>
    }
    return min;
}
c0029f78:	89 f0                	mov    %esi,%eax
c0029f7a:	83 c4 0c             	add    $0xc,%esp
c0029f7d:	5b                   	pop    %ebx
c0029f7e:	5e                   	pop    %esi
c0029f7f:	5f                   	pop    %edi
c0029f80:	5d                   	pop    %ebp
c0029f81:	c3                   	ret    

c0029f82 <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029f82:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029f86:	83 c0 1f             	add    $0x1f,%eax
c0029f89:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c0029f8c:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c0029f93:	c3                   	ret    

c0029f94 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c0029f94:	56                   	push   %esi
c0029f95:	53                   	push   %ebx
c0029f96:	83 ec 04             	sub    $0x4,%esp
c0029f99:	e8 5a 4f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c0029f9e:	81 c3 8a 11 01 00    	add    $0x1118a,%ebx
c0029fa4:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (b != NULL) 
c0029fa8:	85 f6                	test   %esi,%esi
c0029faa:	74 16                	je     c0029fc2 <bitmap_destroy+0x2e>
    {
      free (b->bits);
c0029fac:	83 ec 0c             	sub    $0xc,%esp
c0029faf:	ff 76 04             	pushl  0x4(%esi)
c0029fb2:	e8 f2 9f ff ff       	call   c0023fa9 <free>
      free (b);
c0029fb7:	89 34 24             	mov    %esi,(%esp)
c0029fba:	e8 ea 9f ff ff       	call   c0023fa9 <free>
c0029fbf:	83 c4 10             	add    $0x10,%esp
    }
}
c0029fc2:	83 c4 04             	add    $0x4,%esp
c0029fc5:	5b                   	pop    %ebx
c0029fc6:	5e                   	pop    %esi
c0029fc7:	c3                   	ret    

c0029fc8 <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c0029fc8:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029fcc:	8b 00                	mov    (%eax),%eax
}
c0029fce:	c3                   	ret    

c0029fcf <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c0029fcf:	53                   	push   %ebx
c0029fd0:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029fd4:	89 cb                	mov    %ecx,%ebx
c0029fd6:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029fd9:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029fdd:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029fe0:	b8 01 00 00 00       	mov    $0x1,%eax
c0029fe5:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029fe7:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c0029fea:	5b                   	pop    %ebx
c0029feb:	c3                   	ret    

c0029fec <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c0029fec:	53                   	push   %ebx
c0029fed:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029ff1:	89 cb                	mov    %ecx,%ebx
c0029ff3:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0029ff6:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029ffa:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029ffd:	b8 01 00 00 00       	mov    $0x1,%eax
c002a002:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a004:	f7 d0                	not    %eax
c002a006:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c002a009:	5b                   	pop    %ebx
c002a00a:	c3                   	ret    

c002a00b <bitmap_set>:
{
c002a00b:	53                   	push   %ebx
c002a00c:	83 ec 08             	sub    $0x8,%esp
c002a00f:	e8 e4 4e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a014:	81 c3 14 11 01 00    	add    $0x11114,%ebx
c002a01a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a01e:	8b 54 24 14          	mov    0x14(%esp),%edx
c002a022:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c002a026:	85 c0                	test   %eax,%eax
c002a028:	74 1a                	je     c002a044 <bitmap_set+0x39>
  ASSERT (idx < b->bit_cnt);
c002a02a:	39 10                	cmp    %edx,(%eax)
c002a02c:	76 3f                	jbe    c002a06d <bitmap_set+0x62>
  if (value)
c002a02e:	84 c9                	test   %cl,%cl
c002a030:	74 64                	je     c002a096 <bitmap_set+0x8b>
    bitmap_mark (b, idx);
c002a032:	83 ec 08             	sub    $0x8,%esp
c002a035:	52                   	push   %edx
c002a036:	50                   	push   %eax
c002a037:	e8 93 ff ff ff       	call   c0029fcf <bitmap_mark>
c002a03c:	83 c4 10             	add    $0x10,%esp
}
c002a03f:	83 c4 08             	add    $0x8,%esp
c002a042:	5b                   	pop    %ebx
c002a043:	c3                   	ret    
  ASSERT (b != NULL);
c002a044:	83 ec 0c             	sub    $0xc,%esp
c002a047:	8d 83 7f 6c ff ff    	lea    -0x9381(%ebx),%eax
c002a04d:	50                   	push   %eax
c002a04e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a054:	50                   	push   %eax
c002a055:	8d 83 18 4c ff ff    	lea    -0xb3e8(%ebx),%eax
c002a05b:	50                   	push   %eax
c002a05c:	68 93 00 00 00       	push   $0x93
c002a061:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a067:	50                   	push   %eax
c002a068:	e8 6d f0 ff ff       	call   c00290da <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a06d:	83 ec 0c             	sub    $0xc,%esp
c002a070:	8d 83 19 6e ff ff    	lea    -0x91e7(%ebx),%eax
c002a076:	50                   	push   %eax
c002a077:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a07d:	50                   	push   %eax
c002a07e:	8d 83 18 4c ff ff    	lea    -0xb3e8(%ebx),%eax
c002a084:	50                   	push   %eax
c002a085:	68 94 00 00 00       	push   $0x94
c002a08a:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a090:	50                   	push   %eax
c002a091:	e8 44 f0 ff ff       	call   c00290da <debug_panic>
    bitmap_reset (b, idx);
c002a096:	83 ec 08             	sub    $0x8,%esp
c002a099:	52                   	push   %edx
c002a09a:	50                   	push   %eax
c002a09b:	e8 4c ff ff ff       	call   c0029fec <bitmap_reset>
c002a0a0:	83 c4 10             	add    $0x10,%esp
}
c002a0a3:	eb 9a                	jmp    c002a03f <bitmap_set+0x34>

c002a0a5 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002a0a5:	53                   	push   %ebx
c002a0a6:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a0aa:	89 cb                	mov    %ecx,%ebx
c002a0ac:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a0af:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a0b3:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a0b6:	b8 01 00 00 00       	mov    $0x1,%eax
c002a0bb:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a0bd:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c002a0c0:	5b                   	pop    %ebx
c002a0c1:	c3                   	ret    

c002a0c2 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002a0c2:	53                   	push   %ebx
c002a0c3:	83 ec 08             	sub    $0x8,%esp
c002a0c6:	e8 2d 4e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a0cb:	81 c3 5d 10 01 00    	add    $0x1105d,%ebx
c002a0d1:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a0d5:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c002a0d9:	85 c0                	test   %eax,%eax
c002a0db:	74 1e                	je     c002a0fb <bitmap_test+0x39>
  ASSERT (idx < b->bit_cnt);
c002a0dd:	39 08                	cmp    %ecx,(%eax)
c002a0df:	76 43                	jbe    c002a124 <bitmap_test+0x62>
  return bit_idx / ELEM_BITS;
c002a0e1:	89 cb                	mov    %ecx,%ebx
c002a0e3:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a0e6:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a0e9:	b8 01 00 00 00       	mov    $0x1,%eax
c002a0ee:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a0f0:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c002a0f3:	0f 95 c0             	setne  %al
}
c002a0f6:	83 c4 08             	add    $0x8,%esp
c002a0f9:	5b                   	pop    %ebx
c002a0fa:	c3                   	ret    
  ASSERT (b != NULL);
c002a0fb:	83 ec 0c             	sub    $0xc,%esp
c002a0fe:	8d 83 7f 6c ff ff    	lea    -0x9381(%ebx),%eax
c002a104:	50                   	push   %eax
c002a105:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a10b:	50                   	push   %eax
c002a10c:	8d 83 0c 4c ff ff    	lea    -0xb3f4(%ebx),%eax
c002a112:	50                   	push   %eax
c002a113:	68 c8 00 00 00       	push   $0xc8
c002a118:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a11e:	50                   	push   %eax
c002a11f:	e8 b6 ef ff ff       	call   c00290da <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a124:	83 ec 0c             	sub    $0xc,%esp
c002a127:	8d 83 19 6e ff ff    	lea    -0x91e7(%ebx),%eax
c002a12d:	50                   	push   %eax
c002a12e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a134:	50                   	push   %eax
c002a135:	8d 83 0c 4c ff ff    	lea    -0xb3f4(%ebx),%eax
c002a13b:	50                   	push   %eax
c002a13c:	68 c9 00 00 00       	push   $0xc9
c002a141:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a147:	50                   	push   %eax
c002a148:	e8 8d ef ff ff       	call   c00290da <debug_panic>

c002a14d <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a14d:	55                   	push   %ebp
c002a14e:	57                   	push   %edi
c002a14f:	56                   	push   %esi
c002a150:	53                   	push   %ebx
c002a151:	83 ec 0c             	sub    $0xc,%esp
c002a154:	e8 b3 4d 00 00       	call   c002ef0c <__x86.get_pc_thunk.cx>
c002a159:	81 c1 cf 0f 01 00    	add    $0x10fcf,%ecx
c002a15f:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a163:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a167:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a16b:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a170:	85 ff                	test   %edi,%edi
c002a172:	74 31                	je     c002a1a5 <bitmap_set_multiple+0x58>
  ASSERT (start <= b->bit_cnt);
c002a174:	8b 17                	mov    (%edi),%edx
c002a176:	39 f2                	cmp    %esi,%edx
c002a178:	72 56                	jb     c002a1d0 <bitmap_set_multiple+0x83>
  ASSERT (start + cnt <= b->bit_cnt);
c002a17a:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a17d:	39 ea                	cmp    %ebp,%edx
c002a17f:	72 7a                	jb     c002a1fb <bitmap_set_multiple+0xae>

  for (i = 0; i < cnt; i++)
    bitmap_set (b, start + i, value);
c002a181:	0f b6 db             	movzbl %bl,%ebx
  for (i = 0; i < cnt; i++)
c002a184:	85 c0                	test   %eax,%eax
c002a186:	74 15                	je     c002a19d <bitmap_set_multiple+0x50>
    bitmap_set (b, start + i, value);
c002a188:	83 ec 04             	sub    $0x4,%esp
c002a18b:	53                   	push   %ebx
c002a18c:	56                   	push   %esi
c002a18d:	57                   	push   %edi
c002a18e:	e8 78 fe ff ff       	call   c002a00b <bitmap_set>
c002a193:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a196:	83 c4 10             	add    $0x10,%esp
c002a199:	39 f5                	cmp    %esi,%ebp
c002a19b:	75 eb                	jne    c002a188 <bitmap_set_multiple+0x3b>
}
c002a19d:	83 c4 0c             	add    $0xc,%esp
c002a1a0:	5b                   	pop    %ebx
c002a1a1:	5e                   	pop    %esi
c002a1a2:	5f                   	pop    %edi
c002a1a3:	5d                   	pop    %ebp
c002a1a4:	c3                   	ret    
  ASSERT (b != NULL);
c002a1a5:	83 ec 0c             	sub    $0xc,%esp
c002a1a8:	8d 81 7f 6c ff ff    	lea    -0x9381(%ecx),%eax
c002a1ae:	50                   	push   %eax
c002a1af:	8d 81 94 4f ff ff    	lea    -0xb06c(%ecx),%eax
c002a1b5:	50                   	push   %eax
c002a1b6:	8d 81 e8 4b ff ff    	lea    -0xb418(%ecx),%eax
c002a1bc:	50                   	push   %eax
c002a1bd:	68 de 00 00 00       	push   $0xde
c002a1c2:	8d 81 ff 6d ff ff    	lea    -0x9201(%ecx),%eax
c002a1c8:	50                   	push   %eax
c002a1c9:	89 cb                	mov    %ecx,%ebx
c002a1cb:	e8 0a ef ff ff       	call   c00290da <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a1d0:	83 ec 0c             	sub    $0xc,%esp
c002a1d3:	8d 81 2a 6e ff ff    	lea    -0x91d6(%ecx),%eax
c002a1d9:	50                   	push   %eax
c002a1da:	8d 81 94 4f ff ff    	lea    -0xb06c(%ecx),%eax
c002a1e0:	50                   	push   %eax
c002a1e1:	8d 81 e8 4b ff ff    	lea    -0xb418(%ecx),%eax
c002a1e7:	50                   	push   %eax
c002a1e8:	68 df 00 00 00       	push   $0xdf
c002a1ed:	8d 81 ff 6d ff ff    	lea    -0x9201(%ecx),%eax
c002a1f3:	50                   	push   %eax
c002a1f4:	89 cb                	mov    %ecx,%ebx
c002a1f6:	e8 df ee ff ff       	call   c00290da <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a1fb:	83 ec 0c             	sub    $0xc,%esp
c002a1fe:	8d 81 3e 6e ff ff    	lea    -0x91c2(%ecx),%eax
c002a204:	50                   	push   %eax
c002a205:	8d 81 94 4f ff ff    	lea    -0xb06c(%ecx),%eax
c002a20b:	50                   	push   %eax
c002a20c:	8d 81 e8 4b ff ff    	lea    -0xb418(%ecx),%eax
c002a212:	50                   	push   %eax
c002a213:	68 e0 00 00 00       	push   $0xe0
c002a218:	8d 81 ff 6d ff ff    	lea    -0x9201(%ecx),%eax
c002a21e:	50                   	push   %eax
c002a21f:	89 cb                	mov    %ecx,%ebx
c002a221:	e8 b4 ee ff ff       	call   c00290da <debug_panic>

c002a226 <bitmap_set_all>:
{
c002a226:	53                   	push   %ebx
c002a227:	83 ec 08             	sub    $0x8,%esp
c002a22a:	e8 c9 4c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a22f:	81 c3 f9 0e 01 00    	add    $0x10ef9,%ebx
c002a235:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a239:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c002a23d:	85 c0                	test   %eax,%eax
c002a23f:	74 13                	je     c002a254 <bitmap_set_all+0x2e>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a241:	0f b6 d2             	movzbl %dl,%edx
c002a244:	52                   	push   %edx
c002a245:	ff 30                	pushl  (%eax)
c002a247:	6a 00                	push   $0x0
c002a249:	50                   	push   %eax
c002a24a:	e8 fe fe ff ff       	call   c002a14d <bitmap_set_multiple>
}
c002a24f:	83 c4 18             	add    $0x18,%esp
c002a252:	5b                   	pop    %ebx
c002a253:	c3                   	ret    
  ASSERT (b != NULL);
c002a254:	83 ec 0c             	sub    $0xc,%esp
c002a257:	8d 83 7f 6c ff ff    	lea    -0x9381(%ebx),%eax
c002a25d:	50                   	push   %eax
c002a25e:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a264:	50                   	push   %eax
c002a265:	8d 83 fc 4b ff ff    	lea    -0xb404(%ebx),%eax
c002a26b:	50                   	push   %eax
c002a26c:	68 d3 00 00 00       	push   $0xd3
c002a271:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a277:	50                   	push   %eax
c002a278:	e8 5d ee ff ff       	call   c00290da <debug_panic>

c002a27d <bitmap_create>:
{
c002a27d:	57                   	push   %edi
c002a27e:	56                   	push   %esi
c002a27f:	53                   	push   %ebx
c002a280:	e8 73 4c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a285:	81 c3 a3 0e 01 00    	add    $0x10ea3,%ebx
c002a28b:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct bitmap *b = malloc (sizeof *b);
c002a28f:	83 ec 0c             	sub    $0xc,%esp
c002a292:	6a 08                	push   $0x8
c002a294:	e8 62 9b ff ff       	call   c0023dfb <malloc>
c002a299:	89 c6                	mov    %eax,%esi
  if (b != NULL)
c002a29b:	83 c4 10             	add    $0x10,%esp
c002a29e:	85 c0                	test   %eax,%eax
c002a2a0:	74 30                	je     c002a2d2 <bitmap_create+0x55>
      b->bit_cnt = bit_cnt;
c002a2a2:	89 38                	mov    %edi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a2a4:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a2a7:	8d 47 1f             	lea    0x1f(%edi),%eax
c002a2aa:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a2ad:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c002a2b0:	50                   	push   %eax
c002a2b1:	e8 45 9b ff ff       	call   c0023dfb <malloc>
c002a2b6:	89 46 04             	mov    %eax,0x4(%esi)
      if (b->bits != NULL || bit_cnt == 0)
c002a2b9:	83 c4 10             	add    $0x10,%esp
c002a2bc:	85 ff                	test   %edi,%edi
c002a2be:	74 04                	je     c002a2c4 <bitmap_create+0x47>
c002a2c0:	85 c0                	test   %eax,%eax
c002a2c2:	74 14                	je     c002a2d8 <bitmap_create+0x5b>
          bitmap_set_all (b, false);
c002a2c4:	83 ec 08             	sub    $0x8,%esp
c002a2c7:	6a 00                	push   $0x0
c002a2c9:	56                   	push   %esi
c002a2ca:	e8 57 ff ff ff       	call   c002a226 <bitmap_set_all>
          return b;
c002a2cf:	83 c4 10             	add    $0x10,%esp
}
c002a2d2:	89 f0                	mov    %esi,%eax
c002a2d4:	5b                   	pop    %ebx
c002a2d5:	5e                   	pop    %esi
c002a2d6:	5f                   	pop    %edi
c002a2d7:	c3                   	ret    
      free (b);
c002a2d8:	83 ec 0c             	sub    $0xc,%esp
c002a2db:	56                   	push   %esi
c002a2dc:	e8 c8 9c ff ff       	call   c0023fa9 <free>
c002a2e1:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002a2e4:	be 00 00 00 00       	mov    $0x0,%esi
c002a2e9:	eb e7                	jmp    c002a2d2 <bitmap_create+0x55>

c002a2eb <bitmap_create_in_buf>:
{
c002a2eb:	57                   	push   %edi
c002a2ec:	56                   	push   %esi
c002a2ed:	53                   	push   %ebx
c002a2ee:	e8 05 4c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a2f3:	81 c3 35 0e 01 00    	add    $0x10e35,%ebx
c002a2f9:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002a2fd:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a301:	57                   	push   %edi
c002a302:	e8 7b fc ff ff       	call   c0029f82 <bitmap_buf_size>
c002a307:	83 c4 04             	add    $0x4,%esp
c002a30a:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002a30e:	77 1c                	ja     c002a32c <bitmap_create_in_buf+0x41>
  b->bit_cnt = bit_cnt;
c002a310:	89 3e                	mov    %edi,(%esi)
  b->bits = (elem_type *) (b + 1);
c002a312:	8d 46 08             	lea    0x8(%esi),%eax
c002a315:	89 46 04             	mov    %eax,0x4(%esi)
  bitmap_set_all (b, false);
c002a318:	83 ec 08             	sub    $0x8,%esp
c002a31b:	6a 00                	push   $0x0
c002a31d:	56                   	push   %esi
c002a31e:	e8 03 ff ff ff       	call   c002a226 <bitmap_set_all>
  return b;
c002a323:	83 c4 10             	add    $0x10,%esp
}
c002a326:	89 f0                	mov    %esi,%eax
c002a328:	5b                   	pop    %ebx
c002a329:	5e                   	pop    %esi
c002a32a:	5f                   	pop    %edi
c002a32b:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a32c:	83 ec 0c             	sub    $0xc,%esp
c002a32f:	8d 83 58 6e ff ff    	lea    -0x91a8(%ebx),%eax
c002a335:	50                   	push   %eax
c002a336:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a33c:	50                   	push   %eax
c002a33d:	8d 83 24 4c ff ff    	lea    -0xb3dc(%ebx),%eax
c002a343:	50                   	push   %eax
c002a344:	6a 68                	push   $0x68
c002a346:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a34c:	50                   	push   %eax
c002a34d:	e8 88 ed ff ff       	call   c00290da <debug_panic>

c002a352 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a352:	55                   	push   %ebp
c002a353:	57                   	push   %edi
c002a354:	56                   	push   %esi
c002a355:	53                   	push   %ebx
c002a356:	83 ec 1c             	sub    $0x1c,%esp
c002a359:	e8 9a 4b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a35e:	81 c3 ca 0d 01 00    	add    $0x10dca,%ebx
c002a364:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a368:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a36c:	8b 44 24 38          	mov    0x38(%esp),%eax
c002a370:	0f b6 54 24 3c       	movzbl 0x3c(%esp),%edx
c002a375:	88 54 24 0f          	mov    %dl,0xf(%esp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002a379:	85 ff                	test   %edi,%edi
c002a37b:	74 44                	je     c002a3c1 <bitmap_count+0x6f>
  ASSERT (start <= b->bit_cnt);
c002a37d:	8b 17                	mov    (%edi),%edx
c002a37f:	39 f2                	cmp    %esi,%edx
c002a381:	72 67                	jb     c002a3ea <bitmap_count+0x98>
  ASSERT (start + cnt <= b->bit_cnt);
c002a383:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a386:	39 ea                	cmp    %ebp,%edx
c002a388:	0f 82 89 00 00 00    	jb     c002a417 <bitmap_count+0xc5>

  value_cnt = 0;
c002a38e:	bb 00 00 00 00       	mov    $0x0,%ebx
  for (i = 0; i < cnt; i++)
c002a393:	85 c0                	test   %eax,%eax
c002a395:	74 7c                	je     c002a413 <bitmap_count+0xc1>
    if (bitmap_test (b, start + i) == value)
c002a397:	83 ec 08             	sub    $0x8,%esp
c002a39a:	56                   	push   %esi
c002a39b:	57                   	push   %edi
c002a39c:	e8 21 fd ff ff       	call   c002a0c2 <bitmap_test>
c002a3a1:	83 c4 10             	add    $0x10,%esp
      value_cnt++;
c002a3a4:	3a 44 24 0f          	cmp    0xf(%esp),%al
c002a3a8:	0f 94 c0             	sete   %al
c002a3ab:	0f b6 c0             	movzbl %al,%eax
c002a3ae:	01 c3                	add    %eax,%ebx
c002a3b0:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a3b3:	39 f5                	cmp    %esi,%ebp
c002a3b5:	75 e0                	jne    c002a397 <bitmap_count+0x45>
  return value_cnt;
}
c002a3b7:	89 d8                	mov    %ebx,%eax
c002a3b9:	83 c4 1c             	add    $0x1c,%esp
c002a3bc:	5b                   	pop    %ebx
c002a3bd:	5e                   	pop    %esi
c002a3be:	5f                   	pop    %edi
c002a3bf:	5d                   	pop    %ebp
c002a3c0:	c3                   	ret    
  ASSERT (b != NULL);
c002a3c1:	83 ec 0c             	sub    $0xc,%esp
c002a3c4:	8d 83 7f 6c ff ff    	lea    -0x9381(%ebx),%eax
c002a3ca:	50                   	push   %eax
c002a3cb:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a3d1:	50                   	push   %eax
c002a3d2:	8d 83 d8 4b ff ff    	lea    -0xb428(%ebx),%eax
c002a3d8:	50                   	push   %eax
c002a3d9:	68 ed 00 00 00       	push   $0xed
c002a3de:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a3e4:	50                   	push   %eax
c002a3e5:	e8 f0 ec ff ff       	call   c00290da <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a3ea:	83 ec 0c             	sub    $0xc,%esp
c002a3ed:	8d 83 2a 6e ff ff    	lea    -0x91d6(%ebx),%eax
c002a3f3:	50                   	push   %eax
c002a3f4:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a3fa:	50                   	push   %eax
c002a3fb:	8d 83 d8 4b ff ff    	lea    -0xb428(%ebx),%eax
c002a401:	50                   	push   %eax
c002a402:	68 ee 00 00 00       	push   $0xee
c002a407:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a40d:	50                   	push   %eax
c002a40e:	e8 c7 ec ff ff       	call   c00290da <debug_panic>
  value_cnt = 0;
c002a413:	89 c3                	mov    %eax,%ebx
c002a415:	eb a0                	jmp    c002a3b7 <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c002a417:	83 ec 0c             	sub    $0xc,%esp
c002a41a:	8d 83 3e 6e ff ff    	lea    -0x91c2(%ebx),%eax
c002a420:	50                   	push   %eax
c002a421:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a427:	50                   	push   %eax
c002a428:	8d 83 d8 4b ff ff    	lea    -0xb428(%ebx),%eax
c002a42e:	50                   	push   %eax
c002a42f:	68 ef 00 00 00       	push   $0xef
c002a434:	8d 83 ff 6d ff ff    	lea    -0x9201(%ebx),%eax
c002a43a:	50                   	push   %eax
c002a43b:	e8 9a ec ff ff       	call   c00290da <debug_panic>

c002a440 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a440:	55                   	push   %ebp
c002a441:	57                   	push   %edi
c002a442:	56                   	push   %esi
c002a443:	53                   	push   %ebx
c002a444:	83 ec 0c             	sub    $0xc,%esp
c002a447:	e8 c0 4a 00 00       	call   c002ef0c <__x86.get_pc_thunk.cx>
c002a44c:	81 c1 dc 0c 01 00    	add    $0x10cdc,%ecx
c002a452:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a456:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a45a:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a45e:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a463:	85 ff                	test   %edi,%edi
c002a465:	74 3f                	je     c002a4a6 <bitmap_contains+0x66>
  ASSERT (start <= b->bit_cnt);
c002a467:	8b 17                	mov    (%edi),%edx
c002a469:	39 f2                	cmp    %esi,%edx
c002a46b:	72 64                	jb     c002a4d1 <bitmap_contains+0x91>
  ASSERT (start + cnt <= b->bit_cnt);
c002a46d:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a470:	39 ea                	cmp    %ebp,%edx
c002a472:	0f 82 84 00 00 00    	jb     c002a4fc <bitmap_contains+0xbc>

  for (i = 0; i < cnt; i++)
c002a478:	85 c0                	test   %eax,%eax
c002a47a:	0f 84 ac 00 00 00    	je     c002a52c <bitmap_contains+0xec>
    if (bitmap_test (b, start + i) == value)
c002a480:	83 ec 08             	sub    $0x8,%esp
c002a483:	56                   	push   %esi
c002a484:	57                   	push   %edi
c002a485:	e8 38 fc ff ff       	call   c002a0c2 <bitmap_test>
c002a48a:	83 c4 10             	add    $0x10,%esp
c002a48d:	38 d8                	cmp    %bl,%al
c002a48f:	0f 84 92 00 00 00    	je     c002a527 <bitmap_contains+0xe7>
c002a495:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a498:	39 f5                	cmp    %esi,%ebp
c002a49a:	75 e4                	jne    c002a480 <bitmap_contains+0x40>
      return true;
  return false;
c002a49c:	b8 00 00 00 00       	mov    $0x0,%eax
c002a4a1:	e9 86 00 00 00       	jmp    c002a52c <bitmap_contains+0xec>
  ASSERT (b != NULL);
c002a4a6:	83 ec 0c             	sub    $0xc,%esp
c002a4a9:	8d 81 7f 6c ff ff    	lea    -0x9381(%ecx),%eax
c002a4af:	50                   	push   %eax
c002a4b0:	8d 81 94 4f ff ff    	lea    -0xb06c(%ecx),%eax
c002a4b6:	50                   	push   %eax
c002a4b7:	8d 81 c8 4b ff ff    	lea    -0xb438(%ecx),%eax
c002a4bd:	50                   	push   %eax
c002a4be:	68 ff 00 00 00       	push   $0xff
c002a4c3:	8d 81 ff 6d ff ff    	lea    -0x9201(%ecx),%eax
c002a4c9:	50                   	push   %eax
c002a4ca:	89 cb                	mov    %ecx,%ebx
c002a4cc:	e8 09 ec ff ff       	call   c00290da <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a4d1:	83 ec 0c             	sub    $0xc,%esp
c002a4d4:	8d 81 2a 6e ff ff    	lea    -0x91d6(%ecx),%eax
c002a4da:	50                   	push   %eax
c002a4db:	8d 81 94 4f ff ff    	lea    -0xb06c(%ecx),%eax
c002a4e1:	50                   	push   %eax
c002a4e2:	8d 81 c8 4b ff ff    	lea    -0xb438(%ecx),%eax
c002a4e8:	50                   	push   %eax
c002a4e9:	68 00 01 00 00       	push   $0x100
c002a4ee:	8d 81 ff 6d ff ff    	lea    -0x9201(%ecx),%eax
c002a4f4:	50                   	push   %eax
c002a4f5:	89 cb                	mov    %ecx,%ebx
c002a4f7:	e8 de eb ff ff       	call   c00290da <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a4fc:	83 ec 0c             	sub    $0xc,%esp
c002a4ff:	8d 81 3e 6e ff ff    	lea    -0x91c2(%ecx),%eax
c002a505:	50                   	push   %eax
c002a506:	8d 81 94 4f ff ff    	lea    -0xb06c(%ecx),%eax
c002a50c:	50                   	push   %eax
c002a50d:	8d 81 c8 4b ff ff    	lea    -0xb438(%ecx),%eax
c002a513:	50                   	push   %eax
c002a514:	68 01 01 00 00       	push   $0x101
c002a519:	8d 81 ff 6d ff ff    	lea    -0x9201(%ecx),%eax
c002a51f:	50                   	push   %eax
c002a520:	89 cb                	mov    %ecx,%ebx
c002a522:	e8 b3 eb ff ff       	call   c00290da <debug_panic>
      return true;
c002a527:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a52c:	83 c4 0c             	add    $0xc,%esp
c002a52f:	5b                   	pop    %ebx
c002a530:	5e                   	pop    %esi
c002a531:	5f                   	pop    %edi
c002a532:	5d                   	pop    %ebp
c002a533:	c3                   	ret    

c002a534 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a534:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c002a537:	6a 01                	push   $0x1
c002a539:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a53d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a541:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a545:	e8 f6 fe ff ff       	call   c002a440 <bitmap_contains>
}
c002a54a:	83 c4 1c             	add    $0x1c,%esp
c002a54d:	c3                   	ret    

c002a54e <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a54e:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c002a551:	6a 01                	push   $0x1
c002a553:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a557:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a55b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a55f:	e8 dc fe ff ff       	call   c002a440 <bitmap_contains>
c002a564:	83 f0 01             	xor    $0x1,%eax
}
c002a567:	83 c4 1c             	add    $0x1c,%esp
c002a56a:	c3                   	ret    

c002a56b <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a56b:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c002a56e:	6a 00                	push   $0x0
c002a570:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a574:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a578:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a57c:	e8 bf fe ff ff       	call   c002a440 <bitmap_contains>
c002a581:	83 f0 01             	xor    $0x1,%eax
}
c002a584:	83 c4 1c             	add    $0x1c,%esp
c002a587:	c3                   	ret    

c002a588 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a588:	55                   	push   %ebp
c002a589:	57                   	push   %edi
c002a58a:	56                   	push   %esi
c002a58b:	53                   	push   %ebx
c002a58c:	83 ec 1c             	sub    $0x1c,%esp
c002a58f:	e8 68 49 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c002a594:	05 94 0b 01 00       	add    $0x10b94,%eax
c002a599:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a59d:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a5a1:	8b 6c 24 38          	mov    0x38(%esp),%ebp
c002a5a5:	0f b6 5c 24 3c       	movzbl 0x3c(%esp),%ebx
  ASSERT (b != NULL);
c002a5aa:	85 ff                	test   %edi,%edi
c002a5ac:	74 43                	je     c002a5f1 <bitmap_scan+0x69>
  ASSERT (start <= b->bit_cnt);
c002a5ae:	8b 17                	mov    (%edi),%edx
c002a5b0:	39 f2                	cmp    %esi,%edx
c002a5b2:	72 68                	jb     c002a61c <bitmap_scan+0x94>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002a5b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  if (cnt <= b->bit_cnt) 
c002a5b9:	39 ea                	cmp    %ebp,%edx
c002a5bb:	0f 82 8f 00 00 00    	jb     c002a650 <bitmap_scan+0xc8>
      size_t last = b->bit_cnt - cnt;
c002a5c1:	29 ea                	sub    %ebp,%edx
c002a5c3:	89 54 24 0c          	mov    %edx,0xc(%esp)
      for (i = start; i <= last; i++)
c002a5c7:	39 d6                	cmp    %edx,%esi
c002a5c9:	77 7c                	ja     c002a647 <bitmap_scan+0xbf>
        if (!bitmap_contains (b, i, cnt, !value))
c002a5cb:	83 f3 01             	xor    $0x1,%ebx
c002a5ce:	0f b6 db             	movzbl %bl,%ebx
c002a5d1:	53                   	push   %ebx
c002a5d2:	55                   	push   %ebp
c002a5d3:	56                   	push   %esi
c002a5d4:	57                   	push   %edi
c002a5d5:	e8 66 fe ff ff       	call   c002a440 <bitmap_contains>
c002a5da:	83 c4 10             	add    $0x10,%esp
c002a5dd:	84 c0                	test   %al,%al
c002a5df:	74 6d                	je     c002a64e <bitmap_scan+0xc6>
      for (i = start; i <= last; i++)
c002a5e1:	83 c6 01             	add    $0x1,%esi
c002a5e4:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c002a5e8:	73 e7                	jae    c002a5d1 <bitmap_scan+0x49>
  return BITMAP_ERROR;
c002a5ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a5ef:	eb 5f                	jmp    c002a650 <bitmap_scan+0xc8>
  ASSERT (b != NULL);
c002a5f1:	83 ec 0c             	sub    $0xc,%esp
c002a5f4:	8d 90 7f 6c ff ff    	lea    -0x9381(%eax),%edx
c002a5fa:	52                   	push   %edx
c002a5fb:	8d 90 94 4f ff ff    	lea    -0xb06c(%eax),%edx
c002a601:	52                   	push   %edx
c002a602:	8d 90 bc 4b ff ff    	lea    -0xb444(%eax),%edx
c002a608:	52                   	push   %edx
c002a609:	68 2a 01 00 00       	push   $0x12a
c002a60e:	8d 90 ff 6d ff ff    	lea    -0x9201(%eax),%edx
c002a614:	52                   	push   %edx
c002a615:	89 c3                	mov    %eax,%ebx
c002a617:	e8 be ea ff ff       	call   c00290da <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a61c:	83 ec 0c             	sub    $0xc,%esp
c002a61f:	8d 90 2a 6e ff ff    	lea    -0x91d6(%eax),%edx
c002a625:	52                   	push   %edx
c002a626:	8d 90 94 4f ff ff    	lea    -0xb06c(%eax),%edx
c002a62c:	52                   	push   %edx
c002a62d:	8d 90 bc 4b ff ff    	lea    -0xb444(%eax),%edx
c002a633:	52                   	push   %edx
c002a634:	68 2b 01 00 00       	push   $0x12b
c002a639:	8d 90 ff 6d ff ff    	lea    -0x9201(%eax),%edx
c002a63f:	52                   	push   %edx
c002a640:	89 c3                	mov    %eax,%ebx
c002a642:	e8 93 ea ff ff       	call   c00290da <debug_panic>
  return BITMAP_ERROR;
c002a647:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a64c:	eb 02                	jmp    c002a650 <bitmap_scan+0xc8>
c002a64e:	89 f0                	mov    %esi,%eax
}
c002a650:	83 c4 1c             	add    $0x1c,%esp
c002a653:	5b                   	pop    %ebx
c002a654:	5e                   	pop    %esi
c002a655:	5f                   	pop    %edi
c002a656:	5d                   	pop    %ebp
c002a657:	c3                   	ret    

c002a658 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002a658:	55                   	push   %ebp
c002a659:	57                   	push   %edi
c002a65a:	56                   	push   %esi
c002a65b:	53                   	push   %ebx
c002a65c:	83 ec 0c             	sub    $0xc,%esp
c002a65f:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a663:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002a667:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c002a66b:	0f b6 c3             	movzbl %bl,%eax
c002a66e:	50                   	push   %eax
c002a66f:	55                   	push   %ebp
c002a670:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a674:	57                   	push   %edi
c002a675:	e8 0e ff ff ff       	call   c002a588 <bitmap_scan>
c002a67a:	83 c4 10             	add    $0x10,%esp
c002a67d:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c002a67f:	83 f8 ff             	cmp    $0xffffffff,%eax
c002a682:	75 0a                	jne    c002a68e <bitmap_scan_and_flip+0x36>
    bitmap_set_multiple (b, idx, cnt, !value);
  return idx;
}
c002a684:	89 f0                	mov    %esi,%eax
c002a686:	83 c4 0c             	add    $0xc,%esp
c002a689:	5b                   	pop    %ebx
c002a68a:	5e                   	pop    %esi
c002a68b:	5f                   	pop    %edi
c002a68c:	5d                   	pop    %ebp
c002a68d:	c3                   	ret    
    bitmap_set_multiple (b, idx, cnt, !value);
c002a68e:	83 f3 01             	xor    $0x1,%ebx
c002a691:	0f b6 db             	movzbl %bl,%ebx
c002a694:	53                   	push   %ebx
c002a695:	55                   	push   %ebp
c002a696:	50                   	push   %eax
c002a697:	57                   	push   %edi
c002a698:	e8 b0 fa ff ff       	call   c002a14d <bitmap_set_multiple>
c002a69d:	83 c4 10             	add    $0x10,%esp
  return idx;
c002a6a0:	eb e2                	jmp    c002a684 <bitmap_scan_and_flip+0x2c>

c002a6a2 <bitmap_file_size>:
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a6a2:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a6a6:	8b 00                	mov    (%eax),%eax
c002a6a8:	83 c0 1f             	add    $0x1f,%eax
c002a6ab:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a6ae:	c1 e0 02             	shl    $0x2,%eax
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size (const struct bitmap *b) 
{
  return byte_cnt (b->bit_cnt);
}
c002a6b1:	c3                   	ret    

c002a6b2 <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool
bitmap_read (struct bitmap *b, struct file *file) 
{
c002a6b2:	57                   	push   %edi
c002a6b3:	56                   	push   %esi
c002a6b4:	53                   	push   %ebx
c002a6b5:	e8 3e 48 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a6ba:	81 c3 6e 0a 01 00    	add    $0x10a6e,%ebx
c002a6c0:	8b 7c 24 10          	mov    0x10(%esp),%edi
  bool success = true;
  if (b->bit_cnt > 0) 
c002a6c4:	8b 17                	mov    (%edi),%edx
  bool success = true;
c002a6c6:	b8 01 00 00 00       	mov    $0x1,%eax
  if (b->bit_cnt > 0) 
c002a6cb:	85 d2                	test   %edx,%edx
c002a6cd:	75 04                	jne    c002a6d3 <bitmap_read+0x21>
      off_t size = byte_cnt (b->bit_cnt);
      success = file_read_at (file, b->bits, size, 0) == size;
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
    }
  return success;
}
c002a6cf:	5b                   	pop    %ebx
c002a6d0:	5e                   	pop    %esi
c002a6d1:	5f                   	pop    %edi
c002a6d2:	c3                   	ret    
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a6d3:	83 c2 1f             	add    $0x1f,%edx
c002a6d6:	c1 ea 05             	shr    $0x5,%edx
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a6d9:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
      success = file_read_at (file, b->bits, size, 0) == size;
c002a6e0:	6a 00                	push   $0x0
c002a6e2:	56                   	push   %esi
c002a6e3:	ff 77 04             	pushl  0x4(%edi)
c002a6e6:	ff 74 24 20          	pushl  0x20(%esp)
c002a6ea:	e8 2b 32 00 00       	call   c002d91a <file_read_at>
c002a6ef:	83 c4 10             	add    $0x10,%esp
c002a6f2:	39 f0                	cmp    %esi,%eax
c002a6f4:	0f 94 c0             	sete   %al
  int last_bits = b->bit_cnt % ELEM_BITS;
c002a6f7:	8b 17                	mov    (%edi),%edx
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c002a6f9:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002a6fe:	89 d1                	mov    %edx,%ecx
c002a700:	83 e1 1f             	and    $0x1f,%ecx
c002a703:	74 0a                	je     c002a70f <bitmap_read+0x5d>
c002a705:	be 01 00 00 00       	mov    $0x1,%esi
c002a70a:	d3 e6                	shl    %cl,%esi
c002a70c:	83 ee 01             	sub    $0x1,%esi
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a70f:	83 c2 1f             	add    $0x1f,%edx
c002a712:	c1 ea 05             	shr    $0x5,%edx
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
c002a715:	8b 4f 04             	mov    0x4(%edi),%ecx
c002a718:	21 74 91 fc          	and    %esi,-0x4(%ecx,%edx,4)
c002a71c:	eb b1                	jmp    c002a6cf <bitmap_read+0x1d>

c002a71e <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool
bitmap_write (const struct bitmap *b, struct file *file)
{
c002a71e:	56                   	push   %esi
c002a71f:	53                   	push   %ebx
c002a720:	83 ec 04             	sub    $0x4,%esp
c002a723:	e8 d0 47 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a728:	81 c3 00 0a 01 00    	add    $0x10a00,%ebx
c002a72e:	8b 44 24 10          	mov    0x10(%esp),%eax
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a732:	8b 10                	mov    (%eax),%edx
c002a734:	8d 72 1f             	lea    0x1f(%edx),%esi
c002a737:	c1 ee 05             	shr    $0x5,%esi
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a73a:	c1 e6 02             	shl    $0x2,%esi
  off_t size = byte_cnt (b->bit_cnt);
  return file_write_at (file, b->bits, size, 0) == size;
c002a73d:	6a 00                	push   $0x0
c002a73f:	56                   	push   %esi
c002a740:	ff 70 04             	pushl  0x4(%eax)
c002a743:	ff 74 24 20          	pushl  0x20(%esp)
c002a747:	e8 28 32 00 00       	call   c002d974 <file_write_at>
c002a74c:	39 f0                	cmp    %esi,%eax
c002a74e:	0f 94 c0             	sete   %al
}
c002a751:	83 c4 14             	add    $0x14,%esp
c002a754:	5b                   	pop    %ebx
c002a755:	5e                   	pop    %esi
c002a756:	c3                   	ret    

c002a757 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002a757:	53                   	push   %ebx
c002a758:	83 ec 08             	sub    $0x8,%esp
c002a75b:	e8 98 47 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a760:	81 c3 c8 09 01 00    	add    $0x109c8,%ebx
c002a766:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a76a:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a76c:	8b 02                	mov    (%edx),%eax
c002a76e:	83 c0 1f             	add    $0x1f,%eax
c002a771:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a774:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a777:	50                   	push   %eax
c002a778:	ff 72 04             	pushl  0x4(%edx)
c002a77b:	6a 00                	push   $0x0
c002a77d:	e8 aa d4 ff ff       	call   c0027c2c <hex_dump>
}
c002a782:	83 c4 18             	add    $0x18,%esp
c002a785:	5b                   	pop    %ebx
c002a786:	c3                   	ret    

c002a787 <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002a787:	53                   	push   %ebx
c002a788:	83 ec 10             	sub    $0x10,%esp
c002a78b:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002a78d:	ff 70 14             	pushl  0x14(%eax)
c002a790:	52                   	push   %edx
c002a791:	ff 50 0c             	call   *0xc(%eax)
c002a794:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002a797:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002a79a:	21 c2                	and    %eax,%edx
  return &h->buckets[bucket_idx];
c002a79c:	c1 e2 04             	shl    $0x4,%edx
c002a79f:	89 d0                	mov    %edx,%eax
c002a7a1:	03 43 08             	add    0x8(%ebx),%eax
}
c002a7a4:	83 c4 18             	add    $0x18,%esp
c002a7a7:	5b                   	pop    %ebx
c002a7a8:	c3                   	ret    

c002a7a9 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002a7a9:	55                   	push   %ebp
c002a7aa:	57                   	push   %edi
c002a7ab:	56                   	push   %esi
c002a7ac:	53                   	push   %ebx
c002a7ad:	83 ec 28             	sub    $0x28,%esp
c002a7b0:	e8 43 47 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a7b5:	81 c3 73 09 01 00    	add    $0x10973,%ebx
c002a7bb:	89 c7                	mov    %eax,%edi
c002a7bd:	89 54 24 18          	mov    %edx,0x18(%esp)
c002a7c1:	89 cd                	mov    %ecx,%ebp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002a7c3:	52                   	push   %edx
c002a7c4:	e8 36 ea ff ff       	call   c00291ff <list_begin>
c002a7c9:	89 c6                	mov    %eax,%esi
c002a7cb:	83 c4 10             	add    $0x10,%esp
c002a7ce:	eb 0e                	jmp    c002a7de <find_elem+0x35>
c002a7d0:	83 ec 0c             	sub    $0xc,%esp
c002a7d3:	56                   	push   %esi
c002a7d4:	e8 6b ea ff ff       	call   c0029244 <list_next>
c002a7d9:	89 c6                	mov    %eax,%esi
c002a7db:	83 c4 10             	add    $0x10,%esp
c002a7de:	83 ec 0c             	sub    $0xc,%esp
c002a7e1:	ff 74 24 18          	pushl  0x18(%esp)
c002a7e5:	e8 b7 ea ff ff       	call   c00292a1 <list_end>
c002a7ea:	83 c4 10             	add    $0x10,%esp
c002a7ed:	39 f0                	cmp    %esi,%eax
c002a7ef:	74 26                	je     c002a817 <find_elem+0x6e>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002a7f1:	83 ec 04             	sub    $0x4,%esp
c002a7f4:	ff 77 14             	pushl  0x14(%edi)
c002a7f7:	55                   	push   %ebp
c002a7f8:	56                   	push   %esi
c002a7f9:	ff 57 10             	call   *0x10(%edi)
c002a7fc:	83 c4 10             	add    $0x10,%esp
c002a7ff:	84 c0                	test   %al,%al
c002a801:	75 cd                	jne    c002a7d0 <find_elem+0x27>
c002a803:	83 ec 04             	sub    $0x4,%esp
c002a806:	ff 77 14             	pushl  0x14(%edi)
c002a809:	56                   	push   %esi
c002a80a:	55                   	push   %ebp
c002a80b:	ff 57 10             	call   *0x10(%edi)
c002a80e:	83 c4 10             	add    $0x10,%esp
c002a811:	84 c0                	test   %al,%al
c002a813:	75 bb                	jne    c002a7d0 <find_elem+0x27>
c002a815:	eb 05                	jmp    c002a81c <find_elem+0x73>
        return hi; 
    }
  return NULL;
c002a817:	be 00 00 00 00       	mov    $0x0,%esi
}
c002a81c:	89 f0                	mov    %esi,%eax
c002a81e:	83 c4 1c             	add    $0x1c,%esp
c002a821:	5b                   	pop    %ebx
c002a822:	5e                   	pop    %esi
c002a823:	5f                   	pop    %edi
c002a824:	5d                   	pop    %ebp
c002a825:	c3                   	ret    

c002a826 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002a826:	55                   	push   %ebp
c002a827:	57                   	push   %edi
c002a828:	56                   	push   %esi
c002a829:	53                   	push   %ebx
c002a82a:	83 ec 2c             	sub    $0x2c,%esp
c002a82d:	e8 c6 46 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a832:	81 c3 f6 08 01 00    	add    $0x108f6,%ebx
c002a838:	89 44 24 10          	mov    %eax,0x10(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002a83c:	85 c0                	test   %eax,%eax
c002a83e:	74 1e                	je     c002a85e <rehash+0x38>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c002a840:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a844:	8b 48 04             	mov    0x4(%eax),%ecx
c002a847:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002a84b:	8b 00                	mov    (%eax),%eax
c002a84d:	89 c6                	mov    %eax,%esi
c002a84f:	d1 ee                	shr    %esi
c002a851:	83 f8 07             	cmp    $0x7,%eax
c002a854:	b8 04 00 00 00       	mov    $0x4,%eax
c002a859:	0f 46 f0             	cmovbe %eax,%esi
c002a85c:	eb 2e                	jmp    c002a88c <rehash+0x66>
  ASSERT (h != NULL);
c002a85e:	83 ec 0c             	sub    $0xc,%esp
c002a861:	8d 83 80 6e ff ff    	lea    -0x9180(%ebx),%eax
c002a867:	50                   	push   %eax
c002a868:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002a86e:	50                   	push   %eax
c002a86f:	8d 83 78 4c ff ff    	lea    -0xb388(%ebx),%eax
c002a875:	50                   	push   %eax
c002a876:	68 66 01 00 00       	push   $0x166
c002a87b:	8d 83 8a 6e ff ff    	lea    -0x9176(%ebx),%eax
c002a881:	50                   	push   %eax
c002a882:	e8 53 e8 ff ff       	call   c00290da <debug_panic>
  return x & (x - 1);
c002a887:	8d 46 ff             	lea    -0x1(%esi),%eax
c002a88a:	21 c6                	and    %eax,%esi
  return x != 0 && turn_off_least_1bit (x) == 0;
c002a88c:	85 f6                	test   %esi,%esi
c002a88e:	74 f7                	je     c002a887 <rehash+0x61>
  return x & (x - 1);
c002a890:	8d 46 ff             	lea    -0x1(%esi),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002a893:	85 f0                	test   %esi,%eax
c002a895:	75 f0                	jne    c002a887 <rehash+0x61>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002a897:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c002a89b:	0f 84 df 00 00 00    	je     c002a980 <rehash+0x15a>
  old_buckets = h->buckets;
c002a8a1:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a8a5:	8b 40 08             	mov    0x8(%eax),%eax
c002a8a8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002a8ac:	89 f5                	mov    %esi,%ebp
c002a8ae:	c1 e5 04             	shl    $0x4,%ebp
c002a8b1:	83 ec 0c             	sub    $0xc,%esp
c002a8b4:	55                   	push   %ebp
c002a8b5:	e8 41 95 ff ff       	call   c0023dfb <malloc>
c002a8ba:	89 44 24 24          	mov    %eax,0x24(%esp)
  if (new_buckets == NULL) 
c002a8be:	83 c4 10             	add    $0x10,%esp
c002a8c1:	85 c0                	test   %eax,%eax
c002a8c3:	0f 84 b7 00 00 00    	je     c002a980 <rehash+0x15a>
c002a8c9:	89 c7                	mov    %eax,%edi
c002a8cb:	01 c5                	add    %eax,%ebp
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c002a8cd:	83 ec 0c             	sub    $0xc,%esp
c002a8d0:	57                   	push   %edi
c002a8d1:	e8 d1 e8 ff ff       	call   c00291a7 <list_init>
c002a8d6:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < new_bucket_cnt; i++) 
c002a8d9:	83 c4 10             	add    $0x10,%esp
c002a8dc:	39 fd                	cmp    %edi,%ebp
c002a8de:	75 ed                	jne    c002a8cd <rehash+0xa7>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002a8e0:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a8e4:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002a8e8:	89 48 08             	mov    %ecx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002a8eb:	89 70 04             	mov    %esi,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002a8ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a8f2:	85 c0                	test   %eax,%eax
c002a8f4:	74 7b                	je     c002a971 <rehash+0x14b>
c002a8f6:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002a8fa:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002a8fe:	c1 e0 04             	shl    $0x4,%eax
c002a901:	01 c8                	add    %ecx,%eax
c002a903:	89 44 24 18          	mov    %eax,0x18(%esp)
c002a907:	eb 0f                	jmp    c002a918 <rehash+0xf2>
c002a909:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c002a90e:	8b 44 24 14          	mov    0x14(%esp),%eax
c002a912:	39 44 24 18          	cmp    %eax,0x18(%esp)
c002a916:	74 59                	je     c002a971 <rehash+0x14b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002a918:	8b 44 24 14          	mov    0x14(%esp),%eax
c002a91c:	89 c7                	mov    %eax,%edi
      for (elem = list_begin (old_bucket);
c002a91e:	83 ec 0c             	sub    $0xc,%esp
c002a921:	50                   	push   %eax
c002a922:	e8 d8 e8 ff ff       	call   c00291ff <list_begin>
c002a927:	89 c6                	mov    %eax,%esi
c002a929:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002a92c:	83 ec 0c             	sub    $0xc,%esp
c002a92f:	57                   	push   %edi
c002a930:	e8 6c e9 ff ff       	call   c00292a1 <list_end>
      for (elem = list_begin (old_bucket);
c002a935:	83 c4 10             	add    $0x10,%esp
c002a938:	39 f0                	cmp    %esi,%eax
c002a93a:	74 cd                	je     c002a909 <rehash+0xe3>
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002a93c:	89 f2                	mov    %esi,%edx
c002a93e:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a942:	e8 40 fe ff ff       	call   c002a787 <find_bucket>
c002a947:	89 c5                	mov    %eax,%ebp
          next = list_next (elem);
c002a949:	83 ec 0c             	sub    $0xc,%esp
c002a94c:	56                   	push   %esi
c002a94d:	e8 f2 e8 ff ff       	call   c0029244 <list_next>
c002a952:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          list_remove (elem);
c002a956:	89 34 24             	mov    %esi,(%esp)
c002a959:	e8 4b ee ff ff       	call   c00297a9 <list_remove>
          list_push_front (new_bucket, elem);
c002a95e:	83 c4 08             	add    $0x8,%esp
c002a961:	56                   	push   %esi
c002a962:	55                   	push   %ebp
c002a963:	e8 07 ee ff ff       	call   c002976f <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c002a968:	83 c4 10             	add    $0x10,%esp
c002a96b:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002a96f:	eb bb                	jmp    c002a92c <rehash+0x106>
        }
    }

  free (old_buckets);
c002a971:	83 ec 0c             	sub    $0xc,%esp
c002a974:	ff 74 24 28          	pushl  0x28(%esp)
c002a978:	e8 2c 96 ff ff       	call   c0023fa9 <free>
c002a97d:	83 c4 10             	add    $0x10,%esp
}
c002a980:	83 c4 2c             	add    $0x2c,%esp
c002a983:	5b                   	pop    %ebx
c002a984:	5e                   	pop    %esi
c002a985:	5f                   	pop    %edi
c002a986:	5d                   	pop    %ebp
c002a987:	c3                   	ret    

c002a988 <hash_clear>:
{
c002a988:	55                   	push   %ebp
c002a989:	57                   	push   %edi
c002a98a:	56                   	push   %esi
c002a98b:	53                   	push   %ebx
c002a98c:	83 ec 1c             	sub    $0x1c,%esp
c002a98f:	e8 64 45 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002a994:	81 c3 94 07 01 00    	add    $0x10794,%ebx
c002a99a:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a99e:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  for (i = 0; i < h->bucket_cnt; i++) 
c002a9a2:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c002a9a6:	74 59                	je     c002aa01 <hash_clear+0x79>
c002a9a8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002a9af:	00 
c002a9b0:	eb 1a                	jmp    c002a9cc <hash_clear+0x44>
      list_init (bucket); 
c002a9b2:	83 ec 0c             	sub    $0xc,%esp
c002a9b5:	56                   	push   %esi
c002a9b6:	e8 ec e7 ff ff       	call   c00291a7 <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c002a9bb:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
c002a9c0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a9c4:	83 c4 10             	add    $0x10,%esp
c002a9c7:	39 47 04             	cmp    %eax,0x4(%edi)
c002a9ca:	76 35                	jbe    c002aa01 <hash_clear+0x79>
      struct list *bucket = &h->buckets[i];
c002a9cc:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002a9d0:	c1 e6 04             	shl    $0x4,%esi
c002a9d3:	03 77 08             	add    0x8(%edi),%esi
      if (destructor != NULL) 
c002a9d6:	85 ed                	test   %ebp,%ebp
c002a9d8:	74 d8                	je     c002a9b2 <hash_clear+0x2a>
        while (!list_empty (bucket)) 
c002a9da:	83 ec 0c             	sub    $0xc,%esp
c002a9dd:	56                   	push   %esi
c002a9de:	e8 68 ee ff ff       	call   c002984b <list_empty>
c002a9e3:	83 c4 10             	add    $0x10,%esp
c002a9e6:	84 c0                	test   %al,%al
c002a9e8:	75 c8                	jne    c002a9b2 <hash_clear+0x2a>
            struct list_elem *list_elem = list_pop_front (bucket);
c002a9ea:	83 ec 0c             	sub    $0xc,%esp
c002a9ed:	56                   	push   %esi
c002a9ee:	e8 cf ee ff ff       	call   c00298c2 <list_pop_front>
            destructor (hash_elem, h->aux);
c002a9f3:	83 c4 08             	add    $0x8,%esp
c002a9f6:	ff 77 14             	pushl  0x14(%edi)
c002a9f9:	50                   	push   %eax
c002a9fa:	ff d5                	call   *%ebp
c002a9fc:	83 c4 10             	add    $0x10,%esp
c002a9ff:	eb d9                	jmp    c002a9da <hash_clear+0x52>
  h->elem_cnt = 0;
c002aa01:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
c002aa07:	83 c4 1c             	add    $0x1c,%esp
c002aa0a:	5b                   	pop    %ebx
c002aa0b:	5e                   	pop    %esi
c002aa0c:	5f                   	pop    %edi
c002aa0d:	5d                   	pop    %ebp
c002aa0e:	c3                   	ret    

c002aa0f <hash_init>:
{
c002aa0f:	56                   	push   %esi
c002aa10:	53                   	push   %ebx
c002aa11:	83 ec 10             	sub    $0x10,%esp
c002aa14:	e8 df 44 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002aa19:	81 c3 0f 07 01 00    	add    $0x1070f,%ebx
c002aa1f:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  h->elem_cnt = 0;
c002aa23:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  h->bucket_cnt = 4;
c002aa29:	c7 46 04 04 00 00 00 	movl   $0x4,0x4(%esi)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002aa30:	6a 40                	push   $0x40
c002aa32:	e8 c4 93 ff ff       	call   c0023dfb <malloc>
c002aa37:	89 c2                	mov    %eax,%edx
c002aa39:	89 46 08             	mov    %eax,0x8(%esi)
  h->hash = hash;
c002aa3c:	8b 44 24 24          	mov    0x24(%esp),%eax
c002aa40:	89 46 0c             	mov    %eax,0xc(%esi)
  h->less = less;
c002aa43:	8b 44 24 28          	mov    0x28(%esp),%eax
c002aa47:	89 46 10             	mov    %eax,0x10(%esi)
  h->aux = aux;
c002aa4a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002aa4e:	89 46 14             	mov    %eax,0x14(%esi)
  if (h->buckets != NULL) 
c002aa51:	83 c4 10             	add    $0x10,%esp
    return false;
c002aa54:	b8 00 00 00 00       	mov    $0x0,%eax
  if (h->buckets != NULL) 
c002aa59:	85 d2                	test   %edx,%edx
c002aa5b:	74 13                	je     c002aa70 <hash_init+0x61>
      hash_clear (h, NULL);
c002aa5d:	83 ec 08             	sub    $0x8,%esp
c002aa60:	6a 00                	push   $0x0
c002aa62:	56                   	push   %esi
c002aa63:	e8 20 ff ff ff       	call   c002a988 <hash_clear>
      return true;
c002aa68:	83 c4 10             	add    $0x10,%esp
c002aa6b:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002aa70:	83 c4 04             	add    $0x4,%esp
c002aa73:	5b                   	pop    %ebx
c002aa74:	5e                   	pop    %esi
c002aa75:	c3                   	ret    

c002aa76 <hash_destroy>:
{
c002aa76:	56                   	push   %esi
c002aa77:	53                   	push   %ebx
c002aa78:	83 ec 04             	sub    $0x4,%esp
c002aa7b:	e8 78 44 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002aa80:	81 c3 a8 06 01 00    	add    $0x106a8,%ebx
c002aa86:	8b 74 24 10          	mov    0x10(%esp),%esi
c002aa8a:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c002aa8e:	85 c0                	test   %eax,%eax
c002aa90:	74 0d                	je     c002aa9f <hash_destroy+0x29>
    hash_clear (h, destructor);
c002aa92:	83 ec 08             	sub    $0x8,%esp
c002aa95:	50                   	push   %eax
c002aa96:	56                   	push   %esi
c002aa97:	e8 ec fe ff ff       	call   c002a988 <hash_clear>
c002aa9c:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002aa9f:	83 ec 0c             	sub    $0xc,%esp
c002aaa2:	ff 76 08             	pushl  0x8(%esi)
c002aaa5:	e8 ff 94 ff ff       	call   c0023fa9 <free>
}
c002aaaa:	83 c4 14             	add    $0x14,%esp
c002aaad:	5b                   	pop    %ebx
c002aaae:	5e                   	pop    %esi
c002aaaf:	c3                   	ret    

c002aab0 <hash_insert>:
{
c002aab0:	55                   	push   %ebp
c002aab1:	57                   	push   %edi
c002aab2:	56                   	push   %esi
c002aab3:	53                   	push   %ebx
c002aab4:	83 ec 0c             	sub    $0xc,%esp
c002aab7:	e8 3c 44 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002aabc:	81 c3 6c 06 01 00    	add    $0x1066c,%ebx
c002aac2:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002aac6:	8b 54 24 24          	mov    0x24(%esp),%edx
c002aaca:	89 f0                	mov    %esi,%eax
c002aacc:	e8 b6 fc ff ff       	call   c002a787 <find_bucket>
c002aad1:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002aad3:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002aad7:	89 c2                	mov    %eax,%edx
c002aad9:	89 f0                	mov    %esi,%eax
c002aadb:	e8 c9 fc ff ff       	call   c002a7a9 <find_elem>
c002aae0:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c002aae2:	85 c0                	test   %eax,%eax
c002aae4:	74 11                	je     c002aaf7 <hash_insert+0x47>
  rehash (h);
c002aae6:	89 f0                	mov    %esi,%eax
c002aae8:	e8 39 fd ff ff       	call   c002a826 <rehash>
}
c002aaed:	89 f8                	mov    %edi,%eax
c002aaef:	83 c4 0c             	add    $0xc,%esp
c002aaf2:	5b                   	pop    %ebx
c002aaf3:	5e                   	pop    %esi
c002aaf4:	5f                   	pop    %edi
c002aaf5:	5d                   	pop    %ebp
c002aaf6:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c002aaf7:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002aafa:	83 ec 08             	sub    $0x8,%esp
c002aafd:	ff 74 24 2c          	pushl  0x2c(%esp)
c002ab01:	55                   	push   %ebp
c002ab02:	e8 68 ec ff ff       	call   c002976f <list_push_front>
c002ab07:	83 c4 10             	add    $0x10,%esp
c002ab0a:	eb da                	jmp    c002aae6 <hash_insert+0x36>

c002ab0c <hash_replace>:
{
c002ab0c:	55                   	push   %ebp
c002ab0d:	57                   	push   %edi
c002ab0e:	56                   	push   %esi
c002ab0f:	53                   	push   %ebx
c002ab10:	83 ec 0c             	sub    $0xc,%esp
c002ab13:	e8 e0 43 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ab18:	81 c3 10 06 01 00    	add    $0x10610,%ebx
c002ab1e:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002ab22:	8b 54 24 24          	mov    0x24(%esp),%edx
c002ab26:	89 f0                	mov    %esi,%eax
c002ab28:	e8 5a fc ff ff       	call   c002a787 <find_bucket>
c002ab2d:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002ab2f:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002ab33:	89 c2                	mov    %eax,%edx
c002ab35:	89 f0                	mov    %esi,%eax
c002ab37:	e8 6d fc ff ff       	call   c002a7a9 <find_elem>
c002ab3c:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c002ab3e:	85 c0                	test   %eax,%eax
c002ab40:	74 0f                	je     c002ab51 <hash_replace+0x45>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c002ab42:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002ab45:	83 ec 0c             	sub    $0xc,%esp
c002ab48:	50                   	push   %eax
c002ab49:	e8 5b ec ff ff       	call   c00297a9 <list_remove>
c002ab4e:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c002ab51:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002ab54:	83 ec 08             	sub    $0x8,%esp
c002ab57:	ff 74 24 2c          	pushl  0x2c(%esp)
c002ab5b:	55                   	push   %ebp
c002ab5c:	e8 0e ec ff ff       	call   c002976f <list_push_front>
  rehash (h);
c002ab61:	89 f0                	mov    %esi,%eax
c002ab63:	e8 be fc ff ff       	call   c002a826 <rehash>
}
c002ab68:	89 f8                	mov    %edi,%eax
c002ab6a:	83 c4 1c             	add    $0x1c,%esp
c002ab6d:	5b                   	pop    %ebx
c002ab6e:	5e                   	pop    %esi
c002ab6f:	5f                   	pop    %edi
c002ab70:	5d                   	pop    %ebp
c002ab71:	c3                   	ret    

c002ab72 <hash_find>:
{
c002ab72:	56                   	push   %esi
c002ab73:	53                   	push   %ebx
c002ab74:	83 ec 04             	sub    $0x4,%esp
c002ab77:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002ab7b:	8b 74 24 14          	mov    0x14(%esp),%esi
  return find_elem (h, find_bucket (h, e), e);
c002ab7f:	89 f2                	mov    %esi,%edx
c002ab81:	89 d8                	mov    %ebx,%eax
c002ab83:	e8 ff fb ff ff       	call   c002a787 <find_bucket>
c002ab88:	89 f1                	mov    %esi,%ecx
c002ab8a:	89 c2                	mov    %eax,%edx
c002ab8c:	89 d8                	mov    %ebx,%eax
c002ab8e:	e8 16 fc ff ff       	call   c002a7a9 <find_elem>
}
c002ab93:	83 c4 04             	add    $0x4,%esp
c002ab96:	5b                   	pop    %ebx
c002ab97:	5e                   	pop    %esi
c002ab98:	c3                   	ret    

c002ab99 <hash_delete>:
{
c002ab99:	57                   	push   %edi
c002ab9a:	56                   	push   %esi
c002ab9b:	53                   	push   %ebx
c002ab9c:	e8 57 43 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002aba1:	81 c3 87 05 01 00    	add    $0x10587,%ebx
c002aba7:	8b 74 24 10          	mov    0x10(%esp),%esi
c002abab:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002abaf:	89 fa                	mov    %edi,%edx
c002abb1:	89 f0                	mov    %esi,%eax
c002abb3:	e8 cf fb ff ff       	call   c002a787 <find_bucket>
c002abb8:	89 f9                	mov    %edi,%ecx
c002abba:	89 c2                	mov    %eax,%edx
c002abbc:	89 f0                	mov    %esi,%eax
c002abbe:	e8 e6 fb ff ff       	call   c002a7a9 <find_elem>
c002abc3:	89 c7                	mov    %eax,%edi
  if (found != NULL) 
c002abc5:	85 c0                	test   %eax,%eax
c002abc7:	74 16                	je     c002abdf <hash_delete+0x46>
  h->elem_cnt--;
c002abc9:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002abcc:	83 ec 0c             	sub    $0xc,%esp
c002abcf:	50                   	push   %eax
c002abd0:	e8 d4 eb ff ff       	call   c00297a9 <list_remove>
      rehash (h); 
c002abd5:	89 f0                	mov    %esi,%eax
c002abd7:	e8 4a fc ff ff       	call   c002a826 <rehash>
c002abdc:	83 c4 10             	add    $0x10,%esp
}
c002abdf:	89 f8                	mov    %edi,%eax
c002abe1:	5b                   	pop    %ebx
c002abe2:	5e                   	pop    %esi
c002abe3:	5f                   	pop    %edi
c002abe4:	c3                   	ret    

c002abe5 <hash_apply>:
{
c002abe5:	55                   	push   %ebp
c002abe6:	57                   	push   %edi
c002abe7:	56                   	push   %esi
c002abe8:	53                   	push   %ebx
c002abe9:	83 ec 1c             	sub    $0x1c,%esp
c002abec:	e8 07 43 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002abf1:	81 c3 37 05 01 00    	add    $0x10537,%ebx
c002abf7:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c002abfb:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c002ac00:	74 16                	je     c002ac18 <hash_apply+0x33>
  for (i = 0; i < h->bucket_cnt; i++) 
c002ac02:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002ac09:	00 
c002ac0a:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c002ac0e:	75 3f                	jne    c002ac4f <hash_apply+0x6a>
}
c002ac10:	83 c4 1c             	add    $0x1c,%esp
c002ac13:	5b                   	pop    %ebx
c002ac14:	5e                   	pop    %esi
c002ac15:	5f                   	pop    %edi
c002ac16:	5d                   	pop    %ebp
c002ac17:	c3                   	ret    
  ASSERT (action != NULL);
c002ac18:	83 ec 0c             	sub    $0xc,%esp
c002ac1b:	8d 83 a2 6e ff ff    	lea    -0x915e(%ebx),%eax
c002ac21:	50                   	push   %eax
c002ac22:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002ac28:	50                   	push   %eax
c002ac29:	8d 83 6c 4c ff ff    	lea    -0xb394(%ebx),%eax
c002ac2f:	50                   	push   %eax
c002ac30:	68 a7 00 00 00       	push   $0xa7
c002ac35:	8d 83 8a 6e ff ff    	lea    -0x9176(%ebx),%eax
c002ac3b:	50                   	push   %eax
c002ac3c:	e8 99 e4 ff ff       	call   c00290da <debug_panic>
  for (i = 0; i < h->bucket_cnt; i++) 
c002ac41:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
c002ac46:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002ac4a:	39 45 04             	cmp    %eax,0x4(%ebp)
c002ac4d:	76 c1                	jbe    c002ac10 <hash_apply+0x2b>
      struct list *bucket = &h->buckets[i];
c002ac4f:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002ac53:	c1 e7 04             	shl    $0x4,%edi
c002ac56:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002ac59:	83 ec 0c             	sub    $0xc,%esp
c002ac5c:	57                   	push   %edi
c002ac5d:	e8 9d e5 ff ff       	call   c00291ff <list_begin>
c002ac62:	89 c6                	mov    %eax,%esi
c002ac64:	83 c4 10             	add    $0x10,%esp
c002ac67:	83 ec 0c             	sub    $0xc,%esp
c002ac6a:	57                   	push   %edi
c002ac6b:	e8 31 e6 ff ff       	call   c00292a1 <list_end>
c002ac70:	83 c4 10             	add    $0x10,%esp
c002ac73:	39 f0                	cmp    %esi,%eax
c002ac75:	74 ca                	je     c002ac41 <hash_apply+0x5c>
          next = list_next (elem);
c002ac77:	83 ec 0c             	sub    $0xc,%esp
c002ac7a:	56                   	push   %esi
c002ac7b:	e8 c4 e5 ff ff       	call   c0029244 <list_next>
c002ac80:	89 44 24 18          	mov    %eax,0x18(%esp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002ac84:	83 c4 08             	add    $0x8,%esp
c002ac87:	ff 75 14             	pushl  0x14(%ebp)
c002ac8a:	56                   	push   %esi
c002ac8b:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002ac8f:	83 c4 10             	add    $0x10,%esp
c002ac92:	8b 74 24 08          	mov    0x8(%esp),%esi
c002ac96:	eb cf                	jmp    c002ac67 <hash_apply+0x82>

c002ac98 <hash_first>:
{
c002ac98:	56                   	push   %esi
c002ac99:	53                   	push   %ebx
c002ac9a:	83 ec 04             	sub    $0x4,%esp
c002ac9d:	e8 56 42 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002aca2:	81 c3 86 04 01 00    	add    $0x10486,%ebx
c002aca8:	8b 74 24 10          	mov    0x10(%esp),%esi
c002acac:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c002acb0:	85 f6                	test   %esi,%esi
c002acb2:	74 1e                	je     c002acd2 <hash_first+0x3a>
  ASSERT (h != NULL);
c002acb4:	85 c0                	test   %eax,%eax
c002acb6:	74 43                	je     c002acfb <hash_first+0x63>
  i->hash = h;
c002acb8:	89 06                	mov    %eax,(%esi)
  i->bucket = i->hash->buckets;
c002acba:	8b 40 08             	mov    0x8(%eax),%eax
c002acbd:	89 46 04             	mov    %eax,0x4(%esi)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002acc0:	83 ec 0c             	sub    $0xc,%esp
c002acc3:	50                   	push   %eax
c002acc4:	e8 78 e8 ff ff       	call   c0029541 <list_head>
c002acc9:	89 46 08             	mov    %eax,0x8(%esi)
}
c002accc:	83 c4 14             	add    $0x14,%esp
c002accf:	5b                   	pop    %ebx
c002acd0:	5e                   	pop    %esi
c002acd1:	c3                   	ret    
  ASSERT (i != NULL);
c002acd2:	83 ec 0c             	sub    $0xc,%esp
c002acd5:	8d 83 b1 6e ff ff    	lea    -0x914f(%ebx),%eax
c002acdb:	50                   	push   %eax
c002acdc:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002ace2:	50                   	push   %eax
c002ace3:	8d 83 60 4c ff ff    	lea    -0xb3a0(%ebx),%eax
c002ace9:	50                   	push   %eax
c002acea:	68 ca 00 00 00       	push   $0xca
c002acef:	8d 83 8a 6e ff ff    	lea    -0x9176(%ebx),%eax
c002acf5:	50                   	push   %eax
c002acf6:	e8 df e3 ff ff       	call   c00290da <debug_panic>
  ASSERT (h != NULL);
c002acfb:	83 ec 0c             	sub    $0xc,%esp
c002acfe:	8d 83 80 6e ff ff    	lea    -0x9180(%ebx),%eax
c002ad04:	50                   	push   %eax
c002ad05:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002ad0b:	50                   	push   %eax
c002ad0c:	8d 83 60 4c ff ff    	lea    -0xb3a0(%ebx),%eax
c002ad12:	50                   	push   %eax
c002ad13:	68 cb 00 00 00       	push   $0xcb
c002ad18:	8d 83 8a 6e ff ff    	lea    -0x9176(%ebx),%eax
c002ad1e:	50                   	push   %eax
c002ad1f:	e8 b6 e3 ff ff       	call   c00290da <debug_panic>

c002ad24 <hash_next>:
{
c002ad24:	57                   	push   %edi
c002ad25:	56                   	push   %esi
c002ad26:	53                   	push   %ebx
c002ad27:	e8 cc 41 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ad2c:	81 c3 fc 03 01 00    	add    $0x103fc,%ebx
c002ad32:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (i != NULL);
c002ad36:	85 f6                	test   %esi,%esi
c002ad38:	74 4f                	je     c002ad89 <hash_next+0x65>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002ad3a:	83 ec 0c             	sub    $0xc,%esp
c002ad3d:	ff 76 08             	pushl  0x8(%esi)
c002ad40:	e8 ff e4 ff ff       	call   c0029244 <list_next>
c002ad45:	89 46 08             	mov    %eax,0x8(%esi)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002ad48:	83 c4 10             	add    $0x10,%esp
c002ad4b:	8b 7e 08             	mov    0x8(%esi),%edi
c002ad4e:	83 ec 0c             	sub    $0xc,%esp
c002ad51:	ff 76 04             	pushl  0x4(%esi)
c002ad54:	e8 48 e5 ff ff       	call   c00292a1 <list_end>
c002ad59:	83 c4 10             	add    $0x10,%esp
c002ad5c:	39 c7                	cmp    %eax,%edi
c002ad5e:	75 59                	jne    c002adb9 <hash_next+0x95>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002ad60:	8b 46 04             	mov    0x4(%esi),%eax
c002ad63:	8d 50 10             	lea    0x10(%eax),%edx
c002ad66:	89 56 04             	mov    %edx,0x4(%esi)
c002ad69:	8b 0e                	mov    (%esi),%ecx
c002ad6b:	8b 41 04             	mov    0x4(%ecx),%eax
c002ad6e:	c1 e0 04             	shl    $0x4,%eax
c002ad71:	03 41 08             	add    0x8(%ecx),%eax
c002ad74:	39 c2                	cmp    %eax,%edx
c002ad76:	73 3a                	jae    c002adb2 <hash_next+0x8e>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002ad78:	83 ec 0c             	sub    $0xc,%esp
c002ad7b:	52                   	push   %edx
c002ad7c:	e8 7e e4 ff ff       	call   c00291ff <list_begin>
c002ad81:	89 46 08             	mov    %eax,0x8(%esi)
c002ad84:	83 c4 10             	add    $0x10,%esp
c002ad87:	eb c2                	jmp    c002ad4b <hash_next+0x27>
  ASSERT (i != NULL);
c002ad89:	83 ec 0c             	sub    $0xc,%esp
c002ad8c:	8d 83 b1 6e ff ff    	lea    -0x914f(%ebx),%eax
c002ad92:	50                   	push   %eax
c002ad93:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002ad99:	50                   	push   %eax
c002ad9a:	8d 83 54 4c ff ff    	lea    -0xb3ac(%ebx),%eax
c002ada0:	50                   	push   %eax
c002ada1:	68 dd 00 00 00       	push   $0xdd
c002ada6:	8d 83 8a 6e ff ff    	lea    -0x9176(%ebx),%eax
c002adac:	50                   	push   %eax
c002adad:	e8 28 e3 ff ff       	call   c00290da <debug_panic>
          i->elem = NULL;
c002adb2:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  return i->elem;
c002adb9:	8b 46 08             	mov    0x8(%esi),%eax
}
c002adbc:	5b                   	pop    %ebx
c002adbd:	5e                   	pop    %esi
c002adbe:	5f                   	pop    %edi
c002adbf:	c3                   	ret    

c002adc0 <hash_cur>:
  return i->elem;
c002adc0:	8b 44 24 04          	mov    0x4(%esp),%eax
c002adc4:	8b 40 08             	mov    0x8(%eax),%eax
}
c002adc7:	c3                   	ret    

c002adc8 <hash_size>:
  return h->elem_cnt;
c002adc8:	8b 44 24 04          	mov    0x4(%esp),%eax
c002adcc:	8b 00                	mov    (%eax),%eax
}
c002adce:	c3                   	ret    

c002adcf <hash_empty>:
  return h->elem_cnt == 0;
c002adcf:	8b 44 24 04          	mov    0x4(%esp),%eax
c002add3:	83 38 00             	cmpl   $0x0,(%eax)
c002add6:	0f 94 c0             	sete   %al
}
c002add9:	c3                   	ret    

c002adda <hash_bytes>:
{
c002adda:	53                   	push   %ebx
c002addb:	83 ec 08             	sub    $0x8,%esp
c002adde:	e8 15 41 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ade3:	81 c3 45 03 01 00    	add    $0x10345,%ebx
c002ade9:	8b 54 24 10          	mov    0x10(%esp),%edx
c002aded:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (buf != NULL);
c002adf1:	85 d2                	test   %edx,%edx
c002adf3:	74 24                	je     c002ae19 <hash_bytes+0x3f>
c002adf5:	8d 1c 0a             	lea    (%edx,%ecx,1),%ebx
  hash = FNV_32_BASIS;
c002adf8:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (size-- > 0)
c002adfd:	85 c9                	test   %ecx,%ecx
c002adff:	74 13                	je     c002ae14 <hash_bytes+0x3a>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002ae01:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002ae07:	83 c2 01             	add    $0x1,%edx
c002ae0a:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
c002ae0e:	31 c8                	xor    %ecx,%eax
  while (size-- > 0)
c002ae10:	39 da                	cmp    %ebx,%edx
c002ae12:	75 ed                	jne    c002ae01 <hash_bytes+0x27>
} 
c002ae14:	83 c4 08             	add    $0x8,%esp
c002ae17:	5b                   	pop    %ebx
c002ae18:	c3                   	ret    
  ASSERT (buf != NULL);
c002ae19:	83 ec 0c             	sub    $0xc,%esp
c002ae1c:	8d 83 bb 6e ff ff    	lea    -0x9145(%ebx),%eax
c002ae22:	50                   	push   %eax
c002ae23:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002ae29:	50                   	push   %eax
c002ae2a:	8d 83 48 4c ff ff    	lea    -0xb3b8(%ebx),%eax
c002ae30:	50                   	push   %eax
c002ae31:	68 10 01 00 00       	push   $0x110
c002ae36:	8d 83 8a 6e ff ff    	lea    -0x9176(%ebx),%eax
c002ae3c:	50                   	push   %eax
c002ae3d:	e8 98 e2 ff ff       	call   c00290da <debug_panic>

c002ae42 <hash_string>:
{
c002ae42:	56                   	push   %esi
c002ae43:	53                   	push   %ebx
c002ae44:	83 ec 04             	sub    $0x4,%esp
c002ae47:	e8 ac 40 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ae4c:	81 c3 dc 02 01 00    	add    $0x102dc,%ebx
c002ae52:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (s != NULL);
c002ae56:	85 f6                	test   %esi,%esi
c002ae58:	74 27                	je     c002ae81 <hash_string+0x3f>
  while (*s != '\0')
c002ae5a:	0f b6 16             	movzbl (%esi),%edx
  hash = FNV_32_BASIS;
c002ae5d:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (*s != '\0')
c002ae62:	84 d2                	test   %dl,%dl
c002ae64:	74 15                	je     c002ae7b <hash_string+0x39>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002ae66:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002ae6c:	83 c6 01             	add    $0x1,%esi
c002ae6f:	0f b6 c2             	movzbl %dl,%eax
c002ae72:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c002ae74:	0f b6 16             	movzbl (%esi),%edx
c002ae77:	84 d2                	test   %dl,%dl
c002ae79:	75 eb                	jne    c002ae66 <hash_string+0x24>
}
c002ae7b:	83 c4 04             	add    $0x4,%esp
c002ae7e:	5b                   	pop    %ebx
c002ae7f:	5e                   	pop    %esi
c002ae80:	c3                   	ret    
  ASSERT (s != NULL);
c002ae81:	83 ec 0c             	sub    $0xc,%esp
c002ae84:	8d 93 5b 6a ff ff    	lea    -0x95a5(%ebx),%edx
c002ae8a:	52                   	push   %edx
c002ae8b:	8d 93 94 4f ff ff    	lea    -0xb06c(%ebx),%edx
c002ae91:	52                   	push   %edx
c002ae92:	8d 93 3c 4c ff ff    	lea    -0xb3c4(%ebx),%edx
c002ae98:	52                   	push   %edx
c002ae99:	68 20 01 00 00       	push   $0x120
c002ae9e:	8d 93 8a 6e ff ff    	lea    -0x9176(%ebx),%edx
c002aea4:	52                   	push   %edx
c002aea5:	e8 30 e2 ff ff       	call   c00290da <debug_panic>

c002aeaa <hash_int>:
{
c002aeaa:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c002aead:	6a 04                	push   $0x4
c002aeaf:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002aeb3:	50                   	push   %eax
c002aeb4:	e8 21 ff ff ff       	call   c002adda <hash_bytes>
}
c002aeb9:	83 c4 1c             	add    $0x1c,%esp
c002aebc:	c3                   	ret    

c002aebd <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002aebd:	56                   	push   %esi
c002aebe:	53                   	push   %ebx
c002aebf:	83 ec 04             	sub    $0x4,%esp
c002aec2:	e8 31 40 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002aec7:	81 c3 61 02 01 00    	add    $0x10261,%ebx
c002aecd:	89 c6                	mov    %eax,%esi
  return (intr_context ()
c002aecf:	e8 e1 70 ff ff       	call   c0021fb5 <intr_context>
          || lock_held_by_current_thread (&console_lock));
c002aed4:	84 c0                	test   %al,%al
c002aed6:	75 09                	jne    c002aee1 <putchar_have_lock+0x24>
          || !use_console_lock
c002aed8:	80 bb 64 1c 00 00 00 	cmpb   $0x0,0x1c64(%ebx)
c002aedf:	75 2a                	jne    c002af0b <putchar_have_lock+0x4e>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c002aee1:	83 83 58 1c 00 00 01 	addl   $0x1,0x1c58(%ebx)
c002aee8:	83 93 5c 1c 00 00 00 	adcl   $0x0,0x1c5c(%ebx)
  serial_putc (c);
c002aeef:	89 f0                	mov    %esi,%eax
c002aef1:	0f b6 f0             	movzbl %al,%esi
c002aef4:	83 ec 0c             	sub    $0xc,%esp
c002aef7:	56                   	push   %esi
c002aef8:	e8 0c a0 ff ff       	call   c0024f09 <serial_putc>
  vga_putc (c);
c002aefd:	89 34 24             	mov    %esi,(%esp)
c002af00:	e8 ce 9b ff ff       	call   c0024ad3 <vga_putc>
}
c002af05:	83 c4 14             	add    $0x14,%esp
c002af08:	5b                   	pop    %ebx
c002af09:	5e                   	pop    %esi
c002af0a:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c002af0b:	83 ec 0c             	sub    $0xc,%esp
c002af0e:	8d 83 78 1c 00 00    	lea    0x1c78(%ebx),%eax
c002af14:	50                   	push   %eax
c002af15:	e8 9c 82 ff ff       	call   c00231b6 <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c002af1a:	83 c4 10             	add    $0x10,%esp
c002af1d:	84 c0                	test   %al,%al
c002af1f:	75 c0                	jne    c002aee1 <putchar_have_lock+0x24>
c002af21:	83 ec 0c             	sub    $0xc,%esp
c002af24:	8d 83 c8 6e ff ff    	lea    -0x9138(%ebx),%eax
c002af2a:	50                   	push   %eax
c002af2b:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002af31:	50                   	push   %eax
c002af32:	8d 83 80 4c ff ff    	lea    -0xb380(%ebx),%eax
c002af38:	50                   	push   %eax
c002af39:	68 bb 00 00 00       	push   $0xbb
c002af3e:	8d 83 0d 6f ff ff    	lea    -0x90f3(%ebx),%eax
c002af44:	50                   	push   %eax
c002af45:	e8 90 e1 ff ff       	call   c00290da <debug_panic>

c002af4a <vprintf_helper>:
{
c002af4a:	83 ec 0c             	sub    $0xc,%esp
c002af4d:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002af51:	83 00 01             	addl   $0x1,(%eax)
  putchar_have_lock (c);
c002af54:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002af59:	e8 5f ff ff ff       	call   c002aebd <putchar_have_lock>
}
c002af5e:	83 c4 0c             	add    $0xc,%esp
c002af61:	c3                   	ret    

c002af62 <acquire_console>:
{
c002af62:	53                   	push   %ebx
c002af63:	83 ec 08             	sub    $0x8,%esp
c002af66:	e8 8d 3f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002af6b:	81 c3 bd 01 01 00    	add    $0x101bd,%ebx
  if (!intr_context () && use_console_lock) 
c002af71:	e8 3f 70 ff ff       	call   c0021fb5 <intr_context>
c002af76:	84 c0                	test   %al,%al
c002af78:	75 09                	jne    c002af83 <acquire_console+0x21>
c002af7a:	80 bb 64 1c 00 00 00 	cmpb   $0x0,0x1c64(%ebx)
c002af81:	75 05                	jne    c002af88 <acquire_console+0x26>
}
c002af83:	83 c4 08             	add    $0x8,%esp
c002af86:	5b                   	pop    %ebx
c002af87:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c002af88:	83 ec 0c             	sub    $0xc,%esp
c002af8b:	8d 83 78 1c 00 00    	lea    0x1c78(%ebx),%eax
c002af91:	50                   	push   %eax
c002af92:	e8 1f 82 ff ff       	call   c00231b6 <lock_held_by_current_thread>
c002af97:	83 c4 10             	add    $0x10,%esp
c002af9a:	84 c0                	test   %al,%al
c002af9c:	74 09                	je     c002afa7 <acquire_console+0x45>
        console_lock_depth++; 
c002af9e:	83 83 60 1c 00 00 01 	addl   $0x1,0x1c60(%ebx)
c002afa5:	eb dc                	jmp    c002af83 <acquire_console+0x21>
        lock_acquire (&console_lock); 
c002afa7:	83 ec 0c             	sub    $0xc,%esp
c002afaa:	8d 83 78 1c 00 00    	lea    0x1c78(%ebx),%eax
c002afb0:	50                   	push   %eax
c002afb1:	e8 53 82 ff ff       	call   c0023209 <lock_acquire>
c002afb6:	83 c4 10             	add    $0x10,%esp
}
c002afb9:	eb c8                	jmp    c002af83 <acquire_console+0x21>

c002afbb <release_console>:
{
c002afbb:	53                   	push   %ebx
c002afbc:	83 ec 08             	sub    $0x8,%esp
c002afbf:	e8 34 3f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002afc4:	81 c3 64 01 01 00    	add    $0x10164,%ebx
  if (!intr_context () && use_console_lock) 
c002afca:	e8 e6 6f ff ff       	call   c0021fb5 <intr_context>
c002afcf:	84 c0                	test   %al,%al
c002afd1:	75 1c                	jne    c002afef <release_console+0x34>
c002afd3:	80 bb 64 1c 00 00 00 	cmpb   $0x0,0x1c64(%ebx)
c002afda:	74 13                	je     c002afef <release_console+0x34>
      if (console_lock_depth > 0)
c002afdc:	8b 83 60 1c 00 00    	mov    0x1c60(%ebx),%eax
c002afe2:	85 c0                	test   %eax,%eax
c002afe4:	7e 0e                	jle    c002aff4 <release_console+0x39>
        console_lock_depth--;
c002afe6:	83 e8 01             	sub    $0x1,%eax
c002afe9:	89 83 60 1c 00 00    	mov    %eax,0x1c60(%ebx)
}
c002afef:	83 c4 08             	add    $0x8,%esp
c002aff2:	5b                   	pop    %ebx
c002aff3:	c3                   	ret    
        lock_release (&console_lock); 
c002aff4:	83 ec 0c             	sub    $0xc,%esp
c002aff7:	8d 83 78 1c 00 00    	lea    0x1c78(%ebx),%eax
c002affd:	50                   	push   %eax
c002affe:	e8 07 84 ff ff       	call   c002340a <lock_release>
c002b003:	83 c4 10             	add    $0x10,%esp
}
c002b006:	eb e7                	jmp    c002afef <release_console+0x34>

c002b008 <console_init>:
{
c002b008:	53                   	push   %ebx
c002b009:	83 ec 14             	sub    $0x14,%esp
c002b00c:	e8 e7 3e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b011:	81 c3 17 01 01 00    	add    $0x10117,%ebx
  lock_init (&console_lock);
c002b017:	8d 83 78 1c 00 00    	lea    0x1c78(%ebx),%eax
c002b01d:	50                   	push   %eax
c002b01e:	e8 3a 81 ff ff       	call   c002315d <lock_init>
  use_console_lock = true;
c002b023:	c6 83 64 1c 00 00 01 	movb   $0x1,0x1c64(%ebx)
}
c002b02a:	83 c4 18             	add    $0x18,%esp
c002b02d:	5b                   	pop    %ebx
c002b02e:	c3                   	ret    

c002b02f <console_panic>:
{
c002b02f:	e8 c8 3e 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c002b034:	05 f4 00 01 00       	add    $0x100f4,%eax
  use_console_lock = false;
c002b039:	c6 80 64 1c 00 00 00 	movb   $0x0,0x1c64(%eax)
}
c002b040:	c3                   	ret    

c002b041 <console_print_stats>:
{
c002b041:	53                   	push   %ebx
c002b042:	83 ec 0c             	sub    $0xc,%esp
c002b045:	e8 ae 3e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b04a:	81 c3 de 00 01 00    	add    $0x100de,%ebx
  printf ("Console: %lld characters output\n", write_cnt);
c002b050:	ff b3 5c 1c 00 00    	pushl  0x1c5c(%ebx)
c002b056:	ff b3 58 1c 00 00    	pushl  0x1c58(%ebx)
c002b05c:	8d 83 ec 6e ff ff    	lea    -0x9114(%ebx),%eax
c002b062:	50                   	push   %eax
c002b063:	e8 16 c4 ff ff       	call   c002747e <printf>
}
c002b068:	83 c4 18             	add    $0x18,%esp
c002b06b:	5b                   	pop    %ebx
c002b06c:	c3                   	ret    

c002b06d <vprintf>:
{
c002b06d:	53                   	push   %ebx
c002b06e:	83 ec 18             	sub    $0x18,%esp
c002b071:	e8 82 3e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b076:	81 c3 b2 00 01 00    	add    $0x100b2,%ebx
  int char_cnt = 0;
c002b07c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002b083:	00 
  acquire_console ();
c002b084:	e8 d9 fe ff ff       	call   c002af62 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002b089:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002b08d:	50                   	push   %eax
c002b08e:	8d 83 22 fe fe ff    	lea    -0x101de(%ebx),%eax
c002b094:	50                   	push   %eax
c002b095:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b099:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b09d:	e8 1e c4 ff ff       	call   c00274c0 <__vprintf>
  release_console ();
c002b0a2:	e8 14 ff ff ff       	call   c002afbb <release_console>
}
c002b0a7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b0ab:	83 c4 28             	add    $0x28,%esp
c002b0ae:	5b                   	pop    %ebx
c002b0af:	c3                   	ret    

c002b0b0 <puts>:
{
c002b0b0:	53                   	push   %ebx
c002b0b1:	83 ec 08             	sub    $0x8,%esp
c002b0b4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002b0b8:	e8 a5 fe ff ff       	call   c002af62 <acquire_console>
  while (*s != '\0')
c002b0bd:	0f b6 03             	movzbl (%ebx),%eax
c002b0c0:	84 c0                	test   %al,%al
c002b0c2:	74 12                	je     c002b0d6 <puts+0x26>
    putchar_have_lock (*s++);
c002b0c4:	83 c3 01             	add    $0x1,%ebx
c002b0c7:	0f b6 c0             	movzbl %al,%eax
c002b0ca:	e8 ee fd ff ff       	call   c002aebd <putchar_have_lock>
  while (*s != '\0')
c002b0cf:	0f b6 03             	movzbl (%ebx),%eax
c002b0d2:	84 c0                	test   %al,%al
c002b0d4:	75 ee                	jne    c002b0c4 <puts+0x14>
  putchar_have_lock ('\n');
c002b0d6:	b8 0a 00 00 00       	mov    $0xa,%eax
c002b0db:	e8 dd fd ff ff       	call   c002aebd <putchar_have_lock>
  release_console ();
c002b0e0:	e8 d6 fe ff ff       	call   c002afbb <release_console>
}
c002b0e5:	b8 00 00 00 00       	mov    $0x0,%eax
c002b0ea:	83 c4 08             	add    $0x8,%esp
c002b0ed:	5b                   	pop    %ebx
c002b0ee:	c3                   	ret    

c002b0ef <putbuf>:
{
c002b0ef:	56                   	push   %esi
c002b0f0:	53                   	push   %ebx
c002b0f1:	83 ec 04             	sub    $0x4,%esp
c002b0f4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002b0f8:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c002b0fc:	e8 61 fe ff ff       	call   c002af62 <acquire_console>
  while (n-- > 0)
c002b101:	85 f6                	test   %esi,%esi
c002b103:	74 12                	je     c002b117 <putbuf+0x28>
c002b105:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c002b107:	83 c3 01             	add    $0x1,%ebx
c002b10a:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002b10e:	e8 aa fd ff ff       	call   c002aebd <putchar_have_lock>
  while (n-- > 0)
c002b113:	39 de                	cmp    %ebx,%esi
c002b115:	75 f0                	jne    c002b107 <putbuf+0x18>
  release_console ();
c002b117:	e8 9f fe ff ff       	call   c002afbb <release_console>
}
c002b11c:	83 c4 04             	add    $0x4,%esp
c002b11f:	5b                   	pop    %ebx
c002b120:	5e                   	pop    %esi
c002b121:	c3                   	ret    

c002b122 <putchar>:
{
c002b122:	53                   	push   %ebx
c002b123:	83 ec 08             	sub    $0x8,%esp
c002b126:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002b12a:	e8 33 fe ff ff       	call   c002af62 <acquire_console>
  putchar_have_lock (c);
c002b12f:	0f b6 c3             	movzbl %bl,%eax
c002b132:	e8 86 fd ff ff       	call   c002aebd <putchar_have_lock>
  release_console ();
c002b137:	e8 7f fe ff ff       	call   c002afbb <release_console>
}
c002b13c:	89 d8                	mov    %ebx,%eax
c002b13e:	83 c4 08             	add    $0x8,%esp
c002b141:	5b                   	pop    %ebx
c002b142:	c3                   	ret    

c002b143 <install_page>:
   KPAGE should probably be a page obtained from the user pool
   with palloc_get_page().
   Returns true on success, false if UPAGE is already mapped or
   if memory allocation fails. */
static bool
install_page(void *upage, void *kpage, bool writable) {
c002b143:	55                   	push   %ebp
c002b144:	57                   	push   %edi
c002b145:	56                   	push   %esi
c002b146:	53                   	push   %ebx
c002b147:	83 ec 1c             	sub    $0x1c,%esp
c002b14a:	e8 a9 3d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b14f:	81 c3 d9 ff 00 00    	add    $0xffd9,%ebx
c002b155:	89 c7                	mov    %eax,%edi
c002b157:	89 d5                	mov    %edx,%ebp
c002b159:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    struct thread *t = thread_current();
c002b15d:	e8 14 5e ff ff       	call   c0020f76 <thread_current>
c002b162:	89 c6                	mov    %eax,%esi

    /* Verify that there's not already a page at that virtual
       address, then map our page there. */
    bool success = (pagedir_get_page (t->pagedir, upage) == NULL);
c002b164:	83 ec 08             	sub    $0x8,%esp
c002b167:	57                   	push   %edi
c002b168:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002b16e:	e8 5a 10 00 00       	call   c002c1cd <pagedir_get_page>
    success = success && pagedir_set_page (t->pagedir, upage, kpage, writable);
c002b173:	83 c4 10             	add    $0x10,%esp
c002b176:	85 c0                	test   %eax,%eax
c002b178:	74 10                	je     c002b18a <install_page+0x47>
c002b17a:	b8 00 00 00 00       	mov    $0x0,%eax
c002b17f:	83 e0 01             	and    $0x1,%eax
#ifdef VM
    success = success && spt_install_frame (t->spt, upage, kpage);
    if(success) set_pin_info(kpage, false);
#endif
    return success;
}
c002b182:	83 c4 1c             	add    $0x1c,%esp
c002b185:	5b                   	pop    %ebx
c002b186:	5e                   	pop    %esi
c002b187:	5f                   	pop    %edi
c002b188:	5d                   	pop    %ebp
c002b189:	c3                   	ret    
    success = success && pagedir_set_page (t->pagedir, upage, kpage, writable);
c002b18a:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c002b18f:	50                   	push   %eax
c002b190:	55                   	push   %ebp
c002b191:	57                   	push   %edi
c002b192:	ff b6 10 01 00 00    	pushl  0x110(%esi)
c002b198:	e8 66 0e 00 00       	call   c002c003 <pagedir_set_page>
c002b19d:	0f b6 c0             	movzbl %al,%eax
c002b1a0:	83 c4 10             	add    $0x10,%esp
c002b1a3:	eb da                	jmp    c002b17f <install_page+0x3c>

c002b1a5 <get_file_name>:
char * get_file_name(char * cmd_line) {
c002b1a5:	55                   	push   %ebp
c002b1a6:	57                   	push   %edi
c002b1a7:	56                   	push   %esi
c002b1a8:	53                   	push   %ebx
c002b1a9:	83 ec 18             	sub    $0x18,%esp
c002b1ac:	e8 47 3d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b1b1:	81 c3 77 ff 00 00    	add    $0xff77,%ebx
c002b1b7:	8b 74 24 2c          	mov    0x2c(%esp),%esi
    char * name = (char *) malloc(16);
c002b1bb:	6a 10                	push   $0x10
c002b1bd:	e8 39 8c ff ff       	call   c0023dfb <malloc>
c002b1c2:	89 c3                	mov    %eax,%ebx
c002b1c4:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i <= strlen(cmd_line); i++) {
c002b1c7:	ba 00 00 00 00       	mov    $0x0,%edx
c002b1cc:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b1d1:	b8 00 00 00 00       	mov    $0x0,%eax
        if (*(cmd_line + i) != ' ') {
c002b1d6:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c002b1da:	80 f9 20             	cmp    $0x20,%cl
c002b1dd:	74 1f                	je     c002b1fe <get_file_name+0x59>
            name[i] = *(cmd_line + i);
c002b1df:	88 0c 13             	mov    %cl,(%ebx,%edx,1)
    for (int i = 0; i <= strlen(cmd_line); i++) {
c002b1e2:	83 c2 01             	add    $0x1,%edx
c002b1e5:	89 e9                	mov    %ebp,%ecx
c002b1e7:	89 f7                	mov    %esi,%edi
c002b1e9:	f2 ae                	repnz scas %es:(%edi),%al
c002b1eb:	f7 d1                	not    %ecx
c002b1ed:	83 e9 01             	sub    $0x1,%ecx
c002b1f0:	39 d1                	cmp    %edx,%ecx
c002b1f2:	73 e2                	jae    c002b1d6 <get_file_name+0x31>
}
c002b1f4:	89 d8                	mov    %ebx,%eax
c002b1f6:	83 c4 0c             	add    $0xc,%esp
c002b1f9:	5b                   	pop    %ebx
c002b1fa:	5e                   	pop    %esi
c002b1fb:	5f                   	pop    %edi
c002b1fc:	5d                   	pop    %ebp
c002b1fd:	c3                   	ret    
            name[i] = '\0';
c002b1fe:	c6 04 13 00          	movb   $0x0,(%ebx,%edx,1)
    return name;
c002b202:	eb f0                	jmp    c002b1f4 <get_file_name+0x4f>

c002b204 <process_execute>:
process_execute(const char *file_name) {
c002b204:	55                   	push   %ebp
c002b205:	57                   	push   %edi
c002b206:	56                   	push   %esi
c002b207:	53                   	push   %ebx
c002b208:	83 ec 28             	sub    $0x28,%esp
c002b20b:	e8 e8 3c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b210:	81 c3 18 ff 00 00    	add    $0xff18,%ebx
c002b216:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    char * name = (char *) malloc(16);
c002b21a:	6a 10                	push   $0x10
c002b21c:	e8 da 8b ff ff       	call   c0023dfb <malloc>
c002b221:	89 c5                	mov    %eax,%ebp
    fn_copy = palloc_get_page(0);
c002b223:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b22a:	e8 ba 87 ff ff       	call   c00239e9 <palloc_get_page>
c002b22f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    if (fn_copy == NULL)
c002b233:	83 c4 10             	add    $0x10,%esp
c002b236:	85 c0                	test   %eax,%eax
c002b238:	0f 84 9f 00 00 00    	je     c002b2dd <process_execute+0xd9>
    strlcpy(fn_copy, file_name, PGSIZE);
c002b23e:	83 ec 04             	sub    $0x4,%esp
c002b241:	68 00 10 00 00       	push   $0x1000
c002b246:	56                   	push   %esi
c002b247:	50                   	push   %eax
c002b248:	e8 cf d4 ff ff       	call   c002871c <strlcpy>
c002b24d:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i <= strlen(file_name); i++) {
c002b250:	ba 00 00 00 00       	mov    $0x0,%edx
c002b255:	b8 00 00 00 00       	mov    $0x0,%eax
        if (*(file_name + i) != ' ') {
c002b25a:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c002b25e:	80 f9 20             	cmp    $0x20,%cl
c002b261:	74 73                	je     c002b2d6 <process_execute+0xd2>
            name[i] = *(file_name + i);
c002b263:	88 4c 15 00          	mov    %cl,0x0(%ebp,%edx,1)
    for (int i = 0; i <= strlen(file_name); i++) {
c002b267:	83 c2 01             	add    $0x1,%edx
c002b26a:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b26f:	89 f7                	mov    %esi,%edi
c002b271:	f2 ae                	repnz scas %es:(%edi),%al
c002b273:	f7 d1                	not    %ecx
c002b275:	83 e9 01             	sub    $0x1,%ecx
c002b278:	39 d1                	cmp    %edx,%ecx
c002b27a:	73 de                	jae    c002b25a <process_execute+0x56>
    struct start_process_arg * arg = malloc(sizeof(struct start_process_arg));
c002b27c:	83 ec 0c             	sub    $0xc,%esp
c002b27f:	6a 1c                	push   $0x1c
c002b281:	e8 75 8b ff ff       	call   c0023dfb <malloc>
c002b286:	89 c6                	mov    %eax,%esi
    arg->file_name = fn_copy;
c002b288:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b28c:	89 06                	mov    %eax,(%esi)
    sema_init(&arg->sema, 0);
c002b28e:	8d 7e 04             	lea    0x4(%esi),%edi
c002b291:	83 c4 08             	add    $0x8,%esp
c002b294:	6a 00                	push   $0x0
c002b296:	57                   	push   %edi
c002b297:	e8 f0 7b ff ff       	call   c0022e8c <sema_init>
    tid = thread_create(name, PRI_DEFAULT + 1, start_process, arg);
c002b29c:	56                   	push   %esi
c002b29d:	8d 83 53 05 ff ff    	lea    -0xfaad(%ebx),%eax
c002b2a3:	50                   	push   %eax
c002b2a4:	6a 20                	push   $0x20
c002b2a6:	55                   	push   %ebp
c002b2a7:	e8 9c 64 ff ff       	call   c0021748 <thread_create>
c002b2ac:	89 c5                	mov    %eax,%ebp
    sema_down(&arg->sema);  // wait the process to load file done
c002b2ae:	83 c4 14             	add    $0x14,%esp
c002b2b1:	57                   	push   %edi
c002b2b2:	e8 29 7c ff ff       	call   c0022ee0 <sema_down>
    if (!arg->success) {
c002b2b7:	83 c4 10             	add    $0x10,%esp
c002b2ba:	80 7e 18 00          	cmpb   $0x0,0x18(%esi)
c002b2be:	74 24                	je     c002b2e4 <process_execute+0xe0>
    free(arg);
c002b2c0:	83 ec 0c             	sub    $0xc,%esp
c002b2c3:	56                   	push   %esi
c002b2c4:	e8 e0 8c ff ff       	call   c0023fa9 <free>
    return tid;
c002b2c9:	83 c4 10             	add    $0x10,%esp
}
c002b2cc:	89 e8                	mov    %ebp,%eax
c002b2ce:	83 c4 1c             	add    $0x1c,%esp
c002b2d1:	5b                   	pop    %ebx
c002b2d2:	5e                   	pop    %esi
c002b2d3:	5f                   	pop    %edi
c002b2d4:	5d                   	pop    %ebp
c002b2d5:	c3                   	ret    
            name[i] = '\0';
c002b2d6:	c6 44 15 00 00       	movb   $0x0,0x0(%ebp,%edx,1)
            break;
c002b2db:	eb 9f                	jmp    c002b27c <process_execute+0x78>
        return TID_ERROR;
c002b2dd:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b2e2:	eb e8                	jmp    c002b2cc <process_execute+0xc8>
        return -1;
c002b2e4:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b2e9:	eb e1                	jmp    c002b2cc <process_execute+0xc8>

c002b2eb <get_child_process>:
struct process_info *get_child_process(tid_t child_tid, struct list child_list) {
c002b2eb:	55                   	push   %ebp
c002b2ec:	57                   	push   %edi
c002b2ed:	56                   	push   %esi
c002b2ee:	53                   	push   %ebx
c002b2ef:	83 ec 18             	sub    $0x18,%esp
c002b2f2:	e8 01 3c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b2f7:	81 c3 31 fe 00 00    	add    $0xfe31,%ebx
c002b2fd:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    if (list_empty(&child_list)) return NULL;
c002b301:	8d 44 24 30          	lea    0x30(%esp),%eax
c002b305:	50                   	push   %eax
c002b306:	e8 40 e5 ff ff       	call   c002984b <list_empty>
c002b30b:	83 c4 10             	add    $0x10,%esp
c002b30e:	ba 00 00 00 00       	mov    $0x0,%edx
c002b313:	84 c0                	test   %al,%al
c002b315:	75 4e                	jne    c002b365 <get_child_process+0x7a>
    for (e = list_begin(&child_list); e != list_end(&child_list);
c002b317:	83 ec 0c             	sub    $0xc,%esp
c002b31a:	8d 44 24 30          	lea    0x30(%esp),%eax
c002b31e:	50                   	push   %eax
c002b31f:	e8 db de ff ff       	call   c00291ff <list_begin>
c002b324:	89 c6                	mov    %eax,%esi
c002b326:	83 c4 10             	add    $0x10,%esp
c002b329:	8d 6c 24 24          	lea    0x24(%esp),%ebp
c002b32d:	eb 13                	jmp    c002b342 <get_child_process+0x57>
        struct process_info *t = list_entry(e, struct process_info, elem);
c002b32f:	8d 56 f4             	lea    -0xc(%esi),%edx
c002b332:	eb 31                	jmp    c002b365 <get_child_process+0x7a>
         e = list_next(e)) {
c002b334:	83 ec 0c             	sub    $0xc,%esp
c002b337:	56                   	push   %esi
c002b338:	e8 07 df ff ff       	call   c0029244 <list_next>
c002b33d:	89 c6                	mov    %eax,%esi
c002b33f:	83 c4 10             	add    $0x10,%esp
    for (e = list_begin(&child_list); e != list_end(&child_list);
c002b342:	83 ec 0c             	sub    $0xc,%esp
c002b345:	55                   	push   %ebp
c002b346:	e8 56 df ff ff       	call   c00292a1 <list_end>
c002b34b:	83 c4 10             	add    $0x10,%esp
c002b34e:	39 f0                	cmp    %esi,%eax
c002b350:	74 0e                	je     c002b360 <get_child_process+0x75>
        if (t->tid == child_tid) {
c002b352:	39 7e f8             	cmp    %edi,-0x8(%esi)
c002b355:	74 d8                	je     c002b32f <get_child_process+0x44>
        if (e->next == NULL) break; // shall use lock to prevent this case
c002b357:	8b 56 04             	mov    0x4(%esi),%edx
c002b35a:	85 d2                	test   %edx,%edx
c002b35c:	75 d6                	jne    c002b334 <get_child_process+0x49>
c002b35e:	eb 05                	jmp    c002b365 <get_child_process+0x7a>
    return NULL;
c002b360:	ba 00 00 00 00       	mov    $0x0,%edx
}
c002b365:	89 d0                	mov    %edx,%eax
c002b367:	83 c4 0c             	add    $0xc,%esp
c002b36a:	5b                   	pop    %ebx
c002b36b:	5e                   	pop    %esi
c002b36c:	5f                   	pop    %edi
c002b36d:	5d                   	pop    %ebp
c002b36e:	c3                   	ret    

c002b36f <process_wait>:
process_wait(tid_t child_tid UNUSED) {
c002b36f:	57                   	push   %edi
c002b370:	56                   	push   %esi
c002b371:	53                   	push   %ebx
c002b372:	e8 81 3b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b377:	81 c3 b1 fd 00 00    	add    $0xfdb1,%ebx
    struct thread *t = thread_current();
c002b37d:	e8 f4 5b ff ff       	call   c0020f76 <thread_current>
c002b382:	89 c6                	mov    %eax,%esi
    if (list_empty(&t->child_list)) {
c002b384:	83 ec 0c             	sub    $0xc,%esp
c002b387:	8d 80 cc 00 00 00    	lea    0xcc(%eax),%eax
c002b38d:	50                   	push   %eax
c002b38e:	e8 b8 e4 ff ff       	call   c002984b <list_empty>
c002b393:	83 c4 10             	add    $0x10,%esp
c002b396:	84 c0                	test   %al,%al
c002b398:	75 66                	jne    c002b400 <process_wait+0x91>
    struct process_info *child = get_child_process(child_tid, t->child_list);
c002b39a:	83 ec 0c             	sub    $0xc,%esp
c002b39d:	ff b6 d8 00 00 00    	pushl  0xd8(%esi)
c002b3a3:	ff b6 d4 00 00 00    	pushl  0xd4(%esi)
c002b3a9:	ff b6 d0 00 00 00    	pushl  0xd0(%esi)
c002b3af:	ff b6 cc 00 00 00    	pushl  0xcc(%esi)
c002b3b5:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b3b9:	e8 2d ff ff ff       	call   c002b2eb <get_child_process>
c002b3be:	89 c6                	mov    %eax,%esi
    if (child == NULL || child->is_waiting)
c002b3c0:	83 c4 20             	add    $0x20,%esp
c002b3c3:	85 c0                	test   %eax,%eax
c002b3c5:	74 40                	je     c002b407 <process_wait+0x98>
c002b3c7:	80 38 00             	cmpb   $0x0,(%eax)
c002b3ca:	75 42                	jne    c002b40e <process_wait+0x9f>
    child->is_waiting = true;
c002b3cc:	c6 00 01             	movb   $0x1,(%eax)
    while (!child->has_exited) {
c002b3cf:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
c002b3d3:	75 0b                	jne    c002b3e0 <process_wait+0x71>
        thread_yield();
c002b3d5:	e8 dd 62 ff ff       	call   c00216b7 <thread_yield>
    while (!child->has_exited) {
c002b3da:	80 7e 01 00          	cmpb   $0x0,0x1(%esi)
c002b3de:	74 f5                	je     c002b3d5 <process_wait+0x66>
    int exit_status = child->exit_status;
c002b3e0:	8b 7e 08             	mov    0x8(%esi),%edi
    list_remove(&child->elem);
c002b3e3:	83 ec 0c             	sub    $0xc,%esp
c002b3e6:	8d 46 0c             	lea    0xc(%esi),%eax
c002b3e9:	50                   	push   %eax
c002b3ea:	e8 ba e3 ff ff       	call   c00297a9 <list_remove>
    free(child);
c002b3ef:	89 34 24             	mov    %esi,(%esp)
c002b3f2:	e8 b2 8b ff ff       	call   c0023fa9 <free>
    return exit_status;
c002b3f7:	83 c4 10             	add    $0x10,%esp
}
c002b3fa:	89 f8                	mov    %edi,%eax
c002b3fc:	5b                   	pop    %ebx
c002b3fd:	5e                   	pop    %esi
c002b3fe:	5f                   	pop    %edi
c002b3ff:	c3                   	ret    
        return -1;
c002b400:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002b405:	eb f3                	jmp    c002b3fa <process_wait+0x8b>
        return -1;
c002b407:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002b40c:	eb ec                	jmp    c002b3fa <process_wait+0x8b>
c002b40e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002b413:	eb e5                	jmp    c002b3fa <process_wait+0x8b>

c002b415 <remove_all_children>:
void remove_all_children(struct thread *t) {
c002b415:	56                   	push   %esi
c002b416:	53                   	push   %ebx
c002b417:	83 ec 04             	sub    $0x4,%esp
c002b41a:	e8 d9 3a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b41f:	81 c3 09 fd 00 00    	add    $0xfd09,%ebx
    while (!list_empty(&t->child_list)) {
c002b425:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b429:	8d b0 cc 00 00 00    	lea    0xcc(%eax),%esi
c002b42f:	83 ec 0c             	sub    $0xc,%esp
c002b432:	56                   	push   %esi
c002b433:	e8 13 e4 ff ff       	call   c002984b <list_empty>
c002b438:	83 c4 10             	add    $0x10,%esp
c002b43b:	84 c0                	test   %al,%al
c002b43d:	75 1b                	jne    c002b45a <remove_all_children+0x45>
        e = list_pop_front(&t->child_list);
c002b43f:	83 ec 0c             	sub    $0xc,%esp
c002b442:	56                   	push   %esi
c002b443:	e8 7a e4 ff ff       	call   c00298c2 <list_pop_front>
        child_info->thread_->parent = NULL;
c002b448:	8b 40 08             	mov    0x8(%eax),%eax
c002b44b:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%eax)
c002b452:	00 00 00 
c002b455:	83 c4 10             	add    $0x10,%esp
c002b458:	eb d5                	jmp    c002b42f <remove_all_children+0x1a>
}
c002b45a:	83 c4 04             	add    $0x4,%esp
c002b45d:	5b                   	pop    %ebx
c002b45e:	5e                   	pop    %esi
c002b45f:	c3                   	ret    

c002b460 <process_exit>:
process_exit(void) {
c002b460:	57                   	push   %edi
c002b461:	56                   	push   %esi
c002b462:	53                   	push   %ebx
c002b463:	83 ec 10             	sub    $0x10,%esp
c002b466:	e8 8d 3a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b46b:	81 c3 bd fc 00 00    	add    $0xfcbd,%ebx
    struct thread *cur = thread_current();
c002b471:	e8 00 5b ff ff       	call   c0020f76 <thread_current>
c002b476:	89 c6                	mov    %eax,%esi
    remove_all_children(cur);
c002b478:	83 ec 0c             	sub    $0xc,%esp
c002b47b:	50                   	push   %eax
c002b47c:	e8 94 ff ff ff       	call   c002b415 <remove_all_children>
    if (cur->src_code != NULL)
c002b481:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
c002b487:	83 c4 10             	add    $0x10,%esp
c002b48a:	85 c0                	test   %eax,%eax
c002b48c:	74 0c                	je     c002b49a <process_exit+0x3a>
        file_allow_write(cur->src_code);
c002b48e:	83 ec 0c             	sub    $0xc,%esp
c002b491:	50                   	push   %eax
c002b492:	e8 63 25 00 00       	call   c002d9fa <file_allow_write>
c002b497:	83 c4 10             	add    $0x10,%esp
    struct list brother_list = cur->parent->child_list;
c002b49a:	8b 86 dc 00 00 00    	mov    0xdc(%esi),%eax
c002b4a0:	8b 90 cc 00 00 00    	mov    0xcc(%eax),%edx
c002b4a6:	89 14 24             	mov    %edx,(%esp)
c002b4a9:	8b 88 d0 00 00 00    	mov    0xd0(%eax),%ecx
c002b4af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c002b4b3:	8b b8 d4 00 00 00    	mov    0xd4(%eax),%edi
c002b4b9:	89 7c 24 08          	mov    %edi,0x8(%esp)
c002b4bd:	8b 80 d8 00 00 00    	mov    0xd8(%eax),%eax
c002b4c3:	89 44 24 0c          	mov    %eax,0xc(%esp)
    struct process_info *info_t = get_child_process(cur->tid, brother_list);
c002b4c7:	83 ec 0c             	sub    $0xc,%esp
c002b4ca:	50                   	push   %eax
c002b4cb:	57                   	push   %edi
c002b4cc:	51                   	push   %ecx
c002b4cd:	52                   	push   %edx
c002b4ce:	ff 36                	pushl  (%esi)
c002b4d0:	e8 16 fe ff ff       	call   c002b2eb <get_child_process>
    if (info_t != NULL) {
c002b4d5:	83 c4 20             	add    $0x20,%esp
c002b4d8:	85 c0                	test   %eax,%eax
c002b4da:	74 0a                	je     c002b4e6 <process_exit+0x86>
        info_t->exit_status = cur->exit_status;
c002b4dc:	8b 56 2c             	mov    0x2c(%esi),%edx
c002b4df:	89 50 08             	mov    %edx,0x8(%eax)
        info_t->has_exited = true;
c002b4e2:	c6 40 01 01          	movb   $0x1,0x1(%eax)
    pd = cur->pagedir;
c002b4e6:	8b be 10 01 00 00    	mov    0x110(%esi),%edi
    if (pd != NULL) {
c002b4ec:	85 ff                	test   %edi,%edi
c002b4ee:	74 1f                	je     c002b50f <process_exit+0xaf>
        cur->pagedir = NULL;
c002b4f0:	c7 86 10 01 00 00 00 	movl   $0x0,0x110(%esi)
c002b4f7:	00 00 00 
        pagedir_activate(NULL);
c002b4fa:	83 ec 0c             	sub    $0xc,%esp
c002b4fd:	6a 00                	push   $0x0
c002b4ff:	e8 d0 0d 00 00       	call   c002c2d4 <pagedir_activate>
        pagedir_destroy(pd);
c002b504:	89 3c 24             	mov    %edi,(%esp)
c002b507:	e8 be 09 00 00       	call   c002beca <pagedir_destroy>
c002b50c:	83 c4 10             	add    $0x10,%esp
}
c002b50f:	83 c4 10             	add    $0x10,%esp
c002b512:	5b                   	pop    %ebx
c002b513:	5e                   	pop    %esi
c002b514:	5f                   	pop    %edi
c002b515:	c3                   	ret    

c002b516 <process_activate>:
process_activate(void) {
c002b516:	53                   	push   %ebx
c002b517:	83 ec 08             	sub    $0x8,%esp
c002b51a:	e8 d9 39 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b51f:	81 c3 09 fc 00 00    	add    $0xfc09,%ebx
    struct thread *t = thread_current();
c002b525:	e8 4c 5a ff ff       	call   c0020f76 <thread_current>
    pagedir_activate(t->pagedir);
c002b52a:	83 ec 0c             	sub    $0xc,%esp
c002b52d:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002b533:	e8 9c 0d 00 00       	call   c002c2d4 <pagedir_activate>
    tss_update();
c002b538:	e8 e0 1d 00 00       	call   c002d31d <tss_update>
}
c002b53d:	83 c4 18             	add    $0x18,%esp
c002b540:	5b                   	pop    %ebx
c002b541:	c3                   	ret    

c002b542 <push_arguments>:
void *push_arguments(struct arguments *args, void **esp) {
c002b542:	55                   	push   %ebp
c002b543:	57                   	push   %edi
c002b544:	56                   	push   %esi
c002b545:	53                   	push   %ebx
c002b546:	83 ec 28             	sub    $0x28,%esp
c002b549:	e8 aa 39 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b54e:	81 c3 da fb 00 00    	add    $0xfbda,%ebx
c002b554:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c002b558:	8b 74 24 40          	mov    0x40(%esp),%esi
    void **arg_ptr_list = (void **) malloc(args->argc * sizeof(void *));
c002b55c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002b560:	8b 38                	mov    (%eax),%edi
c002b562:	8d 2c bd 00 00 00 00 	lea    0x0(,%edi,4),%ebp
c002b569:	55                   	push   %ebp
c002b56a:	e8 8c 88 ff ff       	call   c0023dfb <malloc>
c002b56f:	89 44 24 10          	mov    %eax,0x10(%esp)
    for (int i = args->argc - 1; i >= 0; i--) {
c002b573:	83 c4 10             	add    $0x10,%esp
c002b576:	85 ff                	test   %edi,%edi
c002b578:	7e 56                	jle    c002b5d0 <push_arguments+0x8e>
c002b57a:	83 ed 04             	sub    $0x4,%ebp
        char *arg_i = args->argv[i];
c002b57d:	8b 44 24 30          	mov    0x30(%esp),%eax
c002b581:	8b 40 04             	mov    0x4(%eax),%eax
c002b584:	8b 14 28             	mov    (%eax,%ebp,1),%edx
        *esp -= (strlen(arg_i) + 1); // also need to pass %0
c002b587:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b58c:	89 d7                	mov    %edx,%edi
c002b58e:	b8 00 00 00 00       	mov    $0x0,%eax
c002b593:	f2 ae                	repnz scas %es:(%edi),%al
c002b595:	8b 06                	mov    (%esi),%eax
c002b597:	8d 5c 08 01          	lea    0x1(%eax,%ecx,1),%ebx
c002b59b:	89 1e                	mov    %ebx,(%esi)
        memcpy(*esp, arg_i, strlen(arg_i) + 1);
c002b59d:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002b5a2:	89 d7                	mov    %edx,%edi
c002b5a4:	b8 00 00 00 00       	mov    $0x0,%eax
c002b5a9:	f2 ae                	repnz scas %es:(%edi),%al
c002b5ab:	f7 d1                	not    %ecx
c002b5ad:	83 ec 04             	sub    $0x4,%esp
c002b5b0:	51                   	push   %ecx
c002b5b1:	52                   	push   %edx
c002b5b2:	53                   	push   %ebx
c002b5b3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002b5b7:	e8 0d cd ff ff       	call   c00282c9 <memcpy>
        arg_ptr_list[i] = *esp;
c002b5bc:	8b 06                	mov    (%esi),%eax
c002b5be:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002b5c2:	89 04 2f             	mov    %eax,(%edi,%ebp,1)
c002b5c5:	83 ed 04             	sub    $0x4,%ebp
    for (int i = args->argc - 1; i >= 0; i--) {
c002b5c8:	83 c4 10             	add    $0x10,%esp
c002b5cb:	83 fd fc             	cmp    $0xfffffffc,%ebp
c002b5ce:	75 ad                	jne    c002b57d <push_arguments+0x3b>
    int align = ((uint32_t) *esp) % sizeof(uintptr_t);
c002b5d0:	8b 06                	mov    (%esi),%eax
    *esp -= align;
c002b5d2:	89 c1                	mov    %eax,%ecx
c002b5d4:	83 e1 fc             	and    $0xfffffffc,%ecx
c002b5d7:	89 0e                	mov    %ecx,(%esi)
    memset(*esp, 0, align);
c002b5d9:	83 e0 03             	and    $0x3,%eax
c002b5dc:	89 c2                	mov    %eax,%edx
c002b5de:	74 10                	je     c002b5f0 <push_arguments+0xae>
c002b5e0:	b8 00 00 00 00       	mov    $0x0,%eax
c002b5e5:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
c002b5e9:	83 c0 01             	add    $0x1,%eax
c002b5ec:	39 d0                	cmp    %edx,%eax
c002b5ee:	72 f5                	jb     c002b5e5 <push_arguments+0xa3>
    *esp -= sizeof(uint32_t);
c002b5f0:	8b 06                	mov    (%esi),%eax
c002b5f2:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b5f5:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &t, sizeof(uint32_t));
c002b5f7:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    for (int i = args->argc - 1; i >= 0; i--) {
c002b5fe:	8b 44 24 30          	mov    0x30(%esp),%eax
c002b602:	8b 00                	mov    (%eax),%eax
c002b604:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002b608:	83 e8 01             	sub    $0x1,%eax
c002b60b:	78 24                	js     c002b631 <push_arguments+0xef>
c002b60d:	8b 3c 24             	mov    (%esp),%edi
c002b610:	eb 08                	jmp    c002b61a <push_arguments+0xd8>
c002b612:	83 e8 01             	sub    $0x1,%eax
c002b615:	83 f8 ff             	cmp    $0xffffffff,%eax
c002b618:	74 17                	je     c002b631 <push_arguments+0xef>
        uint32_t arg_i_addr = (uint32_t) arg_ptr_list[i];
c002b61a:	8b 0c 87             	mov    (%edi,%eax,4),%ecx
        *esp -= sizeof(uint32_t);
c002b61d:	8b 16                	mov    (%esi),%edx
c002b61f:	8d 5a fc             	lea    -0x4(%edx),%ebx
c002b622:	89 1e                	mov    %ebx,(%esi)
        memcpy(*esp, &arg_i_addr, sizeof(uint32_t));
c002b624:	89 4a fc             	mov    %ecx,-0x4(%edx)
        if (i == 0) argv_ptr = (uint32_t) *esp;
c002b627:	85 c0                	test   %eax,%eax
c002b629:	75 e7                	jne    c002b612 <push_arguments+0xd0>
c002b62b:	8b 06                	mov    (%esi),%eax
c002b62d:	89 44 24 08          	mov    %eax,0x8(%esp)
    *esp -= sizeof(uint32_t);
c002b631:	8b 06                	mov    (%esi),%eax
c002b633:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b636:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &argv_ptr, sizeof(uint32_t));
c002b638:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c002b63c:	89 58 fc             	mov    %ebx,-0x4(%eax)
    *esp -= sizeof(int);
c002b63f:	8b 06                	mov    (%esi),%eax
c002b641:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b644:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &(args->argc), sizeof(int));
c002b646:	8b 5c 24 30          	mov    0x30(%esp),%ebx
c002b64a:	8b 13                	mov    (%ebx),%edx
c002b64c:	89 50 fc             	mov    %edx,-0x4(%eax)
    *esp -= sizeof(void *);
c002b64f:	8b 06                	mov    (%esi),%eax
c002b651:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b654:	89 16                	mov    %edx,(%esi)
    memcpy(*esp, &args->argv[args->argc], sizeof(void *));
c002b656:	8b 0b                	mov    (%ebx),%ecx
c002b658:	8b 53 04             	mov    0x4(%ebx),%edx
c002b65b:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c002b65e:	89 50 fc             	mov    %edx,-0x4(%eax)
    free(arg_ptr_list);
c002b661:	83 ec 0c             	sub    $0xc,%esp
c002b664:	ff 74 24 0c          	pushl  0xc(%esp)
c002b668:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002b66c:	e8 38 89 ff ff       	call   c0023fa9 <free>
    return *esp;
c002b671:	8b 06                	mov    (%esi),%eax
}
c002b673:	83 c4 2c             	add    $0x2c,%esp
c002b676:	5b                   	pop    %ebx
c002b677:	5e                   	pop    %esi
c002b678:	5f                   	pop    %edi
c002b679:	5d                   	pop    %ebp
c002b67a:	c3                   	ret    

c002b67b <start_process>:
start_process(void *arg) {
c002b67b:	55                   	push   %ebp
c002b67c:	57                   	push   %edi
c002b67d:	56                   	push   %esi
c002b67e:	53                   	push   %ebx
c002b67f:	81 ec ec 00 00 00    	sub    $0xec,%esp
c002b685:	e8 6e 38 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002b68a:	81 c3 9e fa 00 00    	add    $0xfa9e,%ebx
    char *file_name = p_arg->file_name;
c002b690:	8b 84 24 00 01 00 00 	mov    0x100(%esp),%eax
c002b697:	8b 00                	mov    (%eax),%eax
c002b699:	89 44 24 08          	mov    %eax,0x8(%esp)
    memset(&if_, 0, sizeof if_);
c002b69d:	8d 94 24 90 00 00 00 	lea    0x90(%esp),%edx
c002b6a4:	b9 14 00 00 00       	mov    $0x14,%ecx
c002b6a9:	b8 00 00 00 00       	mov    $0x0,%eax
c002b6ae:	89 d7                	mov    %edx,%edi
c002b6b0:	f3 ab                	rep stos %eax,%es:(%edi)
    if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002b6b2:	66 c7 84 24 dc 00 00 	movw   $0x23,0xdc(%esp)
c002b6b9:	00 23 00 
c002b6bc:	66 c7 84 24 bc 00 00 	movw   $0x23,0xbc(%esp)
c002b6c3:	00 23 00 
c002b6c6:	66 c7 84 24 b8 00 00 	movw   $0x23,0xb8(%esp)
c002b6cd:	00 23 00 
c002b6d0:	66 c7 84 24 b4 00 00 	movw   $0x23,0xb4(%esp)
c002b6d7:	00 23 00 
c002b6da:	66 c7 84 24 b0 00 00 	movw   $0x23,0xb0(%esp)
c002b6e1:	00 23 00 
    if_.cs = SEL_UCSEG;
c002b6e4:	66 c7 84 24 d0 00 00 	movw   $0x1b,0xd0(%esp)
c002b6eb:	00 1b 00 
    if_.eflags = FLAG_IF | FLAG_MBS;
c002b6ee:	c7 84 24 d4 00 00 00 	movl   $0x202,0xd4(%esp)
c002b6f5:	02 02 00 00 
    struct thread *t = thread_current();
c002b6f9:	e8 78 58 ff ff       	call   c0020f76 <thread_current>
c002b6fe:	89 c7                	mov    %eax,%edi
c002b700:	89 44 24 0c          	mov    %eax,0xc(%esp)
    t->pagedir = pagedir_create();
c002b704:	e8 6f 07 00 00       	call   c002be78 <pagedir_create>
c002b709:	89 87 10 01 00 00    	mov    %eax,0x110(%edi)
    if (t->pagedir == NULL)
c002b70f:	85 c0                	test   %eax,%eax
c002b711:	0f 84 57 01 00 00    	je     c002b86e <start_process+0x1f3>
    process_activate();
c002b717:	e8 fa fd ff ff       	call   c002b516 <process_activate>
    args = (struct arguments *) malloc(sizeof(struct arguments));
c002b71c:	83 ec 0c             	sub    $0xc,%esp
c002b71f:	6a 08                	push   $0x8
c002b721:	e8 d5 86 ff ff       	call   c0023dfb <malloc>
c002b726:	89 c5                	mov    %eax,%ebp
    args->argc = 0;
c002b728:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    args->argv = (char **) palloc_get_page(0); // ??
c002b72e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b735:	e8 af 82 ff ff       	call   c00239e9 <palloc_get_page>
c002b73a:	89 c6                	mov    %eax,%esi
c002b73c:	89 45 04             	mov    %eax,0x4(%ebp)
    if (args->argv == NULL) {
c002b73f:	83 c4 10             	add    $0x10,%esp
c002b742:	85 c0                	test   %eax,%eax
c002b744:	0f 84 f4 00 00 00    	je     c002b83e <start_process+0x1c3>
    for (token = strtok_r(str_input, " ", &saved_ptr); token != NULL;
c002b74a:	83 ec 04             	sub    $0x4,%esp
c002b74d:	8d 44 24 60          	lea    0x60(%esp),%eax
c002b751:	50                   	push   %eax
c002b752:	8d 83 aa 69 ff ff    	lea    -0x9656(%ebx),%eax
c002b758:	50                   	push   %eax
c002b759:	ff 74 24 14          	pushl  0x14(%esp)
c002b75d:	e8 b3 cd ff ff       	call   c0028515 <strtok_r>
c002b762:	83 c4 10             	add    $0x10,%esp
c002b765:	85 c0                	test   %eax,%eax
c002b767:	74 2a                	je     c002b793 <start_process+0x118>
         token = strtok_r(NULL, " ", &saved_ptr)) {
c002b769:	8d 7c 24 5c          	lea    0x5c(%esp),%edi
c002b76d:	8d b3 aa 69 ff ff    	lea    -0x9656(%ebx),%esi
        args->argv[args->argc] = token; // token generated by *s = '\0';
c002b773:	8b 4d 00             	mov    0x0(%ebp),%ecx
c002b776:	8b 55 04             	mov    0x4(%ebp),%edx
c002b779:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
        args->argc++;
c002b77c:	83 45 00 01          	addl   $0x1,0x0(%ebp)
         token = strtok_r(NULL, " ", &saved_ptr)) {
c002b780:	83 ec 04             	sub    $0x4,%esp
c002b783:	57                   	push   %edi
c002b784:	56                   	push   %esi
c002b785:	6a 00                	push   $0x0
c002b787:	e8 89 cd ff ff       	call   c0028515 <strtok_r>
    for (token = strtok_r(str_input, " ", &saved_ptr); token != NULL;
c002b78c:	83 c4 10             	add    $0x10,%esp
c002b78f:	85 c0                	test   %eax,%eax
c002b791:	75 e0                	jne    c002b773 <start_process+0xf8>
    lock_acquire(get_fs_lock());
c002b793:	e8 f8 0f 00 00       	call   c002c790 <get_fs_lock>
c002b798:	83 ec 0c             	sub    $0xc,%esp
c002b79b:	50                   	push   %eax
c002b79c:	e8 68 7a ff ff       	call   c0023209 <lock_acquire>
    file = filesys_open(args->argv[0]);
c002b7a1:	83 c4 04             	add    $0x4,%esp
c002b7a4:	8b 45 04             	mov    0x4(%ebp),%eax
c002b7a7:	ff 30                	pushl  (%eax)
c002b7a9:	e8 67 1d 00 00       	call   c002d515 <filesys_open>
c002b7ae:	89 c6                	mov    %eax,%esi
    if (file == NULL) {
c002b7b0:	83 c4 10             	add    $0x10,%esp
c002b7b3:	85 c0                	test   %eax,%eax
c002b7b5:	0f 84 9c 00 00 00    	je     c002b857 <start_process+0x1dc>
    file_deny_write(file);
c002b7bb:	83 ec 0c             	sub    $0xc,%esp
c002b7be:	56                   	push   %esi
c002b7bf:	e8 db 21 00 00       	call   c002d99f <file_deny_write>
    if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr
c002b7c4:	83 c4 0c             	add    $0xc,%esp
c002b7c7:	6a 34                	push   $0x34
c002b7c9:	8d 44 24 64          	lea    0x64(%esp),%eax
c002b7cd:	50                   	push   %eax
c002b7ce:	56                   	push   %esi
c002b7cf:	e8 17 21 00 00       	call   c002d8eb <file_read>
c002b7d4:	83 c4 10             	add    $0x10,%esp
c002b7d7:	83 f8 34             	cmp    $0x34,%eax
c002b7da:	0f 85 8e 00 00 00    	jne    c002b86e <start_process+0x1f3>
        || memcmp(ehdr.e_ident, "\177ELF\1\1\1", 7)
c002b7e0:	83 ec 04             	sub    $0x4,%esp
c002b7e3:	6a 07                	push   $0x7
c002b7e5:	8d 83 3f 6f ff ff    	lea    -0x90c1(%ebx),%eax
c002b7eb:	50                   	push   %eax
c002b7ec:	8d 44 24 68          	lea    0x68(%esp),%eax
c002b7f0:	50                   	push   %eax
c002b7f1:	e8 4d cb ff ff       	call   c0028343 <memcmp>
c002b7f6:	83 c4 10             	add    $0x10,%esp
c002b7f9:	89 44 24 10          	mov    %eax,0x10(%esp)
c002b7fd:	85 c0                	test   %eax,%eax
c002b7ff:	75 6d                	jne    c002b86e <start_process+0x1f3>
        || ehdr.e_machine != 3
c002b801:	81 7c 24 6c 02 00 03 	cmpl   $0x30002,0x6c(%esp)
c002b808:	00 
c002b809:	75 63                	jne    c002b86e <start_process+0x1f3>
        || ehdr.e_version != 1
c002b80b:	83 7c 24 70 01       	cmpl   $0x1,0x70(%esp)
c002b810:	75 5c                	jne    c002b86e <start_process+0x1f3>
        || ehdr.e_phentsize != sizeof(struct Elf32_Phdr)
c002b812:	66 83 bc 24 86 00 00 	cmpw   $0x20,0x86(%esp)
c002b819:	00 20 
c002b81b:	75 51                	jne    c002b86e <start_process+0x1f3>
        || ehdr.e_phnum > 1024) {
c002b81d:	66 81 bc 24 88 00 00 	cmpw   $0x400,0x88(%esp)
c002b824:	00 00 04 
c002b827:	77 45                	ja     c002b86e <start_process+0x1f3>
    file_ofs = ehdr.e_phoff;
c002b829:	8b 44 24 78          	mov    0x78(%esp),%eax
c002b82d:	89 44 24 28          	mov    %eax,0x28(%esp)
    for (i = 0; i < ehdr.e_phnum; i++) { // Number of program headers
c002b831:	89 74 24 20          	mov    %esi,0x20(%esp)
c002b835:	89 6c 24 2c          	mov    %ebp,0x2c(%esp)
c002b839:	e9 91 00 00 00       	jmp    c002b8cf <start_process+0x254>
        palloc_free_page(args->argv);
c002b83e:	83 ec 0c             	sub    $0xc,%esp
c002b841:	6a 00                	push   $0x0
c002b843:	e8 0c 83 ff ff       	call   c0023b54 <palloc_free_page>
        free(args);
c002b848:	89 2c 24             	mov    %ebp,(%esp)
c002b84b:	e8 59 87 ff ff       	call   c0023fa9 <free>
    if (args == NULL) {
c002b850:	83 c4 10             	add    $0x10,%esp
    args = parse_arguments(file_name); //split into arguments
c002b853:	89 f5                	mov    %esi,%ebp
c002b855:	eb 17                	jmp    c002b86e <start_process+0x1f3>
        printf ("load: %s: open failed\n", args->argv[0]);
c002b857:	83 ec 08             	sub    $0x8,%esp
c002b85a:	8b 45 04             	mov    0x4(%ebp),%eax
c002b85d:	ff 30                	pushl  (%eax)
c002b85f:	8d 83 28 6f ff ff    	lea    -0x90d8(%ebx),%eax
c002b865:	50                   	push   %eax
c002b866:	e8 13 bc ff ff       	call   c002747e <printf>
c002b86b:	83 c4 10             	add    $0x10,%esp
    palloc_free_page(args->argv);
c002b86e:	83 ec 0c             	sub    $0xc,%esp
c002b871:	ff 75 04             	pushl  0x4(%ebp)
c002b874:	e8 db 82 ff ff       	call   c0023b54 <palloc_free_page>
    free(args);
c002b879:	89 2c 24             	mov    %ebp,(%esp)
c002b87c:	e8 28 87 ff ff       	call   c0023fa9 <free>
    lock_release(get_fs_lock());
c002b881:	e8 0a 0f 00 00       	call   c002c790 <get_fs_lock>
c002b886:	89 04 24             	mov    %eax,(%esp)
c002b889:	e8 7c 7b ff ff       	call   c002340a <lock_release>
    palloc_free_page(file_name);
c002b88e:	83 c4 04             	add    $0x4,%esp
c002b891:	ff 74 24 14          	pushl  0x14(%esp)
c002b895:	e8 ba 82 ff ff       	call   c0023b54 <palloc_free_page>
        p_arg->success = false;
c002b89a:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002b8a1:	c6 40 18 00          	movb   $0x0,0x18(%eax)
        sema_up(&p_arg->sema);
c002b8a5:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002b8ac:	83 c0 04             	add    $0x4,%eax
c002b8af:	89 04 24             	mov    %eax,(%esp)
c002b8b2:	e8 54 77 ff ff       	call   c002300b <sema_up>
        thread_exit();
c002b8b7:	e8 19 5d ff ff       	call   c00215d5 <thread_exit>
        switch (phdr.p_type) {
c002b8bc:	83 f8 05             	cmp    $0x5,%eax
c002b8bf:	0f 84 dd 03 00 00    	je     c002bca2 <start_process+0x627>
c002b8c5:	83 44 24 28 20       	addl   $0x20,0x28(%esp)
    for (i = 0; i < ehdr.e_phnum; i++) { // Number of program headers
c002b8ca:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
c002b8cf:	0f b7 84 24 88 00 00 	movzwl 0x88(%esp),%eax
c002b8d6:	00 
c002b8d7:	39 44 24 10          	cmp    %eax,0x10(%esp)
c002b8db:	0f 8d 8c 02 00 00    	jge    c002bb6d <start_process+0x4f2>
        if (file_ofs < 0 || file_ofs > file_length(file))
c002b8e1:	8b 74 24 28          	mov    0x28(%esp),%esi
c002b8e5:	85 f6                	test   %esi,%esi
c002b8e7:	0f 88 91 03 00 00    	js     c002bc7e <start_process+0x603>
c002b8ed:	83 ec 0c             	sub    $0xc,%esp
c002b8f0:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002b8f4:	57                   	push   %edi
c002b8f5:	e8 97 21 00 00       	call   c002da91 <file_length>
c002b8fa:	83 c4 10             	add    $0x10,%esp
c002b8fd:	39 c6                	cmp    %eax,%esi
c002b8ff:	0f 8f 82 03 00 00    	jg     c002bc87 <start_process+0x60c>
        file_seek(file, file_ofs);
c002b905:	83 ec 08             	sub    $0x8,%esp
c002b908:	56                   	push   %esi
c002b909:	57                   	push   %edi
c002b90a:	e8 d1 21 00 00       	call   c002dae0 <file_seek>
        if (file_read(file, &phdr, sizeof phdr) != sizeof phdr)
c002b90f:	83 c4 0c             	add    $0xc,%esp
c002b912:	6a 20                	push   $0x20
c002b914:	8d 44 24 44          	lea    0x44(%esp),%eax
c002b918:	50                   	push   %eax
c002b919:	57                   	push   %edi
c002b91a:	e8 cc 1f 00 00       	call   c002d8eb <file_read>
c002b91f:	83 c4 10             	add    $0x10,%esp
c002b922:	83 f8 20             	cmp    $0x20,%eax
c002b925:	0f 85 65 03 00 00    	jne    c002bc90 <start_process+0x615>
        if (phdr.p_filesz == 0xb4)
c002b92b:	81 7c 24 4c b4 00 00 	cmpl   $0xb4,0x4c(%esp)
c002b932:	00 
c002b933:	74 90                	je     c002b8c5 <start_process+0x24a>
        switch (phdr.p_type) {
c002b935:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002b939:	83 f8 03             	cmp    $0x3,%eax
c002b93c:	0f 87 7a ff ff ff    	ja     c002b8bc <start_process+0x241>
c002b942:	83 f8 02             	cmp    $0x2,%eax
c002b945:	0f 83 4e 03 00 00    	jae    c002bc99 <start_process+0x61e>
c002b94b:	83 f8 01             	cmp    $0x1,%eax
c002b94e:	0f 85 71 ff ff ff    	jne    c002b8c5 <start_process+0x24a>
    if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK))
c002b954:	8b 74 24 40          	mov    0x40(%esp),%esi
c002b958:	89 f0                	mov    %esi,%eax
c002b95a:	33 44 24 44          	xor    0x44(%esp),%eax
c002b95e:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002b963:	74 09                	je     c002b96e <start_process+0x2f3>
c002b965:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002b969:	e9 00 ff ff ff       	jmp    c002b86e <start_process+0x1f3>
    if (phdr->p_offset > (Elf32_Off) file_length(file))
c002b96e:	83 ec 0c             	sub    $0xc,%esp
c002b971:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b975:	e8 17 21 00 00       	call   c002da91 <file_length>
c002b97a:	83 c4 10             	add    $0x10,%esp
c002b97d:	39 c6                	cmp    %eax,%esi
c002b97f:	0f 87 26 03 00 00    	ja     c002bcab <start_process+0x630>
    if (phdr->p_memsz < phdr->p_filesz)
c002b985:	8b 7c 24 50          	mov    0x50(%esp),%edi
c002b989:	8b 6c 24 4c          	mov    0x4c(%esp),%ebp
    if (phdr->p_memsz == 0)
c002b98d:	85 ff                	test   %edi,%edi
c002b98f:	0f 84 1f 03 00 00    	je     c002bcb4 <start_process+0x639>
c002b995:	39 ef                	cmp    %ebp,%edi
c002b997:	0f 82 20 03 00 00    	jb     c002bcbd <start_process+0x642>
    if (!is_user_vaddr((void *) phdr->p_vaddr))
c002b99d:	8b 44 24 44          	mov    0x44(%esp),%eax
c002b9a1:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b9a6:	0f 87 1a 03 00 00    	ja     c002bcc6 <start_process+0x64b>
    if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002b9ac:	89 fa                	mov    %edi,%edx
c002b9ae:	01 c2                	add    %eax,%edx
c002b9b0:	89 54 24 14          	mov    %edx,0x14(%esp)
c002b9b4:	0f 92 c1             	setb   %cl
c002b9b7:	89 ce                	mov    %ecx,%esi
    if (phdr->p_vaddr < PGSIZE)
c002b9b9:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002b9be:	0f 96 c1             	setbe  %cl
                if (validate_segment(&phdr, file)) {
c002b9c1:	89 f2                	mov    %esi,%edx
c002b9c3:	08 ca                	or     %cl,%dl
c002b9c5:	0f 85 04 03 00 00    	jne    c002bccf <start_process+0x654>
c002b9cb:	81 7c 24 14 ff ff ff 	cmpl   $0xbfffffff,0x14(%esp)
c002b9d2:	bf 
c002b9d3:	0f 87 ff 02 00 00    	ja     c002bcd8 <start_process+0x65d>
                    bool writable = (phdr.p_flags & PF_W) != 0;
c002b9d9:	8b 54 24 54          	mov    0x54(%esp),%edx
c002b9dd:	d1 ea                	shr    %edx
c002b9df:	83 e2 01             	and    $0x1,%edx
                    uint32_t file_page = phdr.p_offset & ~PGMASK;
c002b9e2:	8b 74 24 40          	mov    0x40(%esp),%esi
c002b9e6:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
                    uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002b9ec:	89 c1                	mov    %eax,%ecx
c002b9ee:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
                    uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002b9f4:	25 ff 0f 00 00       	and    $0xfff,%eax
                    if (phdr.p_filesz > 0) {
c002b9f9:	85 ed                	test   %ebp,%ebp
c002b9fb:	74 34                	je     c002ba31 <start_process+0x3b6>
                        read_bytes = page_offset + phdr.p_filesz;
c002b9fd:	01 c5                	add    %eax,%ebp
                        zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
c002b9ff:	8d 84 38 ff 0f 00 00 	lea    0xfff(%eax,%edi,1),%eax
c002ba06:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002ba0b:	29 e8                	sub    %ebp,%eax
c002ba0d:	89 44 24 14          	mov    %eax,0x14(%esp)
                    if (!load_segment(file, file_page, (void *) mem_page,
c002ba11:	0f b6 c2             	movzbl %dl,%eax
c002ba14:	89 44 24 24          	mov    %eax,0x24(%esp)
c002ba18:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    file_seek(file, ofs);
c002ba1c:	83 ec 08             	sub    $0x8,%esp
c002ba1f:	56                   	push   %esi
c002ba20:	ff 74 24 2c          	pushl  0x2c(%esp)
c002ba24:	e8 b7 20 00 00       	call   c002dae0 <file_seek>
c002ba29:	83 c4 10             	add    $0x10,%esp
c002ba2c:	e9 8c 00 00 00       	jmp    c002babd <start_process+0x442>
                        zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
c002ba31:	8d 84 38 ff 0f 00 00 	lea    0xfff(%eax,%edi,1),%eax
c002ba38:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002ba3d:	89 44 24 14          	mov    %eax,0x14(%esp)
                    if (!load_segment(file, file_page, (void *) mem_page,
c002ba41:	0f b6 c2             	movzbl %dl,%eax
c002ba44:	89 44 24 24          	mov    %eax,0x24(%esp)
c002ba48:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002ba4c:	eb ce                	jmp    c002ba1c <start_process+0x3a1>
c002ba4e:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
            palloc_free_page(kpage);
c002ba52:	83 ec 0c             	sub    $0xc,%esp
c002ba55:	ff 74 24 24          	pushl  0x24(%esp)
c002ba59:	e8 f6 80 ff ff       	call   c0023b54 <palloc_free_page>
c002ba5e:	83 c4 10             	add    $0x10,%esp
c002ba61:	e9 08 fe ff ff       	jmp    c002b86e <start_process+0x1f3>
        memset(kpage + page_read_bytes, 0, page_zero_bytes);
c002ba66:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c002ba6c:	c7 44 07 fc 00 00 00 	movl   $0x0,-0x4(%edi,%eax,1)
c002ba73:	00 
c002ba74:	8d 50 04             	lea    0x4(%eax),%edx
c002ba77:	83 e2 fc             	and    $0xfffffffc,%edx
c002ba7a:	29 d0                	sub    %edx,%eax
c002ba7c:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
c002ba7f:	c1 e9 02             	shr    $0x2,%ecx
c002ba82:	89 d7                	mov    %edx,%edi
c002ba84:	b8 00 00 00 00       	mov    $0x0,%eax
c002ba89:	f3 ab                	rep stos %eax,%es:(%edi)
        if (!install_page(upage, kpage, writable)) {
c002ba8b:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002ba8f:	8b 54 24 18          	mov    0x18(%esp),%edx
c002ba93:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ba97:	e8 a7 f6 ff ff       	call   c002b143 <install_page>
c002ba9c:	84 c0                	test   %al,%al
c002ba9e:	0f 84 9e 00 00 00    	je     c002bb42 <start_process+0x4c7>
        read_bytes -= page_read_bytes;
c002baa4:	29 f5                	sub    %esi,%ebp
        zero_bytes -= page_zero_bytes;
c002baa6:	8b 44 24 14          	mov    0x14(%esp),%eax
c002baaa:	8d 84 06 00 f0 ff ff 	lea    -0x1000(%esi,%eax,1),%eax
c002bab1:	89 44 24 14          	mov    %eax,0x14(%esp)
        upage += PGSIZE;
c002bab5:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c002babc:	00 
    while (read_bytes > 0 || zero_bytes > 0) {
c002babd:	8b 44 24 14          	mov    0x14(%esp),%eax
c002bac1:	09 e8                	or     %ebp,%eax
c002bac3:	0f 84 fc fd ff ff    	je     c002b8c5 <start_process+0x24a>
        size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002bac9:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
c002bacf:	be 00 10 00 00       	mov    $0x1000,%esi
c002bad4:	0f 46 f5             	cmovbe %ebp,%esi
        size_t page_zero_bytes = PGSIZE - page_read_bytes;
c002bad7:	bf 00 10 00 00       	mov    $0x1000,%edi
c002badc:	29 f7                	sub    %esi,%edi
        uint8_t *kpage = palloc_get_page(PAL_USER);
c002bade:	83 ec 0c             	sub    $0xc,%esp
c002bae1:	6a 04                	push   $0x4
c002bae3:	e8 01 7f ff ff       	call   c00239e9 <palloc_get_page>
c002bae8:	89 44 24 28          	mov    %eax,0x28(%esp)
        if (kpage == NULL)
c002baec:	83 c4 10             	add    $0x10,%esp
c002baef:	85 c0                	test   %eax,%eax
c002baf1:	0f 84 ea 01 00 00    	je     c002bce1 <start_process+0x666>
        if (file_read(file, kpage, page_read_bytes) != (int) page_read_bytes) {
c002baf7:	83 ec 04             	sub    $0x4,%esp
c002bafa:	56                   	push   %esi
c002bafb:	50                   	push   %eax
c002bafc:	ff 74 24 2c          	pushl  0x2c(%esp)
c002bb00:	e8 e6 1d 00 00       	call   c002d8eb <file_read>
c002bb05:	83 c4 10             	add    $0x10,%esp
c002bb08:	39 c6                	cmp    %eax,%esi
c002bb0a:	0f 85 3e ff ff ff    	jne    c002ba4e <start_process+0x3d3>
        memset(kpage + page_read_bytes, 0, page_zero_bytes);
c002bb10:	8b 44 24 18          	mov    0x18(%esp),%eax
c002bb14:	01 f0                	add    %esi,%eax
c002bb16:	83 ff 04             	cmp    $0x4,%edi
c002bb19:	0f 83 47 ff ff ff    	jae    c002ba66 <start_process+0x3eb>
c002bb1f:	85 ff                	test   %edi,%edi
c002bb21:	0f 84 64 ff ff ff    	je     c002ba8b <start_process+0x410>
c002bb27:	c6 00 00             	movb   $0x0,(%eax)
c002bb2a:	f7 c7 02 00 00 00    	test   $0x2,%edi
c002bb30:	0f 84 55 ff ff ff    	je     c002ba8b <start_process+0x410>
c002bb36:	66 c7 44 07 fe 00 00 	movw   $0x0,-0x2(%edi,%eax,1)
c002bb3d:	e9 49 ff ff ff       	jmp    c002ba8b <start_process+0x410>
c002bb42:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
            palloc_free_page(kpage);
c002bb46:	83 ec 0c             	sub    $0xc,%esp
c002bb49:	ff 74 24 24          	pushl  0x24(%esp)
c002bb4d:	e8 02 80 ff ff       	call   c0023b54 <palloc_free_page>
            printf("load_segment: install page failed for data at %x\n", upage);
c002bb52:	83 c4 08             	add    $0x8,%esp
c002bb55:	ff 74 24 24          	pushl  0x24(%esp)
c002bb59:	8d 83 60 6f ff ff    	lea    -0x90a0(%ebx),%eax
c002bb5f:	50                   	push   %eax
c002bb60:	e8 19 b9 ff ff       	call   c002747e <printf>
c002bb65:	83 c4 10             	add    $0x10,%esp
c002bb68:	e9 01 fd ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bb6d:	8b 74 24 20          	mov    0x20(%esp),%esi
c002bb71:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
        kpage = palloc_get_page(PAL_USER | PAL_ZERO);
c002bb75:	83 ec 0c             	sub    $0xc,%esp
c002bb78:	6a 06                	push   $0x6
c002bb7a:	e8 6a 7e ff ff       	call   c00239e9 <palloc_get_page>
c002bb7f:	89 c7                	mov    %eax,%edi
    if (kpage != NULL) {
c002bb81:	83 c4 10             	add    $0x10,%esp
c002bb84:	85 c0                	test   %eax,%eax
c002bb86:	0f 84 d6 00 00 00    	je     c002bc62 <start_process+0x5e7>
        success = install_page(((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
c002bb8c:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bb91:	89 c2                	mov    %eax,%edx
c002bb93:	b8 00 f0 ff bf       	mov    $0xbffff000,%eax
c002bb98:	e8 a6 f5 ff ff       	call   c002b143 <install_page>
        if (success) {
c002bb9d:	84 c0                	test   %al,%al
c002bb9f:	0f 84 b1 00 00 00    	je     c002bc56 <start_process+0x5db>
            *esp = PHYS_BASE - 12; // prevent invalid use of memory
c002bba5:	c7 84 24 d8 00 00 00 	movl   $0xbffffff4,0xd8(%esp)
c002bbac:	f4 ff ff bf 
            *esp = push_arguments(args, esp); // argument passing
c002bbb0:	83 ec 08             	sub    $0x8,%esp
c002bbb3:	8d bc 24 98 00 00 00 	lea    0x98(%esp),%edi
c002bbba:	8d 84 24 e0 00 00 00 	lea    0xe0(%esp),%eax
c002bbc1:	50                   	push   %eax
c002bbc2:	55                   	push   %ebp
c002bbc3:	e8 7a f9 ff ff       	call   c002b542 <push_arguments>
c002bbc8:	89 84 24 e8 00 00 00 	mov    %eax,0xe8(%esp)
    *eip = (void (*)(void)) ehdr.e_entry;
c002bbcf:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
c002bbd6:	89 84 24 dc 00 00 00 	mov    %eax,0xdc(%esp)
    t->src_code = file;
c002bbdd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002bbe1:	89 b0 e0 00 00 00    	mov    %esi,0xe0(%eax)
    palloc_free_page(args->argv);
c002bbe7:	83 c4 04             	add    $0x4,%esp
c002bbea:	ff 75 04             	pushl  0x4(%ebp)
c002bbed:	e8 62 7f ff ff       	call   c0023b54 <palloc_free_page>
    free(args);
c002bbf2:	89 2c 24             	mov    %ebp,(%esp)
c002bbf5:	e8 af 83 ff ff       	call   c0023fa9 <free>
    lock_release(get_fs_lock());
c002bbfa:	e8 91 0b 00 00       	call   c002c790 <get_fs_lock>
c002bbff:	89 04 24             	mov    %eax,(%esp)
c002bc02:	e8 03 78 ff ff       	call   c002340a <lock_release>
    palloc_free_page(file_name);
c002bc07:	83 c4 04             	add    $0x4,%esp
c002bc0a:	ff 74 24 14          	pushl  0x14(%esp)
c002bc0e:	e8 41 7f ff ff       	call   c0023b54 <palloc_free_page>
        p_arg->success = true;
c002bc13:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002bc1a:	c6 40 18 01          	movb   $0x1,0x18(%eax)
        sema_up(&p_arg->sema);
c002bc1e:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
c002bc25:	83 c0 04             	add    $0x4,%eax
c002bc28:	89 04 24             	mov    %eax,(%esp)
c002bc2b:	e8 db 73 ff ff       	call   c002300b <sema_up>
    asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
c002bc30:	89 fc                	mov    %edi,%esp
c002bc32:	e9 7e 66 ff ff       	jmp    c00222b5 <intr_exit>
    NOT_REACHED ();
c002bc37:	8d 83 d0 55 ff ff    	lea    -0xaa30(%ebx),%eax
c002bc3d:	50                   	push   %eax
c002bc3e:	8d 83 94 4c ff ff    	lea    -0xb36c(%ebx),%eax
c002bc44:	50                   	push   %eax
c002bc45:	68 98 00 00 00       	push   $0x98
c002bc4a:	8d 83 47 6f ff ff    	lea    -0x90b9(%ebx),%eax
c002bc50:	50                   	push   %eax
c002bc51:	e8 84 d4 ff ff       	call   c00290da <debug_panic>
            palloc_free_page(kpage);
c002bc56:	83 ec 0c             	sub    $0xc,%esp
c002bc59:	57                   	push   %edi
c002bc5a:	e8 f5 7e ff ff       	call   c0023b54 <palloc_free_page>
c002bc5f:	83 c4 10             	add    $0x10,%esp
        printf("load: %s: set up stack failed\n", args->argv[0]);
c002bc62:	83 ec 08             	sub    $0x8,%esp
c002bc65:	8b 45 04             	mov    0x4(%ebp),%eax
c002bc68:	ff 30                	pushl  (%eax)
c002bc6a:	8d 83 94 6f ff ff    	lea    -0x906c(%ebx),%eax
c002bc70:	50                   	push   %eax
c002bc71:	e8 08 b8 ff ff       	call   c002747e <printf>
c002bc76:	83 c4 10             	add    $0x10,%esp
c002bc79:	e9 f0 fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bc7e:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc82:	e9 e7 fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bc87:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc8b:	e9 de fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bc90:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc94:	e9 d5 fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bc99:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bc9d:	e9 cc fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bca2:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bca6:	e9 c3 fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bcab:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bcaf:	e9 ba fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bcb4:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bcb8:	e9 b1 fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bcbd:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bcc1:	e9 a8 fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bcc6:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bcca:	e9 9f fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bccf:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bcd3:	e9 96 fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bcd8:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bcdc:	e9 8d fb ff ff       	jmp    c002b86e <start_process+0x1f3>
c002bce1:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
c002bce5:	e9 84 fb ff ff       	jmp    c002b86e <start_process+0x1f3>

c002bcea <lookup_page>:
   If PD does not have a page table for VADDR, behavior depends
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page(uint32_t *pd, const void *vaddr, bool create) {
c002bcea:	57                   	push   %edi
c002bceb:	56                   	push   %esi
c002bcec:	53                   	push   %ebx
c002bced:	e8 06 32 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002bcf2:	81 c3 36 f4 00 00    	add    $0xf436,%ebx
    uint32_t *pt, *pde;

    ASSERT (pd != NULL);
c002bcf8:	85 c0                	test   %eax,%eax
c002bcfa:	0f 84 8a 00 00 00    	je     c002bd8a <lookup_page+0xa0>
c002bd00:	89 d6                	mov    %edx,%esi

    /* Shouldn't create new kernel virtual mappings. */
    ASSERT (!create || is_user_vaddr(vaddr));
c002bd02:	80 f9 01             	cmp    $0x1,%cl
c002bd05:	75 0c                	jne    c002bd13 <lookup_page+0x29>
c002bd07:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002bd0d:	0f 87 9d 00 00 00    	ja     c002bdb0 <lookup_page+0xc6>
    return (uintptr_t) va >> PDSHIFT;
c002bd13:	89 f2                	mov    %esi,%edx
c002bd15:	c1 ea 16             	shr    $0x16,%edx

    /* Check for a page table for VADDR.
       If one is missing, create one if requested. */
    pde = pd + pd_no(vaddr);
c002bd18:	8d 3c 90             	lea    (%eax,%edx,4),%edi
    if (*pde == 0) {
c002bd1b:	83 3f 00             	cmpl   $0x0,(%edi)
c002bd1e:	75 3c                	jne    c002bd5c <lookup_page+0x72>
        if (create) {
c002bd20:	84 c9                	test   %cl,%cl
c002bd22:	0f 84 46 01 00 00    	je     c002be6e <lookup_page+0x184>
            pt = palloc_get_page(PAL_ZERO);
c002bd28:	83 ec 0c             	sub    $0xc,%esp
c002bd2b:	6a 02                	push   $0x2
c002bd2d:	e8 b7 7c ff ff       	call   c00239e9 <palloc_get_page>
            if (pt == NULL)
c002bd32:	83 c4 10             	add    $0x10,%esp
c002bd35:	85 c0                	test   %eax,%eax
c002bd37:	74 4d                	je     c002bd86 <lookup_page+0x9c>
c002bd39:	89 c2                	mov    %eax,%edx
    ASSERT (pg_ofs(pt) == 0);
c002bd3b:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002bd40:	0f 85 90 00 00 00    	jne    c002bdd6 <lookup_page+0xec>
    ASSERT (is_kernel_vaddr(vaddr));
c002bd46:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bd4b:	0f 86 ab 00 00 00    	jbe    c002bdfc <lookup_page+0x112>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002bd51:	81 c2 00 00 00 40    	add    $0x40000000,%edx
    return vtop(pt) | PTE_U | PTE_P | PTE_W;
c002bd57:	83 ca 07             	or     $0x7,%edx
c002bd5a:	89 17                	mov    %edx,(%edi)
        } else
            return NULL;
    }

    /* Return the page table entry. */
    pt = pde_get_pt(*pde);
c002bd5c:	8b 07                	mov    (%edi),%eax
    ASSERT (pde & PTE_P);
c002bd5e:	a8 01                	test   $0x1,%al
c002bd60:	0f 84 bc 00 00 00    	je     c002be22 <lookup_page+0x138>
    return ptov(pde & PTE_ADDR);
c002bd66:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    ASSERT ((void *) paddr < PHYS_BASE);
c002bd6b:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bd70:	0f 87 d2 00 00 00    	ja     c002be48 <lookup_page+0x15e>
    return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002bd76:	c1 ee 0a             	shr    $0xa,%esi
    return &pt[pt_no(vaddr)];
c002bd79:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
c002bd7f:	8d 84 30 00 00 00 c0 	lea    -0x40000000(%eax,%esi,1),%eax
}
c002bd86:	5b                   	pop    %ebx
c002bd87:	5e                   	pop    %esi
c002bd88:	5f                   	pop    %edi
c002bd89:	c3                   	ret    
    ASSERT (pd != NULL);
c002bd8a:	83 ec 0c             	sub    $0xc,%esp
c002bd8d:	8d 83 b3 6f ff ff    	lea    -0x904d(%ebx),%eax
c002bd93:	50                   	push   %eax
c002bd94:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002bd9a:	50                   	push   %eax
c002bd9b:	8d 83 d8 4c ff ff    	lea    -0xb328(%ebx),%eax
c002bda1:	50                   	push   %eax
c002bda2:	6a 3c                	push   $0x3c
c002bda4:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002bdaa:	50                   	push   %eax
c002bdab:	e8 2a d3 ff ff       	call   c00290da <debug_panic>
    ASSERT (!create || is_user_vaddr(vaddr));
c002bdb0:	83 ec 0c             	sub    $0xc,%esp
c002bdb3:	8d 83 5c 70 ff ff    	lea    -0x8fa4(%ebx),%eax
c002bdb9:	50                   	push   %eax
c002bdba:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002bdc0:	50                   	push   %eax
c002bdc1:	8d 83 d8 4c ff ff    	lea    -0xb328(%ebx),%eax
c002bdc7:	50                   	push   %eax
c002bdc8:	6a 3f                	push   $0x3f
c002bdca:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002bdd0:	50                   	push   %eax
c002bdd1:	e8 04 d3 ff ff       	call   c00290da <debug_panic>
    ASSERT (pg_ofs(pt) == 0);
c002bdd6:	83 ec 0c             	sub    $0xc,%esp
c002bdd9:	8d 83 84 4f ff ff    	lea    -0xb07c(%ebx),%eax
c002bddf:	50                   	push   %eax
c002bde0:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002bde6:	50                   	push   %eax
c002bde7:	8d 83 cc 4c ff ff    	lea    -0xb334(%ebx),%eax
c002bded:	50                   	push   %eax
c002bdee:	6a 48                	push   $0x48
c002bdf0:	8d 83 ab 4f ff ff    	lea    -0xb055(%ebx),%eax
c002bdf6:	50                   	push   %eax
c002bdf7:	e8 de d2 ff ff       	call   c00290da <debug_panic>
    ASSERT (is_kernel_vaddr(vaddr));
c002bdfc:	83 ec 0c             	sub    $0xc,%esp
c002bdff:	8d 83 bf 4f ff ff    	lea    -0xb041(%ebx),%eax
c002be05:	50                   	push   %eax
c002be06:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002be0c:	50                   	push   %eax
c002be0d:	8d 83 e4 4c ff ff    	lea    -0xb31c(%ebx),%eax
c002be13:	50                   	push   %eax
c002be14:	6a 55                	push   $0x55
c002be16:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002be1c:	50                   	push   %eax
c002be1d:	e8 b8 d2 ff ff       	call   c00290da <debug_panic>
    ASSERT (pde & PTE_P);
c002be22:	83 ec 0c             	sub    $0xc,%esp
c002be25:	8d 83 d7 6f ff ff    	lea    -0x9029(%ebx),%eax
c002be2b:	50                   	push   %eax
c002be2c:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002be32:	50                   	push   %eax
c002be33:	8d 83 08 4d ff ff    	lea    -0xb2f8(%ebx),%eax
c002be39:	50                   	push   %eax
c002be3a:	6a 4f                	push   $0x4f
c002be3c:	8d 83 ab 4f ff ff    	lea    -0xb055(%ebx),%eax
c002be42:	50                   	push   %eax
c002be43:	e8 92 d2 ff ff       	call   c00290da <debug_panic>
    ASSERT ((void *) paddr < PHYS_BASE);
c002be48:	83 ec 0c             	sub    $0xc,%esp
c002be4b:	8d 83 26 5c ff ff    	lea    -0xa3da(%ebx),%eax
c002be51:	50                   	push   %eax
c002be52:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002be58:	50                   	push   %eax
c002be59:	8d 83 00 4d ff ff    	lea    -0xb300(%ebx),%eax
c002be5f:	50                   	push   %eax
c002be60:	6a 4c                	push   $0x4c
c002be62:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002be68:	50                   	push   %eax
c002be69:	e8 6c d2 ff ff       	call   c00290da <debug_panic>
            return NULL;
c002be6e:	b8 00 00 00 00       	mov    $0x0,%eax
c002be73:	e9 0e ff ff ff       	jmp    c002bd86 <lookup_page+0x9c>

c002be78 <pagedir_create>:
pagedir_create(void) {
c002be78:	57                   	push   %edi
c002be79:	56                   	push   %esi
c002be7a:	53                   	push   %ebx
c002be7b:	e8 78 30 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002be80:	81 c3 a8 f2 00 00    	add    $0xf2a8,%ebx
    uint32_t *pd = palloc_get_page(0);
c002be86:	83 ec 0c             	sub    $0xc,%esp
c002be89:	6a 00                	push   $0x0
c002be8b:	e8 59 7b ff ff       	call   c00239e9 <palloc_get_page>
    if (pd != NULL)
c002be90:	83 c4 10             	add    $0x10,%esp
c002be93:	85 c0                	test   %eax,%eax
c002be95:	74 2f                	je     c002bec6 <pagedir_create+0x4e>
        memcpy(pd, init_page_dir, PGSIZE);
c002be97:	c7 c2 78 d0 03 c0    	mov    $0xc003d078,%edx
c002be9d:	8b 32                	mov    (%edx),%esi
c002be9f:	8b 16                	mov    (%esi),%edx
c002bea1:	89 10                	mov    %edx,(%eax)
c002bea3:	8b 96 fc 0f 00 00    	mov    0xffc(%esi),%edx
c002bea9:	89 90 fc 0f 00 00    	mov    %edx,0xffc(%eax)
c002beaf:	8d 78 04             	lea    0x4(%eax),%edi
c002beb2:	83 e7 fc             	and    $0xfffffffc,%edi
c002beb5:	89 c1                	mov    %eax,%ecx
c002beb7:	29 f9                	sub    %edi,%ecx
c002beb9:	29 ce                	sub    %ecx,%esi
c002bebb:	81 c1 00 10 00 00    	add    $0x1000,%ecx
c002bec1:	c1 e9 02             	shr    $0x2,%ecx
c002bec4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
c002bec6:	5b                   	pop    %ebx
c002bec7:	5e                   	pop    %esi
c002bec8:	5f                   	pop    %edi
c002bec9:	c3                   	ret    

c002beca <pagedir_destroy>:
pagedir_destroy(uint32_t *pd) {
c002beca:	55                   	push   %ebp
c002becb:	57                   	push   %edi
c002becc:	56                   	push   %esi
c002becd:	53                   	push   %ebx
c002bece:	83 ec 1c             	sub    $0x1c,%esp
c002bed1:	e8 22 30 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002bed6:	81 c3 52 f2 00 00    	add    $0xf252,%ebx
    if (pd == NULL)
c002bedc:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c002bee1:	0f 84 14 01 00 00    	je     c002bffb <pagedir_destroy+0x131>
    ASSERT (pd != init_page_dir);
c002bee7:	c7 c0 78 d0 03 c0    	mov    $0xc003d078,%eax
c002beed:	8b 54 24 30          	mov    0x30(%esp),%edx
c002bef1:	39 10                	cmp    %edx,(%eax)
c002bef3:	74 12                	je     c002bf07 <pagedir_destroy+0x3d>
    for (pde = pd; pde < pd + pd_no(PHYS_BASE); pde++)
c002bef5:	89 d0                	mov    %edx,%eax
c002bef7:	05 00 0c 00 00       	add    $0xc00,%eax
c002befc:	89 44 24 08          	mov    %eax,0x8(%esp)
c002bf00:	89 d5                	mov    %edx,%ebp
c002bf02:	e9 b6 00 00 00       	jmp    c002bfbd <pagedir_destroy+0xf3>
    ASSERT (pd != init_page_dir);
c002bf07:	83 ec 0c             	sub    $0xc,%esp
c002bf0a:	8d 83 e3 6f ff ff    	lea    -0x901d(%ebx),%eax
c002bf10:	50                   	push   %eax
c002bf11:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002bf17:	50                   	push   %eax
c002bf18:	8d 83 14 4d ff ff    	lea    -0xb2ec(%ebx),%eax
c002bf1e:	50                   	push   %eax
c002bf1f:	6a 24                	push   $0x24
c002bf21:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002bf27:	50                   	push   %eax
c002bf28:	e8 ad d1 ff ff       	call   c00290da <debug_panic>
c002bf2d:	83 ec 0c             	sub    $0xc,%esp
c002bf30:	8d 83 26 5c ff ff    	lea    -0xa3da(%ebx),%eax
c002bf36:	50                   	push   %eax
c002bf37:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002bf3d:	50                   	push   %eax
c002bf3e:	8d 83 00 4d ff ff    	lea    -0xb300(%ebx),%eax
c002bf44:	50                   	push   %eax
c002bf45:	6a 4c                	push   $0x4c
c002bf47:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002bf4d:	50                   	push   %eax
c002bf4e:	e8 87 d1 ff ff       	call   c00290da <debug_panic>
c002bf53:	83 ec 0c             	sub    $0xc,%esp
c002bf56:	8d 83 26 5c ff ff    	lea    -0xa3da(%ebx),%eax
c002bf5c:	50                   	push   %eax
c002bf5d:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002bf63:	50                   	push   %eax
c002bf64:	8d 83 00 4d ff ff    	lea    -0xb300(%ebx),%eax
c002bf6a:	50                   	push   %eax
c002bf6b:	6a 4c                	push   $0x4c
c002bf6d:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002bf73:	50                   	push   %eax
c002bf74:	e8 61 d1 ff ff       	call   c00290da <debug_panic>
            for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002bf79:	83 c6 04             	add    $0x4,%esi
c002bf7c:	39 fe                	cmp    %edi,%esi
c002bf7e:	74 25                	je     c002bfa5 <pagedir_destroy+0xdb>
                if (*pte & PTE_P)
c002bf80:	8b 06                	mov    (%esi),%eax
c002bf82:	a8 01                	test   $0x1,%al
c002bf84:	74 f3                	je     c002bf79 <pagedir_destroy+0xaf>
}

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page(uint32_t pte) {
    return ptov(pte & PTE_ADDR);
c002bf86:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bf8b:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bf90:	77 c1                	ja     c002bf53 <pagedir_destroy+0x89>
                    palloc_free_page(pte_get_page(*pte));
c002bf92:	83 ec 0c             	sub    $0xc,%esp
    return (void *) (paddr + PHYS_BASE);
c002bf95:	2d 00 00 00 40       	sub    $0x40000000,%eax
c002bf9a:	50                   	push   %eax
c002bf9b:	e8 b4 7b ff ff       	call   c0023b54 <palloc_free_page>
c002bfa0:	83 c4 10             	add    $0x10,%esp
c002bfa3:	eb d4                	jmp    c002bf79 <pagedir_destroy+0xaf>
            palloc_free_page(pt);
c002bfa5:	83 ec 0c             	sub    $0xc,%esp
c002bfa8:	ff 74 24 18          	pushl  0x18(%esp)
c002bfac:	e8 a3 7b ff ff       	call   c0023b54 <palloc_free_page>
c002bfb1:	83 c4 10             	add    $0x10,%esp
    for (pde = pd; pde < pd + pd_no(PHYS_BASE); pde++)
c002bfb4:	83 c5 04             	add    $0x4,%ebp
c002bfb7:	3b 6c 24 08          	cmp    0x8(%esp),%ebp
c002bfbb:	74 2f                	je     c002bfec <pagedir_destroy+0x122>
        if (*pde & PTE_P) {
c002bfbd:	8b 7d 00             	mov    0x0(%ebp),%edi
c002bfc0:	f7 c7 01 00 00 00    	test   $0x1,%edi
c002bfc6:	74 ec                	je     c002bfb4 <pagedir_destroy+0xea>
    return ptov(pde & PTE_ADDR);
c002bfc8:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
    ASSERT ((void *) paddr < PHYS_BASE);
c002bfce:	81 ff ff ff ff bf    	cmp    $0xbfffffff,%edi
c002bfd4:	0f 87 53 ff ff ff    	ja     c002bf2d <pagedir_destroy+0x63>
    return (void *) (paddr + PHYS_BASE);
c002bfda:	8d b7 00 00 00 c0    	lea    -0x40000000(%edi),%esi
c002bfe0:	89 74 24 0c          	mov    %esi,0xc(%esp)
            for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002bfe4:	81 ef 00 f0 ff 3f    	sub    $0x3ffff000,%edi
c002bfea:	eb 94                	jmp    c002bf80 <pagedir_destroy+0xb6>
    palloc_free_page(pd);
c002bfec:	83 ec 0c             	sub    $0xc,%esp
c002bfef:	ff 74 24 3c          	pushl  0x3c(%esp)
c002bff3:	e8 5c 7b ff ff       	call   c0023b54 <palloc_free_page>
c002bff8:	83 c4 10             	add    $0x10,%esp
}
c002bffb:	83 c4 1c             	add    $0x1c,%esp
c002bffe:	5b                   	pop    %ebx
c002bfff:	5e                   	pop    %esi
c002c000:	5f                   	pop    %edi
c002c001:	5d                   	pop    %ebp
c002c002:	c3                   	ret    

c002c003 <pagedir_set_page>:
   If WRITABLE is true, the new page is read/write;
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool
pagedir_set_page(uint32_t *pd, void *upage, void *kpage, bool writable) {
c002c003:	55                   	push   %ebp
c002c004:	57                   	push   %edi
c002c005:	56                   	push   %esi
c002c006:	53                   	push   %ebx
c002c007:	83 ec 0c             	sub    $0xc,%esp
c002c00a:	e8 e9 2e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c00f:	81 c3 19 f1 00 00    	add    $0xf119,%ebx
c002c015:	8b 44 24 20          	mov    0x20(%esp),%eax
c002c019:	8b 54 24 24          	mov    0x24(%esp),%edx
c002c01d:	8b 74 24 28          	mov    0x28(%esp),%esi
c002c021:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    uint32_t *pte;

    ASSERT (pg_ofs(upage) == 0);
c002c025:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002c02b:	0f 85 88 00 00 00    	jne    c002c0b9 <pagedir_set_page+0xb6>
    ASSERT (pg_ofs(kpage) == 0);
c002c031:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c002c037:	0f 85 a2 00 00 00    	jne    c002c0df <pagedir_set_page+0xdc>
    ASSERT (is_user_vaddr(upage));
c002c03d:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c043:	0f 87 bc 00 00 00    	ja     c002c105 <pagedir_set_page+0x102>
    ASSERT (is_kernel_vaddr(vaddr));
c002c049:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002c04f:	0f 86 d6 00 00 00    	jbe    c002c12b <pagedir_set_page+0x128>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002c055:	81 c6 00 00 00 40    	add    $0x40000000,%esi
    ASSERT (vtop(kpage) >> PTSHIFT < init_ram_pages);
c002c05b:	89 f5                	mov    %esi,%ebp
c002c05d:	c1 ed 0c             	shr    $0xc,%ebp
c002c060:	c7 c1 be 01 02 c0    	mov    $0xc00201be,%ecx
c002c066:	3b 29                	cmp    (%ecx),%ebp
c002c068:	0f 83 e3 00 00 00    	jae    c002c151 <pagedir_set_page+0x14e>
    ASSERT (pd != init_page_dir);
c002c06e:	c7 c1 78 d0 03 c0    	mov    $0xc003d078,%ecx
c002c074:	39 01                	cmp    %eax,(%ecx)
c002c076:	0f 84 fb 00 00 00    	je     c002c177 <pagedir_set_page+0x174>

    pte = lookup_page(pd, upage, true);
c002c07c:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c081:	e8 64 fc ff ff       	call   c002bcea <lookup_page>

    if (pte != NULL) {
c002c086:	85 c0                	test   %eax,%eax
c002c088:	0f 84 35 01 00 00    	je     c002c1c3 <pagedir_set_page+0x1c0>
        ASSERT ((*pte & PTE_P) == 0);
c002c08e:	8b 10                	mov    (%eax),%edx
c002c090:	83 e2 01             	and    $0x1,%edx
c002c093:	0f 85 04 01 00 00    	jne    c002c19d <pagedir_set_page+0x19a>
    return vtop(page) | PTE_P | (writable ? PTE_W : 0);
c002c099:	89 fb                	mov    %edi,%ebx
c002c09b:	84 db                	test   %bl,%bl
c002c09d:	b9 02 00 00 00       	mov    $0x2,%ecx
c002c0a2:	0f 45 d1             	cmovne %ecx,%edx
c002c0a5:	09 d6                	or     %edx,%esi
    return pte_create_kernel(page, writable) | PTE_U;
c002c0a7:	83 ce 05             	or     $0x5,%esi
c002c0aa:	89 30                	mov    %esi,(%eax)
        *pte = pte_create_user(kpage, writable);
        return true;
c002c0ac:	b8 01 00 00 00       	mov    $0x1,%eax
    } else
        return false;
}
c002c0b1:	83 c4 0c             	add    $0xc,%esp
c002c0b4:	5b                   	pop    %ebx
c002c0b5:	5e                   	pop    %esi
c002c0b6:	5f                   	pop    %edi
c002c0b7:	5d                   	pop    %ebp
c002c0b8:	c3                   	ret    
    ASSERT (pg_ofs(upage) == 0);
c002c0b9:	83 ec 0c             	sub    $0xc,%esp
c002c0bc:	8d 83 f7 6f ff ff    	lea    -0x9009(%ebx),%eax
c002c0c2:	50                   	push   %eax
c002c0c3:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c0c9:	50                   	push   %eax
c002c0ca:	8d 83 ec 4c ff ff    	lea    -0xb314(%ebx),%eax
c002c0d0:	50                   	push   %eax
c002c0d1:	6a 62                	push   $0x62
c002c0d3:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002c0d9:	50                   	push   %eax
c002c0da:	e8 fb cf ff ff       	call   c00290da <debug_panic>
    ASSERT (pg_ofs(kpage) == 0);
c002c0df:	83 ec 0c             	sub    $0xc,%esp
c002c0e2:	8d 83 0a 70 ff ff    	lea    -0x8ff6(%ebx),%eax
c002c0e8:	50                   	push   %eax
c002c0e9:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c0ef:	50                   	push   %eax
c002c0f0:	8d 83 ec 4c ff ff    	lea    -0xb314(%ebx),%eax
c002c0f6:	50                   	push   %eax
c002c0f7:	6a 63                	push   $0x63
c002c0f9:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002c0ff:	50                   	push   %eax
c002c100:	e8 d5 cf ff ff       	call   c00290da <debug_panic>
    ASSERT (is_user_vaddr(upage));
c002c105:	83 ec 0c             	sub    $0xc,%esp
c002c108:	8d 83 1d 70 ff ff    	lea    -0x8fe3(%ebx),%eax
c002c10e:	50                   	push   %eax
c002c10f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c115:	50                   	push   %eax
c002c116:	8d 83 ec 4c ff ff    	lea    -0xb314(%ebx),%eax
c002c11c:	50                   	push   %eax
c002c11d:	6a 64                	push   $0x64
c002c11f:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002c125:	50                   	push   %eax
c002c126:	e8 af cf ff ff       	call   c00290da <debug_panic>
    ASSERT (is_kernel_vaddr(vaddr));
c002c12b:	83 ec 0c             	sub    $0xc,%esp
c002c12e:	8d 83 bf 4f ff ff    	lea    -0xb041(%ebx),%eax
c002c134:	50                   	push   %eax
c002c135:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c13b:	50                   	push   %eax
c002c13c:	8d 83 e4 4c ff ff    	lea    -0xb31c(%ebx),%eax
c002c142:	50                   	push   %eax
c002c143:	6a 55                	push   $0x55
c002c145:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002c14b:	50                   	push   %eax
c002c14c:	e8 89 cf ff ff       	call   c00290da <debug_panic>
    ASSERT (vtop(kpage) >> PTSHIFT < init_ram_pages);
c002c151:	83 ec 0c             	sub    $0xc,%esp
c002c154:	8d 83 7c 70 ff ff    	lea    -0x8f84(%ebx),%eax
c002c15a:	50                   	push   %eax
c002c15b:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c161:	50                   	push   %eax
c002c162:	8d 83 ec 4c ff ff    	lea    -0xb314(%ebx),%eax
c002c168:	50                   	push   %eax
c002c169:	6a 65                	push   $0x65
c002c16b:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002c171:	50                   	push   %eax
c002c172:	e8 63 cf ff ff       	call   c00290da <debug_panic>
    ASSERT (pd != init_page_dir);
c002c177:	83 ec 0c             	sub    $0xc,%esp
c002c17a:	8d 83 e3 6f ff ff    	lea    -0x901d(%ebx),%eax
c002c180:	50                   	push   %eax
c002c181:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c187:	50                   	push   %eax
c002c188:	8d 83 ec 4c ff ff    	lea    -0xb314(%ebx),%eax
c002c18e:	50                   	push   %eax
c002c18f:	6a 66                	push   $0x66
c002c191:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002c197:	50                   	push   %eax
c002c198:	e8 3d cf ff ff       	call   c00290da <debug_panic>
        ASSERT ((*pte & PTE_P) == 0);
c002c19d:	83 ec 0c             	sub    $0xc,%esp
c002c1a0:	8d 83 32 70 ff ff    	lea    -0x8fce(%ebx),%eax
c002c1a6:	50                   	push   %eax
c002c1a7:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c1ad:	50                   	push   %eax
c002c1ae:	8d 83 ec 4c ff ff    	lea    -0xb314(%ebx),%eax
c002c1b4:	50                   	push   %eax
c002c1b5:	6a 6b                	push   $0x6b
c002c1b7:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002c1bd:	50                   	push   %eax
c002c1be:	e8 17 cf ff ff       	call   c00290da <debug_panic>
        return false;
c002c1c3:	b8 00 00 00 00       	mov    $0x0,%eax
c002c1c8:	e9 e4 fe ff ff       	jmp    c002c0b1 <pagedir_set_page+0xae>

c002c1cd <pagedir_get_page>:
/* Looks up the physical address that corresponds to user virtual
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page(uint32_t *pd, const void *uaddr) {
c002c1cd:	56                   	push   %esi
c002c1ce:	53                   	push   %ebx
c002c1cf:	83 ec 04             	sub    $0x4,%esp
c002c1d2:	e8 21 2d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c1d7:	81 c3 51 ef 00 00    	add    $0xef51,%ebx
c002c1dd:	8b 74 24 14          	mov    0x14(%esp),%esi
    uint32_t *pte;

    ASSERT (is_user_vaddr(uaddr));
c002c1e1:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002c1e7:	77 3a                	ja     c002c223 <pagedir_get_page+0x56>

    pte = lookup_page(pd, uaddr, false);
c002c1e9:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c1ee:	89 f2                	mov    %esi,%edx
c002c1f0:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c1f4:	e8 f1 fa ff ff       	call   c002bcea <lookup_page>
    if (pte != NULL && (*pte & PTE_P) != 0)
c002c1f9:	85 c0                	test   %eax,%eax
c002c1fb:	74 20                	je     c002c21d <pagedir_get_page+0x50>
c002c1fd:	8b 00                	mov    (%eax),%eax
c002c1ff:	a8 01                	test   $0x1,%al
c002c201:	74 6c                	je     c002c26f <pagedir_get_page+0xa2>
    return ptov(pte & PTE_ADDR);
c002c203:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    ASSERT ((void *) paddr < PHYS_BASE);
c002c208:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c20d:	77 3a                	ja     c002c249 <pagedir_get_page+0x7c>
    return (uintptr_t) va & PGMASK;
c002c20f:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
        return pte_get_page(*pte) + pg_ofs(uaddr);
c002c215:	09 c6                	or     %eax,%esi
c002c217:	8d 86 00 00 00 c0    	lea    -0x40000000(%esi),%eax
    else
        return NULL;
}
c002c21d:	83 c4 04             	add    $0x4,%esp
c002c220:	5b                   	pop    %ebx
c002c221:	5e                   	pop    %esi
c002c222:	c3                   	ret    
    ASSERT (is_user_vaddr(uaddr));
c002c223:	83 ec 0c             	sub    $0xc,%esp
c002c226:	8d 83 46 70 ff ff    	lea    -0x8fba(%ebx),%eax
c002c22c:	50                   	push   %eax
c002c22d:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c233:	50                   	push   %eax
c002c234:	8d 83 b8 4c ff ff    	lea    -0xb348(%ebx),%eax
c002c23a:	50                   	push   %eax
c002c23b:	6a 7a                	push   $0x7a
c002c23d:	8d 83 be 6f ff ff    	lea    -0x9042(%ebx),%eax
c002c243:	50                   	push   %eax
c002c244:	e8 91 ce ff ff       	call   c00290da <debug_panic>
    ASSERT ((void *) paddr < PHYS_BASE);
c002c249:	83 ec 0c             	sub    $0xc,%esp
c002c24c:	8d 83 26 5c ff ff    	lea    -0xa3da(%ebx),%eax
c002c252:	50                   	push   %eax
c002c253:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c259:	50                   	push   %eax
c002c25a:	8d 83 00 4d ff ff    	lea    -0xb300(%ebx),%eax
c002c260:	50                   	push   %eax
c002c261:	6a 4c                	push   $0x4c
c002c263:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002c269:	50                   	push   %eax
c002c26a:	e8 6b ce ff ff       	call   c00290da <debug_panic>
        return NULL;
c002c26f:	b8 00 00 00 00       	mov    $0x0,%eax
c002c274:	eb a7                	jmp    c002c21d <pagedir_get_page+0x50>

c002c276 <pagedir_is_dirty>:
/* Returns true if the PTE for virtual page VPAGE in PD is dirty,
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool
pagedir_is_dirty(uint32_t *pd, const void *vpage) {
c002c276:	83 ec 0c             	sub    $0xc,%esp
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c279:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c27e:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c282:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c286:	e8 5f fa ff ff       	call   c002bcea <lookup_page>
    return pte != NULL && (*pte & PTE_D) != 0;
c002c28b:	ba 00 00 00 00       	mov    $0x0,%edx
c002c290:	85 c0                	test   %eax,%eax
c002c292:	74 08                	je     c002c29c <pagedir_is_dirty+0x26>
c002c294:	8b 10                	mov    (%eax),%edx
c002c296:	c1 ea 06             	shr    $0x6,%edx
c002c299:	83 e2 01             	and    $0x1,%edx
c002c29c:	89 d0                	mov    %edx,%eax
c002c29e:	83 e0 01             	and    $0x1,%eax
}
c002c2a1:	83 c4 0c             	add    $0xc,%esp
c002c2a4:	c3                   	ret    

c002c2a5 <pagedir_is_accessed>:
/* Returns true if the PTE for virtual page VPAGE in PD has been
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool
pagedir_is_accessed(uint32_t *pd, const void *vpage) {
c002c2a5:	83 ec 0c             	sub    $0xc,%esp
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c2a8:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c2ad:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c2b1:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c2b5:	e8 30 fa ff ff       	call   c002bcea <lookup_page>
    return pte != NULL && (*pte & PTE_A) != 0;
c002c2ba:	ba 00 00 00 00       	mov    $0x0,%edx
c002c2bf:	85 c0                	test   %eax,%eax
c002c2c1:	74 08                	je     c002c2cb <pagedir_is_accessed+0x26>
c002c2c3:	8b 10                	mov    (%eax),%edx
c002c2c5:	c1 ea 05             	shr    $0x5,%edx
c002c2c8:	83 e2 01             	and    $0x1,%edx
c002c2cb:	89 d0                	mov    %edx,%eax
c002c2cd:	83 e0 01             	and    $0x1,%eax
}
c002c2d0:	83 c4 0c             	add    $0xc,%esp
c002c2d3:	c3                   	ret    

c002c2d4 <pagedir_activate>:
}

/* Loads page directory PD into the CPU's page directory base
   register. */
void
pagedir_activate(uint32_t *pd) {
c002c2d4:	53                   	push   %ebx
c002c2d5:	83 ec 08             	sub    $0x8,%esp
c002c2d8:	e8 1b 2c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c2dd:	81 c3 4b ee 00 00    	add    $0xee4b,%ebx
c002c2e3:	8b 44 24 10          	mov    0x10(%esp),%eax
    if (pd == NULL)
c002c2e7:	85 c0                	test   %eax,%eax
c002c2e9:	74 14                	je     c002c2ff <pagedir_activate+0x2b>
    ASSERT (is_kernel_vaddr(vaddr));
c002c2eb:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c2f0:	76 17                	jbe    c002c309 <pagedir_activate+0x35>
    return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002c2f2:	05 00 00 00 40       	add    $0x40000000,%eax
    /* Store the physical address of the page directory into CR3
       aka PDBR (page directory base register).  This activates our
       new page tables immediately.  See [IA32-v2a] "MOV--Move
       to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
       Address of the Page Directory". */
    asm volatile ("movl %0, %%cr3" : : "r" (vtop(pd)) : "memory");
c002c2f7:	0f 22 d8             	mov    %eax,%cr3
}
c002c2fa:	83 c4 08             	add    $0x8,%esp
c002c2fd:	5b                   	pop    %ebx
c002c2fe:	c3                   	ret    
        pd = init_page_dir;
c002c2ff:	c7 c0 78 d0 03 c0    	mov    $0xc003d078,%eax
c002c305:	8b 00                	mov    (%eax),%eax
c002c307:	eb e2                	jmp    c002c2eb <pagedir_activate+0x17>
    ASSERT (is_kernel_vaddr(vaddr));
c002c309:	83 ec 0c             	sub    $0xc,%esp
c002c30c:	8d 83 bf 4f ff ff    	lea    -0xb041(%ebx),%eax
c002c312:	50                   	push   %eax
c002c313:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c319:	50                   	push   %eax
c002c31a:	8d 83 e4 4c ff ff    	lea    -0xb31c(%ebx),%eax
c002c320:	50                   	push   %eax
c002c321:	6a 55                	push   $0x55
c002c323:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002c329:	50                   	push   %eax
c002c32a:	e8 ab cd ff ff       	call   c00290da <debug_panic>

c002c32f <invalidate_pagedir>:

   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir(uint32_t *pd) {
c002c32f:	53                   	push   %ebx
c002c330:	83 ec 08             	sub    $0x8,%esp
c002c333:	e8 c0 2b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c338:	81 c3 f0 ed 00 00    	add    $0xedf0,%ebx
    asm volatile ("movl %%cr3, %0" : "=r" (pd));
c002c33e:	0f 20 da             	mov    %cr3,%edx
    ASSERT ((void *) paddr < PHYS_BASE);
c002c341:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c347:	77 0f                	ja     c002c358 <invalidate_pagedir+0x29>
    return (void *) (paddr + PHYS_BASE);
c002c349:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
    if (active_pd() == pd) {
c002c34f:	39 d0                	cmp    %edx,%eax
c002c351:	74 2b                	je     c002c37e <invalidate_pagedir+0x4f>
        /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
           "Translation Lookaside Buffers (TLBs)". */
        pagedir_activate(pd);
    }
}
c002c353:	83 c4 08             	add    $0x8,%esp
c002c356:	5b                   	pop    %ebx
c002c357:	c3                   	ret    
    ASSERT ((void *) paddr < PHYS_BASE);
c002c358:	83 ec 0c             	sub    $0xc,%esp
c002c35b:	8d 83 26 5c ff ff    	lea    -0xa3da(%ebx),%eax
c002c361:	50                   	push   %eax
c002c362:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002c368:	50                   	push   %eax
c002c369:	8d 83 00 4d ff ff    	lea    -0xb300(%ebx),%eax
c002c36f:	50                   	push   %eax
c002c370:	6a 4c                	push   $0x4c
c002c372:	8d 83 d6 4f ff ff    	lea    -0xb02a(%ebx),%eax
c002c378:	50                   	push   %eax
c002c379:	e8 5c cd ff ff       	call   c00290da <debug_panic>
        pagedir_activate(pd);
c002c37e:	83 ec 0c             	sub    $0xc,%esp
c002c381:	50                   	push   %eax
c002c382:	e8 4d ff ff ff       	call   c002c2d4 <pagedir_activate>
c002c387:	83 c4 10             	add    $0x10,%esp
}
c002c38a:	eb c7                	jmp    c002c353 <invalidate_pagedir+0x24>

c002c38c <pagedir_clear_page>:
pagedir_clear_page(uint32_t *pd, void *upage) {
c002c38c:	56                   	push   %esi
c002c38d:	53                   	push   %ebx
c002c38e:	83 ec 04             	sub    $0x4,%esp
c002c391:	e8 62 2b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c396:	81 c3 92 ed 00 00    	add    $0xed92,%ebx
c002c39c:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c3a0:	8b 54 24 14          	mov    0x14(%esp),%edx
    ASSERT (pg_ofs(upage) == 0);
c002c3a4:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002c3aa:	75 25                	jne    c002c3d1 <pagedir_clear_page+0x45>
    ASSERT (is_user_vaddr(upage));
c002c3ac:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c3b2:	77 46                	ja     c002c3fa <pagedir_clear_page+0x6e>
    pte = lookup_page(pd, upage, false);
c002c3b4:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c3b9:	89 f0                	mov    %esi,%eax
c002c3bb:	e8 2a f9 ff ff       	call   c002bcea <lookup_page>
    if (pte != NULL && (*pte & PTE_P) != 0) {
c002c3c0:	85 c0                	test   %eax,%eax
c002c3c2:	74 07                	je     c002c3cb <pagedir_clear_page+0x3f>
c002c3c4:	8b 10                	mov    (%eax),%edx
c002c3c6:	f6 c2 01             	test   $0x1,%dl
c002c3c9:	75 58                	jne    c002c423 <pagedir_clear_page+0x97>
}
c002c3cb:	83 c4 04             	add    $0x4,%esp
c002c3ce:	5b                   	pop    %ebx
c002c3cf:	5e                   	pop    %esi
c002c3d0:	c3                   	ret    
    ASSERT (pg_ofs(upage) == 0);
c002c3d1:	83 ec 0c             	sub    $0xc,%esp
c002c3d4:	8d 93 f7 6f ff ff    	lea    -0x9009(%ebx),%edx
c002c3da:	52                   	push   %edx
c002c3db:	8d 93 94 4f ff ff    	lea    -0xb06c(%ebx),%edx
c002c3e1:	52                   	push   %edx
c002c3e2:	8d 93 a4 4c ff ff    	lea    -0xb35c(%ebx),%edx
c002c3e8:	52                   	push   %edx
c002c3e9:	68 8b 00 00 00       	push   $0x8b
c002c3ee:	8d 93 be 6f ff ff    	lea    -0x9042(%ebx),%edx
c002c3f4:	52                   	push   %edx
c002c3f5:	e8 e0 cc ff ff       	call   c00290da <debug_panic>
    ASSERT (is_user_vaddr(upage));
c002c3fa:	83 ec 0c             	sub    $0xc,%esp
c002c3fd:	8d 93 1d 70 ff ff    	lea    -0x8fe3(%ebx),%edx
c002c403:	52                   	push   %edx
c002c404:	8d 93 94 4f ff ff    	lea    -0xb06c(%ebx),%edx
c002c40a:	52                   	push   %edx
c002c40b:	8d 93 a4 4c ff ff    	lea    -0xb35c(%ebx),%edx
c002c411:	52                   	push   %edx
c002c412:	68 8c 00 00 00       	push   $0x8c
c002c417:	8d 93 be 6f ff ff    	lea    -0x9042(%ebx),%edx
c002c41d:	52                   	push   %edx
c002c41e:	e8 b7 cc ff ff       	call   c00290da <debug_panic>
        *pte &= ~PTE_P;
c002c423:	83 e2 fe             	and    $0xfffffffe,%edx
c002c426:	89 10                	mov    %edx,(%eax)
        invalidate_pagedir(pd);
c002c428:	89 f0                	mov    %esi,%eax
c002c42a:	e8 00 ff ff ff       	call   c002c32f <invalidate_pagedir>
}
c002c42f:	eb 9a                	jmp    c002c3cb <pagedir_clear_page+0x3f>

c002c431 <pagedir_set_dirty>:
pagedir_set_dirty(uint32_t *pd, const void *vpage, bool dirty) {
c002c431:	56                   	push   %esi
c002c432:	53                   	push   %ebx
c002c433:	83 ec 04             	sub    $0x4,%esp
c002c436:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c43a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c43e:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c443:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c447:	89 f0                	mov    %esi,%eax
c002c449:	e8 9c f8 ff ff       	call   c002bcea <lookup_page>
    if (pte != NULL) {
c002c44e:	85 c0                	test   %eax,%eax
c002c450:	74 07                	je     c002c459 <pagedir_set_dirty+0x28>
        if (dirty)
c002c452:	84 db                	test   %bl,%bl
c002c454:	74 09                	je     c002c45f <pagedir_set_dirty+0x2e>
            *pte |= PTE_D;
c002c456:	83 08 40             	orl    $0x40,(%eax)
}
c002c459:	83 c4 04             	add    $0x4,%esp
c002c45c:	5b                   	pop    %ebx
c002c45d:	5e                   	pop    %esi
c002c45e:	c3                   	ret    
            *pte &= ~(uint32_t) PTE_D;
c002c45f:	83 20 bf             	andl   $0xffffffbf,(%eax)
            invalidate_pagedir(pd);
c002c462:	89 f0                	mov    %esi,%eax
c002c464:	e8 c6 fe ff ff       	call   c002c32f <invalidate_pagedir>
}
c002c469:	eb ee                	jmp    c002c459 <pagedir_set_dirty+0x28>

c002c46b <pagedir_set_accessed>:
pagedir_set_accessed(uint32_t *pd, const void *vpage, bool accessed) {
c002c46b:	56                   	push   %esi
c002c46c:	53                   	push   %ebx
c002c46d:	83 ec 04             	sub    $0x4,%esp
c002c470:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c474:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    uint32_t *pte = lookup_page(pd, vpage, false);
c002c478:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c47d:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c481:	89 f0                	mov    %esi,%eax
c002c483:	e8 62 f8 ff ff       	call   c002bcea <lookup_page>
    if (pte != NULL) {
c002c488:	85 c0                	test   %eax,%eax
c002c48a:	74 07                	je     c002c493 <pagedir_set_accessed+0x28>
        if (accessed)
c002c48c:	84 db                	test   %bl,%bl
c002c48e:	74 09                	je     c002c499 <pagedir_set_accessed+0x2e>
            *pte |= PTE_A;
c002c490:	83 08 20             	orl    $0x20,(%eax)
}
c002c493:	83 c4 04             	add    $0x4,%esp
c002c496:	5b                   	pop    %ebx
c002c497:	5e                   	pop    %esi
c002c498:	c3                   	ret    
            *pte &= ~(uint32_t) PTE_A;
c002c499:	83 20 df             	andl   $0xffffffdf,(%eax)
            invalidate_pagedir(pd);
c002c49c:	89 f0                	mov    %esi,%eax
c002c49e:	e8 8c fe ff ff       	call   c002c32f <invalidate_pagedir>
}
c002c4a3:	eb ee                	jmp    c002c493 <pagedir_set_accessed+0x28>

c002c4a5 <kill>:
    printf("Exception: %lld page faults\n", page_fault_cnt);
}

/* Handler for an exception (probably) caused by a user process. */
static void
kill(struct intr_frame *f) {
c002c4a5:	55                   	push   %ebp
c002c4a6:	57                   	push   %edi
c002c4a7:	56                   	push   %esi
c002c4a8:	53                   	push   %ebx
c002c4a9:	83 ec 0c             	sub    $0xc,%esp
c002c4ac:	e8 47 2a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c4b1:	81 c3 77 ec 00 00    	add    $0xec77,%ebx
c002c4b7:	8b 74 24 20          	mov    0x20(%esp),%esi
       exceptions back to the process via signals, but we don't
       implement them. */

    /* The interrupt frame's code segment value tells us where the
       exception originated. */
    switch (f->cs) {
c002c4bb:	0f b7 7e 40          	movzwl 0x40(%esi),%edi
c002c4bf:	66 83 ff 08          	cmp    $0x8,%di
c002c4c3:	74 3a                	je     c002c4ff <kill+0x5a>
c002c4c5:	66 83 ff 1b          	cmp    $0x1b,%di
c002c4c9:	75 59                	jne    c002c524 <kill+0x7f>
        case SEL_UCSEG:
            /* User's code segment, so it's a user exception, as we
               expected.  Kill the user process.  */
            printf("%s: dying due to interrupt %#04x (%s).\n",
c002c4cb:	83 ec 0c             	sub    $0xc,%esp
c002c4ce:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002c4d2:	50                   	push   %eax
c002c4d3:	e8 a8 5d ff ff       	call   c0022280 <intr_name>
c002c4d8:	89 c5                	mov    %eax,%ebp
c002c4da:	8b 7e 30             	mov    0x30(%esi),%edi
c002c4dd:	e8 88 4b ff ff       	call   c002106a <thread_name>
c002c4e2:	55                   	push   %ebp
c002c4e3:	57                   	push   %edi
c002c4e4:	50                   	push   %eax
c002c4e5:	8d 83 a4 70 ff ff    	lea    -0x8f5c(%ebx),%eax
c002c4eb:	50                   	push   %eax
c002c4ec:	e8 8d af ff ff       	call   c002747e <printf>
                   thread_name(), f->vec_no, intr_name(f->vec_no));
            intr_dump_frame(f);
c002c4f1:	83 c4 14             	add    $0x14,%esp
c002c4f4:	56                   	push   %esi
c002c4f5:	e8 e5 5c ff ff       	call   c00221df <intr_dump_frame>
            thread_exit();
c002c4fa:	e8 d6 50 ff ff       	call   c00215d5 <thread_exit>
        case SEL_KCSEG:
            /* Kernel's code segment, which indicates a kernel bug.
               Kernel code shouldn't throw exceptions.  (Page faults
               may cause kernel exceptions--but they shouldn't arrive
               here.)  Panic the kernel to make the point.  */
            intr_dump_frame(f);
c002c4ff:	83 ec 0c             	sub    $0xc,%esp
c002c502:	56                   	push   %esi
c002c503:	e8 d7 5c ff ff       	call   c00221df <intr_dump_frame>
            PANIC ("Kernel bug - unexpected interrupt in kernel");
c002c508:	8d 83 cc 70 ff ff    	lea    -0x8f34(%ebx),%eax
c002c50e:	50                   	push   %eax
c002c50f:	8d 83 24 4d ff ff    	lea    -0xb2dc(%ebx),%eax
c002c515:	50                   	push   %eax
c002c516:	6a 6e                	push   $0x6e
c002c518:	8d 83 5b 71 ff ff    	lea    -0x8ea5(%ebx),%eax
c002c51e:	50                   	push   %eax
c002c51f:	e8 b6 cb ff ff       	call   c00290da <debug_panic>

        default:
            /* Some other code segment?  Shouldn't happen.  Panic the
               kernel. */
            printf("Interrupt %#04x (%s) in unknown segment %04x\n",
c002c524:	83 ec 0c             	sub    $0xc,%esp
c002c527:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002c52b:	50                   	push   %eax
c002c52c:	e8 4f 5d ff ff       	call   c0022280 <intr_name>
    switch (f->cs) {
c002c531:	0f b7 ff             	movzwl %di,%edi
            printf("Interrupt %#04x (%s) in unknown segment %04x\n",
c002c534:	57                   	push   %edi
c002c535:	50                   	push   %eax
c002c536:	ff 76 30             	pushl  0x30(%esi)
c002c539:	8d 83 f8 70 ff ff    	lea    -0x8f08(%ebx),%eax
c002c53f:	50                   	push   %eax
c002c540:	e8 39 af ff ff       	call   c002747e <printf>
                   f->vec_no, intr_name(f->vec_no), f->cs);
            thread_exit();
c002c545:	83 c4 20             	add    $0x20,%esp
c002c548:	e8 88 50 ff ff       	call   c00215d5 <thread_exit>

c002c54d <page_fault>:
   example code here shows how to parse that information.  You
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault(struct intr_frame *f) {
c002c54d:	55                   	push   %ebp
c002c54e:	57                   	push   %edi
c002c54f:	56                   	push   %esi
c002c550:	53                   	push   %ebx
c002c551:	83 ec 1c             	sub    $0x1c,%esp
c002c554:	e8 9f 29 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c559:	81 c3 cf eb 00 00    	add    $0xebcf,%ebx
       data.  It is not necessarily the address of the instruction
       that caused the fault (that's f->eip).
       See [IA32-v2a] "MOV--Move to/from Control Registers" and
       [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
       (#PF)". */
    asm ("movl %%cr2, %0" : "=r" (fault_addr));
c002c55f:	0f 20 d7             	mov    %cr2,%edi

    /* Turn interrupts back on (they were only off so that we could
       be assured of reading CR2 before it changed). */
    intr_enable();
c002c562:	e8 5f 57 ff ff       	call   c0021cc6 <intr_enable>

    /* Count page faults. */
    page_fault_cnt++;
c002c567:	83 83 a0 1c 00 00 01 	addl   $0x1,0x1ca0(%ebx)
c002c56e:	83 93 a4 1c 00 00 00 	adcl   $0x0,0x1ca4(%ebx)

    /* Determine cause. */
    not_present = (f->error_code & PF_P) == 0;
c002c575:	8b 44 24 30          	mov    0x30(%esp),%eax
c002c579:	8b 70 34             	mov    0x34(%eax),%esi
c002c57c:	89 f0                	mov    %esi,%eax
c002c57e:	83 e0 01             	and    $0x1,%eax
c002c581:	89 44 24 0c          	mov    %eax,0xc(%esp)
    write = (f->error_code & PF_W) != 0;
c002c585:	89 f2                	mov    %esi,%edx
c002c587:	83 e2 02             	and    $0x2,%edx
c002c58a:	89 d5                	mov    %edx,%ebp
#endif

    /* To implement virtual memory, delete the rest of the function
       body, and replace it with code that brings in the page to
       which fault_addr refers. */
    syscall_exit(-1);
c002c58c:	83 ec 0c             	sub    $0xc,%esp
c002c58f:	6a ff                	push   $0xffffffff
c002c591:	e8 0b 02 00 00       	call   c002c7a1 <syscall_exit>
    printf("Page fault at %p: %s error %s page in %s context.\n",
c002c596:	83 e6 04             	and    $0x4,%esi
c002c599:	8d 83 80 61 ff ff    	lea    -0x9e80(%ebx),%eax
c002c59f:	8d 8b 76 71 ff ff    	lea    -0x8e8a(%ebx),%ecx
c002c5a5:	0f 44 c8             	cmove  %eax,%ecx
c002c5a8:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002c5ae:	8d 93 7b 71 ff ff    	lea    -0x8e85(%ebx),%edx
c002c5b4:	85 ed                	test   %ebp,%ebp
c002c5b6:	0f 44 d0             	cmove  %eax,%edx
c002c5b9:	8d b3 97 71 ff ff    	lea    -0x8e69(%ebx),%esi
c002c5bf:	8d 83 8b 71 ff ff    	lea    -0x8e75(%ebx),%eax
c002c5c5:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c002c5ca:	0f 45 c6             	cmovne %esi,%eax
c002c5cd:	89 0c 24             	mov    %ecx,(%esp)
c002c5d0:	52                   	push   %edx
c002c5d1:	50                   	push   %eax
c002c5d2:	57                   	push   %edi
c002c5d3:	8d 83 28 71 ff ff    	lea    -0x8ed8(%ebx),%eax
c002c5d9:	50                   	push   %eax
c002c5da:	e8 9f ae ff ff       	call   c002747e <printf>
           fault_addr,
           not_present ? "not present" : "rights violation",
           write ? "writing" : "reading",
           user ? "user" : "kernel");
    kill(f);
c002c5df:	83 c4 14             	add    $0x14,%esp
c002c5e2:	ff 74 24 3c          	pushl  0x3c(%esp)
c002c5e6:	e8 ba fe ff ff       	call   c002c4a5 <kill>

c002c5eb <exception_init>:
exception_init(void) {
c002c5eb:	56                   	push   %esi
c002c5ec:	53                   	push   %ebx
c002c5ed:	83 ec 10             	sub    $0x10,%esp
c002c5f0:	e8 03 29 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c5f5:	81 c3 33 eb 00 00    	add    $0xeb33,%ebx
    intr_register_int(3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002c5fb:	8d 83 eb 57 ff ff    	lea    -0xa815(%ebx),%eax
c002c601:	50                   	push   %eax
c002c602:	8d b3 7d 13 ff ff    	lea    -0xec83(%ebx),%esi
c002c608:	56                   	push   %esi
c002c609:	6a 01                	push   $0x1
c002c60b:	6a 03                	push   $0x3
c002c60d:	6a 03                	push   $0x3
c002c60f:	e8 3d 59 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002c614:	83 c4 14             	add    $0x14,%esp
c002c617:	8d 83 04 58 ff ff    	lea    -0xa7fc(%ebx),%eax
c002c61d:	50                   	push   %eax
c002c61e:	56                   	push   %esi
c002c61f:	6a 01                	push   $0x1
c002c621:	6a 03                	push   $0x3
c002c623:	6a 04                	push   $0x4
c002c625:	e8 27 59 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(5, 3, INTR_ON, kill,
c002c62a:	83 c4 14             	add    $0x14,%esp
c002c62d:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c002c633:	50                   	push   %eax
c002c634:	56                   	push   %esi
c002c635:	6a 01                	push   $0x1
c002c637:	6a 03                	push   $0x3
c002c639:	6a 05                	push   $0x5
c002c63b:	e8 11 59 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(0, 0, INTR_ON, kill, "#DE Divide Error");
c002c640:	83 c4 14             	add    $0x14,%esp
c002c643:	8d 83 b8 57 ff ff    	lea    -0xa848(%ebx),%eax
c002c649:	50                   	push   %eax
c002c64a:	56                   	push   %esi
c002c64b:	6a 01                	push   $0x1
c002c64d:	6a 00                	push   $0x0
c002c64f:	6a 00                	push   $0x0
c002c651:	e8 fb 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(1, 0, INTR_ON, kill, "#DB Debug Exception");
c002c656:	83 c4 14             	add    $0x14,%esp
c002c659:	8d 83 c9 57 ff ff    	lea    -0xa837(%ebx),%eax
c002c65f:	50                   	push   %eax
c002c660:	56                   	push   %esi
c002c661:	6a 01                	push   $0x1
c002c663:	6a 00                	push   $0x0
c002c665:	6a 01                	push   $0x1
c002c667:	e8 e5 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002c66c:	83 c4 14             	add    $0x14,%esp
c002c66f:	8d 83 1b 58 ff ff    	lea    -0xa7e5(%ebx),%eax
c002c675:	50                   	push   %eax
c002c676:	56                   	push   %esi
c002c677:	6a 01                	push   $0x1
c002c679:	6a 00                	push   $0x0
c002c67b:	6a 06                	push   $0x6
c002c67d:	e8 cf 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(7, 0, INTR_ON, kill,
c002c682:	83 c4 14             	add    $0x14,%esp
c002c685:	8d 83 64 59 ff ff    	lea    -0xa69c(%ebx),%eax
c002c68b:	50                   	push   %eax
c002c68c:	56                   	push   %esi
c002c68d:	6a 01                	push   $0x1
c002c68f:	6a 00                	push   $0x0
c002c691:	6a 07                	push   $0x7
c002c693:	e8 b9 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002c698:	83 c4 14             	add    $0x14,%esp
c002c69b:	8d 83 89 58 ff ff    	lea    -0xa777(%ebx),%eax
c002c6a1:	50                   	push   %eax
c002c6a2:	56                   	push   %esi
c002c6a3:	6a 01                	push   $0x1
c002c6a5:	6a 00                	push   $0x0
c002c6a7:	6a 0b                	push   $0xb
c002c6a9:	e8 a3 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002c6ae:	83 c4 14             	add    $0x14,%esp
c002c6b1:	8d 83 a1 58 ff ff    	lea    -0xa75f(%ebx),%eax
c002c6b7:	50                   	push   %eax
c002c6b8:	56                   	push   %esi
c002c6b9:	6a 01                	push   $0x1
c002c6bb:	6a 00                	push   $0x0
c002c6bd:	6a 0c                	push   $0xc
c002c6bf:	e8 8d 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002c6c4:	83 c4 14             	add    $0x14,%esp
c002c6c7:	8d 83 88 59 ff ff    	lea    -0xa678(%ebx),%eax
c002c6cd:	50                   	push   %eax
c002c6ce:	56                   	push   %esi
c002c6cf:	6a 01                	push   $0x1
c002c6d1:	6a 00                	push   $0x0
c002c6d3:	6a 0d                	push   $0xd
c002c6d5:	e8 77 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002c6da:	83 c4 14             	add    $0x14,%esp
c002c6dd:	8d 83 ac 59 ff ff    	lea    -0xa654(%ebx),%eax
c002c6e3:	50                   	push   %eax
c002c6e4:	56                   	push   %esi
c002c6e5:	6a 01                	push   $0x1
c002c6e7:	6a 00                	push   $0x0
c002c6e9:	6a 10                	push   $0x10
c002c6eb:	e8 61 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(19, 0, INTR_ON, kill,
c002c6f0:	83 c4 14             	add    $0x14,%esp
c002c6f3:	8d 83 d0 59 ff ff    	lea    -0xa630(%ebx),%eax
c002c6f9:	50                   	push   %eax
c002c6fa:	56                   	push   %esi
c002c6fb:	6a 01                	push   $0x1
c002c6fd:	6a 00                	push   $0x0
c002c6ff:	6a 13                	push   $0x13
c002c701:	e8 4b 58 ff ff       	call   c0021f51 <intr_register_int>
    intr_register_int(14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002c706:	83 c4 14             	add    $0x14,%esp
c002c709:	8d 83 bb 58 ff ff    	lea    -0xa745(%ebx),%eax
c002c70f:	50                   	push   %eax
c002c710:	8d 83 25 14 ff ff    	lea    -0xebdb(%ebx),%eax
c002c716:	50                   	push   %eax
c002c717:	6a 00                	push   $0x0
c002c719:	6a 00                	push   $0x0
c002c71b:	6a 0e                	push   $0xe
c002c71d:	e8 2f 58 ff ff       	call   c0021f51 <intr_register_int>
}
c002c722:	83 c4 24             	add    $0x24,%esp
c002c725:	5b                   	pop    %ebx
c002c726:	5e                   	pop    %esi
c002c727:	c3                   	ret    

c002c728 <exception_print_stats>:
exception_print_stats(void) {
c002c728:	53                   	push   %ebx
c002c729:	83 ec 0c             	sub    $0xc,%esp
c002c72c:	e8 c7 27 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c731:	81 c3 f7 e9 00 00    	add    $0xe9f7,%ebx
    printf("Exception: %lld page faults\n", page_fault_cnt);
c002c737:	ff b3 a4 1c 00 00    	pushl  0x1ca4(%ebx)
c002c73d:	ff b3 a0 1c 00 00    	pushl  0x1ca0(%ebx)
c002c743:	8d 83 a8 71 ff ff    	lea    -0x8e58(%ebx),%eax
c002c749:	50                   	push   %eax
c002c74a:	e8 2f ad ff ff       	call   c002747e <printf>
}
c002c74f:	83 c4 18             	add    $0x18,%esp
c002c752:	5b                   	pop    %ebx
c002c753:	c3                   	ret    

c002c754 <syscall_init>:


static struct lock filesystem_lock;

void
syscall_init(void) {
c002c754:	53                   	push   %ebx
c002c755:	83 ec 14             	sub    $0x14,%esp
c002c758:	e8 9b 27 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c75d:	81 c3 cb e9 00 00    	add    $0xe9cb,%ebx
    intr_register_int(0x30, 3, INTR_ON, syscall_handler, "syscall");
c002c763:	8d 83 c5 71 ff ff    	lea    -0x8e3b(%ebx),%eax
c002c769:	50                   	push   %eax
c002c76a:	8d 83 83 1e ff ff    	lea    -0xe17d(%ebx),%eax
c002c770:	50                   	push   %eax
c002c771:	6a 01                	push   $0x1
c002c773:	6a 03                	push   $0x3
c002c775:	6a 30                	push   $0x30
c002c777:	e8 d5 57 ff ff       	call   c0021f51 <intr_register_int>
    lock_init(&filesystem_lock);
c002c77c:	83 c4 14             	add    $0x14,%esp
c002c77f:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002c785:	50                   	push   %eax
c002c786:	e8 d2 69 ff ff       	call   c002315d <lock_init>
}
c002c78b:	83 c4 18             	add    $0x18,%esp
c002c78e:	5b                   	pop    %ebx
c002c78f:	c3                   	ret    

c002c790 <get_fs_lock>:

struct lock * get_fs_lock() {
c002c790:	e8 67 27 00 00       	call   c002eefc <__x86.get_pc_thunk.ax>
c002c795:	05 93 e9 00 00       	add    $0xe993,%eax
    return &filesystem_lock;
c002c79a:	8d 80 b8 1c 00 00    	lea    0x1cb8(%eax),%eax
}
c002c7a0:	c3                   	ret    

c002c7a1 <syscall_exit>:
            return read_size;
        }
    }
}

void syscall_exit (int status) {
c002c7a1:	55                   	push   %ebp
c002c7a2:	57                   	push   %edi
c002c7a3:	56                   	push   %esi
c002c7a4:	53                   	push   %ebx
c002c7a5:	83 ec 0c             	sub    $0xc,%esp
c002c7a8:	e8 4b 27 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c7ad:	81 c3 7b e9 00 00    	add    $0xe97b,%ebx
    struct thread * t = thread_current();
c002c7b3:	e8 be 47 ff ff       	call   c0020f76 <thread_current>
c002c7b8:	89 c5                	mov    %eax,%ebp
    t->exit_status = status;
c002c7ba:	8b 44 24 20          	mov    0x20(%esp),%eax
c002c7be:	89 45 2c             	mov    %eax,0x2c(%ebp)
    while (!list_empty(&t->file_descriptor_list)) {
c002c7c1:	8d 7d 30             	lea    0x30(%ebp),%edi
c002c7c4:	83 ec 0c             	sub    $0xc,%esp
c002c7c7:	57                   	push   %edi
c002c7c8:	e8 7e d0 ff ff       	call   c002984b <list_empty>
c002c7cd:	83 c4 10             	add    $0x10,%esp
c002c7d0:	84 c0                	test   %al,%al
c002c7d2:	75 2e                	jne    c002c802 <syscall_exit+0x61>
        struct file_descriptor * fd_ptr = list_entry(list_pop_front(&t->file_descriptor_list),
c002c7d4:	83 ec 0c             	sub    $0xc,%esp
c002c7d7:	57                   	push   %edi
c002c7d8:	e8 e5 d0 ff ff       	call   c00298c2 <list_pop_front>
c002c7dd:	89 c6                	mov    %eax,%esi
                struct file_descriptor, elem);
        file_close(fd_ptr->opened_file);
c002c7df:	83 c4 04             	add    $0x4,%esp
c002c7e2:	ff 70 fc             	pushl  -0x4(%eax)
c002c7e5:	e8 6b 12 00 00       	call   c002da55 <file_close>
        t->fd_used[fd_ptr->fd] = false;
c002c7ea:	8b 46 f4             	mov    -0xc(%esi),%eax
c002c7ed:	c6 44 05 40 00       	movb   $0x0,0x40(%ebp,%eax,1)
        free(fd_ptr);
c002c7f2:	83 ee 0c             	sub    $0xc,%esi
c002c7f5:	89 34 24             	mov    %esi,(%esp)
c002c7f8:	e8 ac 77 ff ff       	call   c0023fa9 <free>
c002c7fd:	83 c4 10             	add    $0x10,%esp
c002c800:	eb c2                	jmp    c002c7c4 <syscall_exit+0x23>
    }
    // debug_backtrace();
    // printf("stupid child exit %d\n", t->tid);
    printf("%s: exit(%d)\n", thread_current()->name, status);
c002c802:	e8 6f 47 ff ff       	call   c0020f76 <thread_current>
c002c807:	83 ec 04             	sub    $0x4,%esp
c002c80a:	ff 74 24 24          	pushl  0x24(%esp)
c002c80e:	83 c0 08             	add    $0x8,%eax
c002c811:	50                   	push   %eax
c002c812:	8d 83 cd 71 ff ff    	lea    -0x8e33(%ebx),%eax
c002c818:	50                   	push   %eax
c002c819:	e8 60 ac ff ff       	call   c002747e <printf>
    thread_exit();
c002c81e:	e8 b2 4d ff ff       	call   c00215d5 <thread_exit>

c002c823 <validate_user_addr>:
validate_user_addr(const void *uaddr, unsigned int len) {
c002c823:	57                   	push   %edi
c002c824:	56                   	push   %esi
c002c825:	53                   	push   %ebx
c002c826:	e8 cd 26 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c82b:	81 c3 fd e8 00 00    	add    $0xe8fd,%ebx
    for (const void *addr = uaddr; addr < uaddr + len; ++addr) {
c002c831:	8d 3c 10             	lea    (%eax,%edx,1),%edi
c002c834:	39 f8                	cmp    %edi,%eax
c002c836:	73 5d                	jae    c002c895 <validate_user_addr+0x72>
c002c838:	89 c6                	mov    %eax,%esi
        if ((!addr) || !(is_valid_user_vaddr(addr))) {
c002c83a:	85 c0                	test   %eax,%eax
c002c83c:	74 43                	je     c002c881 <validate_user_addr+0x5e>
    return is_user_vaddr(vaddr) && vaddr > ((void *) 0x08048000);
c002c83e:	8d 80 ff 7f fb f7    	lea    -0x8048001(%eax),%eax
c002c844:	3d fe 7f fb b7       	cmp    $0xb7fb7ffe,%eax
c002c849:	77 36                	ja     c002c881 <validate_user_addr+0x5e>
        if (pagedir_get_page(thread_current()->pagedir, pg_round_down(addr)) == NULL) {
c002c84b:	e8 26 47 ff ff       	call   c0020f76 <thread_current>
c002c850:	83 ec 08             	sub    $0x8,%esp
    return (void *) ((uintptr_t) va & ~PGMASK);
c002c853:	89 f2                	mov    %esi,%edx
c002c855:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c002c85b:	52                   	push   %edx
c002c85c:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002c862:	e8 66 f9 ff ff       	call   c002c1cd <pagedir_get_page>
c002c867:	83 c4 10             	add    $0x10,%esp
c002c86a:	85 c0                	test   %eax,%eax
c002c86c:	74 1d                	je     c002c88b <validate_user_addr+0x68>
    for (const void *addr = uaddr; addr < uaddr + len; ++addr) {
c002c86e:	83 c6 01             	add    $0x1,%esi
c002c871:	39 fe                	cmp    %edi,%esi
c002c873:	74 20                	je     c002c895 <validate_user_addr+0x72>
        if ((!addr) || !(is_valid_user_vaddr(addr))) {
c002c875:	85 f6                	test   %esi,%esi
c002c877:	74 08                	je     c002c881 <validate_user_addr+0x5e>
c002c879:	81 fe 00 00 00 c0    	cmp    $0xc0000000,%esi
c002c87f:	75 ca                	jne    c002c84b <validate_user_addr+0x28>
            syscall_exit(-1);
c002c881:	83 ec 0c             	sub    $0xc,%esp
c002c884:	6a ff                	push   $0xffffffff
c002c886:	e8 16 ff ff ff       	call   c002c7a1 <syscall_exit>
            syscall_exit(-1);
c002c88b:	83 ec 0c             	sub    $0xc,%esp
c002c88e:	6a ff                	push   $0xffffffff
c002c890:	e8 0c ff ff ff       	call   c002c7a1 <syscall_exit>
}
c002c895:	5b                   	pop    %ebx
c002c896:	5e                   	pop    %esi
c002c897:	5f                   	pop    %edi
c002c898:	c3                   	ret    

c002c899 <get_syscall_arg>:
get_syscall_arg(struct intr_frame *f, uint32_t *buffer, int argc) {
c002c899:	55                   	push   %ebp
c002c89a:	57                   	push   %edi
c002c89b:	56                   	push   %esi
c002c89c:	53                   	push   %ebx
c002c89d:	83 ec 0c             	sub    $0xc,%esp
    for (int i = 0; i < argc; i++) {
c002c8a0:	85 c9                	test   %ecx,%ecx
c002c8a2:	7e 30                	jle    c002c8d4 <get_syscall_arg+0x3b>
c002c8a4:	89 d5                	mov    %edx,%ebp
c002c8a6:	89 c6                	mov    %eax,%esi
c002c8a8:	89 cf                	mov    %ecx,%edi
c002c8aa:	bb 01 00 00 00       	mov    $0x1,%ebx
c002c8af:	eb 02                	jmp    c002c8b3 <get_syscall_arg+0x1a>
c002c8b1:	89 c3                	mov    %eax,%ebx
        validate_user_addr((uint32_t *) f->esp + i + 1, 4);
c002c8b3:	8b 46 48             	mov    0x48(%esi),%eax
c002c8b6:	8d 04 98             	lea    (%eax,%ebx,4),%eax
c002c8b9:	ba 04 00 00 00       	mov    $0x4,%edx
c002c8be:	e8 60 ff ff ff       	call   c002c823 <validate_user_addr>
        *buffer = *((uint32_t *) f->esp + i + 1);
c002c8c3:	8b 46 48             	mov    0x48(%esi),%eax
c002c8c6:	8b 04 98             	mov    (%eax,%ebx,4),%eax
c002c8c9:	89 44 9d fc          	mov    %eax,-0x4(%ebp,%ebx,4)
        buffer++;
c002c8cd:	8d 43 01             	lea    0x1(%ebx),%eax
    for (int i = 0; i < argc; i++) {
c002c8d0:	39 fb                	cmp    %edi,%ebx
c002c8d2:	75 dd                	jne    c002c8b1 <get_syscall_arg+0x18>
}
c002c8d4:	83 c4 0c             	add    $0xc,%esp
c002c8d7:	5b                   	pop    %ebx
c002c8d8:	5e                   	pop    %esi
c002c8d9:	5f                   	pop    %edi
c002c8da:	5d                   	pop    %ebp
c002c8db:	c3                   	ret    

c002c8dc <get_syscall_type>:
int get_syscall_type(struct intr_frame *f) {
c002c8dc:	53                   	push   %ebx
c002c8dd:	83 ec 08             	sub    $0x8,%esp
c002c8e0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    validate_user_addr(f->esp, sizeof(uint32_t));
c002c8e4:	8b 43 48             	mov    0x48(%ebx),%eax
c002c8e7:	ba 04 00 00 00       	mov    $0x4,%edx
c002c8ec:	e8 32 ff ff ff       	call   c002c823 <validate_user_addr>
    return *((uint32_t *) f->esp);
c002c8f1:	8b 43 48             	mov    0x48(%ebx),%eax
c002c8f4:	8b 00                	mov    (%eax),%eax
}
c002c8f6:	83 c4 08             	add    $0x8,%esp
c002c8f9:	5b                   	pop    %ebx
c002c8fa:	c3                   	ret    

c002c8fb <check_stack>:
void check_stack(void * esp) {
c002c8fb:	56                   	push   %esi
c002c8fc:	53                   	push   %ebx
c002c8fd:	83 ec 04             	sub    $0x4,%esp
c002c900:	e8 f3 25 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c905:	81 c3 23 e8 00 00    	add    $0xe823,%ebx
c002c90b:	8b 74 24 10          	mov    0x10(%esp),%esi
    return is_user_vaddr(vaddr) && vaddr > ((void *) 0x08048000);
c002c90f:	8d 86 ff 7f fb f7    	lea    -0x8048001(%esi),%eax
    if (!is_valid_user_vaddr(esp)) {
c002c915:	3d fe 7f fb b7       	cmp    $0xb7fb7ffe,%eax
c002c91a:	77 2a                	ja     c002c946 <check_stack+0x4b>
        if (pagedir_get_page(thread_current()->pagedir, pg_round_down(esp + 1)) == NULL)
c002c91c:	e8 55 46 ff ff       	call   c0020f76 <thread_current>
c002c921:	83 ec 08             	sub    $0x8,%esp
c002c924:	83 c6 01             	add    $0x1,%esi
    return (void *) ((uintptr_t) va & ~PGMASK);
c002c927:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c002c92d:	56                   	push   %esi
c002c92e:	ff b0 10 01 00 00    	pushl  0x110(%eax)
c002c934:	e8 94 f8 ff ff       	call   c002c1cd <pagedir_get_page>
c002c939:	83 c4 10             	add    $0x10,%esp
c002c93c:	85 c0                	test   %eax,%eax
c002c93e:	74 10                	je     c002c950 <check_stack+0x55>
}
c002c940:	83 c4 04             	add    $0x4,%esp
c002c943:	5b                   	pop    %ebx
c002c944:	5e                   	pop    %esi
c002c945:	c3                   	ret    
        syscall_exit(-1);
c002c946:	83 ec 0c             	sub    $0xc,%esp
c002c949:	6a ff                	push   $0xffffffff
c002c94b:	e8 51 fe ff ff       	call   c002c7a1 <syscall_exit>
            syscall_exit(-1);
c002c950:	83 ec 0c             	sub    $0xc,%esp
c002c953:	6a ff                	push   $0xffffffff
c002c955:	e8 47 fe ff ff       	call   c002c7a1 <syscall_exit>

c002c95a <check_file_addr>:
void check_file_addr(const char * file) {
c002c95a:	53                   	push   %ebx
c002c95b:	83 ec 08             	sub    $0x8,%esp
c002c95e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    if (file == NULL) syscall_exit(-1);
c002c962:	85 db                	test   %ebx,%ebx
c002c964:	74 16                	je     c002c97c <check_file_addr+0x22>
    for (; validate_user_addr(p, 1), *p != '\0'; p++) {
c002c966:	ba 01 00 00 00       	mov    $0x1,%edx
c002c96b:	89 d8                	mov    %ebx,%eax
c002c96d:	e8 b1 fe ff ff       	call   c002c823 <validate_user_addr>
c002c972:	80 3b 00             	cmpb   $0x0,(%ebx)
c002c975:	74 0f                	je     c002c986 <check_file_addr+0x2c>
c002c977:	83 c3 01             	add    $0x1,%ebx
c002c97a:	eb ea                	jmp    c002c966 <check_file_addr+0xc>
    if (file == NULL) syscall_exit(-1);
c002c97c:	83 ec 0c             	sub    $0xc,%esp
c002c97f:	6a ff                	push   $0xffffffff
c002c981:	e8 1b fe ff ff       	call   c002c7a1 <syscall_exit>
    validate_user_addr(p, 1);
c002c986:	ba 01 00 00 00       	mov    $0x1,%edx
c002c98b:	89 d8                	mov    %ebx,%eax
c002c98d:	e8 91 fe ff ff       	call   c002c823 <validate_user_addr>
}
c002c992:	83 c4 08             	add    $0x8,%esp
c002c995:	5b                   	pop    %ebx
c002c996:	c3                   	ret    

c002c997 <check_user>:
  if (! ((void*)uaddr < PHYS_BASE)) {
c002c997:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c99c:	77 01                	ja     c002c99f <check_user+0x8>
c002c99e:	c3                   	ret    
static void check_user (const uint8_t *uaddr) {
c002c99f:	83 ec 18             	sub    $0x18,%esp
    syscall_exit(-1);
c002c9a2:	6a ff                	push   $0xffffffff
c002c9a4:	e8 f8 fd ff ff       	call   c002c7a1 <syscall_exit>

c002c9a9 <syscall_halt>:
}

void syscall_halt(void) {
c002c9a9:	53                   	push   %ebx
c002c9aa:	83 ec 08             	sub    $0x8,%esp
c002c9ad:	e8 46 25 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c9b2:	81 c3 76 e7 00 00    	add    $0xe776,%ebx
    shutdown_power_off();
c002c9b8:	e8 a8 a2 ff ff       	call   c0026c65 <shutdown_power_off>

c002c9bd <syscall_remove>:
    NOT_REACHED ();
}

bool syscall_remove (const char *file) {
c002c9bd:	57                   	push   %edi
c002c9be:	56                   	push   %esi
c002c9bf:	53                   	push   %ebx
c002c9c0:	e8 33 25 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002c9c5:	81 c3 63 e7 00 00    	add    $0xe763,%ebx
c002c9cb:	8b 7c 24 10          	mov    0x10(%esp),%edi
    lock_acquire(&filesystem_lock);
c002c9cf:	83 ec 0c             	sub    $0xc,%esp
c002c9d2:	8d b3 b8 1c 00 00    	lea    0x1cb8(%ebx),%esi
c002c9d8:	56                   	push   %esi
c002c9d9:	e8 2b 68 ff ff       	call   c0023209 <lock_acquire>
    check_file_addr(file);
c002c9de:	89 3c 24             	mov    %edi,(%esp)
c002c9e1:	e8 74 ff ff ff       	call   c002c95a <check_file_addr>
    bool success = filesys_remove(file);
c002c9e6:	89 3c 24             	mov    %edi,(%esp)
c002c9e9:	e8 7a 0b 00 00       	call   c002d568 <filesys_remove>
c002c9ee:	89 c7                	mov    %eax,%edi
    lock_release(&filesystem_lock);
c002c9f0:	89 34 24             	mov    %esi,(%esp)
c002c9f3:	e8 12 6a ff ff       	call   c002340a <lock_release>
    return success;
c002c9f8:	83 c4 10             	add    $0x10,%esp
}
c002c9fb:	89 f8                	mov    %edi,%eax
c002c9fd:	5b                   	pop    %ebx
c002c9fe:	5e                   	pop    %esi
c002c9ff:	5f                   	pop    %edi
c002ca00:	c3                   	ret    

c002ca01 <syscall_create>:

bool syscall_create (const char *file, unsigned initial_size) {
c002ca01:	57                   	push   %edi
c002ca02:	56                   	push   %esi
c002ca03:	53                   	push   %ebx
c002ca04:	e8 ef 24 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ca09:	81 c3 1f e7 00 00    	add    $0xe71f,%ebx
c002ca0f:	8b 7c 24 10          	mov    0x10(%esp),%edi
    lock_acquire(&filesystem_lock);
c002ca13:	83 ec 0c             	sub    $0xc,%esp
c002ca16:	8d b3 b8 1c 00 00    	lea    0x1cb8(%ebx),%esi
c002ca1c:	56                   	push   %esi
c002ca1d:	e8 e7 67 ff ff       	call   c0023209 <lock_acquire>
    check_file_addr(file);
c002ca22:	89 3c 24             	mov    %edi,(%esp)
c002ca25:	e8 30 ff ff ff       	call   c002c95a <check_file_addr>
    bool success = filesys_create(file, initial_size);
c002ca2a:	83 c4 08             	add    $0x8,%esp
c002ca2d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ca31:	57                   	push   %edi
c002ca32:	e8 44 0a 00 00       	call   c002d47b <filesys_create>
c002ca37:	89 c7                	mov    %eax,%edi
    lock_release(&filesystem_lock);
c002ca39:	89 34 24             	mov    %esi,(%esp)
c002ca3c:	e8 c9 69 ff ff       	call   c002340a <lock_release>
    return success;
c002ca41:	83 c4 10             	add    $0x10,%esp
}
c002ca44:	89 f8                	mov    %edi,%eax
c002ca46:	5b                   	pop    %ebx
c002ca47:	5e                   	pop    %esi
c002ca48:	5f                   	pop    %edi
c002ca49:	c3                   	ret    

c002ca4a <select_unused_fd>:

int select_unused_fd(struct thread * t) {
c002ca4a:	8b 54 24 04          	mov    0x4(%esp),%edx
    for (int i = 3; i < 140; i++) {
        if (!t->fd_used[i]) {
c002ca4e:	80 7a 43 00          	cmpb   $0x0,0x43(%edx)
c002ca52:	74 18                	je     c002ca6c <select_unused_fd+0x22>
    for (int i = 3; i < 140; i++) {
c002ca54:	b8 04 00 00 00       	mov    $0x4,%eax
        if (!t->fd_used[i]) {
c002ca59:	80 7c 02 40 00       	cmpb   $0x0,0x40(%edx,%eax,1)
c002ca5e:	74 0b                	je     c002ca6b <select_unused_fd+0x21>
    for (int i = 3; i < 140; i++) {
c002ca60:	83 c0 01             	add    $0x1,%eax
c002ca63:	3d 8c 00 00 00       	cmp    $0x8c,%eax
c002ca68:	75 ef                	jne    c002ca59 <select_unused_fd+0xf>
            return i;
        }
    }
}
c002ca6a:	c3                   	ret    
c002ca6b:	c3                   	ret    
    for (int i = 3; i < 140; i++) {
c002ca6c:	b8 03 00 00 00       	mov    $0x3,%eax
            return i;
c002ca71:	c3                   	ret    

c002ca72 <syscall_open>:

int syscall_open (const char *file) {
c002ca72:	55                   	push   %ebp
c002ca73:	57                   	push   %edi
c002ca74:	56                   	push   %esi
c002ca75:	53                   	push   %ebx
c002ca76:	83 ec 28             	sub    $0x28,%esp
c002ca79:	e8 7a 24 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ca7e:	81 c3 aa e6 00 00    	add    $0xe6aa,%ebx
    /*
     * Opens the file called file. Returns a non-negative integer handle called a
     * "file descriptor" (fd), or -1 if the file could not be opened.
     */
    lock_acquire(&filesystem_lock);
c002ca84:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002ca8a:	50                   	push   %eax
c002ca8b:	e8 79 67 ff ff       	call   c0023209 <lock_acquire>
    check_file_addr(file);
c002ca90:	83 c4 04             	add    $0x4,%esp
c002ca93:	ff 74 24 3c          	pushl  0x3c(%esp)
c002ca97:	e8 be fe ff ff       	call   c002c95a <check_file_addr>
    struct file * fp = filesys_open(file);
c002ca9c:	83 c4 04             	add    $0x4,%esp
c002ca9f:	ff 74 24 3c          	pushl  0x3c(%esp)
c002caa3:	e8 6d 0a 00 00       	call   c002d515 <filesys_open>
c002caa8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    if (fp == NULL) {
c002caac:	83 c4 10             	add    $0x10,%esp
c002caaf:	85 c0                	test   %eax,%eax
c002cab1:	74 68                	je     c002cb1b <syscall_open+0xa9>
        lock_release(&filesystem_lock);
        return -1;
    }

    struct thread * t = thread_current();
c002cab3:	e8 be 44 ff ff       	call   c0020f76 <thread_current>
c002cab8:	89 c7                	mov    %eax,%edi
    int fd = select_unused_fd(t);
c002caba:	83 ec 0c             	sub    $0xc,%esp
c002cabd:	50                   	push   %eax
c002cabe:	e8 87 ff ff ff       	call   c002ca4a <select_unused_fd>
c002cac3:	89 c5                	mov    %eax,%ebp

    struct file_descriptor * fileDescriptor = malloc (sizeof(struct file_descriptor));
c002cac5:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
c002cacc:	e8 2a 73 ff ff       	call   c0023dfb <malloc>
c002cad1:	89 c6                	mov    %eax,%esi
    // printf("open new file, fd is %d\n", fd);
    fileDescriptor->fd = fd;
c002cad3:	89 28                	mov    %ebp,(%eax)
    fileDescriptor->holder = thread_current();
c002cad5:	e8 9c 44 ff ff       	call   c0020f76 <thread_current>
c002cada:	89 46 04             	mov    %eax,0x4(%esi)
    fileDescriptor->name = (char *) file;
c002cadd:	8b 44 24 40          	mov    0x40(%esp),%eax
c002cae1:	89 46 14             	mov    %eax,0x14(%esi)
    fileDescriptor->opened_file = fp;
c002cae4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002cae8:	89 46 08             	mov    %eax,0x8(%esi)

    t->fd_used[fd] = true;
c002caeb:	c6 44 2f 40 01       	movb   $0x1,0x40(%edi,%ebp,1)
    list_push_back(&t->file_descriptor_list, &fileDescriptor->elem );
c002caf0:	83 c4 08             	add    $0x8,%esp
c002caf3:	83 c6 0c             	add    $0xc,%esi
c002caf6:	56                   	push   %esi
c002caf7:	83 c7 30             	add    $0x30,%edi
c002cafa:	57                   	push   %edi
c002cafb:	e8 8c cc ff ff       	call   c002978c <list_push_back>
    lock_release(&filesystem_lock);
c002cb00:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cb06:	89 04 24             	mov    %eax,(%esp)
c002cb09:	e8 fc 68 ff ff       	call   c002340a <lock_release>
    return fd;
c002cb0e:	83 c4 10             	add    $0x10,%esp

}
c002cb11:	89 e8                	mov    %ebp,%eax
c002cb13:	83 c4 1c             	add    $0x1c,%esp
c002cb16:	5b                   	pop    %ebx
c002cb17:	5e                   	pop    %esi
c002cb18:	5f                   	pop    %edi
c002cb19:	5d                   	pop    %ebp
c002cb1a:	c3                   	ret    
        lock_release(&filesystem_lock);
c002cb1b:	83 ec 0c             	sub    $0xc,%esp
c002cb1e:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cb24:	50                   	push   %eax
c002cb25:	e8 e0 68 ff ff       	call   c002340a <lock_release>
        return -1;
c002cb2a:	83 c4 10             	add    $0x10,%esp
c002cb2d:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002cb32:	eb dd                	jmp    c002cb11 <syscall_open+0x9f>

c002cb34 <get_fd_ptr>:

struct file_descriptor * get_fd_ptr(struct thread * t, int fd) {
c002cb34:	55                   	push   %ebp
c002cb35:	57                   	push   %edi
c002cb36:	56                   	push   %esi
c002cb37:	53                   	push   %ebx
c002cb38:	83 ec 18             	sub    $0x18,%esp
c002cb3b:	e8 b8 23 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002cb40:	81 c3 e8 e5 00 00    	add    $0xe5e8,%ebx
c002cb46:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    struct list_elem * e;
    for (e = list_begin(&t->file_descriptor_list); e != list_end(&t->file_descriptor_list);
c002cb4a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002cb4e:	8d 78 30             	lea    0x30(%eax),%edi
c002cb51:	57                   	push   %edi
c002cb52:	e8 a8 c6 ff ff       	call   c00291ff <list_begin>
c002cb57:	89 c6                	mov    %eax,%esi
c002cb59:	83 c4 10             	add    $0x10,%esp
c002cb5c:	83 ec 0c             	sub    $0xc,%esp
c002cb5f:	57                   	push   %edi
c002cb60:	e8 3c c7 ff ff       	call   c00292a1 <list_end>
c002cb65:	83 c4 10             	add    $0x10,%esp
c002cb68:	39 f0                	cmp    %esi,%eax
c002cb6a:	74 1a                	je     c002cb86 <get_fd_ptr+0x52>
         e = list_next(e)) {
        struct file_descriptor * fileDescriptor = list_entry(e, struct file_descriptor, elem);
        if (fileDescriptor->fd == fd) {
c002cb6c:	39 6e f4             	cmp    %ebp,-0xc(%esi)
c002cb6f:	74 10                	je     c002cb81 <get_fd_ptr+0x4d>
         e = list_next(e)) {
c002cb71:	83 ec 0c             	sub    $0xc,%esp
c002cb74:	56                   	push   %esi
c002cb75:	e8 ca c6 ff ff       	call   c0029244 <list_next>
c002cb7a:	89 c6                	mov    %eax,%esi
c002cb7c:	83 c4 10             	add    $0x10,%esp
c002cb7f:	eb db                	jmp    c002cb5c <get_fd_ptr+0x28>
        struct file_descriptor * fileDescriptor = list_entry(e, struct file_descriptor, elem);
c002cb81:	8d 46 f4             	lea    -0xc(%esi),%eax
c002cb84:	eb 05                	jmp    c002cb8b <get_fd_ptr+0x57>
            return fileDescriptor;
        }
    }
    return NULL;
c002cb86:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002cb8b:	83 c4 0c             	add    $0xc,%esp
c002cb8e:	5b                   	pop    %ebx
c002cb8f:	5e                   	pop    %esi
c002cb90:	5f                   	pop    %edi
c002cb91:	5d                   	pop    %ebp
c002cb92:	c3                   	ret    

c002cb93 <syscall_write>:
int syscall_write(int fd, const void *buffer, unsigned size) {
c002cb93:	55                   	push   %ebp
c002cb94:	57                   	push   %edi
c002cb95:	56                   	push   %esi
c002cb96:	53                   	push   %ebx
c002cb97:	83 ec 0c             	sub    $0xc,%esp
c002cb9a:	e8 59 23 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002cb9f:	81 c3 89 e5 00 00    	add    $0xe589,%ebx
c002cba5:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002cba9:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002cbad:	8b 74 24 28          	mov    0x28(%esp),%esi
    check_user((const uint8_t*) buffer);
c002cbb1:	89 f8                	mov    %edi,%eax
c002cbb3:	e8 df fd ff ff       	call   c002c997 <check_user>
    check_user((const uint8_t*) buffer + size - 1);
c002cbb8:	8d 44 37 ff          	lea    -0x1(%edi,%esi,1),%eax
c002cbbc:	e8 d6 fd ff ff       	call   c002c997 <check_user>
    lock_acquire(&filesystem_lock);
c002cbc1:	83 ec 0c             	sub    $0xc,%esp
c002cbc4:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cbca:	50                   	push   %eax
c002cbcb:	e8 39 66 ff ff       	call   c0023209 <lock_acquire>
    switch (fd) {
c002cbd0:	83 c4 10             	add    $0x10,%esp
c002cbd3:	85 ed                	test   %ebp,%ebp
c002cbd5:	74 3d                	je     c002cc14 <syscall_write+0x81>
c002cbd7:	83 fd 01             	cmp    $0x1,%ebp
c002cbda:	74 53                	je     c002cc2f <syscall_write+0x9c>
            struct file_descriptor * fd_ptr = get_fd_ptr(thread_current(), fd);
c002cbdc:	e8 95 43 ff ff       	call   c0020f76 <thread_current>
c002cbe1:	83 ec 08             	sub    $0x8,%esp
c002cbe4:	55                   	push   %ebp
c002cbe5:	50                   	push   %eax
c002cbe6:	e8 49 ff ff ff       	call   c002cb34 <get_fd_ptr>
            if (fd_ptr == NULL) {
c002cbeb:	83 c4 10             	add    $0x10,%esp
c002cbee:	85 c0                	test   %eax,%eax
c002cbf0:	74 62                	je     c002cc54 <syscall_write+0xc1>
            int write_size = file_write(fd_ptr->opened_file, buffer, size);
c002cbf2:	83 ec 04             	sub    $0x4,%esp
c002cbf5:	56                   	push   %esi
c002cbf6:	57                   	push   %edi
c002cbf7:	ff 70 08             	pushl  0x8(%eax)
c002cbfa:	e8 46 0d 00 00       	call   c002d945 <file_write>
c002cbff:	89 c6                	mov    %eax,%esi
            lock_release(&filesystem_lock);
c002cc01:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cc07:	89 04 24             	mov    %eax,(%esp)
c002cc0a:	e8 fb 67 ff ff       	call   c002340a <lock_release>
            return write_size;
c002cc0f:	83 c4 10             	add    $0x10,%esp
c002cc12:	eb 36                	jmp    c002cc4a <syscall_write+0xb7>
            lock_release(&filesystem_lock);
c002cc14:	83 ec 0c             	sub    $0xc,%esp
c002cc17:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cc1d:	50                   	push   %eax
c002cc1e:	e8 e7 67 ff ff       	call   c002340a <lock_release>
            syscall_exit(-1);
c002cc23:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cc2a:	e8 72 fb ff ff       	call   c002c7a1 <syscall_exit>
            putbuf((const char *)buffer, size);
c002cc2f:	83 ec 08             	sub    $0x8,%esp
c002cc32:	56                   	push   %esi
c002cc33:	57                   	push   %edi
c002cc34:	e8 b6 e4 ff ff       	call   c002b0ef <putbuf>
            lock_release(&filesystem_lock);
c002cc39:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cc3f:	89 04 24             	mov    %eax,(%esp)
c002cc42:	e8 c3 67 ff ff       	call   c002340a <lock_release>
            return size;
c002cc47:	83 c4 10             	add    $0x10,%esp
}
c002cc4a:	89 f0                	mov    %esi,%eax
c002cc4c:	83 c4 0c             	add    $0xc,%esp
c002cc4f:	5b                   	pop    %ebx
c002cc50:	5e                   	pop    %esi
c002cc51:	5f                   	pop    %edi
c002cc52:	5d                   	pop    %ebp
c002cc53:	c3                   	ret    
                lock_release(&filesystem_lock);
c002cc54:	83 ec 0c             	sub    $0xc,%esp
c002cc57:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cc5d:	50                   	push   %eax
c002cc5e:	e8 a7 67 ff ff       	call   c002340a <lock_release>
                syscall_exit(-1);
c002cc63:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cc6a:	e8 32 fb ff ff       	call   c002c7a1 <syscall_exit>

c002cc6f <syscall_read>:
int syscall_read (int fd, void *buffer, unsigned size) {
c002cc6f:	55                   	push   %ebp
c002cc70:	57                   	push   %edi
c002cc71:	56                   	push   %esi
c002cc72:	53                   	push   %ebx
c002cc73:	83 ec 0c             	sub    $0xc,%esp
c002cc76:	e8 7d 22 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002cc7b:	81 c3 ad e4 00 00    	add    $0xe4ad,%ebx
c002cc81:	8b 74 24 20          	mov    0x20(%esp),%esi
c002cc85:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002cc89:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    check_user((const uint8_t*) buffer);
c002cc8d:	89 f8                	mov    %edi,%eax
c002cc8f:	e8 03 fd ff ff       	call   c002c997 <check_user>
    check_user((const uint8_t*) buffer + size - 1);
c002cc94:	8d 44 2f ff          	lea    -0x1(%edi,%ebp,1),%eax
c002cc98:	e8 fa fc ff ff       	call   c002c997 <check_user>
    lock_acquire(&filesystem_lock);
c002cc9d:	83 ec 0c             	sub    $0xc,%esp
c002cca0:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cca6:	50                   	push   %eax
c002cca7:	e8 5d 65 ff ff       	call   c0023209 <lock_acquire>
    switch (fd) {
c002ccac:	83 c4 10             	add    $0x10,%esp
c002ccaf:	85 f6                	test   %esi,%esi
c002ccb1:	74 42                	je     c002ccf5 <syscall_read+0x86>
c002ccb3:	83 fe 01             	cmp    $0x1,%esi
c002ccb6:	74 58                	je     c002cd10 <syscall_read+0xa1>
            struct file_descriptor * fd_ptr = get_fd_ptr(thread_current(), fd);
c002ccb8:	e8 b9 42 ff ff       	call   c0020f76 <thread_current>
c002ccbd:	83 ec 08             	sub    $0x8,%esp
c002ccc0:	56                   	push   %esi
c002ccc1:	50                   	push   %eax
c002ccc2:	e8 6d fe ff ff       	call   c002cb34 <get_fd_ptr>
            if (fd_ptr == NULL) {
c002ccc7:	83 c4 10             	add    $0x10,%esp
c002ccca:	85 c0                	test   %eax,%eax
c002cccc:	74 5d                	je     c002cd2b <syscall_read+0xbc>
            int read_size = file_read(fd_ptr->opened_file, buffer, size);
c002ccce:	83 ec 04             	sub    $0x4,%esp
c002ccd1:	55                   	push   %ebp
c002ccd2:	57                   	push   %edi
c002ccd3:	ff 70 08             	pushl  0x8(%eax)
c002ccd6:	e8 10 0c 00 00       	call   c002d8eb <file_read>
c002ccdb:	89 c6                	mov    %eax,%esi
            lock_release(&filesystem_lock);
c002ccdd:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cce3:	89 04 24             	mov    %eax,(%esp)
c002cce6:	e8 1f 67 ff ff       	call   c002340a <lock_release>
}
c002cceb:	89 f0                	mov    %esi,%eax
c002cced:	83 c4 1c             	add    $0x1c,%esp
c002ccf0:	5b                   	pop    %ebx
c002ccf1:	5e                   	pop    %esi
c002ccf2:	5f                   	pop    %edi
c002ccf3:	5d                   	pop    %ebp
c002ccf4:	c3                   	ret    
            lock_release(&filesystem_lock);
c002ccf5:	83 ec 0c             	sub    $0xc,%esp
c002ccf8:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002ccfe:	50                   	push   %eax
c002ccff:	e8 06 67 ff ff       	call   c002340a <lock_release>
            syscall_exit(-1);
c002cd04:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cd0b:	e8 91 fa ff ff       	call   c002c7a1 <syscall_exit>
            lock_release(&filesystem_lock);
c002cd10:	83 ec 0c             	sub    $0xc,%esp
c002cd13:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cd19:	50                   	push   %eax
c002cd1a:	e8 eb 66 ff ff       	call   c002340a <lock_release>
            syscall_exit(-1);
c002cd1f:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cd26:	e8 76 fa ff ff       	call   c002c7a1 <syscall_exit>
                lock_release(&filesystem_lock);
c002cd2b:	83 ec 0c             	sub    $0xc,%esp
c002cd2e:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cd34:	50                   	push   %eax
c002cd35:	e8 d0 66 ff ff       	call   c002340a <lock_release>
                syscall_exit(-1);
c002cd3a:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cd41:	e8 5b fa ff ff       	call   c002c7a1 <syscall_exit>

c002cd46 <syscall_close>:

void syscall_close(int fd) {
c002cd46:	55                   	push   %ebp
c002cd47:	57                   	push   %edi
c002cd48:	56                   	push   %esi
c002cd49:	53                   	push   %ebx
c002cd4a:	83 ec 0c             	sub    $0xc,%esp
c002cd4d:	e8 a6 21 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002cd52:	81 c3 d6 e3 00 00    	add    $0xe3d6,%ebx
c002cd58:	8b 7c 24 20          	mov    0x20(%esp),%edi
    struct thread * t = thread_current();
c002cd5c:	e8 15 42 ff ff       	call   c0020f76 <thread_current>
c002cd61:	89 c5                	mov    %eax,%ebp
    lock_acquire(&filesystem_lock);
c002cd63:	83 ec 0c             	sub    $0xc,%esp
c002cd66:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cd6c:	50                   	push   %eax
c002cd6d:	e8 97 64 ff ff       	call   c0023209 <lock_acquire>

    if (fd <= 1 || list_empty(&t->file_descriptor_list)) {
c002cd72:	83 c4 10             	add    $0x10,%esp
c002cd75:	83 ff 01             	cmp    $0x1,%edi
c002cd78:	7e 5f                	jle    c002cdd9 <syscall_close+0x93>
c002cd7a:	83 ec 0c             	sub    $0xc,%esp
c002cd7d:	8d 45 30             	lea    0x30(%ebp),%eax
c002cd80:	50                   	push   %eax
c002cd81:	e8 c5 ca ff ff       	call   c002984b <list_empty>
c002cd86:	83 c4 10             	add    $0x10,%esp
c002cd89:	84 c0                	test   %al,%al
c002cd8b:	75 4c                	jne    c002cdd9 <syscall_close+0x93>
        // printf("This thread (%s) has no opened file\n", t->name);
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file_descriptor * fd_ptr = get_fd_ptr(t, fd);
c002cd8d:	83 ec 08             	sub    $0x8,%esp
c002cd90:	57                   	push   %edi
c002cd91:	55                   	push   %ebp
c002cd92:	e8 9d fd ff ff       	call   c002cb34 <get_fd_ptr>
c002cd97:	89 c6                	mov    %eax,%esi
    if (fd_ptr == NULL) {
c002cd99:	83 c4 10             	add    $0x10,%esp
c002cd9c:	85 c0                	test   %eax,%eax
c002cd9e:	74 54                	je     c002cdf4 <syscall_close+0xae>
        // printf("No such fd opened: %d\n", fd);
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    file_close(fd_ptr->opened_file);
c002cda0:	83 ec 0c             	sub    $0xc,%esp
c002cda3:	ff 70 08             	pushl  0x8(%eax)
c002cda6:	e8 aa 0c 00 00       	call   c002da55 <file_close>
    t->fd_used[fd] = false;
c002cdab:	c6 44 3d 40 00       	movb   $0x0,0x40(%ebp,%edi,1)
    list_remove(&fd_ptr->elem);
c002cdb0:	8d 46 0c             	lea    0xc(%esi),%eax
c002cdb3:	89 04 24             	mov    %eax,(%esp)
c002cdb6:	e8 ee c9 ff ff       	call   c00297a9 <list_remove>
    free(fd_ptr);
c002cdbb:	89 34 24             	mov    %esi,(%esp)
c002cdbe:	e8 e6 71 ff ff       	call   c0023fa9 <free>
    lock_release(&filesystem_lock);
c002cdc3:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cdc9:	89 04 24             	mov    %eax,(%esp)
c002cdcc:	e8 39 66 ff ff       	call   c002340a <lock_release>
}
c002cdd1:	83 c4 1c             	add    $0x1c,%esp
c002cdd4:	5b                   	pop    %ebx
c002cdd5:	5e                   	pop    %esi
c002cdd6:	5f                   	pop    %edi
c002cdd7:	5d                   	pop    %ebp
c002cdd8:	c3                   	ret    
        lock_release(&filesystem_lock);
c002cdd9:	83 ec 0c             	sub    $0xc,%esp
c002cddc:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cde2:	50                   	push   %eax
c002cde3:	e8 22 66 ff ff       	call   c002340a <lock_release>
        syscall_exit(-1);
c002cde8:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cdef:	e8 ad f9 ff ff       	call   c002c7a1 <syscall_exit>
        lock_release(&filesystem_lock);
c002cdf4:	83 ec 0c             	sub    $0xc,%esp
c002cdf7:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cdfd:	50                   	push   %eax
c002cdfe:	e8 07 66 ff ff       	call   c002340a <lock_release>
        syscall_exit(-1);
c002ce03:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002ce0a:	e8 92 f9 ff ff       	call   c002c7a1 <syscall_exit>

c002ce0f <syscall_filesize>:

int syscall_filesize(int fd) {
c002ce0f:	56                   	push   %esi
c002ce10:	53                   	push   %ebx
c002ce11:	83 ec 10             	sub    $0x10,%esp
c002ce14:	e8 df 20 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ce19:	81 c3 0f e3 00 00    	add    $0xe30f,%ebx
    // printf("call sys_filesize\n");
    lock_acquire(&filesystem_lock);
c002ce1f:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002ce25:	50                   	push   %eax
c002ce26:	e8 de 63 ff ff       	call   c0023209 <lock_acquire>
    struct file_descriptor * fileDescriptor = get_fd_ptr(thread_current(), fd);
c002ce2b:	e8 46 41 ff ff       	call   c0020f76 <thread_current>
c002ce30:	83 c4 08             	add    $0x8,%esp
c002ce33:	ff 74 24 18          	pushl  0x18(%esp)
c002ce37:	50                   	push   %eax
c002ce38:	e8 f7 fc ff ff       	call   c002cb34 <get_fd_ptr>
    if (fileDescriptor == NULL) {
c002ce3d:	83 c4 10             	add    $0x10,%esp
c002ce40:	85 c0                	test   %eax,%eax
c002ce42:	74 23                	je     c002ce67 <syscall_filesize+0x58>
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file * fp = fileDescriptor->opened_file;
    int ans = file_length(fp);
c002ce44:	83 ec 0c             	sub    $0xc,%esp
c002ce47:	ff 70 08             	pushl  0x8(%eax)
c002ce4a:	e8 42 0c 00 00       	call   c002da91 <file_length>
c002ce4f:	89 c6                	mov    %eax,%esi
    lock_release(&filesystem_lock);
c002ce51:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002ce57:	89 04 24             	mov    %eax,(%esp)
c002ce5a:	e8 ab 65 ff ff       	call   c002340a <lock_release>
    return ans;
}
c002ce5f:	89 f0                	mov    %esi,%eax
c002ce61:	83 c4 14             	add    $0x14,%esp
c002ce64:	5b                   	pop    %ebx
c002ce65:	5e                   	pop    %esi
c002ce66:	c3                   	ret    
        lock_release(&filesystem_lock);
c002ce67:	83 ec 0c             	sub    $0xc,%esp
c002ce6a:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002ce70:	50                   	push   %eax
c002ce71:	e8 94 65 ff ff       	call   c002340a <lock_release>
        syscall_exit(-1);
c002ce76:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002ce7d:	e8 1f f9 ff ff       	call   c002c7a1 <syscall_exit>

c002ce82 <syscall_exec>:

pid_t syscall_exec (const char *file) {
c002ce82:	56                   	push   %esi
c002ce83:	53                   	push   %ebx
c002ce84:	83 ec 10             	sub    $0x10,%esp
c002ce87:	e8 6c 20 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ce8c:	81 c3 9c e2 00 00    	add    $0xe29c,%ebx
c002ce92:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    check_file_addr(file);
c002ce96:	56                   	push   %esi
c002ce97:	e8 be fa ff ff       	call   c002c95a <check_file_addr>
    /*
     * Thus, the parent process cannot return from the exec until it knows whether the child
     * process successfully loaded its executable. You must use appropriate
     * synchronization to ensure this.
     */
    int tid = process_execute(file);
c002ce9c:	89 34 24             	mov    %esi,(%esp)
c002ce9f:	e8 60 e3 ff ff       	call   c002b204 <process_execute>
    // printf("exec %s \n", file);
    return tid;
}
c002cea4:	83 c4 14             	add    $0x14,%esp
c002cea7:	5b                   	pop    %ebx
c002cea8:	5e                   	pop    %esi
c002cea9:	c3                   	ret    

c002ceaa <syscall_wait>:

int syscall_wait (pid_t pid) {
c002ceaa:	53                   	push   %ebx
c002ceab:	83 ec 14             	sub    $0x14,%esp
c002ceae:	e8 45 20 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ceb3:	81 c3 75 e2 00 00    	add    $0xe275,%ebx
    return process_wait(pid);
c002ceb9:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cebd:	e8 ad e4 ff ff       	call   c002b36f <process_wait>
}
c002cec2:	83 c4 18             	add    $0x18,%esp
c002cec5:	5b                   	pop    %ebx
c002cec6:	c3                   	ret    

c002cec7 <syscall_seek>:

void syscall_seek (int fd, unsigned position) {
c002cec7:	53                   	push   %ebx
c002cec8:	83 ec 14             	sub    $0x14,%esp
c002cecb:	e8 28 20 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ced0:	81 c3 58 e2 00 00    	add    $0xe258,%ebx
    lock_acquire(&filesystem_lock);
c002ced6:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cedc:	50                   	push   %eax
c002cedd:	e8 27 63 ff ff       	call   c0023209 <lock_acquire>
    struct file_descriptor * fileDescriptor = get_fd_ptr(thread_current(), fd);
c002cee2:	e8 8f 40 ff ff       	call   c0020f76 <thread_current>
c002cee7:	83 c4 08             	add    $0x8,%esp
c002ceea:	ff 74 24 18          	pushl  0x18(%esp)
c002ceee:	50                   	push   %eax
c002ceef:	e8 40 fc ff ff       	call   c002cb34 <get_fd_ptr>
    if (fileDescriptor == NULL) {
c002cef4:	83 c4 10             	add    $0x10,%esp
c002cef7:	85 c0                	test   %eax,%eax
c002cef9:	74 22                	je     c002cf1d <syscall_seek+0x56>
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file * fp = fileDescriptor->opened_file;
    file_seek(fp, position);
c002cefb:	83 ec 08             	sub    $0x8,%esp
c002cefe:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cf02:	ff 70 08             	pushl  0x8(%eax)
c002cf05:	e8 d6 0b 00 00       	call   c002dae0 <file_seek>
    lock_release(&filesystem_lock);
c002cf0a:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cf10:	89 04 24             	mov    %eax,(%esp)
c002cf13:	e8 f2 64 ff ff       	call   c002340a <lock_release>
}
c002cf18:	83 c4 18             	add    $0x18,%esp
c002cf1b:	5b                   	pop    %ebx
c002cf1c:	c3                   	ret    
        lock_release(&filesystem_lock);
c002cf1d:	83 ec 0c             	sub    $0xc,%esp
c002cf20:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cf26:	50                   	push   %eax
c002cf27:	e8 de 64 ff ff       	call   c002340a <lock_release>
        syscall_exit(-1);
c002cf2c:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cf33:	e8 69 f8 ff ff       	call   c002c7a1 <syscall_exit>

c002cf38 <syscall_tell>:

int syscall_tell (int fd) {
c002cf38:	56                   	push   %esi
c002cf39:	53                   	push   %ebx
c002cf3a:	83 ec 10             	sub    $0x10,%esp
c002cf3d:	e8 b6 1f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002cf42:	81 c3 e6 e1 00 00    	add    $0xe1e6,%ebx
    lock_acquire(&filesystem_lock);
c002cf48:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cf4e:	50                   	push   %eax
c002cf4f:	e8 b5 62 ff ff       	call   c0023209 <lock_acquire>
    struct file_descriptor * fileDescriptor = get_fd_ptr(thread_current(), fd);
c002cf54:	e8 1d 40 ff ff       	call   c0020f76 <thread_current>
c002cf59:	83 c4 08             	add    $0x8,%esp
c002cf5c:	ff 74 24 18          	pushl  0x18(%esp)
c002cf60:	50                   	push   %eax
c002cf61:	e8 ce fb ff ff       	call   c002cb34 <get_fd_ptr>
    if (fileDescriptor == NULL) {
c002cf66:	83 c4 10             	add    $0x10,%esp
c002cf69:	85 c0                	test   %eax,%eax
c002cf6b:	74 23                	je     c002cf90 <syscall_tell+0x58>
        lock_release(&filesystem_lock);
        syscall_exit(-1);
    }
    struct file * fp = fileDescriptor->opened_file;
    int pos = file_tell(fp);
c002cf6d:	83 ec 0c             	sub    $0xc,%esp
c002cf70:	ff 70 08             	pushl  0x8(%eax)
c002cf73:	e8 e1 0b 00 00       	call   c002db59 <file_tell>
c002cf78:	89 c6                	mov    %eax,%esi
    lock_release(&filesystem_lock);
c002cf7a:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cf80:	89 04 24             	mov    %eax,(%esp)
c002cf83:	e8 82 64 ff ff       	call   c002340a <lock_release>
    return pos;
}
c002cf88:	89 f0                	mov    %esi,%eax
c002cf8a:	83 c4 14             	add    $0x14,%esp
c002cf8d:	5b                   	pop    %ebx
c002cf8e:	5e                   	pop    %esi
c002cf8f:	c3                   	ret    
        lock_release(&filesystem_lock);
c002cf90:	83 ec 0c             	sub    $0xc,%esp
c002cf93:	8d 83 b8 1c 00 00    	lea    0x1cb8(%ebx),%eax
c002cf99:	50                   	push   %eax
c002cf9a:	e8 6b 64 ff ff       	call   c002340a <lock_release>
        syscall_exit(-1);
c002cf9f:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002cfa6:	e8 f6 f7 ff ff       	call   c002c7a1 <syscall_exit>

c002cfab <syscall_handler>:
syscall_handler(struct intr_frame *f UNUSED) {
c002cfab:	56                   	push   %esi
c002cfac:	53                   	push   %ebx
c002cfad:	83 ec 14             	sub    $0x14,%esp
c002cfb0:	e8 43 1f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002cfb5:	81 c3 73 e1 00 00    	add    $0xe173,%ebx
c002cfbb:	8b 74 24 20          	mov    0x20(%esp),%esi
    thread_current()->stack = f->esp;
c002cfbf:	e8 b2 3f ff ff       	call   c0020f76 <thread_current>
c002cfc4:	8b 56 48             	mov    0x48(%esi),%edx
c002cfc7:	89 50 18             	mov    %edx,0x18(%eax)
    check_stack(f->esp);
c002cfca:	83 ec 0c             	sub    $0xc,%esp
c002cfcd:	52                   	push   %edx
c002cfce:	e8 28 f9 ff ff       	call   c002c8fb <check_stack>
    int type = get_syscall_type(f);
c002cfd3:	89 34 24             	mov    %esi,(%esp)
c002cfd6:	e8 01 f9 ff ff       	call   c002c8dc <get_syscall_type>
    switch (type) {
c002cfdb:	83 c4 10             	add    $0x10,%esp
c002cfde:	83 f8 0e             	cmp    $0xe,%eax
c002cfe1:	0f 87 f8 01 00 00    	ja     c002d1df <.L113+0x13>
c002cfe7:	89 d9                	mov    %ebx,%ecx
c002cfe9:	03 8c 83 2c 4d ff ff 	add    -0xb2d4(%ebx,%eax,4),%ecx
c002cff0:	ff e1                	jmp    *%ecx

c002cff2 <.L128>:
    shutdown_power_off();
c002cff2:	e8 6e 9c ff ff       	call   c0026c65 <shutdown_power_off>

c002cff7 <.L127>:
            get_syscall_arg(f, syscall_args, 1);
c002cff7:	89 e2                	mov    %esp,%edx
c002cff9:	b9 01 00 00 00       	mov    $0x1,%ecx
c002cffe:	89 f0                	mov    %esi,%eax
c002d000:	e8 94 f8 ff ff       	call   c002c899 <get_syscall_arg>
            syscall_exit(syscall_args[0]);
c002d005:	83 ec 0c             	sub    $0xc,%esp
c002d008:	ff 74 24 0c          	pushl  0xc(%esp)
c002d00c:	e8 90 f7 ff ff       	call   c002c7a1 <syscall_exit>

c002d011 <.L126>:
            get_syscall_arg(f, syscall_args, 1);
c002d011:	89 e2                	mov    %esp,%edx
c002d013:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d018:	89 f0                	mov    %esi,%eax
c002d01a:	e8 7a f8 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_exec((char *) syscall_args[0]);
c002d01f:	83 ec 0c             	sub    $0xc,%esp
c002d022:	ff 74 24 0c          	pushl  0xc(%esp)
c002d026:	e8 57 fe ff ff       	call   c002ce82 <syscall_exec>
c002d02b:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d02e:	83 c4 10             	add    $0x10,%esp
}
c002d031:	83 c4 14             	add    $0x14,%esp
c002d034:	5b                   	pop    %ebx
c002d035:	5e                   	pop    %esi
c002d036:	c3                   	ret    

c002d037 <.L125>:
            get_syscall_arg(f, syscall_args, 1);
c002d037:	89 e2                	mov    %esp,%edx
c002d039:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d03e:	89 f0                	mov    %esi,%eax
c002d040:	e8 54 f8 ff ff       	call   c002c899 <get_syscall_arg>
    return process_wait(pid);
c002d045:	83 ec 0c             	sub    $0xc,%esp
c002d048:	ff 74 24 0c          	pushl  0xc(%esp)
c002d04c:	e8 1e e3 ff ff       	call   c002b36f <process_wait>
            f->eax = syscall_wait(syscall_args[0]);
c002d051:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d054:	83 c4 10             	add    $0x10,%esp
c002d057:	eb d8                	jmp    c002d031 <.L126+0x20>

c002d059 <.L124>:
            get_syscall_arg(f, syscall_args, 2);
c002d059:	89 e2                	mov    %esp,%edx
c002d05b:	b9 02 00 00 00       	mov    $0x2,%ecx
c002d060:	89 f0                	mov    %esi,%eax
c002d062:	e8 32 f8 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_create(file, size);
c002d067:	83 ec 08             	sub    $0x8,%esp
c002d06a:	ff 74 24 0c          	pushl  0xc(%esp)
c002d06e:	ff 74 24 0c          	pushl  0xc(%esp)
c002d072:	e8 8a f9 ff ff       	call   c002ca01 <syscall_create>
c002d077:	0f b6 c0             	movzbl %al,%eax
c002d07a:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d07d:	83 c4 10             	add    $0x10,%esp
c002d080:	eb af                	jmp    c002d031 <.L126+0x20>

c002d082 <.L123>:
            get_syscall_arg(f, syscall_args, 1);
c002d082:	89 e2                	mov    %esp,%edx
c002d084:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d089:	89 f0                	mov    %esi,%eax
c002d08b:	e8 09 f8 ff ff       	call   c002c899 <get_syscall_arg>
            syscall_remove(file);
c002d090:	83 ec 0c             	sub    $0xc,%esp
c002d093:	ff 74 24 0c          	pushl  0xc(%esp)
c002d097:	e8 21 f9 ff ff       	call   c002c9bd <syscall_remove>
            break;
c002d09c:	83 c4 10             	add    $0x10,%esp
c002d09f:	eb 90                	jmp    c002d031 <.L126+0x20>

c002d0a1 <.L122>:
            get_syscall_arg(f, syscall_args, 1);
c002d0a1:	89 e2                	mov    %esp,%edx
c002d0a3:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d0a8:	89 f0                	mov    %esi,%eax
c002d0aa:	e8 ea f7 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_open(file);
c002d0af:	83 ec 0c             	sub    $0xc,%esp
c002d0b2:	ff 74 24 0c          	pushl  0xc(%esp)
c002d0b6:	e8 b7 f9 ff ff       	call   c002ca72 <syscall_open>
c002d0bb:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d0be:	83 c4 10             	add    $0x10,%esp
c002d0c1:	e9 6b ff ff ff       	jmp    c002d031 <.L126+0x20>

c002d0c6 <.L121>:
            get_syscall_arg(f, syscall_args, 1);
c002d0c6:	89 e2                	mov    %esp,%edx
c002d0c8:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d0cd:	89 f0                	mov    %esi,%eax
c002d0cf:	e8 c5 f7 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_filesize(fd);
c002d0d4:	83 ec 0c             	sub    $0xc,%esp
c002d0d7:	ff 74 24 0c          	pushl  0xc(%esp)
c002d0db:	e8 2f fd ff ff       	call   c002ce0f <syscall_filesize>
c002d0e0:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d0e3:	83 c4 10             	add    $0x10,%esp
c002d0e6:	e9 46 ff ff ff       	jmp    c002d031 <.L126+0x20>

c002d0eb <.L120>:
            get_syscall_arg(f, syscall_args, 3);
c002d0eb:	89 e2                	mov    %esp,%edx
c002d0ed:	b9 03 00 00 00       	mov    $0x3,%ecx
c002d0f2:	89 f0                	mov    %esi,%eax
c002d0f4:	e8 a0 f7 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_read(fd, buffer, size);
c002d0f9:	83 ec 04             	sub    $0x4,%esp
c002d0fc:	ff 74 24 0c          	pushl  0xc(%esp)
c002d100:	ff 74 24 0c          	pushl  0xc(%esp)
c002d104:	ff 74 24 0c          	pushl  0xc(%esp)
c002d108:	e8 62 fb ff ff       	call   c002cc6f <syscall_read>
c002d10d:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d110:	83 c4 10             	add    $0x10,%esp
c002d113:	e9 19 ff ff ff       	jmp    c002d031 <.L126+0x20>

c002d118 <.L119>:
            get_syscall_arg(f, syscall_args, 3);
c002d118:	89 e2                	mov    %esp,%edx
c002d11a:	b9 03 00 00 00       	mov    $0x3,%ecx
c002d11f:	89 f0                	mov    %esi,%eax
c002d121:	e8 73 f7 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_write(fd, buffer, size);
c002d126:	83 ec 04             	sub    $0x4,%esp
c002d129:	ff 74 24 0c          	pushl  0xc(%esp)
c002d12d:	ff 74 24 0c          	pushl  0xc(%esp)
c002d131:	ff 74 24 0c          	pushl  0xc(%esp)
c002d135:	e8 59 fa ff ff       	call   c002cb93 <syscall_write>
c002d13a:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d13d:	83 c4 10             	add    $0x10,%esp
c002d140:	e9 ec fe ff ff       	jmp    c002d031 <.L126+0x20>

c002d145 <.L118>:
            get_syscall_arg(f, syscall_args, 2);
c002d145:	89 e2                	mov    %esp,%edx
c002d147:	b9 02 00 00 00       	mov    $0x2,%ecx
c002d14c:	89 f0                	mov    %esi,%eax
c002d14e:	e8 46 f7 ff ff       	call   c002c899 <get_syscall_arg>
            syscall_seek(fd, pos);
c002d153:	83 ec 08             	sub    $0x8,%esp
c002d156:	ff 74 24 0c          	pushl  0xc(%esp)
c002d15a:	ff 74 24 0c          	pushl  0xc(%esp)
c002d15e:	e8 64 fd ff ff       	call   c002cec7 <syscall_seek>
            break;
c002d163:	83 c4 10             	add    $0x10,%esp
c002d166:	e9 c6 fe ff ff       	jmp    c002d031 <.L126+0x20>

c002d16b <.L117>:
            get_syscall_arg(f, syscall_args, 1);
c002d16b:	89 e2                	mov    %esp,%edx
c002d16d:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d172:	89 f0                	mov    %esi,%eax
c002d174:	e8 20 f7 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_tell(fd);
c002d179:	83 ec 0c             	sub    $0xc,%esp
c002d17c:	ff 74 24 0c          	pushl  0xc(%esp)
c002d180:	e8 b3 fd ff ff       	call   c002cf38 <syscall_tell>
c002d185:	89 46 1c             	mov    %eax,0x1c(%esi)
            break;
c002d188:	83 c4 10             	add    $0x10,%esp
c002d18b:	e9 a1 fe ff ff       	jmp    c002d031 <.L126+0x20>

c002d190 <.L116>:
            get_syscall_arg(f, syscall_args, 1);
c002d190:	89 e2                	mov    %esp,%edx
c002d192:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d197:	89 f0                	mov    %esi,%eax
c002d199:	e8 fb f6 ff ff       	call   c002c899 <get_syscall_arg>
            syscall_close(fd);
c002d19e:	83 ec 0c             	sub    $0xc,%esp
c002d1a1:	ff 74 24 0c          	pushl  0xc(%esp)
c002d1a5:	e8 9c fb ff ff       	call   c002cd46 <syscall_close>
            break;
c002d1aa:	83 c4 10             	add    $0x10,%esp
c002d1ad:	e9 7f fe ff ff       	jmp    c002d031 <.L126+0x20>

c002d1b2 <.L115>:
            get_syscall_arg(f, syscall_args, 2);
c002d1b2:	89 e2                	mov    %esp,%edx
c002d1b4:	b9 02 00 00 00       	mov    $0x2,%ecx
c002d1b9:	89 f0                	mov    %esi,%eax
c002d1bb:	e8 d9 f6 ff ff       	call   c002c899 <get_syscall_arg>
            f->eax = syscall_mmap(fd, addr);
c002d1c0:	c7 46 1c 00 00 00 00 	movl   $0x0,0x1c(%esi)
            break;
c002d1c7:	e9 65 fe ff ff       	jmp    c002d031 <.L126+0x20>

c002d1cc <.L113>:
            get_syscall_arg(f, syscall_args, 1);
c002d1cc:	89 e2                	mov    %esp,%edx
c002d1ce:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d1d3:	89 f0                	mov    %esi,%eax
c002d1d5:	e8 bf f6 ff ff       	call   c002c899 <get_syscall_arg>
            break;
c002d1da:	e9 52 fe ff ff       	jmp    c002d031 <.L126+0x20>
            printf("other system call...\n");
c002d1df:	83 ec 0c             	sub    $0xc,%esp
c002d1e2:	8d 83 db 71 ff ff    	lea    -0x8e25(%ebx),%eax
c002d1e8:	50                   	push   %eax
c002d1e9:	e8 c2 de ff ff       	call   c002b0b0 <puts>
            syscall_exit(-1);
c002d1ee:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c002d1f5:	e8 a7 f5 ff ff       	call   c002c7a1 <syscall_exit>

c002d1fa <get_mmap_info>:
            }
        }
    }
#endif
    return NULL;
}
c002d1fa:	b8 00 00 00 00       	mov    $0x0,%eax
c002d1ff:	c3                   	ret    

c002d200 <mmap_clear>:
    int r = thread_current()->mapid;
    for (int i = 0; i < r; i++) {
        remove_mapid(i);
    }
    #endif
}
c002d200:	c3                   	ret    

c002d201 <syscall_munmap>:
void syscall_munmap (mapid_t mapping) {
#ifdef VM
    //printf("call syscall_munmap");
    remove_mapid(mapping);
#endif
}
c002d201:	c3                   	ret    

c002d202 <syscall_mmap>:

    return mapid;
#else
    return 0;
#endif
c002d202:	b8 00 00 00 00       	mov    $0x0,%eax
c002d207:	c3                   	ret    

c002d208 <gdt_init>:
static uint64_t make_gdtr_operand(uint16_t limit, void *base);

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void
gdt_init(void) {
c002d208:	53                   	push   %ebx
c002d209:	83 ec 18             	sub    $0x18,%esp
c002d20c:	e8 e7 1c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d211:	81 c3 17 df 00 00    	add    $0xdf17,%ebx
    uint64_t gdtr_operand;

    /* Initialize GDT. */
    gdt[SEL_NULL / sizeof *gdt] = 0;
c002d217:	c7 83 f8 1c 00 00 00 	movl   $0x0,0x1cf8(%ebx)
c002d21e:	00 00 00 
c002d221:	c7 83 fc 1c 00 00 00 	movl   $0x0,0x1cfc(%ebx)
c002d228:	00 00 00 
    gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc(0);
c002d22b:	c7 83 00 1d 00 00 ff 	movl   $0xffff,0x1d00(%ebx)
c002d232:	ff 00 00 
c002d235:	c7 83 04 1d 00 00 00 	movl   $0xcf9a00,0x1d04(%ebx)
c002d23c:	9a cf 00 
    gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc(0);
c002d23f:	c7 83 08 1d 00 00 ff 	movl   $0xffff,0x1d08(%ebx)
c002d246:	ff 00 00 
c002d249:	c7 83 0c 1d 00 00 00 	movl   $0xcf9200,0x1d0c(%ebx)
c002d250:	92 cf 00 
    gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc(3);
c002d253:	c7 83 10 1d 00 00 ff 	movl   $0xffff,0x1d10(%ebx)
c002d25a:	ff 00 00 
c002d25d:	c7 83 14 1d 00 00 00 	movl   $0xcffa00,0x1d14(%ebx)
c002d264:	fa cf 00 
    gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc(3);
c002d267:	c7 83 18 1d 00 00 ff 	movl   $0xffff,0x1d18(%ebx)
c002d26e:	ff 00 00 
c002d271:	c7 83 1c 1d 00 00 00 	movl   $0xcff200,0x1d1c(%ebx)
c002d278:	f2 cf 00 
    gdt[SEL_TSS / sizeof *gdt] = make_tss_desc(tss_get());
c002d27b:	e8 59 00 00 00       	call   c002d2d9 <tss_get>
    ASSERT (granularity == GRAN_BYTE || granularity == GRAN_PAGE);

    e0 = ((limit & 0xffff)             /* Limit 15:0. */
          | (base << 16));             /* Base 15:0. */

    e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002d280:	89 c2                	mov    %eax,%edx
c002d282:	c1 ea 10             	shr    $0x10,%edx
c002d285:	0f b6 d2             	movzbl %dl,%edx
          | (dpl << 13)                /* Descriptor privilege. */
          | (1 << 15)                  /* Present. */
          | (limit & 0xf0000)          /* Limit 16:19. */
          | (1 << 22)                  /* 32-bit segment. */
          | (granularity << 23)        /* Byte/page granularity. */
          | (base & 0xff000000));      /* Base 31:24. */
c002d288:	89 c1                	mov    %eax,%ecx
c002d28a:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
    e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002d290:	09 ca                	or     %ecx,%edx
c002d292:	81 ca 00 89 40 00    	or     $0x408900,%edx
          | (base << 16));             /* Base 15:0. */
c002d298:	c1 e0 10             	shl    $0x10,%eax
    e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002d29b:	83 c8 67             	or     $0x67,%eax

    return e0 | ((uint64_t) e1 << 32);
c002d29e:	89 83 20 1d 00 00    	mov    %eax,0x1d20(%ebx)
c002d2a4:	89 93 24 1d 00 00    	mov    %edx,0x1d24(%ebx)

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand(uint16_t limit, void *base) {
    return limit | ((uint64_t) (uint32_t) base << 16);
c002d2aa:	8d 83 f8 1c 00 00    	lea    0x1cf8(%ebx),%eax
c002d2b0:	ba 00 00 00 00       	mov    $0x0,%edx
c002d2b5:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002d2b9:	c1 e0 10             	shl    $0x10,%eax
c002d2bc:	83 c8 2f             	or     $0x2f,%eax
c002d2bf:	89 44 24 08          	mov    %eax,0x8(%esp)
c002d2c3:	89 54 24 0c          	mov    %edx,0xc(%esp)
    asm volatile ("lgdt %0" : : "m" (gdtr_operand));
c002d2c7:	0f 01 54 24 08       	lgdtl  0x8(%esp)
    asm volatile ("ltr %w0" : : "q" (SEL_TSS));
c002d2cc:	b8 28 00 00 00       	mov    $0x28,%eax
c002d2d1:	0f 00 d8             	ltr    %ax
}
c002d2d4:	83 c4 18             	add    $0x18,%esp
c002d2d7:	5b                   	pop    %ebx
c002d2d8:	c3                   	ret    

c002d2d9 <tss_get>:
    tss_update();
}

/* Returns the kernel TSS. */
struct tss *
tss_get(void) {
c002d2d9:	53                   	push   %ebx
c002d2da:	83 ec 08             	sub    $0x8,%esp
c002d2dd:	e8 16 1c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d2e2:	81 c3 46 de 00 00    	add    $0xde46,%ebx
    ASSERT (tss != NULL);
c002d2e8:	8b 83 28 1d 00 00    	mov    0x1d28(%ebx),%eax
c002d2ee:	85 c0                	test   %eax,%eax
c002d2f0:	74 05                	je     c002d2f7 <tss_get+0x1e>
    return tss;
}
c002d2f2:	83 c4 08             	add    $0x8,%esp
c002d2f5:	5b                   	pop    %ebx
c002d2f6:	c3                   	ret    
    ASSERT (tss != NULL);
c002d2f7:	83 ec 0c             	sub    $0xc,%esp
c002d2fa:	8d 83 f0 71 ff ff    	lea    -0x8e10(%ebx),%eax
c002d300:	50                   	push   %eax
c002d301:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002d307:	50                   	push   %eax
c002d308:	8d 83 74 4d ff ff    	lea    -0xb28c(%ebx),%eax
c002d30e:	50                   	push   %eax
c002d30f:	6a 5e                	push   $0x5e
c002d311:	8d 83 fc 71 ff ff    	lea    -0x8e04(%ebx),%eax
c002d317:	50                   	push   %eax
c002d318:	e8 bd bd ff ff       	call   c00290da <debug_panic>

c002d31d <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void
tss_update(void) {
c002d31d:	53                   	push   %ebx
c002d31e:	83 ec 08             	sub    $0x8,%esp
c002d321:	e8 d2 1b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d326:	81 c3 02 de 00 00    	add    $0xde02,%ebx
    ASSERT (tss != NULL);
c002d32c:	83 bb 28 1d 00 00 00 	cmpl   $0x0,0x1d28(%ebx)
c002d333:	74 18                	je     c002d34d <tss_update+0x30>
    tss->esp0 = (uint8_t *) thread_current() + PGSIZE;
c002d335:	e8 3c 3c ff ff       	call   c0020f76 <thread_current>
c002d33a:	8b 93 28 1d 00 00    	mov    0x1d28(%ebx),%edx
c002d340:	05 00 10 00 00       	add    $0x1000,%eax
c002d345:	89 42 04             	mov    %eax,0x4(%edx)
}
c002d348:	83 c4 08             	add    $0x8,%esp
c002d34b:	5b                   	pop    %ebx
c002d34c:	c3                   	ret    
    ASSERT (tss != NULL);
c002d34d:	83 ec 0c             	sub    $0xc,%esp
c002d350:	8d 83 f0 71 ff ff    	lea    -0x8e10(%ebx),%eax
c002d356:	50                   	push   %eax
c002d357:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002d35d:	50                   	push   %eax
c002d35e:	8d 83 68 4d ff ff    	lea    -0xb298(%ebx),%eax
c002d364:	50                   	push   %eax
c002d365:	6a 66                	push   $0x66
c002d367:	8d 83 fc 71 ff ff    	lea    -0x8e04(%ebx),%eax
c002d36d:	50                   	push   %eax
c002d36e:	e8 67 bd ff ff       	call   c00290da <debug_panic>

c002d373 <tss_init>:
tss_init(void) {
c002d373:	53                   	push   %ebx
c002d374:	83 ec 14             	sub    $0x14,%esp
c002d377:	e8 7c 1b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d37c:	81 c3 ac dd 00 00    	add    $0xddac,%ebx
    tss = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c002d382:	6a 03                	push   $0x3
c002d384:	e8 60 66 ff ff       	call   c00239e9 <palloc_get_page>
c002d389:	89 83 28 1d 00 00    	mov    %eax,0x1d28(%ebx)
    tss->ss0 = SEL_KDSEG;
c002d38f:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
    tss->bitmap = 0xdfff;
c002d395:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
    tss_update();
c002d39b:	e8 7d ff ff ff       	call   c002d31d <tss_update>
}
c002d3a0:	83 c4 18             	add    $0x18,%esp
c002d3a3:	5b                   	pop    %ebx
c002d3a4:	c3                   	ret    

c002d3a5 <filesys_init>:
static void do_format(void);

/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void
filesys_init(bool format) {
c002d3a5:	56                   	push   %esi
c002d3a6:	53                   	push   %ebx
c002d3a7:	83 ec 10             	sub    $0x10,%esp
c002d3aa:	e8 49 1b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d3af:	81 c3 79 dd 00 00    	add    $0xdd79,%ebx
c002d3b5:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    fs_device = block_get_role(BLOCK_FILESYS);
c002d3b9:	6a 01                	push   $0x1
c002d3bb:	e8 1a 7d ff ff       	call   c00250da <block_get_role>
c002d3c0:	c7 c2 84 d0 03 c0    	mov    $0xc003d084,%edx
c002d3c6:	89 02                	mov    %eax,(%edx)
    if (fs_device == NULL)
c002d3c8:	83 c4 10             	add    $0x10,%esp
c002d3cb:	85 c0                	test   %eax,%eax
c002d3cd:	74 1b                	je     c002d3ea <filesys_init+0x45>
        PANIC ("No file system device found, can't initialize file system.");

    inode_init();
c002d3cf:	e8 79 0d 00 00       	call   c002e14d <inode_init>
    free_map_init();
c002d3d4:	e8 d5 01 00 00       	call   c002d5ae <free_map_init>

    if (format)
c002d3d9:	89 f0                	mov    %esi,%eax
c002d3db:	84 c0                	test   %al,%al
c002d3dd:	75 27                	jne    c002d406 <filesys_init+0x61>
        do_format();

    free_map_open();
c002d3df:	e8 29 03 00 00       	call   c002d70d <free_map_open>
}
c002d3e4:	83 c4 04             	add    $0x4,%esp
c002d3e7:	5b                   	pop    %ebx
c002d3e8:	5e                   	pop    %esi
c002d3e9:	c3                   	ret    
        PANIC ("No file system device found, can't initialize file system.");
c002d3ea:	8d 83 14 72 ff ff    	lea    -0x8dec(%ebx),%eax
c002d3f0:	50                   	push   %eax
c002d3f1:	8d 83 88 4d ff ff    	lea    -0xb278(%ebx),%eax
c002d3f7:	50                   	push   %eax
c002d3f8:	6a 16                	push   $0x16
c002d3fa:	8d 83 6f 72 ff ff    	lea    -0x8d91(%ebx),%eax
c002d400:	50                   	push   %eax
c002d401:	e8 d4 bc ff ff       	call   c00290da <debug_panic>
}

/* Formats the file system. */
static void
do_format(void) {
    printf("Formatting file system...");
c002d406:	83 ec 0c             	sub    $0xc,%esp
c002d409:	8d 83 87 72 ff ff    	lea    -0x8d79(%ebx),%eax
c002d40f:	50                   	push   %eax
c002d410:	e8 69 a0 ff ff       	call   c002747e <printf>
    free_map_create();
c002d415:	e8 90 03 00 00       	call   c002d7aa <free_map_create>
    if (!dir_create(ROOT_DIR_SECTOR, 16))
c002d41a:	83 c4 08             	add    $0x8,%esp
c002d41d:	6a 10                	push   $0x10
c002d41f:	6a 01                	push   $0x1
c002d421:	e8 91 08 00 00       	call   c002dcb7 <dir_create>
c002d426:	83 c4 10             	add    $0x10,%esp
c002d429:	84 c0                	test   %al,%al
c002d42b:	74 19                	je     c002d446 <filesys_init+0xa1>
        PANIC ("root directory creation failed");
    free_map_close();
c002d42d:	e8 59 03 00 00       	call   c002d78b <free_map_close>
    printf("done.\n");
c002d432:	83 ec 0c             	sub    $0xc,%esp
c002d435:	8d 83 35 5b ff ff    	lea    -0xa4cb(%ebx),%eax
c002d43b:	50                   	push   %eax
c002d43c:	e8 6f dc ff ff       	call   c002b0b0 <puts>
c002d441:	83 c4 10             	add    $0x10,%esp
c002d444:	eb 99                	jmp    c002d3df <filesys_init+0x3a>
        PANIC ("root directory creation failed");
c002d446:	8d 83 50 72 ff ff    	lea    -0x8db0(%ebx),%eax
c002d44c:	50                   	push   %eax
c002d44d:	8d 83 7c 4d ff ff    	lea    -0xb284(%ebx),%eax
c002d453:	50                   	push   %eax
c002d454:	6a 5f                	push   $0x5f
c002d456:	8d 83 6f 72 ff ff    	lea    -0x8d91(%ebx),%eax
c002d45c:	50                   	push   %eax
c002d45d:	e8 78 bc ff ff       	call   c00290da <debug_panic>

c002d462 <filesys_done>:
filesys_done(void) {
c002d462:	53                   	push   %ebx
c002d463:	83 ec 08             	sub    $0x8,%esp
c002d466:	e8 8d 1a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d46b:	81 c3 bd dc 00 00    	add    $0xdcbd,%ebx
    free_map_close();
c002d471:	e8 15 03 00 00       	call   c002d78b <free_map_close>
}
c002d476:	83 c4 08             	add    $0x8,%esp
c002d479:	5b                   	pop    %ebx
c002d47a:	c3                   	ret    

c002d47b <filesys_create>:
filesys_create(const char *name, off_t initial_size) {
c002d47b:	57                   	push   %edi
c002d47c:	56                   	push   %esi
c002d47d:	53                   	push   %ebx
c002d47e:	83 ec 10             	sub    $0x10,%esp
c002d481:	e8 72 1a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d486:	81 c3 a2 dc 00 00    	add    $0xdca2,%ebx
    block_sector_t inode_sector = 0;
c002d48c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d493:	00 
    struct dir *dir = dir_open_root();
c002d494:	e8 9b 08 00 00       	call   c002dd34 <dir_open_root>
c002d499:	89 c6                	mov    %eax,%esi
                    && dir_add(dir, name, inode_sector));
c002d49b:	85 c0                	test   %eax,%eax
c002d49d:	74 16                	je     c002d4b5 <filesys_create+0x3a>
                    && free_map_allocate(1, &inode_sector)
c002d49f:	83 ec 08             	sub    $0x8,%esp
c002d4a2:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d4a6:	50                   	push   %eax
c002d4a7:	6a 01                	push   $0x1
c002d4a9:	e8 6d 01 00 00       	call   c002d61b <free_map_allocate>
c002d4ae:	83 c4 10             	add    $0x10,%esp
c002d4b1:	84 c0                	test   %al,%al
c002d4b3:	75 1d                	jne    c002d4d2 <filesys_create+0x57>
    if (!success && inode_sector != 0)
c002d4b5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d4b9:	bf 00 00 00 00       	mov    $0x0,%edi
c002d4be:	85 c0                	test   %eax,%eax
c002d4c0:	74 41                	je     c002d503 <filesys_create+0x88>
        free_map_release(inode_sector, 1);
c002d4c2:	83 ec 08             	sub    $0x8,%esp
c002d4c5:	6a 01                	push   $0x1
c002d4c7:	50                   	push   %eax
c002d4c8:	e8 c3 01 00 00       	call   c002d690 <free_map_release>
c002d4cd:	83 c4 10             	add    $0x10,%esp
c002d4d0:	eb 31                	jmp    c002d503 <filesys_create+0x88>
                    && inode_create(inode_sector, initial_size)
c002d4d2:	83 ec 08             	sub    $0x8,%esp
c002d4d5:	ff 74 24 2c          	pushl  0x2c(%esp)
c002d4d9:	ff 74 24 18          	pushl  0x18(%esp)
c002d4dd:	e8 8b 0c 00 00       	call   c002e16d <inode_create>
c002d4e2:	83 c4 10             	add    $0x10,%esp
c002d4e5:	84 c0                	test   %al,%al
c002d4e7:	74 cc                	je     c002d4b5 <filesys_create+0x3a>
                    && dir_add(dir, name, inode_sector));
c002d4e9:	83 ec 04             	sub    $0x4,%esp
c002d4ec:	ff 74 24 10          	pushl  0x10(%esp)
c002d4f0:	ff 74 24 28          	pushl  0x28(%esp)
c002d4f4:	56                   	push   %esi
c002d4f5:	e8 68 09 00 00       	call   c002de62 <dir_add>
c002d4fa:	89 c7                	mov    %eax,%edi
    if (!success && inode_sector != 0)
c002d4fc:	83 c4 10             	add    $0x10,%esp
c002d4ff:	84 c0                	test   %al,%al
c002d501:	74 b2                	je     c002d4b5 <filesys_create+0x3a>
    dir_close(dir);
c002d503:	83 ec 0c             	sub    $0xc,%esp
c002d506:	56                   	push   %esi
c002d507:	e8 72 08 00 00       	call   c002dd7e <dir_close>
}
c002d50c:	89 f8                	mov    %edi,%eax
c002d50e:	83 c4 20             	add    $0x20,%esp
c002d511:	5b                   	pop    %ebx
c002d512:	5e                   	pop    %esi
c002d513:	5f                   	pop    %edi
c002d514:	c3                   	ret    

c002d515 <filesys_open>:
filesys_open(const char *name) {
c002d515:	56                   	push   %esi
c002d516:	53                   	push   %ebx
c002d517:	83 ec 14             	sub    $0x14,%esp
c002d51a:	e8 d9 19 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d51f:	81 c3 09 dc 00 00    	add    $0xdc09,%ebx
    struct dir *dir = dir_open_root();
c002d525:	e8 0a 08 00 00       	call   c002dd34 <dir_open_root>
c002d52a:	89 c6                	mov    %eax,%esi
    struct inode *inode = NULL;
c002d52c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d533:	00 
    if (dir != NULL)
c002d534:	85 c0                	test   %eax,%eax
c002d536:	74 15                	je     c002d54d <filesys_open+0x38>
        dir_lookup(dir, name, &inode);
c002d538:	83 ec 04             	sub    $0x4,%esp
c002d53b:	8d 44 24 10          	lea    0x10(%esp),%eax
c002d53f:	50                   	push   %eax
c002d540:	ff 74 24 28          	pushl  0x28(%esp)
c002d544:	56                   	push   %esi
c002d545:	e8 6e 08 00 00       	call   c002ddb8 <dir_lookup>
c002d54a:	83 c4 10             	add    $0x10,%esp
    dir_close(dir);
c002d54d:	83 ec 0c             	sub    $0xc,%esp
c002d550:	56                   	push   %esi
c002d551:	e8 28 08 00 00       	call   c002dd7e <dir_close>
    return file_open(inode);
c002d556:	83 c4 04             	add    $0x4,%esp
c002d559:	ff 74 24 18          	pushl  0x18(%esp)
c002d55d:	e8 02 03 00 00       	call   c002d864 <file_open>
}
c002d562:	83 c4 24             	add    $0x24,%esp
c002d565:	5b                   	pop    %ebx
c002d566:	5e                   	pop    %esi
c002d567:	c3                   	ret    

c002d568 <filesys_remove>:
filesys_remove(const char *name) {
c002d568:	57                   	push   %edi
c002d569:	56                   	push   %esi
c002d56a:	53                   	push   %ebx
c002d56b:	e8 88 19 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d570:	81 c3 b8 db 00 00    	add    $0xdbb8,%ebx
    struct dir *dir = dir_open_root();
c002d576:	e8 b9 07 00 00       	call   c002dd34 <dir_open_root>
c002d57b:	89 c7                	mov    %eax,%edi
    bool success = dir != NULL && dir_remove(dir, name);
c002d57d:	be 00 00 00 00       	mov    $0x0,%esi
c002d582:	85 c0                	test   %eax,%eax
c002d584:	74 13                	je     c002d599 <filesys_remove+0x31>
c002d586:	83 ec 08             	sub    $0x8,%esp
c002d589:	ff 74 24 18          	pushl  0x18(%esp)
c002d58d:	50                   	push   %eax
c002d58e:	e8 f9 09 00 00       	call   c002df8c <dir_remove>
c002d593:	0f b6 f0             	movzbl %al,%esi
c002d596:	83 c4 10             	add    $0x10,%esp
    dir_close(dir);
c002d599:	83 ec 0c             	sub    $0xc,%esp
c002d59c:	57                   	push   %edi
c002d59d:	e8 dc 07 00 00       	call   c002dd7e <dir_close>
    bool success = dir != NULL && dir_remove(dir, name);
c002d5a2:	89 f0                	mov    %esi,%eax
c002d5a4:	83 e0 01             	and    $0x1,%eax
    return success;
c002d5a7:	83 c4 10             	add    $0x10,%esp
}
c002d5aa:	5b                   	pop    %ebx
c002d5ab:	5e                   	pop    %esi
c002d5ac:	5f                   	pop    %edi
c002d5ad:	c3                   	ret    

c002d5ae <free_map_init>:
static struct file *free_map_file;   /* Free map file. */
static struct bitmap *free_map;      /* Free map, one bit per sector. */

/* Initializes the free map. */
void
free_map_init(void) {
c002d5ae:	53                   	push   %ebx
c002d5af:	83 ec 14             	sub    $0x14,%esp
c002d5b2:	e8 41 19 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d5b7:	81 c3 71 db 00 00    	add    $0xdb71,%ebx
    free_map = bitmap_create(block_size(fs_device));
c002d5bd:	c7 c0 84 d0 03 c0    	mov    $0xc003d084,%eax
c002d5c3:	ff 30                	pushl  (%eax)
c002d5c5:	e8 2f 7d ff ff       	call   c00252f9 <block_size>
c002d5ca:	89 04 24             	mov    %eax,(%esp)
c002d5cd:	e8 ab cc ff ff       	call   c002a27d <bitmap_create>
c002d5d2:	89 83 2c 1d 00 00    	mov    %eax,0x1d2c(%ebx)
    if (free_map == NULL)
c002d5d8:	83 c4 10             	add    $0x10,%esp
c002d5db:	85 c0                	test   %eax,%eax
c002d5dd:	74 20                	je     c002d5ff <free_map_init+0x51>
        PANIC ("bitmap creation failed--file system device is too large");
    bitmap_mark(free_map, FREE_MAP_SECTOR);
c002d5df:	83 ec 08             	sub    $0x8,%esp
c002d5e2:	6a 00                	push   $0x0
c002d5e4:	50                   	push   %eax
c002d5e5:	e8 e5 c9 ff ff       	call   c0029fcf <bitmap_mark>
    bitmap_mark(free_map, ROOT_DIR_SECTOR);
c002d5ea:	83 c4 08             	add    $0x8,%esp
c002d5ed:	6a 01                	push   $0x1
c002d5ef:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d5f5:	e8 d5 c9 ff ff       	call   c0029fcf <bitmap_mark>
}
c002d5fa:	83 c4 18             	add    $0x18,%esp
c002d5fd:	5b                   	pop    %ebx
c002d5fe:	c3                   	ret    
        PANIC ("bitmap creation failed--file system device is too large");
c002d5ff:	8d 83 a4 72 ff ff    	lea    -0x8d5c(%ebx),%eax
c002d605:	50                   	push   %eax
c002d606:	8d 83 cc 4d ff ff    	lea    -0xb234(%ebx),%eax
c002d60c:	50                   	push   %eax
c002d60d:	6a 10                	push   $0x10
c002d60f:	8d 83 fe 72 ff ff    	lea    -0x8d02(%ebx),%eax
c002d615:	50                   	push   %eax
c002d616:	e8 bf ba ff ff       	call   c00290da <debug_panic>

c002d61b <free_map_allocate>:
   the first into *SECTORP.
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool
free_map_allocate(size_t cnt, block_sector_t *sectorp) {
c002d61b:	57                   	push   %edi
c002d61c:	56                   	push   %esi
c002d61d:	53                   	push   %ebx
c002d61e:	e8 d5 18 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d623:	81 c3 05 db 00 00    	add    $0xdb05,%ebx
c002d629:	8b 7c 24 10          	mov    0x10(%esp),%edi
    block_sector_t sector = bitmap_scan_and_flip(free_map, 0, cnt, false);
c002d62d:	6a 00                	push   $0x0
c002d62f:	57                   	push   %edi
c002d630:	6a 00                	push   $0x0
c002d632:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d638:	e8 1b d0 ff ff       	call   c002a658 <bitmap_scan_and_flip>
c002d63d:	89 c6                	mov    %eax,%esi
    if (sector != BITMAP_ERROR
c002d63f:	83 c4 10             	add    $0x10,%esp
c002d642:	83 f8 ff             	cmp    $0xffffffff,%eax
c002d645:	74 26                	je     c002d66d <free_map_allocate+0x52>
        && free_map_file != NULL
c002d647:	8b 83 30 1d 00 00    	mov    0x1d30(%ebx),%eax
c002d64d:	85 c0                	test   %eax,%eax
c002d64f:	74 16                	je     c002d667 <free_map_allocate+0x4c>
        && !bitmap_write(free_map, free_map_file)) {
c002d651:	83 ec 08             	sub    $0x8,%esp
c002d654:	50                   	push   %eax
c002d655:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d65b:	e8 be d0 ff ff       	call   c002a71e <bitmap_write>
c002d660:	83 c4 10             	add    $0x10,%esp
c002d663:	84 c0                	test   %al,%al
c002d665:	74 10                	je     c002d677 <free_map_allocate+0x5c>
        bitmap_set_multiple(free_map, sector, cnt, false);
        sector = BITMAP_ERROR;
    }
    if (sector != BITMAP_ERROR)
        *sectorp = sector;
c002d667:	8b 44 24 14          	mov    0x14(%esp),%eax
c002d66b:	89 30                	mov    %esi,(%eax)
    return sector != BITMAP_ERROR;
c002d66d:	83 fe ff             	cmp    $0xffffffff,%esi
c002d670:	0f 95 c0             	setne  %al
}
c002d673:	5b                   	pop    %ebx
c002d674:	5e                   	pop    %esi
c002d675:	5f                   	pop    %edi
c002d676:	c3                   	ret    
        bitmap_set_multiple(free_map, sector, cnt, false);
c002d677:	6a 00                	push   $0x0
c002d679:	57                   	push   %edi
c002d67a:	56                   	push   %esi
c002d67b:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d681:	e8 c7 ca ff ff       	call   c002a14d <bitmap_set_multiple>
c002d686:	83 c4 10             	add    $0x10,%esp
        sector = BITMAP_ERROR;
c002d689:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002d68e:	eb dd                	jmp    c002d66d <free_map_allocate+0x52>

c002d690 <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void
free_map_release(block_sector_t sector, size_t cnt) {
c002d690:	57                   	push   %edi
c002d691:	56                   	push   %esi
c002d692:	53                   	push   %ebx
c002d693:	e8 60 18 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d698:	81 c3 90 da 00 00    	add    $0xda90,%ebx
c002d69e:	8b 74 24 10          	mov    0x10(%esp),%esi
c002d6a2:	8b 7c 24 14          	mov    0x14(%esp),%edi
    ASSERT (bitmap_all(free_map, sector, cnt));
c002d6a6:	83 ec 04             	sub    $0x4,%esp
c002d6a9:	57                   	push   %edi
c002d6aa:	56                   	push   %esi
c002d6ab:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d6b1:	e8 b5 ce ff ff       	call   c002a56b <bitmap_all>
c002d6b6:	83 c4 10             	add    $0x10,%esp
c002d6b9:	84 c0                	test   %al,%al
c002d6bb:	74 2a                	je     c002d6e7 <free_map_release+0x57>
    bitmap_set_multiple(free_map, sector, cnt, false);
c002d6bd:	6a 00                	push   $0x0
c002d6bf:	57                   	push   %edi
c002d6c0:	56                   	push   %esi
c002d6c1:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d6c7:	e8 81 ca ff ff       	call   c002a14d <bitmap_set_multiple>
    bitmap_write(free_map, free_map_file);
c002d6cc:	83 c4 08             	add    $0x8,%esp
c002d6cf:	ff b3 30 1d 00 00    	pushl  0x1d30(%ebx)
c002d6d5:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d6db:	e8 3e d0 ff ff       	call   c002a71e <bitmap_write>
}
c002d6e0:	83 c4 10             	add    $0x10,%esp
c002d6e3:	5b                   	pop    %ebx
c002d6e4:	5e                   	pop    %esi
c002d6e5:	5f                   	pop    %edi
c002d6e6:	c3                   	ret    
    ASSERT (bitmap_all(free_map, sector, cnt));
c002d6e7:	83 ec 0c             	sub    $0xc,%esp
c002d6ea:	8d 83 dc 72 ff ff    	lea    -0x8d24(%ebx),%eax
c002d6f0:	50                   	push   %eax
c002d6f1:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002d6f7:	50                   	push   %eax
c002d6f8:	8d 83 b8 4d ff ff    	lea    -0xb248(%ebx),%eax
c002d6fe:	50                   	push   %eax
c002d6ff:	6a 2b                	push   $0x2b
c002d701:	8d 83 fe 72 ff ff    	lea    -0x8d02(%ebx),%eax
c002d707:	50                   	push   %eax
c002d708:	e8 cd b9 ff ff       	call   c00290da <debug_panic>

c002d70d <free_map_open>:

/* Opens the free map file and reads it from disk. */
void
free_map_open(void) {
c002d70d:	53                   	push   %ebx
c002d70e:	83 ec 14             	sub    $0x14,%esp
c002d711:	e8 e2 17 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d716:	81 c3 12 da 00 00    	add    $0xda12,%ebx
    free_map_file = file_open(inode_open(FREE_MAP_SECTOR));
c002d71c:	6a 00                	push   $0x0
c002d71e:	e8 59 0b 00 00       	call   c002e27c <inode_open>
c002d723:	89 04 24             	mov    %eax,(%esp)
c002d726:	e8 39 01 00 00       	call   c002d864 <file_open>
c002d72b:	89 83 30 1d 00 00    	mov    %eax,0x1d30(%ebx)
    if (free_map_file == NULL)
c002d731:	83 c4 10             	add    $0x10,%esp
c002d734:	85 c0                	test   %eax,%eax
c002d736:	74 1b                	je     c002d753 <free_map_open+0x46>
        PANIC ("can't open free map");
    if (!bitmap_read(free_map, free_map_file))
c002d738:	83 ec 08             	sub    $0x8,%esp
c002d73b:	50                   	push   %eax
c002d73c:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d742:	e8 6b cf ff ff       	call   c002a6b2 <bitmap_read>
c002d747:	83 c4 10             	add    $0x10,%esp
c002d74a:	84 c0                	test   %al,%al
c002d74c:	74 21                	je     c002d76f <free_map_open+0x62>
        PANIC ("can't read free map");
}
c002d74e:	83 c4 08             	add    $0x8,%esp
c002d751:	5b                   	pop    %ebx
c002d752:	c3                   	ret    
        PANIC ("can't open free map");
c002d753:	8d 83 17 73 ff ff    	lea    -0x8ce9(%ebx),%eax
c002d759:	50                   	push   %eax
c002d75a:	8d 83 a8 4d ff ff    	lea    -0xb258(%ebx),%eax
c002d760:	50                   	push   %eax
c002d761:	6a 35                	push   $0x35
c002d763:	8d 83 fe 72 ff ff    	lea    -0x8d02(%ebx),%eax
c002d769:	50                   	push   %eax
c002d76a:	e8 6b b9 ff ff       	call   c00290da <debug_panic>
        PANIC ("can't read free map");
c002d76f:	8d 83 2b 73 ff ff    	lea    -0x8cd5(%ebx),%eax
c002d775:	50                   	push   %eax
c002d776:	8d 83 a8 4d ff ff    	lea    -0xb258(%ebx),%eax
c002d77c:	50                   	push   %eax
c002d77d:	6a 37                	push   $0x37
c002d77f:	8d 83 fe 72 ff ff    	lea    -0x8d02(%ebx),%eax
c002d785:	50                   	push   %eax
c002d786:	e8 4f b9 ff ff       	call   c00290da <debug_panic>

c002d78b <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void
free_map_close(void) {
c002d78b:	53                   	push   %ebx
c002d78c:	83 ec 14             	sub    $0x14,%esp
c002d78f:	e8 64 17 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d794:	81 c3 94 d9 00 00    	add    $0xd994,%ebx
    file_close(free_map_file);
c002d79a:	ff b3 30 1d 00 00    	pushl  0x1d30(%ebx)
c002d7a0:	e8 b0 02 00 00       	call   c002da55 <file_close>
}
c002d7a5:	83 c4 18             	add    $0x18,%esp
c002d7a8:	5b                   	pop    %ebx
c002d7a9:	c3                   	ret    

c002d7aa <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void
free_map_create(void) {
c002d7aa:	53                   	push   %ebx
c002d7ab:	83 ec 14             	sub    $0x14,%esp
c002d7ae:	e8 45 17 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d7b3:	81 c3 75 d9 00 00    	add    $0xd975,%ebx
    /* Create inode. */
    if (!inode_create(FREE_MAP_SECTOR, bitmap_file_size(free_map)))
c002d7b9:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d7bf:	e8 de ce ff ff       	call   c002a6a2 <bitmap_file_size>
c002d7c4:	83 c4 08             	add    $0x8,%esp
c002d7c7:	50                   	push   %eax
c002d7c8:	6a 00                	push   $0x0
c002d7ca:	e8 9e 09 00 00       	call   c002e16d <inode_create>
c002d7cf:	83 c4 10             	add    $0x10,%esp
c002d7d2:	84 c0                	test   %al,%al
c002d7d4:	74 3a                	je     c002d810 <free_map_create+0x66>
        PANIC ("free map creation failed");

    /* Write bitmap to file. */
    free_map_file = file_open(inode_open(FREE_MAP_SECTOR));
c002d7d6:	83 ec 0c             	sub    $0xc,%esp
c002d7d9:	6a 00                	push   $0x0
c002d7db:	e8 9c 0a 00 00       	call   c002e27c <inode_open>
c002d7e0:	89 04 24             	mov    %eax,(%esp)
c002d7e3:	e8 7c 00 00 00       	call   c002d864 <file_open>
c002d7e8:	89 83 30 1d 00 00    	mov    %eax,0x1d30(%ebx)
    if (free_map_file == NULL)
c002d7ee:	83 c4 10             	add    $0x10,%esp
c002d7f1:	85 c0                	test   %eax,%eax
c002d7f3:	74 37                	je     c002d82c <free_map_create+0x82>
        PANIC ("can't open free map");
    if (!bitmap_write(free_map, free_map_file))
c002d7f5:	83 ec 08             	sub    $0x8,%esp
c002d7f8:	50                   	push   %eax
c002d7f9:	ff b3 2c 1d 00 00    	pushl  0x1d2c(%ebx)
c002d7ff:	e8 1a cf ff ff       	call   c002a71e <bitmap_write>
c002d804:	83 c4 10             	add    $0x10,%esp
c002d807:	84 c0                	test   %al,%al
c002d809:	74 3d                	je     c002d848 <free_map_create+0x9e>
        PANIC ("can't write free map");
}
c002d80b:	83 c4 08             	add    $0x8,%esp
c002d80e:	5b                   	pop    %ebx
c002d80f:	c3                   	ret    
        PANIC ("free map creation failed");
c002d810:	8d 83 3f 73 ff ff    	lea    -0x8cc1(%ebx),%eax
c002d816:	50                   	push   %eax
c002d817:	8d 83 98 4d ff ff    	lea    -0xb268(%ebx),%eax
c002d81d:	50                   	push   %eax
c002d81e:	6a 46                	push   $0x46
c002d820:	8d 83 fe 72 ff ff    	lea    -0x8d02(%ebx),%eax
c002d826:	50                   	push   %eax
c002d827:	e8 ae b8 ff ff       	call   c00290da <debug_panic>
        PANIC ("can't open free map");
c002d82c:	8d 83 17 73 ff ff    	lea    -0x8ce9(%ebx),%eax
c002d832:	50                   	push   %eax
c002d833:	8d 83 98 4d ff ff    	lea    -0xb268(%ebx),%eax
c002d839:	50                   	push   %eax
c002d83a:	6a 4b                	push   $0x4b
c002d83c:	8d 83 fe 72 ff ff    	lea    -0x8d02(%ebx),%eax
c002d842:	50                   	push   %eax
c002d843:	e8 92 b8 ff ff       	call   c00290da <debug_panic>
        PANIC ("can't write free map");
c002d848:	8d 83 58 73 ff ff    	lea    -0x8ca8(%ebx),%eax
c002d84e:	50                   	push   %eax
c002d84f:	8d 83 98 4d ff ff    	lea    -0xb268(%ebx),%eax
c002d855:	50                   	push   %eax
c002d856:	6a 4d                	push   $0x4d
c002d858:	8d 83 fe 72 ff ff    	lea    -0x8d02(%ebx),%eax
c002d85e:	50                   	push   %eax
c002d85f:	e8 76 b8 ff ff       	call   c00290da <debug_panic>

c002d864 <file_open>:

/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open(struct inode *inode) {
c002d864:	57                   	push   %edi
c002d865:	56                   	push   %esi
c002d866:	53                   	push   %ebx
c002d867:	e8 8c 16 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d86c:	81 c3 bc d8 00 00    	add    $0xd8bc,%ebx
c002d872:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct file *file = calloc(1, sizeof *file);
c002d876:	83 ec 08             	sub    $0x8,%esp
c002d879:	6a 0c                	push   $0xc
c002d87b:	6a 01                	push   $0x1
c002d87d:	e8 d6 66 ff ff       	call   c0023f58 <calloc>
c002d882:	89 c6                	mov    %eax,%esi
    if (inode != NULL && file != NULL) {
c002d884:	83 c4 10             	add    $0x10,%esp
c002d887:	85 ff                	test   %edi,%edi
c002d889:	74 17                	je     c002d8a2 <file_open+0x3e>
c002d88b:	85 c0                	test   %eax,%eax
c002d88d:	74 13                	je     c002d8a2 <file_open+0x3e>
        file->inode = inode;
c002d88f:	89 38                	mov    %edi,(%eax)
        file->pos = 0;
c002d891:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        file->deny_write = false;
c002d898:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    } else {
        inode_close(inode);
        free(file);
        return NULL;
    }
}
c002d89c:	89 f0                	mov    %esi,%eax
c002d89e:	5b                   	pop    %ebx
c002d89f:	5e                   	pop    %esi
c002d8a0:	5f                   	pop    %edi
c002d8a1:	c3                   	ret    
        inode_close(inode);
c002d8a2:	83 ec 0c             	sub    $0xc,%esp
c002d8a5:	57                   	push   %edi
c002d8a6:	e8 96 0a 00 00       	call   c002e341 <inode_close>
        free(file);
c002d8ab:	89 34 24             	mov    %esi,(%esp)
c002d8ae:	e8 f6 66 ff ff       	call   c0023fa9 <free>
        return NULL;
c002d8b3:	83 c4 10             	add    $0x10,%esp
c002d8b6:	be 00 00 00 00       	mov    $0x0,%esi
c002d8bb:	eb df                	jmp    c002d89c <file_open+0x38>

c002d8bd <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen(struct file *file) {
c002d8bd:	53                   	push   %ebx
c002d8be:	83 ec 14             	sub    $0x14,%esp
c002d8c1:	e8 32 16 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d8c6:	81 c3 62 d8 00 00    	add    $0xd862,%ebx
    return file_open(inode_reopen(file->inode));
c002d8cc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d8d0:	ff 30                	pushl  (%eax)
c002d8d2:	e8 98 09 00 00       	call   c002e26f <inode_reopen>
c002d8d7:	89 04 24             	mov    %eax,(%esp)
c002d8da:	e8 85 ff ff ff       	call   c002d864 <file_open>
}
c002d8df:	83 c4 18             	add    $0x18,%esp
c002d8e2:	5b                   	pop    %ebx
c002d8e3:	c3                   	ret    

c002d8e4 <file_get_inode>:
}

/* Returns the inode encapsulated by FILE. */
struct inode *
file_get_inode(struct file *file) {
    return file->inode;
c002d8e4:	8b 44 24 04          	mov    0x4(%esp),%eax
c002d8e8:	8b 00                	mov    (%eax),%eax
}
c002d8ea:	c3                   	ret    

c002d8eb <file_read>:
   starting at the file's current position.
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   Advances FILE's position by the number of bytes read. */
off_t
file_read(struct file *file, void *buffer, off_t size) {
c002d8eb:	56                   	push   %esi
c002d8ec:	53                   	push   %ebx
c002d8ed:	83 ec 04             	sub    $0x4,%esp
c002d8f0:	e8 03 16 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d8f5:	81 c3 33 d8 00 00    	add    $0xd833,%ebx
c002d8fb:	8b 74 24 10          	mov    0x10(%esp),%esi
    off_t bytes_read = inode_read_at(file->inode, buffer, size, file->pos);
c002d8ff:	ff 76 04             	pushl  0x4(%esi)
c002d902:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d906:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d90a:	ff 36                	pushl  (%esi)
c002d90c:	e8 f7 0a 00 00       	call   c002e408 <inode_read_at>
    file->pos += bytes_read;
c002d911:	01 46 04             	add    %eax,0x4(%esi)
    return bytes_read;
}
c002d914:	83 c4 14             	add    $0x14,%esp
c002d917:	5b                   	pop    %ebx
c002d918:	5e                   	pop    %esi
c002d919:	c3                   	ret    

c002d91a <file_read_at>:
   starting at offset FILE_OFS in the file.
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   The file's current position is unaffected. */
off_t
file_read_at(struct file *file, void *buffer, off_t size, off_t file_ofs) {
c002d91a:	53                   	push   %ebx
c002d91b:	83 ec 08             	sub    $0x8,%esp
c002d91e:	e8 d5 15 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d923:	81 c3 05 d8 00 00    	add    $0xd805,%ebx
    return inode_read_at(file->inode, buffer, size, file_ofs);
c002d929:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d92d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d931:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d935:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d939:	ff 30                	pushl  (%eax)
c002d93b:	e8 c8 0a 00 00       	call   c002e408 <inode_read_at>
}
c002d940:	83 c4 18             	add    $0x18,%esp
c002d943:	5b                   	pop    %ebx
c002d944:	c3                   	ret    

c002d945 <file_write>:
   which may be less than SIZE if end of file is reached.
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   Advances FILE's position by the number of bytes read. */
off_t
file_write(struct file *file, const void *buffer, off_t size) {
c002d945:	56                   	push   %esi
c002d946:	53                   	push   %ebx
c002d947:	83 ec 04             	sub    $0x4,%esp
c002d94a:	e8 a9 15 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d94f:	81 c3 d9 d7 00 00    	add    $0xd7d9,%ebx
c002d955:	8b 74 24 10          	mov    0x10(%esp),%esi
    off_t bytes_written = inode_write_at(file->inode, buffer, size, file->pos);
c002d959:	ff 76 04             	pushl  0x4(%esi)
c002d95c:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d960:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d964:	ff 36                	pushl  (%esi)
c002d966:	e8 24 0c 00 00       	call   c002e58f <inode_write_at>
    file->pos += bytes_written;
c002d96b:	01 46 04             	add    %eax,0x4(%esi)
    return bytes_written;
}
c002d96e:	83 c4 14             	add    $0x14,%esp
c002d971:	5b                   	pop    %ebx
c002d972:	5e                   	pop    %esi
c002d973:	c3                   	ret    

c002d974 <file_write_at>:
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   The file's current position is unaffected. */
off_t
file_write_at(struct file *file, const void *buffer, off_t size,
              off_t file_ofs) {
c002d974:	53                   	push   %ebx
c002d975:	83 ec 08             	sub    $0x8,%esp
c002d978:	e8 7b 15 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d97d:	81 c3 ab d7 00 00    	add    $0xd7ab,%ebx
    return inode_write_at(file->inode, buffer, size, file_ofs);
c002d983:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d987:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d98b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d98f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d993:	ff 30                	pushl  (%eax)
c002d995:	e8 f5 0b 00 00       	call   c002e58f <inode_write_at>
}
c002d99a:	83 c4 18             	add    $0x18,%esp
c002d99d:	5b                   	pop    %ebx
c002d99e:	c3                   	ret    

c002d99f <file_deny_write>:

/* Prevents write operations on FILE's underlying inode
   until file_allow_write() is called or FILE is closed. */
void
file_deny_write(struct file *file) {
c002d99f:	53                   	push   %ebx
c002d9a0:	83 ec 08             	sub    $0x8,%esp
c002d9a3:	e8 50 15 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002d9a8:	81 c3 80 d7 00 00    	add    $0xd780,%ebx
c002d9ae:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002d9b2:	85 c0                	test   %eax,%eax
c002d9b4:	74 0b                	je     c002d9c1 <file_deny_write+0x22>
    if (!file->deny_write) {
c002d9b6:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002d9ba:	74 2b                	je     c002d9e7 <file_deny_write+0x48>
        file->deny_write = true;
        inode_deny_write(file->inode);
    }
}
c002d9bc:	83 c4 08             	add    $0x8,%esp
c002d9bf:	5b                   	pop    %ebx
c002d9c0:	c3                   	ret    
    ASSERT (file != NULL);
c002d9c1:	83 ec 0c             	sub    $0xc,%esp
c002d9c4:	8d 83 6d 73 ff ff    	lea    -0x8c93(%ebx),%eax
c002d9ca:	50                   	push   %eax
c002d9cb:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002d9d1:	50                   	push   %eax
c002d9d2:	8d 83 14 4e ff ff    	lea    -0xb1ec(%ebx),%eax
c002d9d8:	50                   	push   %eax
c002d9d9:	6a 6c                	push   $0x6c
c002d9db:	8d 83 7a 73 ff ff    	lea    -0x8c86(%ebx),%eax
c002d9e1:	50                   	push   %eax
c002d9e2:	e8 f3 b6 ff ff       	call   c00290da <debug_panic>
        file->deny_write = true;
c002d9e7:	c6 40 08 01          	movb   $0x1,0x8(%eax)
        inode_deny_write(file->inode);
c002d9eb:	83 ec 0c             	sub    $0xc,%esp
c002d9ee:	ff 30                	pushl  (%eax)
c002d9f0:	e8 88 0d 00 00       	call   c002e77d <inode_deny_write>
c002d9f5:	83 c4 10             	add    $0x10,%esp
}
c002d9f8:	eb c2                	jmp    c002d9bc <file_deny_write+0x1d>

c002d9fa <file_allow_write>:

/* Re-enables write operations on FILE's underlying inode.
   (Writes might still be denied by some other file that has the
   same inode open.) */
void
file_allow_write(struct file *file) {
c002d9fa:	53                   	push   %ebx
c002d9fb:	83 ec 08             	sub    $0x8,%esp
c002d9fe:	e8 f5 14 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002da03:	81 c3 25 d7 00 00    	add    $0xd725,%ebx
c002da09:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002da0d:	85 c0                	test   %eax,%eax
c002da0f:	74 0b                	je     c002da1c <file_allow_write+0x22>
    if (file->deny_write) {
c002da11:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002da15:	75 2b                	jne    c002da42 <file_allow_write+0x48>
        file->deny_write = false;
        inode_allow_write(file->inode);
    }
}
c002da17:	83 c4 08             	add    $0x8,%esp
c002da1a:	5b                   	pop    %ebx
c002da1b:	c3                   	ret    
    ASSERT (file != NULL);
c002da1c:	83 ec 0c             	sub    $0xc,%esp
c002da1f:	8d 83 6d 73 ff ff    	lea    -0x8c93(%ebx),%eax
c002da25:	50                   	push   %eax
c002da26:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002da2c:	50                   	push   %eax
c002da2d:	8d 83 00 4e ff ff    	lea    -0xb200(%ebx),%eax
c002da33:	50                   	push   %eax
c002da34:	6a 78                	push   $0x78
c002da36:	8d 83 7a 73 ff ff    	lea    -0x8c86(%ebx),%eax
c002da3c:	50                   	push   %eax
c002da3d:	e8 98 b6 ff ff       	call   c00290da <debug_panic>
        file->deny_write = false;
c002da42:	c6 40 08 00          	movb   $0x0,0x8(%eax)
        inode_allow_write(file->inode);
c002da46:	83 ec 0c             	sub    $0xc,%esp
c002da49:	ff 30                	pushl  (%eax)
c002da4b:	e8 7c 0d 00 00       	call   c002e7cc <inode_allow_write>
c002da50:	83 c4 10             	add    $0x10,%esp
}
c002da53:	eb c2                	jmp    c002da17 <file_allow_write+0x1d>

c002da55 <file_close>:
file_close(struct file *file) {
c002da55:	56                   	push   %esi
c002da56:	53                   	push   %ebx
c002da57:	83 ec 04             	sub    $0x4,%esp
c002da5a:	e8 99 14 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002da5f:	81 c3 c9 d6 00 00    	add    $0xd6c9,%ebx
c002da65:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (file != NULL) {
c002da69:	85 f6                	test   %esi,%esi
c002da6b:	74 1e                	je     c002da8b <file_close+0x36>
        file_allow_write(file);
c002da6d:	83 ec 0c             	sub    $0xc,%esp
c002da70:	56                   	push   %esi
c002da71:	e8 84 ff ff ff       	call   c002d9fa <file_allow_write>
        inode_close(file->inode);
c002da76:	83 c4 04             	add    $0x4,%esp
c002da79:	ff 36                	pushl  (%esi)
c002da7b:	e8 c1 08 00 00       	call   c002e341 <inode_close>
        free(file);
c002da80:	89 34 24             	mov    %esi,(%esp)
c002da83:	e8 21 65 ff ff       	call   c0023fa9 <free>
c002da88:	83 c4 10             	add    $0x10,%esp
}
c002da8b:	83 c4 04             	add    $0x4,%esp
c002da8e:	5b                   	pop    %ebx
c002da8f:	5e                   	pop    %esi
c002da90:	c3                   	ret    

c002da91 <file_length>:

/* Returns the size of FILE in bytes. */
off_t
file_length(struct file *file) {
c002da91:	53                   	push   %ebx
c002da92:	83 ec 08             	sub    $0x8,%esp
c002da95:	e8 5e 14 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002da9a:	81 c3 8e d6 00 00    	add    $0xd68e,%ebx
c002daa0:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002daa4:	85 c0                	test   %eax,%eax
c002daa6:	74 0f                	je     c002dab7 <file_length+0x26>
    return inode_length(file->inode);
c002daa8:	83 ec 0c             	sub    $0xc,%esp
c002daab:	ff 30                	pushl  (%eax)
c002daad:	e8 96 0d 00 00       	call   c002e848 <inode_length>
}
c002dab2:	83 c4 18             	add    $0x18,%esp
c002dab5:	5b                   	pop    %ebx
c002dab6:	c3                   	ret    
    ASSERT (file != NULL);
c002dab7:	83 ec 0c             	sub    $0xc,%esp
c002daba:	8d 83 6d 73 ff ff    	lea    -0x8c93(%ebx),%eax
c002dac0:	50                   	push   %eax
c002dac1:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002dac7:	50                   	push   %eax
c002dac8:	8d 83 f4 4d ff ff    	lea    -0xb20c(%ebx),%eax
c002dace:	50                   	push   %eax
c002dacf:	68 82 00 00 00       	push   $0x82
c002dad4:	8d 83 7a 73 ff ff    	lea    -0x8c86(%ebx),%eax
c002dada:	50                   	push   %eax
c002dadb:	e8 fa b5 ff ff       	call   c00290da <debug_panic>

c002dae0 <file_seek>:

/* Sets the current position in FILE to NEW_POS bytes from the
   start of the file. */
void
file_seek(struct file *file, off_t new_pos) {
c002dae0:	53                   	push   %ebx
c002dae1:	83 ec 08             	sub    $0x8,%esp
c002dae4:	e8 0f 14 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002dae9:	81 c3 3f d6 00 00    	add    $0xd63f,%ebx
c002daef:	8b 44 24 10          	mov    0x10(%esp),%eax
c002daf3:	8b 54 24 14          	mov    0x14(%esp),%edx
    ASSERT (file != NULL);
c002daf7:	85 c0                	test   %eax,%eax
c002daf9:	74 0c                	je     c002db07 <file_seek+0x27>
    ASSERT (new_pos >= 0);
c002dafb:	85 d2                	test   %edx,%edx
c002dafd:	78 31                	js     c002db30 <file_seek+0x50>
    file->pos = new_pos;
c002daff:	89 50 04             	mov    %edx,0x4(%eax)
}
c002db02:	83 c4 08             	add    $0x8,%esp
c002db05:	5b                   	pop    %ebx
c002db06:	c3                   	ret    
    ASSERT (file != NULL);
c002db07:	83 ec 0c             	sub    $0xc,%esp
c002db0a:	8d 83 6d 73 ff ff    	lea    -0x8c93(%ebx),%eax
c002db10:	50                   	push   %eax
c002db11:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002db17:	50                   	push   %eax
c002db18:	8d 83 e8 4d ff ff    	lea    -0xb218(%ebx),%eax
c002db1e:	50                   	push   %eax
c002db1f:	68 8a 00 00 00       	push   $0x8a
c002db24:	8d 83 7a 73 ff ff    	lea    -0x8c86(%ebx),%eax
c002db2a:	50                   	push   %eax
c002db2b:	e8 aa b5 ff ff       	call   c00290da <debug_panic>
    ASSERT (new_pos >= 0);
c002db30:	83 ec 0c             	sub    $0xc,%esp
c002db33:	8d 83 8f 73 ff ff    	lea    -0x8c71(%ebx),%eax
c002db39:	50                   	push   %eax
c002db3a:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002db40:	50                   	push   %eax
c002db41:	8d 83 e8 4d ff ff    	lea    -0xb218(%ebx),%eax
c002db47:	50                   	push   %eax
c002db48:	68 8b 00 00 00       	push   $0x8b
c002db4d:	8d 83 7a 73 ff ff    	lea    -0x8c86(%ebx),%eax
c002db53:	50                   	push   %eax
c002db54:	e8 81 b5 ff ff       	call   c00290da <debug_panic>

c002db59 <file_tell>:

/* Returns the current position in FILE as a byte offset from the
   start of the file. */
off_t
file_tell(struct file *file) {
c002db59:	53                   	push   %ebx
c002db5a:	83 ec 08             	sub    $0x8,%esp
c002db5d:	e8 96 13 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002db62:	81 c3 c6 d5 00 00    	add    $0xd5c6,%ebx
c002db68:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (file != NULL);
c002db6c:	85 c0                	test   %eax,%eax
c002db6e:	74 08                	je     c002db78 <file_tell+0x1f>
    return file->pos;
c002db70:	8b 40 04             	mov    0x4(%eax),%eax
}
c002db73:	83 c4 08             	add    $0x8,%esp
c002db76:	5b                   	pop    %ebx
c002db77:	c3                   	ret    
    ASSERT (file != NULL);
c002db78:	83 ec 0c             	sub    $0xc,%esp
c002db7b:	8d 83 6d 73 ff ff    	lea    -0x8c93(%ebx),%eax
c002db81:	50                   	push   %eax
c002db82:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002db88:	50                   	push   %eax
c002db89:	8d 83 dc 4d ff ff    	lea    -0xb224(%ebx),%eax
c002db8f:	50                   	push   %eax
c002db90:	68 93 00 00 00       	push   $0x93
c002db95:	8d 83 7a 73 ff ff    	lea    -0x8c86(%ebx),%eax
c002db9b:	50                   	push   %eax
c002db9c:	e8 39 b5 ff ff       	call   c00290da <debug_panic>

c002dba1 <lookup>:
   if EP is non-null, and sets *OFSP to the byte offset of the
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup(const struct dir *dir, const char *name,
       struct dir_entry *ep, off_t *ofsp) {
c002dba1:	55                   	push   %ebp
c002dba2:	57                   	push   %edi
c002dba3:	56                   	push   %esi
c002dba4:	53                   	push   %ebx
c002dba5:	83 ec 4c             	sub    $0x4c,%esp
c002dba8:	e8 4b 13 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002dbad:	81 c3 7b d5 00 00    	add    $0xd57b,%ebx
c002dbb3:	89 54 24 14          	mov    %edx,0x14(%esp)
c002dbb7:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    struct dir_entry e;
    size_t ofs;

    ASSERT (dir != NULL);
c002dbbb:	85 c0                	test   %eax,%eax
c002dbbd:	74 20                	je     c002dbdf <lookup+0x3e>
c002dbbf:	89 c5                	mov    %eax,%ebp
    ASSERT (name != NULL);
c002dbc1:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002dbc6:	74 3d                	je     c002dc05 <lookup+0x64>

    for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002dbc8:	be 00 00 00 00       	mov    $0x0,%esi
c002dbcd:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002dbd1:	89 44 24 0c          	mov    %eax,0xc(%esp)
         ofs += sizeof e)
        if (e.in_use && !strcmp(name, e.name)) {
c002dbd5:	8d 44 24 30          	lea    0x30(%esp),%eax
c002dbd9:	89 44 24 18          	mov    %eax,0x18(%esp)
c002dbdd:	eb 4f                	jmp    c002dc2e <lookup+0x8d>
    ASSERT (dir != NULL);
c002dbdf:	83 ec 0c             	sub    $0xc,%esp
c002dbe2:	8d 83 9c 73 ff ff    	lea    -0x8c64(%ebx),%eax
c002dbe8:	50                   	push   %eax
c002dbe9:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002dbef:	50                   	push   %eax
c002dbf0:	8d 83 38 4e ff ff    	lea    -0xb1c8(%ebx),%eax
c002dbf6:	50                   	push   %eax
c002dbf7:	6a 55                	push   $0x55
c002dbf9:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002dbff:	50                   	push   %eax
c002dc00:	e8 d5 b4 ff ff       	call   c00290da <debug_panic>
    ASSERT (name != NULL);
c002dc05:	83 ec 0c             	sub    $0xc,%esp
c002dc08:	8d 83 84 56 ff ff    	lea    -0xa97c(%ebx),%eax
c002dc0e:	50                   	push   %eax
c002dc0f:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002dc15:	50                   	push   %eax
c002dc16:	8d 83 38 4e ff ff    	lea    -0xb1c8(%ebx),%eax
c002dc1c:	50                   	push   %eax
c002dc1d:	6a 56                	push   $0x56
c002dc1f:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002dc25:	50                   	push   %eax
c002dc26:	e8 af b4 ff ff       	call   c00290da <debug_panic>
         ofs += sizeof e)
c002dc2b:	83 c6 14             	add    $0x14,%esi
    for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002dc2e:	89 74 24 10          	mov    %esi,0x10(%esp)
c002dc32:	56                   	push   %esi
c002dc33:	6a 14                	push   $0x14
c002dc35:	ff 74 24 14          	pushl  0x14(%esp)
c002dc39:	ff 75 00             	pushl  0x0(%ebp)
c002dc3c:	e8 c7 07 00 00       	call   c002e408 <inode_read_at>
c002dc41:	83 c4 10             	add    $0x10,%esp
c002dc44:	83 f8 14             	cmp    $0x14,%eax
c002dc47:	75 5f                	jne    c002dca8 <lookup+0x107>
        if (e.in_use && !strcmp(name, e.name)) {
c002dc49:	0f b6 7c 24 3f       	movzbl 0x3f(%esp),%edi
c002dc4e:	89 f8                	mov    %edi,%eax
c002dc50:	84 c0                	test   %al,%al
c002dc52:	74 d7                	je     c002dc2b <lookup+0x8a>
c002dc54:	83 ec 08             	sub    $0x8,%esp
c002dc57:	ff 74 24 20          	pushl  0x20(%esp)
c002dc5b:	ff 74 24 20          	pushl  0x20(%esp)
c002dc5f:	e8 2c a7 ff ff       	call   c0028390 <strcmp>
c002dc64:	83 c4 10             	add    $0x10,%esp
c002dc67:	85 c0                	test   %eax,%eax
c002dc69:	75 c0                	jne    c002dc2b <lookup+0x8a>
            if (ep != NULL)
c002dc6b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002dc6f:	85 d2                	test   %edx,%edx
c002dc71:	74 22                	je     c002dc95 <lookup+0xf4>
                *ep = e;
c002dc73:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002dc77:	89 02                	mov    %eax,(%edx)
c002dc79:	8b 44 24 30          	mov    0x30(%esp),%eax
c002dc7d:	89 42 04             	mov    %eax,0x4(%edx)
c002dc80:	8b 44 24 34          	mov    0x34(%esp),%eax
c002dc84:	89 42 08             	mov    %eax,0x8(%edx)
c002dc87:	8b 44 24 38          	mov    0x38(%esp),%eax
c002dc8b:	89 42 0c             	mov    %eax,0xc(%edx)
c002dc8e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002dc92:	89 42 10             	mov    %eax,0x10(%edx)
            if (ofsp != NULL)
c002dc95:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
c002dc9a:	74 11                	je     c002dcad <lookup+0x10c>
                *ofsp = ofs;
c002dc9c:	8b 44 24 60          	mov    0x60(%esp),%eax
c002dca0:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002dca4:	89 08                	mov    %ecx,(%eax)
c002dca6:	eb 05                	jmp    c002dcad <lookup+0x10c>
            return true;
        }
    return false;
c002dca8:	bf 00 00 00 00       	mov    $0x0,%edi
}
c002dcad:	89 f8                	mov    %edi,%eax
c002dcaf:	83 c4 4c             	add    $0x4c,%esp
c002dcb2:	5b                   	pop    %ebx
c002dcb3:	5e                   	pop    %esi
c002dcb4:	5f                   	pop    %edi
c002dcb5:	5d                   	pop    %ebp
c002dcb6:	c3                   	ret    

c002dcb7 <dir_create>:
dir_create(block_sector_t sector, size_t entry_cnt) {
c002dcb7:	53                   	push   %ebx
c002dcb8:	83 ec 10             	sub    $0x10,%esp
c002dcbb:	e8 38 12 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002dcc0:	81 c3 68 d4 00 00    	add    $0xd468,%ebx
c002dcc6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    return inode_create(sector, entry_cnt * sizeof(struct dir_entry));
c002dcca:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002dccd:	c1 e0 02             	shl    $0x2,%eax
c002dcd0:	50                   	push   %eax
c002dcd1:	ff 74 24 1c          	pushl  0x1c(%esp)
c002dcd5:	e8 93 04 00 00       	call   c002e16d <inode_create>
}
c002dcda:	83 c4 18             	add    $0x18,%esp
c002dcdd:	5b                   	pop    %ebx
c002dcde:	c3                   	ret    

c002dcdf <dir_open>:
dir_open(struct inode *inode) {
c002dcdf:	57                   	push   %edi
c002dce0:	56                   	push   %esi
c002dce1:	53                   	push   %ebx
c002dce2:	e8 11 12 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002dce7:	81 c3 41 d4 00 00    	add    $0xd441,%ebx
c002dced:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct dir *dir = calloc(1, sizeof *dir);
c002dcf1:	83 ec 08             	sub    $0x8,%esp
c002dcf4:	6a 08                	push   $0x8
c002dcf6:	6a 01                	push   $0x1
c002dcf8:	e8 5b 62 ff ff       	call   c0023f58 <calloc>
c002dcfd:	89 c6                	mov    %eax,%esi
    if (inode != NULL && dir != NULL) {
c002dcff:	83 c4 10             	add    $0x10,%esp
c002dd02:	85 ff                	test   %edi,%edi
c002dd04:	74 13                	je     c002dd19 <dir_open+0x3a>
c002dd06:	85 c0                	test   %eax,%eax
c002dd08:	74 0f                	je     c002dd19 <dir_open+0x3a>
        dir->inode = inode;
c002dd0a:	89 38                	mov    %edi,(%eax)
        dir->pos = 0;
c002dd0c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
c002dd13:	89 f0                	mov    %esi,%eax
c002dd15:	5b                   	pop    %ebx
c002dd16:	5e                   	pop    %esi
c002dd17:	5f                   	pop    %edi
c002dd18:	c3                   	ret    
        inode_close(inode);
c002dd19:	83 ec 0c             	sub    $0xc,%esp
c002dd1c:	57                   	push   %edi
c002dd1d:	e8 1f 06 00 00       	call   c002e341 <inode_close>
        free(dir);
c002dd22:	89 34 24             	mov    %esi,(%esp)
c002dd25:	e8 7f 62 ff ff       	call   c0023fa9 <free>
        return NULL;
c002dd2a:	83 c4 10             	add    $0x10,%esp
c002dd2d:	be 00 00 00 00       	mov    $0x0,%esi
c002dd32:	eb df                	jmp    c002dd13 <dir_open+0x34>

c002dd34 <dir_open_root>:
dir_open_root(void) {
c002dd34:	53                   	push   %ebx
c002dd35:	83 ec 14             	sub    $0x14,%esp
c002dd38:	e8 bb 11 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002dd3d:	81 c3 eb d3 00 00    	add    $0xd3eb,%ebx
    return dir_open(inode_open(ROOT_DIR_SECTOR));
c002dd43:	6a 01                	push   $0x1
c002dd45:	e8 32 05 00 00       	call   c002e27c <inode_open>
c002dd4a:	89 04 24             	mov    %eax,(%esp)
c002dd4d:	e8 8d ff ff ff       	call   c002dcdf <dir_open>
}
c002dd52:	83 c4 18             	add    $0x18,%esp
c002dd55:	5b                   	pop    %ebx
c002dd56:	c3                   	ret    

c002dd57 <dir_reopen>:
dir_reopen(struct dir *dir) {
c002dd57:	53                   	push   %ebx
c002dd58:	83 ec 14             	sub    $0x14,%esp
c002dd5b:	e8 98 11 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002dd60:	81 c3 c8 d3 00 00    	add    $0xd3c8,%ebx
    return dir_open(inode_reopen(dir->inode));
c002dd66:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002dd6a:	ff 30                	pushl  (%eax)
c002dd6c:	e8 fe 04 00 00       	call   c002e26f <inode_reopen>
c002dd71:	89 04 24             	mov    %eax,(%esp)
c002dd74:	e8 66 ff ff ff       	call   c002dcdf <dir_open>
}
c002dd79:	83 c4 18             	add    $0x18,%esp
c002dd7c:	5b                   	pop    %ebx
c002dd7d:	c3                   	ret    

c002dd7e <dir_close>:
dir_close(struct dir *dir) {
c002dd7e:	56                   	push   %esi
c002dd7f:	53                   	push   %ebx
c002dd80:	83 ec 04             	sub    $0x4,%esp
c002dd83:	e8 70 11 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002dd88:	81 c3 a0 d3 00 00    	add    $0xd3a0,%ebx
c002dd8e:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (dir != NULL) {
c002dd92:	85 f6                	test   %esi,%esi
c002dd94:	74 15                	je     c002ddab <dir_close+0x2d>
        inode_close(dir->inode);
c002dd96:	83 ec 0c             	sub    $0xc,%esp
c002dd99:	ff 36                	pushl  (%esi)
c002dd9b:	e8 a1 05 00 00       	call   c002e341 <inode_close>
        free(dir);
c002dda0:	89 34 24             	mov    %esi,(%esp)
c002dda3:	e8 01 62 ff ff       	call   c0023fa9 <free>
c002dda8:	83 c4 10             	add    $0x10,%esp
}
c002ddab:	83 c4 04             	add    $0x4,%esp
c002ddae:	5b                   	pop    %ebx
c002ddaf:	5e                   	pop    %esi
c002ddb0:	c3                   	ret    

c002ddb1 <dir_get_inode>:
    return dir->inode;
c002ddb1:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ddb5:	8b 00                	mov    (%eax),%eax
}
c002ddb7:	c3                   	ret    

c002ddb8 <dir_lookup>:
   and returns true if one exists, false otherwise.
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool
dir_lookup(const struct dir *dir, const char *name,
           struct inode **inode) {
c002ddb8:	56                   	push   %esi
c002ddb9:	53                   	push   %ebx
c002ddba:	83 ec 24             	sub    $0x24,%esp
c002ddbd:	e8 36 11 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ddc2:	81 c3 66 d3 00 00    	add    $0xd366,%ebx
c002ddc8:	8b 44 24 30          	mov    0x30(%esp),%eax
c002ddcc:	8b 54 24 34          	mov    0x34(%esp),%edx
c002ddd0:	8b 74 24 38          	mov    0x38(%esp),%esi
    struct dir_entry e;

    ASSERT (dir != NULL);
c002ddd4:	85 c0                	test   %eax,%eax
c002ddd6:	74 2b                	je     c002de03 <dir_lookup+0x4b>
    ASSERT (name != NULL);
c002ddd8:	85 d2                	test   %edx,%edx
c002ddda:	74 4d                	je     c002de29 <dir_lookup+0x71>

    if (lookup(dir, name, &e, NULL))
c002dddc:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002dde0:	83 ec 0c             	sub    $0xc,%esp
c002dde3:	6a 00                	push   $0x0
c002dde5:	e8 b7 fd ff ff       	call   c002dba1 <lookup>
c002ddea:	83 c4 10             	add    $0x10,%esp
c002dded:	84 c0                	test   %al,%al
c002ddef:	75 5e                	jne    c002de4f <dir_lookup+0x97>
        *inode = inode_open(e.inode_sector);
    else
        *inode = NULL;
c002ddf1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)

    return *inode != NULL;
c002ddf7:	83 3e 00             	cmpl   $0x0,(%esi)
c002ddfa:	0f 95 c0             	setne  %al
}
c002ddfd:	83 c4 24             	add    $0x24,%esp
c002de00:	5b                   	pop    %ebx
c002de01:	5e                   	pop    %esi
c002de02:	c3                   	ret    
    ASSERT (dir != NULL);
c002de03:	83 ec 0c             	sub    $0xc,%esp
c002de06:	8d 83 9c 73 ff ff    	lea    -0x8c64(%ebx),%eax
c002de0c:	50                   	push   %eax
c002de0d:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002de13:	50                   	push   %eax
c002de14:	8d 83 40 4e ff ff    	lea    -0xb1c0(%ebx),%eax
c002de1a:	50                   	push   %eax
c002de1b:	6a 6d                	push   $0x6d
c002de1d:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002de23:	50                   	push   %eax
c002de24:	e8 b1 b2 ff ff       	call   c00290da <debug_panic>
    ASSERT (name != NULL);
c002de29:	83 ec 0c             	sub    $0xc,%esp
c002de2c:	8d 83 84 56 ff ff    	lea    -0xa97c(%ebx),%eax
c002de32:	50                   	push   %eax
c002de33:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002de39:	50                   	push   %eax
c002de3a:	8d 83 40 4e ff ff    	lea    -0xb1c0(%ebx),%eax
c002de40:	50                   	push   %eax
c002de41:	6a 6e                	push   $0x6e
c002de43:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002de49:	50                   	push   %eax
c002de4a:	e8 8b b2 ff ff       	call   c00290da <debug_panic>
        *inode = inode_open(e.inode_sector);
c002de4f:	83 ec 0c             	sub    $0xc,%esp
c002de52:	ff 74 24 18          	pushl  0x18(%esp)
c002de56:	e8 21 04 00 00       	call   c002e27c <inode_open>
c002de5b:	89 06                	mov    %eax,(%esi)
c002de5d:	83 c4 10             	add    $0x10,%esp
c002de60:	eb 95                	jmp    c002ddf7 <dir_lookup+0x3f>

c002de62 <dir_add>:
   INODE_SECTOR.
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool
dir_add(struct dir *dir, const char *name, block_sector_t inode_sector) {
c002de62:	55                   	push   %ebp
c002de63:	57                   	push   %edi
c002de64:	56                   	push   %esi
c002de65:	53                   	push   %ebx
c002de66:	83 ec 2c             	sub    $0x2c,%esp
c002de69:	e8 8a 10 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002de6e:	81 c3 ba d2 00 00    	add    $0xd2ba,%ebx
c002de74:	8b 6c 24 40          	mov    0x40(%esp),%ebp
    struct dir_entry e;
    off_t ofs;
    bool success = false;

    ASSERT (dir != NULL);
c002de78:	85 ed                	test   %ebp,%ebp
c002de7a:	74 34                	je     c002deb0 <dir_add+0x4e>
    ASSERT (name != NULL);
c002de7c:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
c002de81:	74 56                	je     c002ded9 <dir_add+0x77>

    /* Check NAME for validity. */
    if (*name == '\0' || strlen(name) > NAME_MAX)
        return false;
c002de83:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*name == '\0' || strlen(name) > NAME_MAX)
c002de88:	8b 54 24 44          	mov    0x44(%esp),%edx
c002de8c:	80 3a 00             	cmpb   $0x0,(%edx)
c002de8f:	74 17                	je     c002dea8 <dir_add+0x46>
c002de91:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002de96:	89 d7                	mov    %edx,%edi
c002de98:	f2 ae                	repnz scas %es:(%edi),%al
c002de9a:	89 ca                	mov    %ecx,%edx
c002de9c:	f7 d2                	not    %edx
c002de9e:	89 d1                	mov    %edx,%ecx
c002dea0:	83 e9 01             	sub    $0x1,%ecx
c002dea3:	83 f9 0e             	cmp    $0xe,%ecx
c002dea6:	76 5a                	jbe    c002df02 <dir_add+0xa0>
    e.inode_sector = inode_sector;
    success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;

    done:
    return success;
}
c002dea8:	83 c4 2c             	add    $0x2c,%esp
c002deab:	5b                   	pop    %ebx
c002deac:	5e                   	pop    %esi
c002dead:	5f                   	pop    %edi
c002deae:	5d                   	pop    %ebp
c002deaf:	c3                   	ret    
    ASSERT (dir != NULL);
c002deb0:	83 ec 0c             	sub    $0xc,%esp
c002deb3:	8d 83 9c 73 ff ff    	lea    -0x8c64(%ebx),%eax
c002deb9:	50                   	push   %eax
c002deba:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002dec0:	50                   	push   %eax
c002dec1:	8d 83 30 4e ff ff    	lea    -0xb1d0(%ebx),%eax
c002dec7:	50                   	push   %eax
c002dec8:	68 84 00 00 00       	push   $0x84
c002decd:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002ded3:	50                   	push   %eax
c002ded4:	e8 01 b2 ff ff       	call   c00290da <debug_panic>
    ASSERT (name != NULL);
c002ded9:	83 ec 0c             	sub    $0xc,%esp
c002dedc:	8d 83 84 56 ff ff    	lea    -0xa97c(%ebx),%eax
c002dee2:	50                   	push   %eax
c002dee3:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002dee9:	50                   	push   %eax
c002deea:	8d 83 30 4e ff ff    	lea    -0xb1d0(%ebx),%eax
c002def0:	50                   	push   %eax
c002def1:	68 85 00 00 00       	push   $0x85
c002def6:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002defc:	50                   	push   %eax
c002defd:	e8 d8 b1 ff ff       	call   c00290da <debug_panic>
    if (lookup(dir, name, NULL, NULL))
c002df02:	83 ec 0c             	sub    $0xc,%esp
c002df05:	6a 00                	push   $0x0
c002df07:	b9 00 00 00 00       	mov    $0x0,%ecx
c002df0c:	8b 54 24 54          	mov    0x54(%esp),%edx
c002df10:	89 e8                	mov    %ebp,%eax
c002df12:	e8 8a fc ff ff       	call   c002dba1 <lookup>
c002df17:	89 c2                	mov    %eax,%edx
c002df19:	83 c4 10             	add    $0x10,%esp
    bool success = false;
c002df1c:	b8 00 00 00 00       	mov    $0x0,%eax
    if (lookup(dir, name, NULL, NULL))
c002df21:	84 d2                	test   %dl,%dl
c002df23:	75 83                	jne    c002dea8 <dir_add+0x46>
    for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002df25:	be 00 00 00 00       	mov    $0x0,%esi
c002df2a:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002df2e:	56                   	push   %esi
c002df2f:	6a 14                	push   $0x14
c002df31:	57                   	push   %edi
c002df32:	ff 75 00             	pushl  0x0(%ebp)
c002df35:	e8 ce 04 00 00       	call   c002e408 <inode_read_at>
c002df3a:	83 c4 10             	add    $0x10,%esp
c002df3d:	83 f8 14             	cmp    $0x14,%eax
c002df40:	75 0c                	jne    c002df4e <dir_add+0xec>
        if (!e.in_use)
c002df42:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c002df47:	74 05                	je     c002df4e <dir_add+0xec>
c002df49:	83 c6 14             	add    $0x14,%esi
c002df4c:	eb e0                	jmp    c002df2e <dir_add+0xcc>
    e.in_use = true;
c002df4e:	c6 44 24 1f 01       	movb   $0x1,0x1f(%esp)
    strlcpy(e.name, name, sizeof e.name);
c002df53:	83 ec 04             	sub    $0x4,%esp
c002df56:	6a 0f                	push   $0xf
c002df58:	ff 74 24 4c          	pushl  0x4c(%esp)
c002df5c:	8d 7c 24 18          	lea    0x18(%esp),%edi
c002df60:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002df64:	50                   	push   %eax
c002df65:	e8 b2 a7 ff ff       	call   c002871c <strlcpy>
    e.inode_sector = inode_sector;
c002df6a:	8b 44 24 58          	mov    0x58(%esp),%eax
c002df6e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002df72:	56                   	push   %esi
c002df73:	6a 14                	push   $0x14
c002df75:	57                   	push   %edi
c002df76:	ff 75 00             	pushl  0x0(%ebp)
c002df79:	e8 11 06 00 00       	call   c002e58f <inode_write_at>
c002df7e:	83 c4 20             	add    $0x20,%esp
c002df81:	83 f8 14             	cmp    $0x14,%eax
c002df84:	0f 94 c0             	sete   %al
c002df87:	e9 1c ff ff ff       	jmp    c002dea8 <dir_add+0x46>

c002df8c <dir_remove>:

/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool
dir_remove(struct dir *dir, const char *name) {
c002df8c:	55                   	push   %ebp
c002df8d:	57                   	push   %edi
c002df8e:	56                   	push   %esi
c002df8f:	53                   	push   %ebx
c002df90:	83 ec 2c             	sub    $0x2c,%esp
c002df93:	e8 60 0f 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002df98:	81 c3 90 d1 00 00    	add    $0xd190,%ebx
c002df9e:	8b 7c 24 40          	mov    0x40(%esp),%edi
c002dfa2:	8b 54 24 44          	mov    0x44(%esp),%edx
    struct dir_entry e;
    struct inode *inode = NULL;
    bool success = false;
    off_t ofs;

    ASSERT (dir != NULL);
c002dfa6:	85 ff                	test   %edi,%edi
c002dfa8:	74 38                	je     c002dfe2 <dir_remove+0x56>
    ASSERT (name != NULL);
c002dfaa:	85 d2                	test   %edx,%edx
c002dfac:	74 5d                	je     c002e00b <dir_remove+0x7f>

    /* Find directory entry. */
    if (!lookup(dir, name, &e, &ofs))
c002dfae:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002dfb2:	83 ec 0c             	sub    $0xc,%esp
c002dfb5:	8d 44 24 14          	lea    0x14(%esp),%eax
c002dfb9:	50                   	push   %eax
c002dfba:	89 f8                	mov    %edi,%eax
c002dfbc:	e8 e0 fb ff ff       	call   c002dba1 <lookup>
c002dfc1:	89 c6                	mov    %eax,%esi
c002dfc3:	83 c4 10             	add    $0x10,%esp
    struct inode *inode = NULL;
c002dfc6:	bd 00 00 00 00       	mov    $0x0,%ebp
    if (!lookup(dir, name, &e, &ofs))
c002dfcb:	84 c0                	test   %al,%al
c002dfcd:	75 65                	jne    c002e034 <dir_remove+0xa8>
    /* Remove inode. */
    inode_remove(inode);
    success = true;

    done:
    inode_close(inode);
c002dfcf:	83 ec 0c             	sub    $0xc,%esp
c002dfd2:	55                   	push   %ebp
c002dfd3:	e8 69 03 00 00       	call   c002e341 <inode_close>
    return success;
}
c002dfd8:	89 f0                	mov    %esi,%eax
c002dfda:	83 c4 3c             	add    $0x3c,%esp
c002dfdd:	5b                   	pop    %ebx
c002dfde:	5e                   	pop    %esi
c002dfdf:	5f                   	pop    %edi
c002dfe0:	5d                   	pop    %ebp
c002dfe1:	c3                   	ret    
    ASSERT (dir != NULL);
c002dfe2:	83 ec 0c             	sub    $0xc,%esp
c002dfe5:	8d 83 9c 73 ff ff    	lea    -0x8c64(%ebx),%eax
c002dfeb:	50                   	push   %eax
c002dfec:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002dff2:	50                   	push   %eax
c002dff3:	8d 83 24 4e ff ff    	lea    -0xb1dc(%ebx),%eax
c002dff9:	50                   	push   %eax
c002dffa:	68 af 00 00 00       	push   $0xaf
c002dfff:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002e005:	50                   	push   %eax
c002e006:	e8 cf b0 ff ff       	call   c00290da <debug_panic>
    ASSERT (name != NULL);
c002e00b:	83 ec 0c             	sub    $0xc,%esp
c002e00e:	8d 83 84 56 ff ff    	lea    -0xa97c(%ebx),%eax
c002e014:	50                   	push   %eax
c002e015:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002e01b:	50                   	push   %eax
c002e01c:	8d 83 24 4e ff ff    	lea    -0xb1dc(%ebx),%eax
c002e022:	50                   	push   %eax
c002e023:	68 b0 00 00 00       	push   $0xb0
c002e028:	8d 83 a8 73 ff ff    	lea    -0x8c58(%ebx),%eax
c002e02e:	50                   	push   %eax
c002e02f:	e8 a6 b0 ff ff       	call   c00290da <debug_panic>
    inode = inode_open(e.inode_sector);
c002e034:	83 ec 0c             	sub    $0xc,%esp
c002e037:	ff 74 24 18          	pushl  0x18(%esp)
c002e03b:	e8 3c 02 00 00       	call   c002e27c <inode_open>
c002e040:	89 c5                	mov    %eax,%ebp
    if (inode == NULL)
c002e042:	83 c4 10             	add    $0x10,%esp
c002e045:	85 c0                	test   %eax,%eax
c002e047:	74 3a                	je     c002e083 <dir_remove+0xf7>
    e.in_use = false;
c002e049:	c6 44 24 1f 00       	movb   $0x0,0x1f(%esp)
    if (inode_write_at(dir->inode, &e, sizeof e, ofs) != sizeof e)
c002e04e:	ff 74 24 08          	pushl  0x8(%esp)
c002e052:	6a 14                	push   $0x14
c002e054:	8d 44 24 14          	lea    0x14(%esp),%eax
c002e058:	50                   	push   %eax
c002e059:	ff 37                	pushl  (%edi)
c002e05b:	e8 2f 05 00 00       	call   c002e58f <inode_write_at>
c002e060:	83 c4 10             	add    $0x10,%esp
c002e063:	83 f8 14             	cmp    $0x14,%eax
c002e066:	74 0a                	je     c002e072 <dir_remove+0xe6>
    bool success = false;
c002e068:	be 00 00 00 00       	mov    $0x0,%esi
c002e06d:	e9 5d ff ff ff       	jmp    c002dfcf <dir_remove+0x43>
    inode_remove(inode);
c002e072:	83 ec 0c             	sub    $0xc,%esp
c002e075:	55                   	push   %ebp
c002e076:	e8 44 03 00 00       	call   c002e3bf <inode_remove>
c002e07b:	83 c4 10             	add    $0x10,%esp
c002e07e:	e9 4c ff ff ff       	jmp    c002dfcf <dir_remove+0x43>
    bool success = false;
c002e083:	be 00 00 00 00       	mov    $0x0,%esi
c002e088:	e9 42 ff ff ff       	jmp    c002dfcf <dir_remove+0x43>

c002e08d <dir_readdir>:

/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool
dir_readdir(struct dir *dir, char name[NAME_MAX + 1]) {
c002e08d:	55                   	push   %ebp
c002e08e:	57                   	push   %edi
c002e08f:	56                   	push   %esi
c002e090:	53                   	push   %ebx
c002e091:	83 ec 2c             	sub    $0x2c,%esp
c002e094:	e8 5f 0e 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e099:	81 c3 8f d0 00 00    	add    $0xd08f,%ebx
c002e09f:	8b 74 24 40          	mov    0x40(%esp),%esi
    struct dir_entry e;

    while (inode_read_at(dir->inode, &e, sizeof e, dir->pos) == sizeof e) {
c002e0a3:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c002e0a7:	ff 76 04             	pushl  0x4(%esi)
c002e0aa:	6a 14                	push   $0x14
c002e0ac:	55                   	push   %ebp
c002e0ad:	ff 36                	pushl  (%esi)
c002e0af:	e8 54 03 00 00       	call   c002e408 <inode_read_at>
c002e0b4:	83 c4 10             	add    $0x10,%esp
c002e0b7:	83 f8 14             	cmp    $0x14,%eax
c002e0ba:	75 27                	jne    c002e0e3 <dir_readdir+0x56>
        dir->pos += sizeof e;
c002e0bc:	83 46 04 14          	addl   $0x14,0x4(%esi)
        if (e.in_use) {
c002e0c0:	0f b6 7c 24 1f       	movzbl 0x1f(%esp),%edi
c002e0c5:	89 f8                	mov    %edi,%eax
c002e0c7:	84 c0                	test   %al,%al
c002e0c9:	74 dc                	je     c002e0a7 <dir_readdir+0x1a>
            strlcpy(name, e.name, NAME_MAX + 1);
c002e0cb:	83 ec 04             	sub    $0x4,%esp
c002e0ce:	6a 0f                	push   $0xf
c002e0d0:	8d 44 24 18          	lea    0x18(%esp),%eax
c002e0d4:	50                   	push   %eax
c002e0d5:	ff 74 24 50          	pushl  0x50(%esp)
c002e0d9:	e8 3e a6 ff ff       	call   c002871c <strlcpy>
            return true;
c002e0de:	83 c4 10             	add    $0x10,%esp
c002e0e1:	eb 05                	jmp    c002e0e8 <dir_readdir+0x5b>
        }
    }
    return false;
c002e0e3:	bf 00 00 00 00       	mov    $0x0,%edi
}
c002e0e8:	89 f8                	mov    %edi,%eax
c002e0ea:	83 c4 2c             	add    $0x2c,%esp
c002e0ed:	5b                   	pop    %ebx
c002e0ee:	5e                   	pop    %esi
c002e0ef:	5f                   	pop    %edi
c002e0f0:	5d                   	pop    %ebp
c002e0f1:	c3                   	ret    

c002e0f2 <byte_to_sector>:
/* Returns the block device sector that contains byte offset POS
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector(const struct inode *inode, off_t pos) {
c002e0f2:	53                   	push   %ebx
c002e0f3:	83 ec 08             	sub    $0x8,%esp
c002e0f6:	e8 fd 0d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e0fb:	81 c3 2d d0 00 00    	add    $0xd02d,%ebx
    ASSERT (inode != NULL);
c002e101:	85 c0                	test   %eax,%eax
c002e103:	74 22                	je     c002e127 <byte_to_sector+0x35>
    if (pos < inode->data.length)
        return inode->data.start + pos / BLOCK_SECTOR_SIZE;
    else
        return -1;
c002e105:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    if (pos < inode->data.length)
c002e10a:	39 50 1c             	cmp    %edx,0x1c(%eax)
c002e10d:	7e 11                	jle    c002e120 <byte_to_sector+0x2e>
        return inode->data.start + pos / BLOCK_SECTOR_SIZE;
c002e10f:	8d 8a ff 01 00 00    	lea    0x1ff(%edx),%ecx
c002e115:	85 d2                	test   %edx,%edx
c002e117:	0f 49 ca             	cmovns %edx,%ecx
c002e11a:	c1 f9 09             	sar    $0x9,%ecx
c002e11d:	03 48 18             	add    0x18(%eax),%ecx
}
c002e120:	89 c8                	mov    %ecx,%eax
c002e122:	83 c4 08             	add    $0x8,%esp
c002e125:	5b                   	pop    %ebx
c002e126:	c3                   	ret    
    ASSERT (inode != NULL);
c002e127:	83 ec 0c             	sub    $0xc,%esp
c002e12a:	8d 83 c2 73 ff ff    	lea    -0x8c3e(%ebx),%eax
c002e130:	50                   	push   %eax
c002e131:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002e137:	50                   	push   %eax
c002e138:	8d 83 74 4e ff ff    	lea    -0xb18c(%ebx),%eax
c002e13e:	50                   	push   %eax
c002e13f:	6a 2d                	push   $0x2d
c002e141:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
c002e147:	50                   	push   %eax
c002e148:	e8 8d af ff ff       	call   c00290da <debug_panic>

c002e14d <inode_init>:
   returns the same `struct inode'. */
static struct list open_inodes;

/* Initializes the inode module. */
void
inode_init(void) {
c002e14d:	53                   	push   %ebx
c002e14e:	83 ec 14             	sub    $0x14,%esp
c002e151:	e8 a2 0d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e156:	81 c3 d2 cf 00 00    	add    $0xcfd2,%ebx
    list_init(&open_inodes);
c002e15c:	8d 83 38 1f 00 00    	lea    0x1f38(%ebx),%eax
c002e162:	50                   	push   %eax
c002e163:	e8 3f b0 ff ff       	call   c00291a7 <list_init>
}
c002e168:	83 c4 18             	add    $0x18,%esp
c002e16b:	5b                   	pop    %ebx
c002e16c:	c3                   	ret    

c002e16d <inode_create>:
   writes the new inode to sector SECTOR on the file system
   device.
   Returns true if successful.
   Returns false if memory or disk allocation fails. */
bool
inode_create(block_sector_t sector, off_t length) {
c002e16d:	55                   	push   %ebp
c002e16e:	57                   	push   %edi
c002e16f:	56                   	push   %esi
c002e170:	53                   	push   %ebx
c002e171:	83 ec 1c             	sub    $0x1c,%esp
c002e174:	e8 7f 0d 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e179:	81 c3 af cf 00 00    	add    $0xcfaf,%ebx
c002e17f:	8b 7c 24 34          	mov    0x34(%esp),%edi
    struct inode_disk *disk_inode = NULL;
    bool success = false;

    ASSERT (length >= 0);
c002e183:	85 ff                	test   %edi,%edi
c002e185:	78 6c                	js     c002e1f3 <inode_create+0x86>

    /* If this assertion fails, the inode structure is not exactly
       one sector in size, and you should fix that. */
    ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

    disk_inode = calloc(1, sizeof *disk_inode);
c002e187:	83 ec 08             	sub    $0x8,%esp
c002e18a:	68 00 02 00 00       	push   $0x200
c002e18f:	6a 01                	push   $0x1
c002e191:	e8 c2 5d ff ff       	call   c0023f58 <calloc>
c002e196:	89 c6                	mov    %eax,%esi
    if (disk_inode != NULL) {
c002e198:	83 c4 10             	add    $0x10,%esp
    bool success = false;
c002e19b:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
    if (disk_inode != NULL) {
c002e1a0:	85 c0                	test   %eax,%eax
c002e1a2:	74 42                	je     c002e1e6 <inode_create+0x79>
    return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002e1a4:	8d af fe 03 00 00    	lea    0x3fe(%edi),%ebp
c002e1aa:	89 f8                	mov    %edi,%eax
c002e1ac:	05 ff 01 00 00       	add    $0x1ff,%eax
c002e1b1:	0f 49 e8             	cmovns %eax,%ebp
c002e1b4:	c1 fd 09             	sar    $0x9,%ebp
c002e1b7:	89 6c 24 08          	mov    %ebp,0x8(%esp)
        size_t sectors = bytes_to_sectors(length);
        disk_inode->length = length;
c002e1bb:	89 7e 04             	mov    %edi,0x4(%esi)
        disk_inode->magic = INODE_MAGIC;
c002e1be:	c7 46 08 44 4f 4e 49 	movl   $0x494e4f44,0x8(%esi)
        if (free_map_allocate(sectors, &disk_inode->start)) {
c002e1c5:	83 ec 08             	sub    $0x8,%esp
c002e1c8:	56                   	push   %esi
c002e1c9:	55                   	push   %ebp
c002e1ca:	e8 4c f4 ff ff       	call   c002d61b <free_map_allocate>
c002e1cf:	88 44 24 17          	mov    %al,0x17(%esp)
c002e1d3:	83 c4 10             	add    $0x10,%esp
c002e1d6:	84 c0                	test   %al,%al
c002e1d8:	75 3f                	jne    c002e219 <inode_create+0xac>
                for (i = 0; i < sectors; i++)
                    block_write(fs_device, disk_inode->start + i, zeros);
            }
            success = true;
        }
        free(disk_inode);
c002e1da:	83 ec 0c             	sub    $0xc,%esp
c002e1dd:	56                   	push   %esi
c002e1de:	e8 c6 5d ff ff       	call   c0023fa9 <free>
c002e1e3:	83 c4 10             	add    $0x10,%esp
    }
    return success;
}
c002e1e6:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c002e1eb:	83 c4 1c             	add    $0x1c,%esp
c002e1ee:	5b                   	pop    %ebx
c002e1ef:	5e                   	pop    %esi
c002e1f0:	5f                   	pop    %edi
c002e1f1:	5d                   	pop    %ebp
c002e1f2:	c3                   	ret    
    ASSERT (length >= 0);
c002e1f3:	83 ec 0c             	sub    $0xc,%esp
c002e1f6:	8d 83 e6 73 ff ff    	lea    -0x8c1a(%ebx),%eax
c002e1fc:	50                   	push   %eax
c002e1fd:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002e203:	50                   	push   %eax
c002e204:	8d 83 94 4e ff ff    	lea    -0xb16c(%ebx),%eax
c002e20a:	50                   	push   %eax
c002e20b:	6a 48                	push   $0x48
c002e20d:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
c002e213:	50                   	push   %eax
c002e214:	e8 c1 ae ff ff       	call   c00290da <debug_panic>
            block_write(fs_device, sector, disk_inode);
c002e219:	83 ec 04             	sub    $0x4,%esp
c002e21c:	56                   	push   %esi
c002e21d:	ff 74 24 38          	pushl  0x38(%esp)
c002e221:	c7 c0 84 d0 03 c0    	mov    $0xc003d084,%eax
c002e227:	ff 30                	pushl  (%eax)
c002e229:	e8 5d 70 ff ff       	call   c002528b <block_write>
            if (sectors > 0) {
c002e22e:	83 c4 10             	add    $0x10,%esp
c002e231:	85 ed                	test   %ebp,%ebp
c002e233:	74 a5                	je     c002e1da <inode_create+0x6d>
                for (i = 0; i < sectors; i++)
c002e235:	bf 00 00 00 00       	mov    $0x0,%edi
                    block_write(fs_device, disk_inode->start + i, zeros);
c002e23a:	8d ab 38 1d 00 00    	lea    0x1d38(%ebx),%ebp
c002e240:	c7 c0 84 d0 03 c0    	mov    $0xc003d084,%eax
c002e246:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002e24a:	83 ec 04             	sub    $0x4,%esp
c002e24d:	55                   	push   %ebp
c002e24e:	89 f8                	mov    %edi,%eax
c002e250:	03 06                	add    (%esi),%eax
c002e252:	50                   	push   %eax
c002e253:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e257:	ff 30                	pushl  (%eax)
c002e259:	e8 2d 70 ff ff       	call   c002528b <block_write>
                for (i = 0; i < sectors; i++)
c002e25e:	83 c7 01             	add    $0x1,%edi
c002e261:	83 c4 10             	add    $0x10,%esp
c002e264:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002e268:	75 e0                	jne    c002e24a <inode_create+0xdd>
c002e26a:	e9 6b ff ff ff       	jmp    c002e1da <inode_create+0x6d>

c002e26f <inode_reopen>:
    return inode;
}

/* Reopens and returns INODE. */
struct inode *
inode_reopen(struct inode *inode) {
c002e26f:	8b 44 24 04          	mov    0x4(%esp),%eax
    if (inode != NULL)
c002e273:	85 c0                	test   %eax,%eax
c002e275:	74 04                	je     c002e27b <inode_reopen+0xc>
        inode->open_cnt++;
c002e277:	83 40 0c 01          	addl   $0x1,0xc(%eax)
    return inode;
}
c002e27b:	c3                   	ret    

c002e27c <inode_open>:
inode_open(block_sector_t sector) {
c002e27c:	55                   	push   %ebp
c002e27d:	57                   	push   %edi
c002e27e:	56                   	push   %esi
c002e27f:	53                   	push   %ebx
c002e280:	83 ec 18             	sub    $0x18,%esp
c002e283:	e8 70 0c 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e288:	81 c3 a0 ce 00 00    	add    $0xcea0,%ebx
c002e28e:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    for (e = list_begin(&open_inodes); e != list_end(&open_inodes);
c002e292:	8d 83 38 1f 00 00    	lea    0x1f38(%ebx),%eax
c002e298:	50                   	push   %eax
c002e299:	e8 61 af ff ff       	call   c00291ff <list_begin>
c002e29e:	89 c6                	mov    %eax,%esi
c002e2a0:	83 c4 10             	add    $0x10,%esp
c002e2a3:	8d ab 38 1f 00 00    	lea    0x1f38(%ebx),%ebp
c002e2a9:	83 ec 0c             	sub    $0xc,%esp
c002e2ac:	55                   	push   %ebp
c002e2ad:	e8 ef af ff ff       	call   c00292a1 <list_end>
c002e2b2:	83 c4 10             	add    $0x10,%esp
c002e2b5:	39 f0                	cmp    %esi,%eax
c002e2b7:	74 2b                	je     c002e2e4 <inode_open+0x68>
        if (inode->sector == sector) {
c002e2b9:	39 7e 08             	cmp    %edi,0x8(%esi)
c002e2bc:	74 10                	je     c002e2ce <inode_open+0x52>
         e = list_next(e)) {
c002e2be:	83 ec 0c             	sub    $0xc,%esp
c002e2c1:	56                   	push   %esi
c002e2c2:	e8 7d af ff ff       	call   c0029244 <list_next>
c002e2c7:	89 c6                	mov    %eax,%esi
c002e2c9:	83 c4 10             	add    $0x10,%esp
c002e2cc:	eb db                	jmp    c002e2a9 <inode_open+0x2d>
            inode_reopen(inode);
c002e2ce:	83 ec 0c             	sub    $0xc,%esp
c002e2d1:	56                   	push   %esi
c002e2d2:	e8 98 ff ff ff       	call   c002e26f <inode_reopen>
            return inode;
c002e2d7:	83 c4 10             	add    $0x10,%esp
}
c002e2da:	89 f0                	mov    %esi,%eax
c002e2dc:	83 c4 0c             	add    $0xc,%esp
c002e2df:	5b                   	pop    %ebx
c002e2e0:	5e                   	pop    %esi
c002e2e1:	5f                   	pop    %edi
c002e2e2:	5d                   	pop    %ebp
c002e2e3:	c3                   	ret    
    inode = malloc(sizeof *inode);
c002e2e4:	83 ec 0c             	sub    $0xc,%esp
c002e2e7:	68 18 02 00 00       	push   $0x218
c002e2ec:	e8 0a 5b ff ff       	call   c0023dfb <malloc>
c002e2f1:	89 c6                	mov    %eax,%esi
    if (inode == NULL)
c002e2f3:	83 c4 10             	add    $0x10,%esp
c002e2f6:	85 c0                	test   %eax,%eax
c002e2f8:	74 e0                	je     c002e2da <inode_open+0x5e>
    list_push_front(&open_inodes, &inode->elem);
c002e2fa:	83 ec 08             	sub    $0x8,%esp
c002e2fd:	50                   	push   %eax
c002e2fe:	8d 83 38 1f 00 00    	lea    0x1f38(%ebx),%eax
c002e304:	50                   	push   %eax
c002e305:	e8 65 b4 ff ff       	call   c002976f <list_push_front>
    inode->sector = sector;
c002e30a:	89 7e 08             	mov    %edi,0x8(%esi)
    inode->open_cnt = 1;
c002e30d:	c7 46 0c 01 00 00 00 	movl   $0x1,0xc(%esi)
    inode->deny_write_cnt = 0;
c002e314:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
    inode->removed = false;
c002e31b:	c6 46 10 00          	movb   $0x0,0x10(%esi)
    block_read(fs_device, inode->sector, &inode->data);
c002e31f:	83 c4 0c             	add    $0xc,%esp
c002e322:	8d 46 18             	lea    0x18(%esi),%eax
c002e325:	50                   	push   %eax
c002e326:	57                   	push   %edi
c002e327:	c7 c0 84 d0 03 c0    	mov    $0xc003d084,%eax
c002e32d:	ff 30                	pushl  (%eax)
c002e32f:	e8 23 6f ff ff       	call   c0025257 <block_read>
    return inode;
c002e334:	83 c4 10             	add    $0x10,%esp
c002e337:	eb a1                	jmp    c002e2da <inode_open+0x5e>

c002e339 <inode_get_inumber>:

/* Returns INODE's inode number. */
block_sector_t
inode_get_inumber(const struct inode *inode) {
    return inode->sector;
c002e339:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e33d:	8b 40 08             	mov    0x8(%eax),%eax
}
c002e340:	c3                   	ret    

c002e341 <inode_close>:

/* Closes INODE and writes it to disk.
   If this was the last reference to INODE, frees its memory.
   If INODE was also a removed inode, frees its blocks. */
void
inode_close(struct inode *inode) {
c002e341:	56                   	push   %esi
c002e342:	53                   	push   %ebx
c002e343:	83 ec 04             	sub    $0x4,%esp
c002e346:	e8 ad 0b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e34b:	81 c3 dd cd 00 00    	add    $0xcddd,%ebx
c002e351:	8b 74 24 10          	mov    0x10(%esp),%esi
    /* Ignore null pointer. */
    if (inode == NULL)
c002e355:	85 f6                	test   %esi,%esi
c002e357:	74 0b                	je     c002e364 <inode_close+0x23>
        return;

    /* Release resources if this was the last opener. */
    if (--inode->open_cnt == 0) {
c002e359:	8b 46 0c             	mov    0xc(%esi),%eax
c002e35c:	83 e8 01             	sub    $0x1,%eax
c002e35f:	89 46 0c             	mov    %eax,0xc(%esi)
c002e362:	74 06                	je     c002e36a <inode_close+0x29>
                             bytes_to_sectors(inode->data.length));
        }

        free(inode);
    }
}
c002e364:	83 c4 04             	add    $0x4,%esp
c002e367:	5b                   	pop    %ebx
c002e368:	5e                   	pop    %esi
c002e369:	c3                   	ret    
        list_remove(&inode->elem);
c002e36a:	83 ec 0c             	sub    $0xc,%esp
c002e36d:	56                   	push   %esi
c002e36e:	e8 36 b4 ff ff       	call   c00297a9 <list_remove>
        if (inode->removed) {
c002e373:	83 c4 10             	add    $0x10,%esp
c002e376:	80 7e 10 00          	cmpb   $0x0,0x10(%esi)
c002e37a:	75 0e                	jne    c002e38a <inode_close+0x49>
        free(inode);
c002e37c:	83 ec 0c             	sub    $0xc,%esp
c002e37f:	56                   	push   %esi
c002e380:	e8 24 5c ff ff       	call   c0023fa9 <free>
c002e385:	83 c4 10             	add    $0x10,%esp
c002e388:	eb da                	jmp    c002e364 <inode_close+0x23>
            free_map_release(inode->sector, 1);
c002e38a:	83 ec 08             	sub    $0x8,%esp
c002e38d:	6a 01                	push   $0x1
c002e38f:	ff 76 08             	pushl  0x8(%esi)
c002e392:	e8 f9 f2 ff ff       	call   c002d690 <free_map_release>
            free_map_release(inode->data.start,
c002e397:	83 c4 08             	add    $0x8,%esp
    return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002e39a:	8b 56 1c             	mov    0x1c(%esi),%edx
c002e39d:	8d 8a ff 01 00 00    	lea    0x1ff(%edx),%ecx
c002e3a3:	8d 82 fe 03 00 00    	lea    0x3fe(%edx),%eax
c002e3a9:	85 c9                	test   %ecx,%ecx
c002e3ab:	0f 49 c1             	cmovns %ecx,%eax
c002e3ae:	c1 f8 09             	sar    $0x9,%eax
            free_map_release(inode->data.start,
c002e3b1:	50                   	push   %eax
c002e3b2:	ff 76 18             	pushl  0x18(%esi)
c002e3b5:	e8 d6 f2 ff ff       	call   c002d690 <free_map_release>
c002e3ba:	83 c4 10             	add    $0x10,%esp
c002e3bd:	eb bd                	jmp    c002e37c <inode_close+0x3b>

c002e3bf <inode_remove>:

/* Marks INODE to be deleted when it is closed by the last caller who
   has it open. */
void
inode_remove(struct inode *inode) {
c002e3bf:	53                   	push   %ebx
c002e3c0:	83 ec 08             	sub    $0x8,%esp
c002e3c3:	e8 30 0b 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e3c8:	81 c3 60 cd 00 00    	add    $0xcd60,%ebx
c002e3ce:	8b 44 24 10          	mov    0x10(%esp),%eax
    ASSERT (inode != NULL);
c002e3d2:	85 c0                	test   %eax,%eax
c002e3d4:	74 09                	je     c002e3df <inode_remove+0x20>
    inode->removed = true;
c002e3d6:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c002e3da:	83 c4 08             	add    $0x8,%esp
c002e3dd:	5b                   	pop    %ebx
c002e3de:	c3                   	ret    
    ASSERT (inode != NULL);
c002e3df:	83 ec 0c             	sub    $0xc,%esp
c002e3e2:	8d 83 c2 73 ff ff    	lea    -0x8c3e(%ebx),%eax
c002e3e8:	50                   	push   %eax
c002e3e9:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002e3ef:	50                   	push   %eax
c002e3f0:	8d 83 84 4e ff ff    	lea    -0xb17c(%ebx),%eax
c002e3f6:	50                   	push   %eax
c002e3f7:	68 af 00 00 00       	push   $0xaf
c002e3fc:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
c002e402:	50                   	push   %eax
c002e403:	e8 d2 ac ff ff       	call   c00290da <debug_panic>

c002e408 <inode_read_at>:

/* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
   Returns the number of bytes actually read, which may be less
   than SIZE if an error occurs or end of file is reached. */
off_t
inode_read_at(struct inode *inode, void *buffer_, off_t size, off_t offset) {
c002e408:	55                   	push   %ebp
c002e409:	89 e5                	mov    %esp,%ebp
c002e40b:	57                   	push   %edi
c002e40c:	56                   	push   %esi
c002e40d:	53                   	push   %ebx
c002e40e:	83 ec 2c             	sub    $0x2c,%esp
c002e411:	e8 e2 0a 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e416:	81 c3 12 cd 00 00    	add    $0xcd12,%ebx
    uint8_t *buffer = buffer_;
    off_t bytes_read = 0;
    uint8_t *bounce = NULL;

    while (size > 0) {
c002e41c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e420:	0f 8e 56 01 00 00    	jle    c002e57c <inode_read_at+0x174>
    uint8_t *bounce = NULL;
c002e426:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    off_t bytes_read = 0;
c002e42d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            if (bounce == NULL) {
                bounce = malloc(BLOCK_SECTOR_SIZE);
                if (bounce == NULL)
                    break;
            }
            block_read(fs_device, sector_idx, bounce);
c002e434:	c7 c0 84 d0 03 c0    	mov    $0xc003d084,%eax
c002e43a:	89 45 d8             	mov    %eax,-0x28(%ebp)
            block_read(fs_device, sector_idx, buffer + bytes_read);
c002e43d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c002e440:	e9 83 00 00 00       	jmp    c002e4c8 <inode_read_at+0xc0>
c002e445:	83 ec 04             	sub    $0x4,%esp
c002e448:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e44b:	03 45 0c             	add    0xc(%ebp),%eax
c002e44e:	50                   	push   %eax
c002e44f:	57                   	push   %edi
c002e450:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e453:	ff 30                	pushl  (%eax)
c002e455:	e8 fd 6d ff ff       	call   c0025257 <block_read>
c002e45a:	83 c4 10             	add    $0x10,%esp
c002e45d:	eb 57                	jmp    c002e4b6 <inode_read_at+0xae>
                bounce = malloc(BLOCK_SECTOR_SIZE);
c002e45f:	83 ec 0c             	sub    $0xc,%esp
c002e462:	68 00 02 00 00       	push   $0x200
c002e467:	e8 8f 59 ff ff       	call   c0023dfb <malloc>
c002e46c:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (bounce == NULL)
c002e46f:	83 c4 10             	add    $0x10,%esp
c002e472:	85 c0                	test   %eax,%eax
c002e474:	0f 85 b1 00 00 00    	jne    c002e52b <inode_read_at+0x123>
        /* Advance. */
        size -= chunk_size;
        offset += chunk_size;
        bytes_read += chunk_size;
    }
    free(bounce);
c002e47a:	83 ec 0c             	sub    $0xc,%esp
c002e47d:	ff 75 e0             	pushl  -0x20(%ebp)
c002e480:	e8 24 5b ff ff       	call   c0023fa9 <free>

    return bytes_read;
c002e485:	83 c4 10             	add    $0x10,%esp
}
c002e488:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e48b:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e48e:	5b                   	pop    %ebx
c002e48f:	5e                   	pop    %esi
c002e490:	5f                   	pop    %edi
c002e491:	5d                   	pop    %ebp
c002e492:	c3                   	ret    
            memcpy(buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002e493:	8b 06                	mov    (%esi),%eax
c002e495:	89 01                	mov    %eax,(%ecx)
c002e497:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e49a:	8b 44 32 fc          	mov    -0x4(%edx,%esi,1),%eax
c002e49e:	89 44 0a fc          	mov    %eax,-0x4(%edx,%ecx,1)
c002e4a2:	8d 79 04             	lea    0x4(%ecx),%edi
c002e4a5:	83 e7 fc             	and    $0xfffffffc,%edi
c002e4a8:	29 f9                	sub    %edi,%ecx
c002e4aa:	29 ce                	sub    %ecx,%esi
c002e4ac:	01 d1                	add    %edx,%ecx
c002e4ae:	c1 e9 02             	shr    $0x2,%ecx
c002e4b1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c002e4b3:	83 c4 10             	add    $0x10,%esp
        size -= chunk_size;
c002e4b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e4b9:	29 45 10             	sub    %eax,0x10(%ebp)
        offset += chunk_size;
c002e4bc:	01 45 14             	add    %eax,0x14(%ebp)
        bytes_read += chunk_size;
c002e4bf:	01 45 dc             	add    %eax,-0x24(%ebp)
    while (size > 0) {
c002e4c2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e4c6:	7e b2                	jle    c002e47a <inode_read_at+0x72>
        block_sector_t sector_idx = byte_to_sector(inode, offset);
c002e4c8:	8b 55 14             	mov    0x14(%ebp),%edx
c002e4cb:	8b 45 08             	mov    0x8(%ebp),%eax
c002e4ce:	e8 1f fc ff ff       	call   c002e0f2 <byte_to_sector>
c002e4d3:	89 c7                	mov    %eax,%edi
        int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e4d5:	8b 45 14             	mov    0x14(%ebp),%eax
c002e4d8:	c1 f8 1f             	sar    $0x1f,%eax
c002e4db:	c1 e8 17             	shr    $0x17,%eax
c002e4de:	89 c6                	mov    %eax,%esi
c002e4e0:	03 75 14             	add    0x14(%ebp),%esi
c002e4e3:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
c002e4e9:	29 c6                	sub    %eax,%esi
        off_t inode_left = inode_length(inode) - offset;
c002e4eb:	8b 45 08             	mov    0x8(%ebp),%eax
c002e4ee:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e4f1:	2b 45 14             	sub    0x14(%ebp),%eax
        int chunk_size = size < min_left ? size : min_left;
c002e4f4:	3b 45 10             	cmp    0x10(%ebp),%eax
c002e4f7:	0f 4f 45 10          	cmovg  0x10(%ebp),%eax
        int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002e4fb:	ba 00 02 00 00       	mov    $0x200,%edx
c002e500:	29 f2                	sub    %esi,%edx
        int chunk_size = size < min_left ? size : min_left;
c002e502:	39 d0                	cmp    %edx,%eax
c002e504:	0f 4f c2             	cmovg  %edx,%eax
c002e507:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (chunk_size <= 0)
c002e50a:	85 c0                	test   %eax,%eax
c002e50c:	0f 8e 68 ff ff ff    	jle    c002e47a <inode_read_at+0x72>
        if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE) {
c002e512:	85 f6                	test   %esi,%esi
c002e514:	75 0b                	jne    c002e521 <inode_read_at+0x119>
c002e516:	3d 00 02 00 00       	cmp    $0x200,%eax
c002e51b:	0f 84 24 ff ff ff    	je     c002e445 <inode_read_at+0x3d>
            if (bounce == NULL) {
c002e521:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002e525:	0f 84 34 ff ff ff    	je     c002e45f <inode_read_at+0x57>
            block_read(fs_device, sector_idx, bounce);
c002e52b:	83 ec 04             	sub    $0x4,%esp
c002e52e:	ff 75 e0             	pushl  -0x20(%ebp)
c002e531:	57                   	push   %edi
c002e532:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c002e535:	ff 31                	pushl  (%ecx)
c002e537:	e8 1b 6d ff ff       	call   c0025257 <block_read>
            memcpy(buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002e53c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c002e53f:	03 4d 0c             	add    0xc(%ebp),%ecx
c002e542:	03 75 e0             	add    -0x20(%ebp),%esi
c002e545:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c002e548:	83 ff 04             	cmp    $0x4,%edi
c002e54b:	0f 83 42 ff ff ff    	jae    c002e493 <inode_read_at+0x8b>
c002e551:	85 ff                	test   %edi,%edi
c002e553:	0f 84 5a ff ff ff    	je     c002e4b3 <inode_read_at+0xab>
c002e559:	0f b6 06             	movzbl (%esi),%eax
c002e55c:	88 01                	mov    %al,(%ecx)
c002e55e:	f7 c7 02 00 00 00    	test   $0x2,%edi
c002e564:	0f 84 49 ff ff ff    	je     c002e4b3 <inode_read_at+0xab>
c002e56a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c002e56d:	0f b7 44 37 fe       	movzwl -0x2(%edi,%esi,1),%eax
c002e572:	66 89 44 0f fe       	mov    %ax,-0x2(%edi,%ecx,1)
c002e577:	e9 37 ff ff ff       	jmp    c002e4b3 <inode_read_at+0xab>
    off_t bytes_read = 0;
c002e57c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    uint8_t *bounce = NULL;
c002e583:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c002e58a:	e9 eb fe ff ff       	jmp    c002e47a <inode_read_at+0x72>

c002e58f <inode_write_at>:
   less than SIZE if end of file is reached or an error occurs.
   (Normally a write at end of file would extend the inode, but
   growth is not yet implemented.) */
off_t
inode_write_at(struct inode *inode, const void *buffer_, off_t size,
               off_t offset) {
c002e58f:	55                   	push   %ebp
c002e590:	57                   	push   %edi
c002e591:	56                   	push   %esi
c002e592:	53                   	push   %ebx
c002e593:	83 ec 2c             	sub    $0x2c,%esp
c002e596:	e8 5d 09 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e59b:	81 c3 8d cb 00 00    	add    $0xcb8d,%ebx
    const uint8_t *buffer = buffer_;
    off_t bytes_written = 0;
    uint8_t *bounce = NULL;

    if (inode->deny_write_cnt)
c002e5a1:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e5a5:	8b 40 14             	mov    0x14(%eax),%eax
c002e5a8:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002e5ac:	85 c0                	test   %eax,%eax
c002e5ae:	0f 85 bc 01 00 00    	jne    c002e770 <inode_write_at+0x1e1>
        return 0;

    while (size > 0) {
c002e5b4:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002e5b9:	0f 8e a4 01 00 00    	jle    c002e763 <inode_write_at+0x1d4>
    uint8_t *bounce = NULL;
c002e5bf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e5c6:	00 
            if (sector_ofs > 0 || chunk_size < sector_left)
                block_read(fs_device, sector_idx, bounce);
            else
                memset(bounce, 0, BLOCK_SECTOR_SIZE);
            memcpy(bounce + sector_ofs, buffer + bytes_written, chunk_size);
            block_write(fs_device, sector_idx, bounce);
c002e5c7:	c7 c0 84 d0 03 c0    	mov    $0xc003d084,%eax
c002e5cd:	89 44 24 18          	mov    %eax,0x18(%esp)
                block_read(fs_device, sector_idx, bounce);
c002e5d1:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002e5d5:	e9 f0 00 00 00       	jmp    c002e6ca <inode_write_at+0x13b>
            block_write(fs_device, sector_idx, buffer + bytes_written);
c002e5da:	83 ec 04             	sub    $0x4,%esp
c002e5dd:	8b 44 24 10          	mov    0x10(%esp),%eax
c002e5e1:	03 44 24 48          	add    0x48(%esp),%eax
c002e5e5:	50                   	push   %eax
c002e5e6:	52                   	push   %edx
c002e5e7:	c7 c0 84 d0 03 c0    	mov    $0xc003d084,%eax
c002e5ed:	ff 30                	pushl  (%eax)
c002e5ef:	e8 97 6c ff ff       	call   c002528b <block_write>
c002e5f4:	83 c4 10             	add    $0x10,%esp
c002e5f7:	e9 b7 00 00 00       	jmp    c002e6b3 <inode_write_at+0x124>
                bounce = malloc(BLOCK_SECTOR_SIZE);
c002e5fc:	83 ec 0c             	sub    $0xc,%esp
c002e5ff:	68 00 02 00 00       	push   $0x200
c002e604:	e8 f2 57 ff ff       	call   c0023dfb <malloc>
c002e609:	89 44 24 18          	mov    %eax,0x18(%esp)
                if (bounce == NULL)
c002e60d:	83 c4 10             	add    $0x10,%esp
c002e610:	85 c0                	test   %eax,%eax
c002e612:	0f 85 26 01 00 00    	jne    c002e73e <inode_write_at+0x1af>
        /* Advance. */
        size -= chunk_size;
        offset += chunk_size;
        bytes_written += chunk_size;
    }
    free(bounce);
c002e618:	83 ec 0c             	sub    $0xc,%esp
c002e61b:	ff 74 24 14          	pushl  0x14(%esp)
c002e61f:	e8 85 59 ff ff       	call   c0023fa9 <free>

    return bytes_written;
c002e624:	83 c4 10             	add    $0x10,%esp
}
c002e627:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002e62b:	83 c4 2c             	add    $0x2c,%esp
c002e62e:	5b                   	pop    %ebx
c002e62f:	5e                   	pop    %esi
c002e630:	5f                   	pop    %edi
c002e631:	5d                   	pop    %ebp
c002e632:	c3                   	ret    
                block_read(fs_device, sector_idx, bounce);
c002e633:	83 ec 04             	sub    $0x4,%esp
c002e636:	ff 74 24 0c          	pushl  0xc(%esp)
c002e63a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e63e:	8b 44 24 28          	mov    0x28(%esp),%eax
c002e642:	ff 30                	pushl  (%eax)
c002e644:	e8 0e 6c ff ff       	call   c0025257 <block_read>
c002e649:	83 c4 10             	add    $0x10,%esp
            memcpy(bounce + sector_ofs, buffer + bytes_written, chunk_size);
c002e64c:	8b 44 24 08          	mov    0x8(%esp),%eax
c002e650:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
c002e653:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002e657:	03 74 24 44          	add    0x44(%esp),%esi
c002e65b:	83 fd 04             	cmp    $0x4,%ebp
c002e65e:	73 1d                	jae    c002e67d <inode_write_at+0xee>
c002e660:	85 ed                	test   %ebp,%ebp
c002e662:	74 36                	je     c002e69a <inode_write_at+0x10b>
c002e664:	0f b6 06             	movzbl (%esi),%eax
c002e667:	88 01                	mov    %al,(%ecx)
c002e669:	f7 c5 02 00 00 00    	test   $0x2,%ebp
c002e66f:	74 29                	je     c002e69a <inode_write_at+0x10b>
c002e671:	0f b7 44 35 fe       	movzwl -0x2(%ebp,%esi,1),%eax
c002e676:	66 89 44 0d fe       	mov    %ax,-0x2(%ebp,%ecx,1)
c002e67b:	eb 1d                	jmp    c002e69a <inode_write_at+0x10b>
c002e67d:	8b 06                	mov    (%esi),%eax
c002e67f:	89 01                	mov    %eax,(%ecx)
c002e681:	8b 44 35 fc          	mov    -0x4(%ebp,%esi,1),%eax
c002e685:	89 44 0d fc          	mov    %eax,-0x4(%ebp,%ecx,1)
c002e689:	8d 79 04             	lea    0x4(%ecx),%edi
c002e68c:	83 e7 fc             	and    $0xfffffffc,%edi
c002e68f:	29 f9                	sub    %edi,%ecx
c002e691:	29 ce                	sub    %ecx,%esi
c002e693:	01 e9                	add    %ebp,%ecx
c002e695:	c1 e9 02             	shr    $0x2,%ecx
c002e698:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
            block_write(fs_device, sector_idx, bounce);
c002e69a:	83 ec 04             	sub    $0x4,%esp
c002e69d:	ff 74 24 0c          	pushl  0xc(%esp)
c002e6a1:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e6a5:	8b 44 24 24          	mov    0x24(%esp),%eax
c002e6a9:	ff 30                	pushl  (%eax)
c002e6ab:	e8 db 6b ff ff       	call   c002528b <block_write>
c002e6b0:	83 c4 10             	add    $0x10,%esp
        size -= chunk_size;
c002e6b3:	29 6c 24 48          	sub    %ebp,0x48(%esp)
        offset += chunk_size;
c002e6b7:	01 6c 24 4c          	add    %ebp,0x4c(%esp)
        bytes_written += chunk_size;
c002e6bb:	01 6c 24 0c          	add    %ebp,0xc(%esp)
    while (size > 0) {
c002e6bf:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002e6c4:	0f 8e 4e ff ff ff    	jle    c002e618 <inode_write_at+0x89>
        block_sector_t sector_idx = byte_to_sector(inode, offset);
c002e6ca:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c002e6ce:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e6d2:	e8 1b fa ff ff       	call   c002e0f2 <byte_to_sector>
c002e6d7:	89 c2                	mov    %eax,%edx
c002e6d9:	89 44 24 14          	mov    %eax,0x14(%esp)
        int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e6dd:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002e6e1:	c1 f8 1f             	sar    $0x1f,%eax
c002e6e4:	c1 e8 17             	shr    $0x17,%eax
c002e6e7:	89 c6                	mov    %eax,%esi
c002e6e9:	03 74 24 4c          	add    0x4c(%esp),%esi
c002e6ed:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
c002e6f3:	29 c6                	sub    %eax,%esi
        int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002e6f5:	bf 00 02 00 00       	mov    $0x200,%edi
c002e6fa:	29 f7                	sub    %esi,%edi
        off_t inode_left = inode_length(inode) - offset;
c002e6fc:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e700:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e703:	89 44 24 10          	mov    %eax,0x10(%esp)
c002e707:	89 c5                	mov    %eax,%ebp
c002e709:	2b 6c 24 4c          	sub    0x4c(%esp),%ebp
        int chunk_size = size < min_left ? size : min_left;
c002e70d:	3b 6c 24 48          	cmp    0x48(%esp),%ebp
c002e711:	0f 4f 6c 24 48       	cmovg  0x48(%esp),%ebp
c002e716:	39 fd                	cmp    %edi,%ebp
c002e718:	0f 4f ef             	cmovg  %edi,%ebp
        if (chunk_size <= 0)
c002e71b:	85 ed                	test   %ebp,%ebp
c002e71d:	0f 8e f5 fe ff ff    	jle    c002e618 <inode_write_at+0x89>
        if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE) {
c002e723:	85 f6                	test   %esi,%esi
c002e725:	75 0c                	jne    c002e733 <inode_write_at+0x1a4>
c002e727:	81 fd 00 02 00 00    	cmp    $0x200,%ebp
c002e72d:	0f 84 a7 fe ff ff    	je     c002e5da <inode_write_at+0x4b>
            if (bounce == NULL) {
c002e733:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002e738:	0f 84 be fe ff ff    	je     c002e5fc <inode_write_at+0x6d>
            if (sector_ofs > 0 || chunk_size < sector_left)
c002e73e:	85 f6                	test   %esi,%esi
c002e740:	0f 8f ed fe ff ff    	jg     c002e633 <inode_write_at+0xa4>
c002e746:	39 ef                	cmp    %ebp,%edi
c002e748:	0f 8f e5 fe ff ff    	jg     c002e633 <inode_write_at+0xa4>
                memset(bounce, 0, BLOCK_SECTOR_SIZE);
c002e74e:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e753:	b8 00 00 00 00       	mov    $0x0,%eax
c002e758:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002e75c:	f3 ab                	rep stos %eax,%es:(%edi)
c002e75e:	e9 e9 fe ff ff       	jmp    c002e64c <inode_write_at+0xbd>
    uint8_t *bounce = NULL;
c002e763:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e76a:	00 
c002e76b:	e9 a8 fe ff ff       	jmp    c002e618 <inode_write_at+0x89>
        return 0;
c002e770:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002e777:	00 
c002e778:	e9 aa fe ff ff       	jmp    c002e627 <inode_write_at+0x98>

c002e77d <inode_deny_write>:

/* Disables writes to INODE.
   May be called at most once per inode opener. */
void
inode_deny_write(struct inode *inode) {
c002e77d:	53                   	push   %ebx
c002e77e:	83 ec 08             	sub    $0x8,%esp
c002e781:	e8 72 07 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e786:	81 c3 a2 c9 00 00    	add    $0xc9a2,%ebx
c002e78c:	8b 54 24 10          	mov    0x10(%esp),%edx
    inode->deny_write_cnt++;
c002e790:	8b 42 14             	mov    0x14(%edx),%eax
c002e793:	83 c0 01             	add    $0x1,%eax
c002e796:	89 42 14             	mov    %eax,0x14(%edx)
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e799:	3b 42 0c             	cmp    0xc(%edx),%eax
c002e79c:	7f 05                	jg     c002e7a3 <inode_deny_write+0x26>
}
c002e79e:	83 c4 08             	add    $0x8,%esp
c002e7a1:	5b                   	pop    %ebx
c002e7a2:	c3                   	ret    
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e7a3:	83 ec 0c             	sub    $0xc,%esp
c002e7a6:	8d 83 0c 74 ff ff    	lea    -0x8bf4(%ebx),%eax
c002e7ac:	50                   	push   %eax
c002e7ad:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002e7b3:	50                   	push   %eax
c002e7b4:	8d 83 60 4e ff ff    	lea    -0xb1a0(%ebx),%eax
c002e7ba:	50                   	push   %eax
c002e7bb:	68 27 01 00 00       	push   $0x127
c002e7c0:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
c002e7c6:	50                   	push   %eax
c002e7c7:	e8 0e a9 ff ff       	call   c00290da <debug_panic>

c002e7cc <inode_allow_write>:

/* Re-enables writes to INODE.
   Must be called once by each inode opener who has called
   inode_deny_write() on the inode, before closing the inode. */
void
inode_allow_write(struct inode *inode) {
c002e7cc:	53                   	push   %ebx
c002e7cd:	83 ec 08             	sub    $0x8,%esp
c002e7d0:	e8 23 07 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e7d5:	81 c3 53 c9 00 00    	add    $0xc953,%ebx
c002e7db:	8b 54 24 10          	mov    0x10(%esp),%edx
    ASSERT (inode->deny_write_cnt > 0);
c002e7df:	8b 42 14             	mov    0x14(%edx),%eax
c002e7e2:	85 c0                	test   %eax,%eax
c002e7e4:	7e 10                	jle    c002e7f6 <inode_allow_write+0x2a>
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e7e6:	3b 42 0c             	cmp    0xc(%edx),%eax
c002e7e9:	7f 34                	jg     c002e81f <inode_allow_write+0x53>
    inode->deny_write_cnt--;
c002e7eb:	83 e8 01             	sub    $0x1,%eax
c002e7ee:	89 42 14             	mov    %eax,0x14(%edx)
}
c002e7f1:	83 c4 08             	add    $0x8,%esp
c002e7f4:	5b                   	pop    %ebx
c002e7f5:	c3                   	ret    
    ASSERT (inode->deny_write_cnt > 0);
c002e7f6:	83 ec 0c             	sub    $0xc,%esp
c002e7f9:	8d 83 f2 73 ff ff    	lea    -0x8c0e(%ebx),%eax
c002e7ff:	50                   	push   %eax
c002e800:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002e806:	50                   	push   %eax
c002e807:	8d 83 4c 4e ff ff    	lea    -0xb1b4(%ebx),%eax
c002e80d:	50                   	push   %eax
c002e80e:	68 2f 01 00 00       	push   $0x12f
c002e813:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
c002e819:	50                   	push   %eax
c002e81a:	e8 bb a8 ff ff       	call   c00290da <debug_panic>
    ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e81f:	83 ec 0c             	sub    $0xc,%esp
c002e822:	8d 83 0c 74 ff ff    	lea    -0x8bf4(%ebx),%eax
c002e828:	50                   	push   %eax
c002e829:	8d 83 94 4f ff ff    	lea    -0xb06c(%ebx),%eax
c002e82f:	50                   	push   %eax
c002e830:	8d 83 4c 4e ff ff    	lea    -0xb1b4(%ebx),%eax
c002e836:	50                   	push   %eax
c002e837:	68 30 01 00 00       	push   $0x130
c002e83c:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
c002e842:	50                   	push   %eax
c002e843:	e8 92 a8 ff ff       	call   c00290da <debug_panic>

c002e848 <inode_length>:

/* Returns the length, in bytes, of INODE's data. */
off_t
inode_length(const struct inode *inode) {
    return inode->data.length;
c002e848:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e84c:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002e84f:	c3                   	ret    

c002e850 <fsutil_ls>:
#include "threads/palloc.h"
#include "threads/vaddr.h"

/* List files in the root directory. */
void
fsutil_ls(char **argv UNUSED) {
c002e850:	57                   	push   %edi
c002e851:	56                   	push   %esi
c002e852:	53                   	push   %ebx
c002e853:	83 ec 1c             	sub    $0x1c,%esp
c002e856:	e8 9d 06 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e85b:	81 c3 cd c8 00 00    	add    $0xc8cd,%ebx
    struct dir *dir;
    char name[NAME_MAX + 1];

    printf("Files in the root directory:\n");
c002e861:	8d 83 35 74 ff ff    	lea    -0x8bcb(%ebx),%eax
c002e867:	50                   	push   %eax
c002e868:	e8 43 c8 ff ff       	call   c002b0b0 <puts>
    dir = dir_open_root();
c002e86d:	e8 c2 f4 ff ff       	call   c002dd34 <dir_open_root>
    if (dir == NULL)
c002e872:	83 c4 10             	add    $0x10,%esp
c002e875:	85 c0                	test   %eax,%eax
c002e877:	74 25                	je     c002e89e <fsutil_ls+0x4e>
c002e879:	89 c7                	mov    %eax,%edi
        PANIC ("root dir open failed");
    while (dir_readdir(dir, name))
c002e87b:	8d 74 24 01          	lea    0x1(%esp),%esi
c002e87f:	83 ec 08             	sub    $0x8,%esp
c002e882:	56                   	push   %esi
c002e883:	57                   	push   %edi
c002e884:	e8 04 f8 ff ff       	call   c002e08d <dir_readdir>
c002e889:	83 c4 10             	add    $0x10,%esp
c002e88c:	84 c0                	test   %al,%al
c002e88e:	74 2a                	je     c002e8ba <fsutil_ls+0x6a>
        printf("%s\n", name);
c002e890:	83 ec 0c             	sub    $0xc,%esp
c002e893:	56                   	push   %esi
c002e894:	e8 17 c8 ff ff       	call   c002b0b0 <puts>
c002e899:	83 c4 10             	add    $0x10,%esp
c002e89c:	eb e1                	jmp    c002e87f <fsutil_ls+0x2f>
        PANIC ("root dir open failed");
c002e89e:	8d 83 52 74 ff ff    	lea    -0x8bae(%ebx),%eax
c002e8a4:	50                   	push   %eax
c002e8a5:	8d 83 dc 4e ff ff    	lea    -0xb124(%ebx),%eax
c002e8ab:	50                   	push   %eax
c002e8ac:	6a 17                	push   $0x17
c002e8ae:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002e8b4:	50                   	push   %eax
c002e8b5:	e8 20 a8 ff ff       	call   c00290da <debug_panic>
    dir_close(dir);
c002e8ba:	83 ec 0c             	sub    $0xc,%esp
c002e8bd:	57                   	push   %edi
c002e8be:	e8 bb f4 ff ff       	call   c002dd7e <dir_close>
    printf("End of listing.\n");
c002e8c3:	8d 83 7e 74 ff ff    	lea    -0x8b82(%ebx),%eax
c002e8c9:	89 04 24             	mov    %eax,(%esp)
c002e8cc:	e8 df c7 ff ff       	call   c002b0b0 <puts>
}
c002e8d1:	83 c4 20             	add    $0x20,%esp
c002e8d4:	5b                   	pop    %ebx
c002e8d5:	5e                   	pop    %esi
c002e8d6:	5f                   	pop    %edi
c002e8d7:	c3                   	ret    

c002e8d8 <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void
fsutil_cat(char **argv) {
c002e8d8:	55                   	push   %ebp
c002e8d9:	57                   	push   %edi
c002e8da:	56                   	push   %esi
c002e8db:	53                   	push   %ebx
c002e8dc:	83 ec 14             	sub    $0x14,%esp
c002e8df:	e8 14 06 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e8e4:	81 c3 44 c8 00 00    	add    $0xc844,%ebx
    const char *file_name = argv[1];
c002e8ea:	8b 44 24 28          	mov    0x28(%esp),%eax
c002e8ee:	8b 78 04             	mov    0x4(%eax),%edi

    struct file *file;
    char *buffer;

    printf("Printing '%s' to the console...\n", file_name);
c002e8f1:	57                   	push   %edi
c002e8f2:	8d 83 58 75 ff ff    	lea    -0x8aa8(%ebx),%eax
c002e8f8:	50                   	push   %eax
c002e8f9:	e8 80 8b ff ff       	call   c002747e <printf>
    file = filesys_open(file_name);
c002e8fe:	89 3c 24             	mov    %edi,(%esp)
c002e901:	e8 0f ec ff ff       	call   c002d515 <filesys_open>
    if (file == NULL)
c002e906:	83 c4 10             	add    $0x10,%esp
c002e909:	85 c0                	test   %eax,%eax
c002e90b:	74 41                	je     c002e94e <fsutil_cat+0x76>
c002e90d:	89 c6                	mov    %eax,%esi
        PANIC ("%s: open failed", file_name);
    buffer = palloc_get_page(PAL_ASSERT);
c002e90f:	83 ec 0c             	sub    $0xc,%esp
c002e912:	6a 01                	push   $0x1
c002e914:	e8 d0 50 ff ff       	call   c00239e9 <palloc_get_page>
c002e919:	89 c7                	mov    %eax,%edi
c002e91b:	83 c4 10             	add    $0x10,%esp
    for (;;) {
        off_t pos = file_tell(file);
c002e91e:	83 ec 0c             	sub    $0xc,%esp
c002e921:	56                   	push   %esi
c002e922:	e8 32 f2 ff ff       	call   c002db59 <file_tell>
c002e927:	89 c5                	mov    %eax,%ebp
        off_t n = file_read(file, buffer, PGSIZE);
c002e929:	83 c4 0c             	add    $0xc,%esp
c002e92c:	68 00 10 00 00       	push   $0x1000
c002e931:	57                   	push   %edi
c002e932:	56                   	push   %esi
c002e933:	e8 b3 ef ff ff       	call   c002d8eb <file_read>
        if (n == 0)
c002e938:	83 c4 10             	add    $0x10,%esp
c002e93b:	85 c0                	test   %eax,%eax
c002e93d:	74 2f                	je     c002e96e <fsutil_cat+0x96>
            break;

        hex_dump(pos, buffer, n, true);
c002e93f:	6a 01                	push   $0x1
c002e941:	50                   	push   %eax
c002e942:	57                   	push   %edi
c002e943:	55                   	push   %ebp
c002e944:	e8 e3 92 ff ff       	call   c0027c2c <hex_dump>
    for (;;) {
c002e949:	83 c4 10             	add    $0x10,%esp
c002e94c:	eb d0                	jmp    c002e91e <fsutil_cat+0x46>
        PANIC ("%s: open failed", file_name);
c002e94e:	83 ec 0c             	sub    $0xc,%esp
c002e951:	57                   	push   %edi
c002e952:	8d 83 8e 74 ff ff    	lea    -0x8b72(%ebx),%eax
c002e958:	50                   	push   %eax
c002e959:	8d 83 d0 4e ff ff    	lea    -0xb130(%ebx),%eax
c002e95f:	50                   	push   %eax
c002e960:	6a 2a                	push   $0x2a
c002e962:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002e968:	50                   	push   %eax
c002e969:	e8 6c a7 ff ff       	call   c00290da <debug_panic>
    }
    palloc_free_page(buffer);
c002e96e:	83 ec 0c             	sub    $0xc,%esp
c002e971:	57                   	push   %edi
c002e972:	e8 dd 51 ff ff       	call   c0023b54 <palloc_free_page>
    file_close(file);
c002e977:	89 34 24             	mov    %esi,(%esp)
c002e97a:	e8 d6 f0 ff ff       	call   c002da55 <file_close>
}
c002e97f:	83 c4 1c             	add    $0x1c,%esp
c002e982:	5b                   	pop    %ebx
c002e983:	5e                   	pop    %esi
c002e984:	5f                   	pop    %edi
c002e985:	5d                   	pop    %ebp
c002e986:	c3                   	ret    

c002e987 <fsutil_rm>:

/* Deletes file ARGV[1]. */
void
fsutil_rm(char **argv) {
c002e987:	56                   	push   %esi
c002e988:	53                   	push   %ebx
c002e989:	83 ec 0c             	sub    $0xc,%esp
c002e98c:	e8 67 05 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e991:	81 c3 97 c7 00 00    	add    $0xc797,%ebx
    const char *file_name = argv[1];
c002e997:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e99b:	8b 70 04             	mov    0x4(%eax),%esi

    printf("Deleting '%s'...\n", file_name);
c002e99e:	56                   	push   %esi
c002e99f:	8d 83 9e 74 ff ff    	lea    -0x8b62(%ebx),%eax
c002e9a5:	50                   	push   %eax
c002e9a6:	e8 d3 8a ff ff       	call   c002747e <printf>
    if (!filesys_remove(file_name))
c002e9ab:	89 34 24             	mov    %esi,(%esp)
c002e9ae:	e8 b5 eb ff ff       	call   c002d568 <filesys_remove>
c002e9b3:	83 c4 10             	add    $0x10,%esp
c002e9b6:	84 c0                	test   %al,%al
c002e9b8:	74 06                	je     c002e9c0 <fsutil_rm+0x39>
        PANIC ("%s: delete failed\n", file_name);
}
c002e9ba:	83 c4 04             	add    $0x4,%esp
c002e9bd:	5b                   	pop    %ebx
c002e9be:	5e                   	pop    %esi
c002e9bf:	c3                   	ret    
        PANIC ("%s: delete failed\n", file_name);
c002e9c0:	83 ec 0c             	sub    $0xc,%esp
c002e9c3:	56                   	push   %esi
c002e9c4:	8d 83 b0 74 ff ff    	lea    -0x8b50(%ebx),%eax
c002e9ca:	50                   	push   %eax
c002e9cb:	8d 83 c4 4e ff ff    	lea    -0xb13c(%ebx),%eax
c002e9d1:	50                   	push   %eax
c002e9d2:	6a 3f                	push   $0x3f
c002e9d4:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002e9da:	50                   	push   %eax
c002e9db:	e8 fa a6 ff ff       	call   c00290da <debug_panic>

c002e9e0 <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void
fsutil_extract(char **argv UNUSED) {
c002e9e0:	55                   	push   %ebp
c002e9e1:	57                   	push   %edi
c002e9e2:	56                   	push   %esi
c002e9e3:	53                   	push   %ebx
c002e9e4:	83 ec 38             	sub    $0x38,%esp
c002e9e7:	e8 0c 05 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002e9ec:	81 c3 3c c7 00 00    	add    $0xc73c,%ebx

    struct block *src;
    void *header, *data;

    /* Allocate buffers. */
    header = malloc(BLOCK_SECTOR_SIZE);
c002e9f2:	68 00 02 00 00       	push   $0x200
c002e9f7:	e8 ff 53 ff ff       	call   c0023dfb <malloc>
c002e9fc:	89 c7                	mov    %eax,%edi
c002e9fe:	89 44 24 14          	mov    %eax,0x14(%esp)
    data = malloc(BLOCK_SECTOR_SIZE);
c002ea02:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002ea09:	e8 ed 53 ff ff       	call   c0023dfb <malloc>
c002ea0e:	89 c5                	mov    %eax,%ebp
    if (header == NULL || data == NULL)
c002ea10:	83 c4 10             	add    $0x10,%esp
c002ea13:	85 ff                	test   %edi,%edi
c002ea15:	74 3d                	je     c002ea54 <fsutil_extract+0x74>
c002ea17:	85 c0                	test   %eax,%eax
c002ea19:	74 39                	je     c002ea54 <fsutil_extract+0x74>
        PANIC ("couldn't allocate buffers");

    /* Open source block device. */
    src = block_get_role(BLOCK_SCRATCH);
c002ea1b:	83 ec 0c             	sub    $0xc,%esp
c002ea1e:	6a 02                	push   $0x2
c002ea20:	e8 b5 66 ff ff       	call   c00250da <block_get_role>
c002ea25:	89 44 24 10          	mov    %eax,0x10(%esp)
    if (src == NULL)
c002ea29:	83 c4 10             	add    $0x10,%esp
c002ea2c:	85 c0                	test   %eax,%eax
c002ea2e:	74 40                	je     c002ea70 <fsutil_extract+0x90>
        PANIC ("couldn't open scratch device");

    printf("Extracting ustar archive from scratch device "
c002ea30:	83 ec 0c             	sub    $0xc,%esp
c002ea33:	8d 83 7c 75 ff ff    	lea    -0x8a84(%ebx),%eax
c002ea39:	50                   	push   %eax
c002ea3a:	e8 71 c6 ff ff       	call   c002b0b0 <puts>
c002ea3f:	83 c4 10             	add    $0x10,%esp
        enum ustar_type type;
        int size;

        /* Read and parse ustar header. */
        block_read(src, sector++, header);
        error = ustar_parse_header(header, &file_name, &type, &size);
c002ea42:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002ea46:	89 44 24 08          	mov    %eax,0x8(%esp)
c002ea4a:	8d 44 24 18          	lea    0x18(%esp),%eax
c002ea4e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002ea52:	eb 78                	jmp    c002eacc <fsutil_extract+0xec>
        PANIC ("couldn't allocate buffers");
c002ea54:	8d 83 c3 74 ff ff    	lea    -0x8b3d(%ebx),%eax
c002ea5a:	50                   	push   %eax
c002ea5b:	8d 83 b4 4e ff ff    	lea    -0xb14c(%ebx),%eax
c002ea61:	50                   	push   %eax
c002ea62:	6a 4f                	push   $0x4f
c002ea64:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ea6a:	50                   	push   %eax
c002ea6b:	e8 6a a6 ff ff       	call   c00290da <debug_panic>
        PANIC ("couldn't open scratch device");
c002ea70:	8d 83 dd 74 ff ff    	lea    -0x8b23(%ebx),%eax
c002ea76:	50                   	push   %eax
c002ea77:	8d 83 b4 4e ff ff    	lea    -0xb14c(%ebx),%eax
c002ea7d:	50                   	push   %eax
c002ea7e:	6a 54                	push   $0x54
c002ea80:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ea86:	50                   	push   %eax
c002ea87:	e8 4e a6 ff ff       	call   c00290da <debug_panic>
        if (error != NULL)
            PANIC ("bad ustar header in sector %"
c002ea8c:	83 ec 08             	sub    $0x8,%esp
c002ea8f:	50                   	push   %eax
c002ea90:	8b 83 4c 1f 00 00    	mov    0x1f4c(%ebx),%eax
c002ea96:	83 e8 01             	sub    $0x1,%eax
c002ea99:	50                   	push   %eax
c002ea9a:	8d 83 c0 75 ff ff    	lea    -0x8a40(%ebx),%eax
c002eaa0:	50                   	push   %eax
c002eaa1:	8d 83 b4 4e ff ff    	lea    -0xb14c(%ebx),%eax
c002eaa7:	50                   	push   %eax
c002eaa8:	6a 65                	push   $0x65
c002eaaa:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002eab0:	50                   	push   %eax
c002eab1:	e8 24 a6 ff ff       	call   c00290da <debug_panic>

        if (type == USTAR_EOF) {
            /* End of archive. */
            break;
        } else if (type == USTAR_DIRECTORY)
            printf("ignoring directory %s\n", file_name);
c002eab6:	83 ec 08             	sub    $0x8,%esp
c002eab9:	ff 74 24 1c          	pushl  0x1c(%esp)
c002eabd:	8d 83 fa 74 ff ff    	lea    -0x8b06(%ebx),%eax
c002eac3:	50                   	push   %eax
c002eac4:	e8 b5 89 ff ff       	call   c002747e <printf>
c002eac9:	83 c4 10             	add    $0x10,%esp
        block_read(src, sector++, header);
c002eacc:	8b 83 4c 1f 00 00    	mov    0x1f4c(%ebx),%eax
c002ead2:	8d 50 01             	lea    0x1(%eax),%edx
c002ead5:	89 93 4c 1f 00 00    	mov    %edx,0x1f4c(%ebx)
c002eadb:	83 ec 04             	sub    $0x4,%esp
c002eade:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002eae2:	57                   	push   %edi
c002eae3:	50                   	push   %eax
c002eae4:	ff 74 24 0c          	pushl  0xc(%esp)
c002eae8:	e8 6a 67 ff ff       	call   c0025257 <block_read>
        error = ustar_parse_header(header, &file_name, &type, &size);
c002eaed:	ff 74 24 18          	pushl  0x18(%esp)
c002eaf1:	ff 74 24 20          	pushl  0x20(%esp)
c002eaf5:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002eaf9:	50                   	push   %eax
c002eafa:	57                   	push   %edi
c002eafb:	e8 48 a3 ff ff       	call   c0028e48 <ustar_parse_header>
        if (error != NULL)
c002eb00:	83 c4 20             	add    $0x20,%esp
c002eb03:	85 c0                	test   %eax,%eax
c002eb05:	75 85                	jne    c002ea8c <fsutil_extract+0xac>
        if (type == USTAR_EOF) {
c002eb07:	8b 44 24 18          	mov    0x18(%esp),%eax
c002eb0b:	83 f8 ff             	cmp    $0xffffffff,%eax
c002eb0e:	0f 84 23 01 00 00    	je     c002ec37 <fsutil_extract+0x257>
        } else if (type == USTAR_DIRECTORY)
c002eb14:	83 f8 35             	cmp    $0x35,%eax
c002eb17:	74 9d                	je     c002eab6 <fsutil_extract+0xd6>
        else if (type == USTAR_REGULAR) {
c002eb19:	83 f8 30             	cmp    $0x30,%eax
c002eb1c:	75 ae                	jne    c002eacc <fsutil_extract+0xec>
            struct file *dst;

            printf("Putting '%s' into the file system...\n", file_name);
c002eb1e:	83 ec 08             	sub    $0x8,%esp
c002eb21:	ff 74 24 1c          	pushl  0x1c(%esp)
c002eb25:	8d 83 e4 75 ff ff    	lea    -0x8a1c(%ebx),%eax
c002eb2b:	50                   	push   %eax
c002eb2c:	e8 4d 89 ff ff       	call   c002747e <printf>

            /* Create destination file. */
            if (!filesys_create(file_name, size))
c002eb31:	83 c4 08             	add    $0x8,%esp
c002eb34:	ff 74 24 24          	pushl  0x24(%esp)
c002eb38:	ff 74 24 20          	pushl  0x20(%esp)
c002eb3c:	e8 3a e9 ff ff       	call   c002d47b <filesys_create>
c002eb41:	83 c4 10             	add    $0x10,%esp
c002eb44:	84 c0                	test   %al,%al
c002eb46:	74 7f                	je     c002ebc7 <fsutil_extract+0x1e7>
                PANIC ("%s: create failed", file_name);
            dst = filesys_open(file_name);
c002eb48:	83 ec 0c             	sub    $0xc,%esp
c002eb4b:	ff 74 24 20          	pushl  0x20(%esp)
c002eb4f:	e8 c1 e9 ff ff       	call   c002d515 <filesys_open>
c002eb54:	89 c7                	mov    %eax,%edi
            if (dst == NULL)
c002eb56:	83 c4 10             	add    $0x10,%esp
c002eb59:	85 c0                	test   %eax,%eax
c002eb5b:	0f 84 89 00 00 00    	je     c002ebea <fsutil_extract+0x20a>
                PANIC ("%s: open failed", file_name);

            /* Do copy. */
            while (size > 0) {
c002eb61:	8b 74 24 1c          	mov    0x1c(%esp),%esi
c002eb65:	85 f6                	test   %esi,%esi
c002eb67:	7e 4d                	jle    c002ebb6 <fsutil_extract+0x1d6>
                int chunk_size = (size > BLOCK_SECTOR_SIZE
c002eb69:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c002eb6f:	b8 00 02 00 00       	mov    $0x200,%eax
c002eb74:	0f 4f f0             	cmovg  %eax,%esi
                                  ? BLOCK_SECTOR_SIZE
                                  : size);
                block_read(src, sector++, data);
c002eb77:	8b 83 4c 1f 00 00    	mov    0x1f4c(%ebx),%eax
c002eb7d:	8d 50 01             	lea    0x1(%eax),%edx
c002eb80:	89 93 4c 1f 00 00    	mov    %edx,0x1f4c(%ebx)
c002eb86:	83 ec 04             	sub    $0x4,%esp
c002eb89:	55                   	push   %ebp
c002eb8a:	50                   	push   %eax
c002eb8b:	ff 74 24 0c          	pushl  0xc(%esp)
c002eb8f:	e8 c3 66 ff ff       	call   c0025257 <block_read>
                if (file_write(dst, data, chunk_size) != chunk_size)
c002eb94:	83 c4 0c             	add    $0xc,%esp
c002eb97:	56                   	push   %esi
c002eb98:	55                   	push   %ebp
c002eb99:	57                   	push   %edi
c002eb9a:	e8 a6 ed ff ff       	call   c002d945 <file_write>
c002eb9f:	83 c4 10             	add    $0x10,%esp
c002eba2:	39 f0                	cmp    %esi,%eax
c002eba4:	75 67                	jne    c002ec0d <fsutil_extract+0x22d>
                    PANIC ("%s: write failed with %d bytes unwritten",
                           file_name, size);
                size -= chunk_size;
c002eba6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ebaa:	29 f0                	sub    %esi,%eax
c002ebac:	89 c6                	mov    %eax,%esi
c002ebae:	89 44 24 1c          	mov    %eax,0x1c(%esp)
            while (size > 0) {
c002ebb2:	85 c0                	test   %eax,%eax
c002ebb4:	7f b3                	jg     c002eb69 <fsutil_extract+0x189>
            }

            /* Finish up. */
            file_close(dst);
c002ebb6:	83 ec 0c             	sub    $0xc,%esp
c002ebb9:	57                   	push   %edi
c002ebba:	e8 96 ee ff ff       	call   c002da55 <file_close>
c002ebbf:	83 c4 10             	add    $0x10,%esp
    for (;;) {
c002ebc2:	e9 05 ff ff ff       	jmp    c002eacc <fsutil_extract+0xec>
                PANIC ("%s: create failed", file_name);
c002ebc7:	83 ec 0c             	sub    $0xc,%esp
c002ebca:	ff 74 24 20          	pushl  0x20(%esp)
c002ebce:	8d 83 11 75 ff ff    	lea    -0x8aef(%ebx),%eax
c002ebd4:	50                   	push   %eax
c002ebd5:	8d 83 b4 4e ff ff    	lea    -0xb14c(%ebx),%eax
c002ebdb:	50                   	push   %eax
c002ebdc:	6a 73                	push   $0x73
c002ebde:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ebe4:	50                   	push   %eax
c002ebe5:	e8 f0 a4 ff ff       	call   c00290da <debug_panic>
                PANIC ("%s: open failed", file_name);
c002ebea:	83 ec 0c             	sub    $0xc,%esp
c002ebed:	ff 74 24 20          	pushl  0x20(%esp)
c002ebf1:	8d 83 8e 74 ff ff    	lea    -0x8b72(%ebx),%eax
c002ebf7:	50                   	push   %eax
c002ebf8:	8d 83 b4 4e ff ff    	lea    -0xb14c(%ebx),%eax
c002ebfe:	50                   	push   %eax
c002ebff:	6a 76                	push   $0x76
c002ec01:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ec07:	50                   	push   %eax
c002ec08:	e8 cd a4 ff ff       	call   c00290da <debug_panic>
                    PANIC ("%s: write failed with %d bytes unwritten",
c002ec0d:	83 ec 08             	sub    $0x8,%esp
c002ec10:	ff 74 24 24          	pushl  0x24(%esp)
c002ec14:	ff 74 24 20          	pushl  0x20(%esp)
c002ec18:	8d 83 0c 76 ff ff    	lea    -0x89f4(%ebx),%eax
c002ec1e:	50                   	push   %eax
c002ec1f:	8d 83 b4 4e ff ff    	lea    -0xb14c(%ebx),%eax
c002ec25:	50                   	push   %eax
c002ec26:	68 80 00 00 00       	push   $0x80
c002ec2b:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ec31:	50                   	push   %eax
c002ec32:	e8 a3 a4 ff ff       	call   c00290da <debug_panic>

    /* Erase the ustar header from the start of the block device,
       so that the extraction operation is idempotent.  We erase
       two blocks because two blocks of zeros are the ustar
       end-of-archive marker. */
    printf("Erasing ustar archive...\n");
c002ec37:	83 ec 0c             	sub    $0xc,%esp
c002ec3a:	8d 83 23 75 ff ff    	lea    -0x8add(%ebx),%eax
c002ec40:	50                   	push   %eax
c002ec41:	e8 6a c4 ff ff       	call   c002b0b0 <puts>
    memset(header, 0, BLOCK_SECTOR_SIZE);
c002ec46:	b9 80 00 00 00       	mov    $0x80,%ecx
c002ec4b:	b8 00 00 00 00       	mov    $0x0,%eax
c002ec50:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002ec54:	f3 ab                	rep stos %eax,%es:(%edi)
    block_write(src, 0, header);
c002ec56:	83 c4 0c             	add    $0xc,%esp
c002ec59:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002ec5d:	57                   	push   %edi
c002ec5e:	6a 00                	push   $0x0
c002ec60:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002ec64:	56                   	push   %esi
c002ec65:	e8 21 66 ff ff       	call   c002528b <block_write>
    block_write(src, 1, header);
c002ec6a:	83 c4 0c             	add    $0xc,%esp
c002ec6d:	57                   	push   %edi
c002ec6e:	6a 01                	push   $0x1
c002ec70:	56                   	push   %esi
c002ec71:	e8 15 66 ff ff       	call   c002528b <block_write>

    free(data);
c002ec76:	89 2c 24             	mov    %ebp,(%esp)
c002ec79:	e8 2b 53 ff ff       	call   c0023fa9 <free>
    free(header);
c002ec7e:	89 3c 24             	mov    %edi,(%esp)
c002ec81:	e8 23 53 ff ff       	call   c0023fa9 <free>
}
c002ec86:	83 c4 3c             	add    $0x3c,%esp
c002ec89:	5b                   	pop    %ebx
c002ec8a:	5e                   	pop    %esi
c002ec8b:	5f                   	pop    %edi
c002ec8c:	5d                   	pop    %ebp
c002ec8d:	c3                   	ret    

c002ec8e <fsutil_append>:
   beginning of the scratch device.  Later calls advance across
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void
fsutil_append(char **argv) {
c002ec8e:	55                   	push   %ebp
c002ec8f:	57                   	push   %edi
c002ec90:	56                   	push   %esi
c002ec91:	53                   	push   %ebx
c002ec92:	83 ec 24             	sub    $0x24,%esp
c002ec95:	e8 5e 02 00 00       	call   c002eef8 <__x86.get_pc_thunk.bx>
c002ec9a:	81 c3 8e c4 00 00    	add    $0xc48e,%ebx
    static block_sector_t sector = 0;

    const char *file_name = argv[1];
c002eca0:	8b 44 24 38          	mov    0x38(%esp),%eax
c002eca4:	8b 40 04             	mov    0x4(%eax),%eax
c002eca7:	89 44 24 14          	mov    %eax,0x14(%esp)
    void *buffer;
    struct file *src;
    struct block *dst;
    off_t size;

    printf("Appending '%s' to ustar archive on scratch device...\n", file_name);
c002ecab:	50                   	push   %eax
c002ecac:	8d 83 38 76 ff ff    	lea    -0x89c8(%ebx),%eax
c002ecb2:	50                   	push   %eax
c002ecb3:	e8 c6 87 ff ff       	call   c002747e <printf>

    /* Allocate buffer. */
    buffer = malloc(BLOCK_SECTOR_SIZE);
c002ecb8:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002ecbf:	e8 37 51 ff ff       	call   c0023dfb <malloc>
    if (buffer == NULL)
c002ecc4:	83 c4 10             	add    $0x10,%esp
c002ecc7:	85 c0                	test   %eax,%eax
c002ecc9:	0f 84 52 01 00 00    	je     c002ee21 <fsutil_append+0x193>
c002eccf:	89 c5                	mov    %eax,%ebp
        PANIC ("couldn't allocate buffer");

    /* Open source file. */
    src = filesys_open(file_name);
c002ecd1:	83 ec 0c             	sub    $0xc,%esp
c002ecd4:	ff 74 24 18          	pushl  0x18(%esp)
c002ecd8:	e8 38 e8 ff ff       	call   c002d515 <filesys_open>
c002ecdd:	89 44 24 18          	mov    %eax,0x18(%esp)
    if (src == NULL)
c002ece1:	83 c4 10             	add    $0x10,%esp
c002ece4:	85 c0                	test   %eax,%eax
c002ece6:	0f 84 54 01 00 00    	je     c002ee40 <fsutil_append+0x1b2>
        PANIC ("%s: open failed", file_name);
    size = file_length(src);
c002ecec:	83 ec 0c             	sub    $0xc,%esp
c002ecef:	ff 74 24 14          	pushl  0x14(%esp)
c002ecf3:	e8 99 ed ff ff       	call   c002da91 <file_length>
c002ecf8:	89 c7                	mov    %eax,%edi

    /* Open target block device. */
    dst = block_get_role(BLOCK_SCRATCH);
c002ecfa:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c002ed01:	e8 d4 63 ff ff       	call   c00250da <block_get_role>
c002ed06:	89 44 24 14          	mov    %eax,0x14(%esp)
    if (dst == NULL)
c002ed0a:	83 c4 10             	add    $0x10,%esp
c002ed0d:	85 c0                	test   %eax,%eax
c002ed0f:	0f 84 51 01 00 00    	je     c002ee66 <fsutil_append+0x1d8>
        PANIC ("couldn't open scratch device");

    /* Write ustar header to first sector. */
    if (!ustar_make_header(file_name, USTAR_REGULAR, size, buffer))
c002ed15:	55                   	push   %ebp
c002ed16:	57                   	push   %edi
c002ed17:	6a 30                	push   $0x30
c002ed19:	ff 74 24 18          	pushl  0x18(%esp)
c002ed1d:	e8 33 9f ff ff       	call   c0028c55 <ustar_make_header>
c002ed22:	83 c4 10             	add    $0x10,%esp
c002ed25:	84 c0                	test   %al,%al
c002ed27:	0f 84 58 01 00 00    	je     c002ee85 <fsutil_append+0x1f7>
        PANIC ("%s: name too long for ustar format", file_name);
    block_write(dst, sector++, buffer);
c002ed2d:	8b 83 48 1f 00 00    	mov    0x1f48(%ebx),%eax
c002ed33:	8d 50 01             	lea    0x1(%eax),%edx
c002ed36:	89 93 48 1f 00 00    	mov    %edx,0x1f48(%ebx)
c002ed3c:	83 ec 04             	sub    $0x4,%esp
c002ed3f:	55                   	push   %ebp
c002ed40:	50                   	push   %eax
c002ed41:	ff 74 24 10          	pushl  0x10(%esp)
c002ed45:	e8 41 65 ff ff       	call   c002528b <block_write>

    /* Do copy. */
    while (size > 0) {
c002ed4a:	83 c4 10             	add    $0x10,%esp
c002ed4d:	85 ff                	test   %edi,%edi
c002ed4f:	7e 7f                	jle    c002edd0 <fsutil_append+0x142>
        int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c002ed51:	81 ff 00 02 00 00    	cmp    $0x200,%edi
c002ed57:	be 00 02 00 00       	mov    $0x200,%esi
c002ed5c:	0f 4e f7             	cmovle %edi,%esi
        if (sector >= block_size(dst))
c002ed5f:	83 ec 0c             	sub    $0xc,%esp
c002ed62:	ff 74 24 10          	pushl  0x10(%esp)
c002ed66:	e8 8e 65 ff ff       	call   c00252f9 <block_size>
c002ed6b:	83 c4 10             	add    $0x10,%esp
c002ed6e:	3b 83 48 1f 00 00    	cmp    0x1f48(%ebx),%eax
c002ed74:	0f 86 31 01 00 00    	jbe    c002eeab <fsutil_append+0x21d>
            PANIC ("%s: out of space on scratch device", file_name);
        if (file_read(src, buffer, chunk_size) != chunk_size)
c002ed7a:	83 ec 04             	sub    $0x4,%esp
c002ed7d:	56                   	push   %esi
c002ed7e:	55                   	push   %ebp
c002ed7f:	ff 74 24 14          	pushl  0x14(%esp)
c002ed83:	e8 63 eb ff ff       	call   c002d8eb <file_read>
c002ed88:	83 c4 10             	add    $0x10,%esp
c002ed8b:	39 f0                	cmp    %esi,%eax
c002ed8d:	0f 85 3e 01 00 00    	jne    c002eed1 <fsutil_append+0x243>
            PANIC ("%s: read failed with %"
                           PROTd
                           " bytes unread", file_name, size);
        memset(buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c002ed93:	ba 00 02 00 00       	mov    $0x200,%edx
c002ed98:	29 f2                	sub    %esi,%edx
c002ed9a:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
c002ed9e:	83 ec 04             	sub    $0x4,%esp
c002eda1:	52                   	push   %edx
c002eda2:	6a 00                	push   $0x0
c002eda4:	50                   	push   %eax
c002eda5:	e8 9f 98 ff ff       	call   c0028649 <memset>
        block_write(dst, sector++, buffer);
c002edaa:	8b 83 48 1f 00 00    	mov    0x1f48(%ebx),%eax
c002edb0:	8d 50 01             	lea    0x1(%eax),%edx
c002edb3:	89 93 48 1f 00 00    	mov    %edx,0x1f48(%ebx)
c002edb9:	83 c4 0c             	add    $0xc,%esp
c002edbc:	55                   	push   %ebp
c002edbd:	50                   	push   %eax
c002edbe:	ff 74 24 10          	pushl  0x10(%esp)
c002edc2:	e8 c4 64 ff ff       	call   c002528b <block_write>
        size -= chunk_size;
c002edc7:	29 f7                	sub    %esi,%edi
    while (size > 0) {
c002edc9:	83 c4 10             	add    $0x10,%esp
c002edcc:	85 ff                	test   %edi,%edi
c002edce:	7f 81                	jg     c002ed51 <fsutil_append+0xc3>
    }

    /* Write ustar end-of-archive marker, which is two consecutive
       sectors full of zeros.  Don't advance our position past
       them, though, in case we have more files to append. */
    memset(buffer, 0, BLOCK_SECTOR_SIZE);
c002edd0:	b9 80 00 00 00       	mov    $0x80,%ecx
c002edd5:	b8 00 00 00 00       	mov    $0x0,%eax
c002edda:	89 ef                	mov    %ebp,%edi
c002eddc:	f3 ab                	rep stos %eax,%es:(%edi)
    block_write(dst, sector, buffer);
c002edde:	83 ec 04             	sub    $0x4,%esp
c002ede1:	55                   	push   %ebp
c002ede2:	ff b3 48 1f 00 00    	pushl  0x1f48(%ebx)
c002ede8:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002edec:	57                   	push   %edi
c002eded:	e8 99 64 ff ff       	call   c002528b <block_write>
    block_write(dst, sector, buffer + 1);
c002edf2:	83 c4 0c             	add    $0xc,%esp
c002edf5:	8d 45 01             	lea    0x1(%ebp),%eax
c002edf8:	50                   	push   %eax
c002edf9:	ff b3 48 1f 00 00    	pushl  0x1f48(%ebx)
c002edff:	57                   	push   %edi
c002ee00:	e8 86 64 ff ff       	call   c002528b <block_write>

    /* Finish up. */
    file_close(src);
c002ee05:	83 c4 04             	add    $0x4,%esp
c002ee08:	ff 74 24 14          	pushl  0x14(%esp)
c002ee0c:	e8 44 ec ff ff       	call   c002da55 <file_close>
    free(buffer);
c002ee11:	89 2c 24             	mov    %ebp,(%esp)
c002ee14:	e8 90 51 ff ff       	call   c0023fa9 <free>
}
c002ee19:	83 c4 2c             	add    $0x2c,%esp
c002ee1c:	5b                   	pop    %ebx
c002ee1d:	5e                   	pop    %esi
c002ee1e:	5f                   	pop    %edi
c002ee1f:	5d                   	pop    %ebp
c002ee20:	c3                   	ret    
        PANIC ("couldn't allocate buffer");
c002ee21:	8d 83 3c 75 ff ff    	lea    -0x8ac4(%ebx),%eax
c002ee27:	50                   	push   %eax
c002ee28:	8d 83 a4 4e ff ff    	lea    -0xb15c(%ebx),%eax
c002ee2e:	50                   	push   %eax
c002ee2f:	68 ad 00 00 00       	push   $0xad
c002ee34:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ee3a:	50                   	push   %eax
c002ee3b:	e8 9a a2 ff ff       	call   c00290da <debug_panic>
        PANIC ("%s: open failed", file_name);
c002ee40:	83 ec 0c             	sub    $0xc,%esp
c002ee43:	ff 74 24 18          	pushl  0x18(%esp)
c002ee47:	8d 83 8e 74 ff ff    	lea    -0x8b72(%ebx),%eax
c002ee4d:	50                   	push   %eax
c002ee4e:	8d 83 a4 4e ff ff    	lea    -0xb15c(%ebx),%eax
c002ee54:	50                   	push   %eax
c002ee55:	68 b2 00 00 00       	push   $0xb2
c002ee5a:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ee60:	50                   	push   %eax
c002ee61:	e8 74 a2 ff ff       	call   c00290da <debug_panic>
        PANIC ("couldn't open scratch device");
c002ee66:	8d 83 dd 74 ff ff    	lea    -0x8b23(%ebx),%eax
c002ee6c:	50                   	push   %eax
c002ee6d:	8d 83 a4 4e ff ff    	lea    -0xb15c(%ebx),%eax
c002ee73:	50                   	push   %eax
c002ee74:	68 b8 00 00 00       	push   $0xb8
c002ee79:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002ee7f:	50                   	push   %eax
c002ee80:	e8 55 a2 ff ff       	call   c00290da <debug_panic>
        PANIC ("%s: name too long for ustar format", file_name);
c002ee85:	83 ec 0c             	sub    $0xc,%esp
c002ee88:	ff 74 24 18          	pushl  0x18(%esp)
c002ee8c:	8d 83 70 76 ff ff    	lea    -0x8990(%ebx),%eax
c002ee92:	50                   	push   %eax
c002ee93:	8d 83 a4 4e ff ff    	lea    -0xb15c(%ebx),%eax
c002ee99:	50                   	push   %eax
c002ee9a:	68 bc 00 00 00       	push   $0xbc
c002ee9f:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002eea5:	50                   	push   %eax
c002eea6:	e8 2f a2 ff ff       	call   c00290da <debug_panic>
            PANIC ("%s: out of space on scratch device", file_name);
c002eeab:	83 ec 0c             	sub    $0xc,%esp
c002eeae:	ff 74 24 18          	pushl  0x18(%esp)
c002eeb2:	8d 83 94 76 ff ff    	lea    -0x896c(%ebx),%eax
c002eeb8:	50                   	push   %eax
c002eeb9:	8d 83 a4 4e ff ff    	lea    -0xb15c(%ebx),%eax
c002eebf:	50                   	push   %eax
c002eec0:	68 c3 00 00 00       	push   $0xc3
c002eec5:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002eecb:	50                   	push   %eax
c002eecc:	e8 09 a2 ff ff       	call   c00290da <debug_panic>
            PANIC ("%s: read failed with %"
c002eed1:	83 ec 08             	sub    $0x8,%esp
c002eed4:	57                   	push   %edi
c002eed5:	ff 74 24 18          	pushl  0x18(%esp)
c002eed9:	8d 83 b8 76 ff ff    	lea    -0x8948(%ebx),%eax
c002eedf:	50                   	push   %eax
c002eee0:	8d 83 a4 4e ff ff    	lea    -0xb15c(%ebx),%eax
c002eee6:	50                   	push   %eax
c002eee7:	68 c7 00 00 00       	push   $0xc7
c002eeec:	8d 83 67 74 ff ff    	lea    -0x8b99(%ebx),%eax
c002eef2:	50                   	push   %eax
c002eef3:	e8 e2 a1 ff ff       	call   c00290da <debug_panic>

Disassembly of section .text.__x86.get_pc_thunk.bx:

c002eef8 <__x86.get_pc_thunk.bx>:
c002eef8:	8b 1c 24             	mov    (%esp),%ebx
c002eefb:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

c002eefc <__x86.get_pc_thunk.ax>:
c002eefc:	8b 04 24             	mov    (%esp),%eax
c002eeff:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bp:

c002ef00 <__x86.get_pc_thunk.bp>:
c002ef00:	8b 2c 24             	mov    (%esp),%ebp
c002ef03:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.di:

c002ef04 <__x86.get_pc_thunk.di>:
c002ef04:	8b 3c 24             	mov    (%esp),%edi
c002ef07:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c002ef08 <__x86.get_pc_thunk.dx>:
c002ef08:	8b 14 24             	mov    (%esp),%edx
c002ef0b:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

c002ef0c <__x86.get_pc_thunk.cx>:
c002ef0c:	8b 0c 24             	mov    (%esp),%ecx
c002ef0f:	c3                   	ret    
